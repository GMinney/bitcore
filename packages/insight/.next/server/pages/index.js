/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "../bitcore-lib/index.js":
/*!*******************************!*\
  !*** ../bitcore-lib/index.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar bitcore = module.exports;\r\n\r\n// module information\r\nbitcore.version = 'v' + (__webpack_require__(/*! ./package.json */ \"../bitcore-lib/package.json\").version);\r\nbitcore.versionGuard = function(version) {\r\n  if (version !== undefined) {\r\n    var message = 'More than one instance of bitcore-lib found. ' +\r\n      'Please make sure to require bitcore-lib and check that submodules do' +\r\n      ' not also include their own bitcore-lib dependency.';\r\n    throw new Error(message);\r\n  }\r\n};\r\nbitcore.versionGuard(global._bitcore);\r\nglobal._bitcore = bitcore.version;\r\n\r\n// crypto\r\nbitcore.crypto = {};\r\nbitcore.crypto.BN = __webpack_require__(/*! ./lib/crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nbitcore.crypto.ECDSA = __webpack_require__(/*! ./lib/crypto/ecdsa */ \"../bitcore-lib/lib/crypto/ecdsa.js\");\r\nbitcore.crypto.Schnorr = __webpack_require__(/*! ./lib/crypto/schnorr */ \"../bitcore-lib/lib/crypto/schnorr.js\");\r\nbitcore.crypto.Hash = __webpack_require__(/*! ./lib/crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nbitcore.crypto.Random = __webpack_require__(/*! ./lib/crypto/random */ \"../bitcore-lib/lib/crypto/random.js\");\r\nbitcore.crypto.Point = __webpack_require__(/*! ./lib/crypto/point */ \"../bitcore-lib/lib/crypto/point.js\");\r\nbitcore.crypto.Signature = __webpack_require__(/*! ./lib/crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nbitcore.crypto.TaggedHash = __webpack_require__(/*! ./lib/crypto/taggedhash */ \"../bitcore-lib/lib/crypto/taggedhash.js\");\r\n\r\n// encoding\r\nbitcore.encoding = {};\r\nbitcore.encoding.Base58 = __webpack_require__(/*! ./lib/encoding/base58 */ \"../bitcore-lib/lib/encoding/base58.js\");\r\nbitcore.encoding.Base58Check = __webpack_require__(/*! ./lib/encoding/base58check */ \"../bitcore-lib/lib/encoding/base58check.js\");\r\nbitcore.encoding.BufferReader = __webpack_require__(/*! ./lib/encoding/bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nbitcore.encoding.BufferWriter = __webpack_require__(/*! ./lib/encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nbitcore.encoding.Varint = __webpack_require__(/*! ./lib/encoding/varint */ \"../bitcore-lib/lib/encoding/varint.js\");\r\n\r\n// utilities\r\nbitcore.util = {};\r\nbitcore.util.buffer = __webpack_require__(/*! ./lib/util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nbitcore.util.js = __webpack_require__(/*! ./lib/util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nbitcore.util.preconditions = __webpack_require__(/*! ./lib/util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\n// errors thrown by the library\r\nbitcore.errors = __webpack_require__(/*! ./lib/errors */ \"../bitcore-lib/lib/errors/index.js\");\r\n\r\n// main bitcoin library\r\nbitcore.Address = __webpack_require__(/*! ./lib/address */ \"../bitcore-lib/lib/address.js\");\r\nbitcore.Block = __webpack_require__(/*! ./lib/block */ \"../bitcore-lib/lib/block/index.js\");\r\nbitcore.MerkleBlock = __webpack_require__(/*! ./lib/block/merkleblock */ \"../bitcore-lib/lib/block/merkleblock.js\");\r\nbitcore.BlockHeader = __webpack_require__(/*! ./lib/block/blockheader */ \"../bitcore-lib/lib/block/blockheader.js\");\r\nbitcore.HDPrivateKey = __webpack_require__(/*! ./lib/hdprivatekey.js */ \"../bitcore-lib/lib/hdprivatekey.js\");\r\nbitcore.HDPublicKey = __webpack_require__(/*! ./lib/hdpublickey.js */ \"../bitcore-lib/lib/hdpublickey.js\");\r\nbitcore.Message = __webpack_require__(/*! ./lib/message */ \"../bitcore-lib/lib/message.js\");\r\nbitcore.Networks = __webpack_require__(/*! ./lib/networks */ \"../bitcore-lib/lib/networks.js\");\r\nbitcore.Opcode = __webpack_require__(/*! ./lib/opcode */ \"../bitcore-lib/lib/opcode.js\");\r\nbitcore.PrivateKey = __webpack_require__(/*! ./lib/privatekey */ \"../bitcore-lib/lib/privatekey.js\");\r\nbitcore.PublicKey = __webpack_require__(/*! ./lib/publickey */ \"../bitcore-lib/lib/publickey.js\");\r\nbitcore.Script = __webpack_require__(/*! ./lib/script */ \"../bitcore-lib/lib/script/index.js\");\r\nbitcore.Transaction = __webpack_require__(/*! ./lib/transaction */ \"../bitcore-lib/lib/transaction/index.js\");\r\nbitcore.URI = __webpack_require__(/*! ./lib/uri */ \"../bitcore-lib/lib/uri.js\");\r\nbitcore.Unit = __webpack_require__(/*! ./lib/unit */ \"../bitcore-lib/lib/unit.js\");\r\n\r\n// dependencies, subject to change\r\nbitcore.deps = {};\r\nbitcore.deps.bnjs = __webpack_require__(/*! bn.js */ \"../bitcore-lib/node_modules/bn.js/lib/bn.js\");\r\nbitcore.deps.bs58 = __webpack_require__(/*! bs58 */ \"../bitcore-lib/node_modules/bs58/src/cjs/index.cjs\");\r\nbitcore.deps.Buffer = Buffer;\r\nbitcore.deps.elliptic = __webpack_require__(/*! elliptic */ \"../bitcore-lib/node_modules/elliptic/lib/elliptic.js\");\r\nbitcore.deps._ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\n// Internal usage, exposed for testing/advanced tweaking\r\nbitcore.Transaction.sighash = __webpack_require__(/*! ./lib/transaction/sighash */ \"../bitcore-lib/lib/transaction/sighash.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0ZBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0RBQWlCO0FBQzdDLHVCQUF1QixtQkFBTyxDQUFDLDhEQUFvQjtBQUNuRCx5QkFBeUIsbUJBQU8sQ0FBQyxrRUFBc0I7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsNERBQW1CO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLGdFQUFxQjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQyw4REFBb0I7QUFDbkQsMkJBQTJCLG1CQUFPLENBQUMsc0VBQXdCO0FBQzNELDRCQUE0QixtQkFBTyxDQUFDLHdFQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxvRUFBdUI7QUFDekQsK0JBQStCLG1CQUFPLENBQUMsOEVBQTRCO0FBQ25FLGdDQUFnQyxtQkFBTyxDQUFDLGdGQUE2QjtBQUNyRSxnQ0FBZ0MsbUJBQU8sQ0FBQyxnRkFBNkI7QUFDckUsMEJBQTBCLG1CQUFPLENBQUMsb0VBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLDREQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxvREFBZTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQywwRUFBMEI7QUFDL0Q7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdEQUFjO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxvREFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBYTtBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyx3RUFBeUI7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsd0VBQXlCO0FBQ3ZELHVCQUF1QixtQkFBTyxDQUFDLGlFQUF1QjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQywrREFBc0I7QUFDcEQsa0JBQWtCLG1CQUFPLENBQUMsb0RBQWU7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsc0RBQWdCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLGtEQUFjO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLDBEQUFrQjtBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyx3REFBaUI7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsd0RBQWM7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsa0VBQW1CO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyw0Q0FBVztBQUNqQyxlQUFlLG1CQUFPLENBQUMsOENBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsMERBQU87QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsZ0VBQU07QUFDbEMsc0JBQXNCLE1BQU07QUFDNUIsd0JBQXdCLG1CQUFPLENBQUMsc0VBQVU7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsNERBQVE7QUFDakM7QUFDQTtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLDRFQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvaW5kZXguanM/M2E1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYml0Y29yZSA9IG1vZHVsZS5leHBvcnRzO1xyXG5cclxuLy8gbW9kdWxlIGluZm9ybWF0aW9uXHJcbmJpdGNvcmUudmVyc2lvbiA9ICd2JyArIHJlcXVpcmUoJy4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcclxuYml0Y29yZS52ZXJzaW9uR3VhcmQgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XHJcbiAgaWYgKHZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmFyIG1lc3NhZ2UgPSAnTW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBvZiBiaXRjb3JlLWxpYiBmb3VuZC4gJyArXHJcbiAgICAgICdQbGVhc2UgbWFrZSBzdXJlIHRvIHJlcXVpcmUgYml0Y29yZS1saWIgYW5kIGNoZWNrIHRoYXQgc3VibW9kdWxlcyBkbycgK1xyXG4gICAgICAnIG5vdCBhbHNvIGluY2x1ZGUgdGhlaXIgb3duIGJpdGNvcmUtbGliIGRlcGVuZGVuY3kuJztcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICB9XHJcbn07XHJcbmJpdGNvcmUudmVyc2lvbkd1YXJkKGdsb2JhbC5fYml0Y29yZSk7XHJcbmdsb2JhbC5fYml0Y29yZSA9IGJpdGNvcmUudmVyc2lvbjtcclxuXHJcbi8vIGNyeXB0b1xyXG5iaXRjb3JlLmNyeXB0byA9IHt9O1xyXG5iaXRjb3JlLmNyeXB0by5CTiA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9ibicpO1xyXG5iaXRjb3JlLmNyeXB0by5FQ0RTQSA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9lY2RzYScpO1xyXG5iaXRjb3JlLmNyeXB0by5TY2hub3JyID0gcmVxdWlyZSgnLi9saWIvY3J5cHRvL3NjaG5vcnInKTtcclxuYml0Y29yZS5jcnlwdG8uSGFzaCA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9oYXNoJyk7XHJcbmJpdGNvcmUuY3J5cHRvLlJhbmRvbSA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9yYW5kb20nKTtcclxuYml0Y29yZS5jcnlwdG8uUG9pbnQgPSByZXF1aXJlKCcuL2xpYi9jcnlwdG8vcG9pbnQnKTtcclxuYml0Y29yZS5jcnlwdG8uU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9saWIvY3J5cHRvL3NpZ25hdHVyZScpO1xyXG5iaXRjb3JlLmNyeXB0by5UYWdnZWRIYXNoID0gcmVxdWlyZSgnLi9saWIvY3J5cHRvL3RhZ2dlZGhhc2gnKTtcclxuXHJcbi8vIGVuY29kaW5nXHJcbmJpdGNvcmUuZW5jb2RpbmcgPSB7fTtcclxuYml0Y29yZS5lbmNvZGluZy5CYXNlNTggPSByZXF1aXJlKCcuL2xpYi9lbmNvZGluZy9iYXNlNTgnKTtcclxuYml0Y29yZS5lbmNvZGluZy5CYXNlNThDaGVjayA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XHJcbmJpdGNvcmUuZW5jb2RpbmcuQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9saWIvZW5jb2RpbmcvYnVmZmVycmVhZGVyJyk7XHJcbmJpdGNvcmUuZW5jb2RpbmcuQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi9saWIvZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XHJcbmJpdGNvcmUuZW5jb2RpbmcuVmFyaW50ID0gcmVxdWlyZSgnLi9saWIvZW5jb2RpbmcvdmFyaW50Jyk7XHJcblxyXG4vLyB1dGlsaXRpZXNcclxuYml0Y29yZS51dGlsID0ge307XHJcbmJpdGNvcmUudXRpbC5idWZmZXIgPSByZXF1aXJlKCcuL2xpYi91dGlsL2J1ZmZlcicpO1xyXG5iaXRjb3JlLnV0aWwuanMgPSByZXF1aXJlKCcuL2xpYi91dGlsL2pzJyk7XHJcbmJpdGNvcmUudXRpbC5wcmVjb25kaXRpb25zID0gcmVxdWlyZSgnLi9saWIvdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcblxyXG4vLyBlcnJvcnMgdGhyb3duIGJ5IHRoZSBsaWJyYXJ5XHJcbmJpdGNvcmUuZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvZXJyb3JzJyk7XHJcblxyXG4vLyBtYWluIGJpdGNvaW4gbGlicmFyeVxyXG5iaXRjb3JlLkFkZHJlc3MgPSByZXF1aXJlKCcuL2xpYi9hZGRyZXNzJyk7XHJcbmJpdGNvcmUuQmxvY2sgPSByZXF1aXJlKCcuL2xpYi9ibG9jaycpO1xyXG5iaXRjb3JlLk1lcmtsZUJsb2NrID0gcmVxdWlyZSgnLi9saWIvYmxvY2svbWVya2xlYmxvY2snKTtcclxuYml0Y29yZS5CbG9ja0hlYWRlciA9IHJlcXVpcmUoJy4vbGliL2Jsb2NrL2Jsb2NraGVhZGVyJyk7XHJcbmJpdGNvcmUuSERQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9saWIvaGRwcml2YXRla2V5LmpzJyk7XHJcbmJpdGNvcmUuSERQdWJsaWNLZXkgPSByZXF1aXJlKCcuL2xpYi9oZHB1YmxpY2tleS5qcycpO1xyXG5iaXRjb3JlLk1lc3NhZ2UgPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlJyk7XHJcbmJpdGNvcmUuTmV0d29ya3MgPSByZXF1aXJlKCcuL2xpYi9uZXR3b3JrcycpO1xyXG5iaXRjb3JlLk9wY29kZSA9IHJlcXVpcmUoJy4vbGliL29wY29kZScpO1xyXG5iaXRjb3JlLlByaXZhdGVLZXkgPSByZXF1aXJlKCcuL2xpYi9wcml2YXRla2V5Jyk7XHJcbmJpdGNvcmUuUHVibGljS2V5ID0gcmVxdWlyZSgnLi9saWIvcHVibGlja2V5Jyk7XHJcbmJpdGNvcmUuU2NyaXB0ID0gcmVxdWlyZSgnLi9saWIvc2NyaXB0Jyk7XHJcbmJpdGNvcmUuVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL2xpYi90cmFuc2FjdGlvbicpO1xyXG5iaXRjb3JlLlVSSSA9IHJlcXVpcmUoJy4vbGliL3VyaScpO1xyXG5iaXRjb3JlLlVuaXQgPSByZXF1aXJlKCcuL2xpYi91bml0Jyk7XHJcblxyXG4vLyBkZXBlbmRlbmNpZXMsIHN1YmplY3QgdG8gY2hhbmdlXHJcbmJpdGNvcmUuZGVwcyA9IHt9O1xyXG5iaXRjb3JlLmRlcHMuYm5qcyA9IHJlcXVpcmUoJ2JuLmpzJyk7XHJcbmJpdGNvcmUuZGVwcy5iczU4ID0gcmVxdWlyZSgnYnM1OCcpO1xyXG5iaXRjb3JlLmRlcHMuQnVmZmVyID0gQnVmZmVyO1xyXG5iaXRjb3JlLmRlcHMuZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpO1xyXG5iaXRjb3JlLmRlcHMuXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5cclxuLy8gSW50ZXJuYWwgdXNhZ2UsIGV4cG9zZWQgZm9yIHRlc3RpbmcvYWR2YW5jZWQgdHdlYWtpbmdcclxuYml0Y29yZS5UcmFuc2FjdGlvbi5zaWdoYXNoID0gcmVxdWlyZSgnLi9saWIvdHJhbnNhY3Rpb24vc2lnaGFzaCcpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/index.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/address.js":
/*!*************************************!*\
  !*** ../bitcore-lib/lib/address.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar errors = __webpack_require__(/*! ./errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"../bitcore-lib/lib/encoding/base58check.js\");\r\nvar Bech32 = __webpack_require__(/*! ./encoding/bech32 */ \"../bitcore-lib/lib/encoding/bech32.js\");\r\nvar Networks = __webpack_require__(/*! ./networks */ \"../bitcore-lib/lib/networks.js\");\r\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"../bitcore-lib/lib/publickey.js\");\r\n\r\n/**\r\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\r\n * or an instance of {@link PublicKey} or {@link Script}.\r\n *\r\n * This is an immutable class, and if the first parameter provided to this constructor is an\r\n * `Address` instance, the same argument will be returned.\r\n *\r\n * An address has two key properties: `network` and `type`. The type is one of\r\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),\r\n * `Address.PayToScriptHash` (the string `'scripthash'`),\r\n * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),\r\n * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).\r\n * The network is an instance of {@link Network}.\r\n * You can quickly check whether an address is of a given kind by using the methods\r\n * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,\r\n * and `isPayToWitnessScriptHash`.\r\n *\r\n * @example\r\n * ```javascript\r\n * // validate that an input field is valid\r\n * var error = Address.getValidationError(input, 'testnet');\r\n * if (!error) {\r\n *   var address = Address(input, 'testnet');\r\n * } else {\r\n *   // invalid network or checksum (typo?)\r\n *   var message = error.messsage;\r\n * }\r\n *\r\n * // get an address from a public key\r\n * var address = Address(publicKey, 'testnet').toString();\r\n * ```\r\n *\r\n * @param {*} data - The encoded data in various formats\r\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\r\n * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash, 'witnesspubkeyhash', or 'taproot'\r\n * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'\r\n * @returns {Address} A new valid and frozen instance of an Address\r\n * @constructor\r\n */\r\nfunction Address(data, network, type, multisigType) {\r\n  /* jshint maxcomplexity: 12 */\r\n  /* jshint maxstatements: 20 */\r\n\r\n  if (!(this instanceof Address)) {\r\n    return new Address(data, network, type);\r\n  }\r\n\r\n  if (_.isArray(data) && _.isNumber(network)) {\r\n    return Address.createMultisig(data, network, type, false, multisigType);\r\n  }\r\n\r\n  if (data instanceof Address) {\r\n    // Immutable instance\r\n    return data;\r\n  }\r\n\r\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\r\n\r\n  if (network && !Networks.get(network)) {\r\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\r\n  }\r\n\r\n  if (type && (\r\n    type !== Address.PayToPublicKeyHash\r\n    && type !== Address.PayToScriptHash\r\n    && type !== Address.PayToWitnessPublicKeyHash\r\n    && type !== Address.PayToWitnessScriptHash\r\n    && type !== Address.PayToTaproot)) {\r\n    throw new TypeError('Third argument must be \"pubkeyhash\", \"scripthash\", \"witnesspubkeyhash\", \"witnessscripthash\", or \"taproot\".');\r\n  }\r\n\r\n  var info = this._classifyArguments(data, network, type);\r\n\r\n  // set defaults if not set\r\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\r\n  info.type = info.type || type || Address.PayToPublicKeyHash;\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    hashBuffer: info.hashBuffer,\r\n    network: info.network,\r\n    type: info.type\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\n/**\r\n * Internal function used to split different kinds of arguments of the constructor\r\n * @param {*} data - The encoded data in various formats\r\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\r\n * @param {string=} type - The type of address: 'script' or 'pubkey'\r\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\r\n */\r\nAddress.prototype._classifyArguments = function(data, network, type) {\r\n  /* jshint maxcomplexity: 10 */\r\n  // transform and validate input data\r\n  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {\r\n    return Address._transformHash(data, network, type);\r\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {\r\n    return Address._transformBuffer(data, network, type);\r\n  } else if (data instanceof PublicKey) {\r\n    return Address._transformPublicKey(data, network, type);\r\n  } else if (data instanceof Script) {\r\n    return Address._transformScript(data, network);\r\n  } else if (typeof(data) === 'string') {\r\n    return Address._transformString(data, network, type);\r\n  } else if (_.isObject(data)) {\r\n    return Address._transformObject(data);\r\n  } else {\r\n    throw new TypeError('First argument is an unrecognized data format.');\r\n  }\r\n};\r\n\r\n/** @static */\r\nAddress.PayToPublicKeyHash = 'pubkeyhash';\r\n/** @static */\r\nAddress.PayToScriptHash = 'scripthash';\r\n/** @static */\r\nAddress.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';\r\n/** @static */\r\nAddress.PayToWitnessScriptHash = 'witnessscripthash';\r\n/** @static */\r\nAddress.PayToTaproot = 'taproot';\r\n\r\n/**\r\n * @param {Buffer} hash - An instance of a hash Buffer\r\n * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\r\n * @param {Network=} network - the name of the network associated\r\n * @returns {Object} An object with keys: hashBuffer\r\n * @private\r\n */\r\nAddress._transformHash = function(hash, network, type) {\r\n  var info = {};\r\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\r\n    throw new TypeError('Address supplied is not a buffer.');\r\n  }\r\n  if (hash.length !== 20 && hash.length !== 32) {\r\n    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');\r\n  }\r\n  info.hashBuffer = hash;\r\n  info.network = Networks.get(network) || Networks.defaultNetwork;\r\n  info.type = type;\r\n  return info;\r\n};\r\n\r\n/**\r\n * Deserializes an address serialized through `Address#toObject()`\r\n * @param {Object} data\r\n * @param {string} data.hash - the hash that this address encodes\r\n * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\r\n * @param {Network=} data.network - the name of the network associated\r\n * @return {Address}\r\n */\r\nAddress._transformObject = function(data) {\r\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\r\n  $.checkArgument(data.type, 'Must provide a `type` property');\r\n  return {\r\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\r\n    network: Networks.get(data.network) || Networks.defaultNetwork,\r\n    type: data.type\r\n  };\r\n};\r\n\r\n/**\r\n * Internal function to discover the network and type based on the first data byte\r\n *\r\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\r\n * @returns {Object} An object with keys: network and type\r\n * @private\r\n */\r\nAddress._classifyFromVersion = function(buffer) {\r\n  var version = {};\r\n\r\n  if (buffer.length > 21) {\r\n    var info = Bech32.decode(buffer.toString('utf8'));\r\n    if (info.version !== 0 && info.version !== 1) { // v1 == taproot\r\n      throw new TypeError('Only witness v0 and v1 addresses are supported.');\r\n    }\r\n\r\n    if (info.version === 0) {\r\n      if (info.data.length === 20) {\r\n        version.type = Address.PayToWitnessPublicKeyHash;\r\n      } else if (info.data.length === 32) {\r\n        version.type = Address.PayToWitnessScriptHash;\r\n      } else {\r\n        throw new TypeError('Witness data must be either 20 or 32 bytes.')\r\n      }\r\n    } else if (info.version === 1) {\r\n      if (info.data.length === 32) {\r\n        version.type = Address.PayToTaproot;\r\n      } else {\r\n        throw new TypeError('Witness data must be 32 bytes for v1');\r\n      }\r\n    } else {\r\n    }\r\n    version.network = Networks.get(info.prefix, 'bech32prefix');\r\n  } else {\r\n\r\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\r\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\r\n\r\n    if (pubkeyhashNetwork) {\r\n      version.network = pubkeyhashNetwork;\r\n      version.type = Address.PayToPublicKeyHash;\r\n    } else if (scripthashNetwork) {\r\n      version.network = scripthashNetwork;\r\n      version.type = Address.PayToScriptHash;\r\n    }\r\n  }\r\n\r\n  return version;\r\n};\r\n\r\n/**\r\n * Internal function to transform a bitcoin address buffer\r\n *\r\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\r\n * @param {string=} network - The network: 'livenet' or 'testnet'\r\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\r\n * @returns {Object} An object with keys: hashBuffer, network and type\r\n * @private\r\n */\r\nAddress._transformBuffer = function(buffer, network, type) {\r\n  /* jshint maxcomplexity: 9 */\r\n  var info = {};\r\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\r\n    throw new TypeError('Address supplied is not a buffer.');\r\n  }\r\n\r\n  if (buffer.length < 21) {\r\n    throw new TypeError('Address buffer is incorrect length.');\r\n  }\r\n\r\n  var networkObj = Networks.get(network);\r\n  var bufferVersion = Address._classifyFromVersion(buffer);\r\n\r\n  if (network && !networkObj) {\r\n    throw new TypeError('Unknown network');\r\n  }\r\n\r\n  if (!bufferVersion.network || (networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey)) {\r\n    throw new TypeError('Address has mismatched network type.');\r\n  }\r\n\r\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\r\n    throw new TypeError('Address has mismatched type.');\r\n  }\r\n\r\n  if (buffer.length > 21) {\r\n    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;\r\n  } else {\r\n    info.hashBuffer = buffer.slice(1);\r\n  }\r\n  info.network = networkObj || bufferVersion.network;\r\n  info.type = bufferVersion.type;\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to transform a {@link PublicKey}\r\n *\r\n * @param {PublicKey} pubkey - An instance of PublicKey\r\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', 'scripthash', or 'taproot'\r\n * @returns {Object} An object with keys: hashBuffer, type\r\n * @private\r\n */\r\nAddress._transformPublicKey = function(pubkey, network, type) {\r\n  var info = {};\r\n  if (!(pubkey instanceof PublicKey)) {\r\n    throw new TypeError('Address must be an instance of PublicKey.');\r\n  }\r\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash && type !== Address.PayToTaproot) {\r\n    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, scripthash, or taproot to transform public key.');\r\n  }\r\n  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {\r\n    throw new TypeError('Witness addresses must use compressed public keys.');\r\n  }\r\n  if (type === Address.PayToScriptHash) {\r\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());\r\n  } else if (type === Address.PayToTaproot) {\r\n    info.hashBuffer = pubkey.createTapTweak().tweakedPubKey;\r\n  } else {\r\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\r\n  }\r\n  info.type = type || Address.PayToPublicKeyHash;\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to transform a {@link Script} into a `info` object.\r\n *\r\n * @param {Script} script - An instance of Script\r\n * @returns {Object} An object with keys: hashBuffer, type\r\n * @private\r\n */\r\nAddress._transformScript = function(script, network) {\r\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\r\n  var info = script.getAddressInfo(network);\r\n  if (!info) {\r\n    throw new errors.Script.CantDeriveAddress(script);\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * Creates a P2SH address from a set of public keys and a threshold.\r\n *\r\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\r\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\r\n * interface.\r\n *\r\n * @param {Array} publicKeys - a set of public keys to create an address\r\n * @param {number} threshold - the number of signatures needed to release the funds\r\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness\r\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored\r\n * @return {Address}\r\n */\r\nAddress.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {\r\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\r\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {\r\n    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');\r\n  }\r\n  if (nestedWitness || type === Address.PayToWitnessScriptHash) {\r\n    publicKeys = _.map(publicKeys, PublicKey);\r\n    for (var i = 0; i < publicKeys.length; i++) {\r\n      if (!publicKeys[i].compressed) {\r\n        throw new TypeError('Witness addresses must use compressed public keys.');\r\n      }\r\n    }\r\n  }\r\n  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);\r\n  if (nestedWitness) {\r\n    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);\r\n  }\r\n  return Address.payingTo(redeemScript, network, type);\r\n};\r\n\r\n/**\r\n * Internal function to transform a bitcoin address string\r\n *\r\n * @param {string} data\r\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\r\n * @returns {Object} An object with keys: hashBuffer, network and type\r\n * @private\r\n */\r\nAddress._transformString = function(data, network, type) {\r\n  if (typeof(data) !== 'string') {\r\n    throw new TypeError('data parameter supplied is not a string.');\r\n  }\r\n\r\n  if(data.length > 100) {\r\n    throw new TypeError('address string is too long');\r\n  }\r\n\r\n  if (network && !Networks.get(network)) {\r\n    throw new TypeError('Unknown network');\r\n  }\r\n\r\n  data = data.trim();\r\n\r\n  try {\r\n    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);\r\n    return info;\r\n  } catch (e) {\r\n    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash || type === Address.PayToTaproot) {\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  var addressBuffer = Base58Check.decode(data);\r\n  var info = Address._transformBuffer(addressBuffer, network, type);\r\n  return info;\r\n};\r\n\r\n/**\r\n * Instantiate an address from a PublicKey instance\r\n *\r\n * @param {PublicKey} data\r\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\r\n * @returns {Address} A new valid and frozen instance of an Address\r\n */\r\nAddress.fromPublicKey = function(data, network, type) {\r\n  var info = Address._transformPublicKey(data, network, type);\r\n  network = network || Networks.defaultNetwork;\r\n  return new Address(info.hashBuffer, network, info.type);\r\n};\r\n\r\n/**\r\n * Instantiate an address from a ripemd160 public key hash\r\n *\r\n * @param {Buffer} hash - An instance of buffer of the hash\r\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\r\n * @returns {Address} A new valid and frozen instance of an Address\r\n */\r\nAddress.fromPublicKeyHash = function(hash, network) {\r\n  var info = Address._transformHash(hash);\r\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\r\n};\r\n\r\n/**\r\n * Instantiate an address from a ripemd160 script hash\r\n *\r\n * @param {Buffer} hash - An instance of buffer of the hash\r\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\r\n * @returns {Address} A new valid and frozen instance of an Address\r\n */\r\nAddress.fromScriptHash = function(hash, network, type) {\r\n  $.checkArgument(hash, 'hash parameter is required');\r\n  var info = Address._transformHash(hash);\r\n  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {\r\n      throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');\r\n  }\r\n  var type = type || Address.PayToScriptHash;\r\n  return new Address(info.hashBuffer, network, type);\r\n};\r\n\r\n/**\r\n * Builds a p2sh address paying to script. This will hash the script and\r\n * use that to create the address.\r\n * If you want to extract an address associated with a script instead,\r\n * see {{Address#fromScript}}\r\n *\r\n * @param {Script} script - An instance of Script\r\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\r\n * @returns {Address} A new valid and frozen instance of an Address\r\n */\r\nAddress.payingTo = function(script, network, type) {\r\n  $.checkArgument(script, 'script is required');\r\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\r\n  var hash;\r\n  if (type === Address.PayToWitnessScriptHash) {\r\n    hash = Hash.sha256(script.toBuffer());\r\n  } else {\r\n    hash = Hash.sha256ripemd160(script.toBuffer());\r\n  }\r\n  var type = type || Address.PayToScriptHash;\r\n  return Address.fromScriptHash(hash, network, type);\r\n};\r\n\r\n/**\r\n * Extract address from a Script. The script must be of one\r\n * of the following types: p2pkh input, p2pkh output, p2sh input\r\n * or p2sh output.\r\n * This will analyze the script and extract address information from it.\r\n * If you want to transform any script to a p2sh Address paying\r\n * to that script's hash instead, use {{Address#payingTo}}\r\n *\r\n * @param {Script} script - An instance of Script\r\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\r\n * @returns {Address} A new valid and frozen instance of an Address\r\n */\r\nAddress.fromScript = function(script, network) {\r\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\r\n  var info = Address._transformScript(script, network);\r\n  return new Address(info.hashBuffer, network, info.type);\r\n};\r\n\r\n/**\r\n * Instantiate an address from a buffer of the address\r\n *\r\n * @param {Buffer} buffer - An instance of buffer of the address\r\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {string=} type - The type of address: 'script' or 'pubkey'\r\n * @returns {Address} A new valid and frozen instance of an Address\r\n */\r\nAddress.fromBuffer = function(buffer, network, type) {\r\n  var info = Address._transformBuffer(buffer, network, type);\r\n  return new Address(info.hashBuffer, info.network, info.type);\r\n};\r\n\r\n/**\r\n * Instantiate an address from an address string\r\n *\r\n * @param {string} str - An string of the bitcoin address\r\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {string=} type - The type of address: 'script' or 'pubkey'\r\n * @returns {Address} A new valid and frozen instance of an Address\r\n */\r\nAddress.fromString = function(str, network, type) {\r\n  var info = Address._transformString(str, network, type);\r\n  return new Address(info.hashBuffer, info.network, info.type);\r\n};\r\n\r\n/**\r\n * Instantiate an address from an Object\r\n *\r\n * @param {string} json - An JSON string or Object with keys: hash, network and type\r\n * @returns {Address} A new valid instance of an Address\r\n */\r\nAddress.fromObject = function fromObject(obj) {\r\n  $.checkState(\r\n    JSUtil.isHexa(obj.hash),\r\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\r\n  );\r\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\r\n  return new Address(hashBuffer, obj.network, obj.type);\r\n};\r\n\r\n/**\r\n * Will return a validation error if exists\r\n *\r\n * @example\r\n * ```javascript\r\n * // a network mismatch error\r\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\r\n * ```\r\n *\r\n * @param {string} data - The encoded data\r\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {string} type - The type of address: 'script' or 'pubkey'\r\n * @returns {null|Error} The corresponding error message\r\n */\r\nAddress.getValidationError = function(data, network, type) {\r\n  var error;\r\n  try {\r\n    /* jshint nonew: false */\r\n    new Address(data, network, type);\r\n  } catch (e) {\r\n    error = e;\r\n  }\r\n  return error;\r\n};\r\n\r\n/**\r\n * Will return a boolean if an address is valid\r\n *\r\n * @example\r\n * ```javascript\r\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\r\n * ```\r\n *\r\n * @param {string} data - The encoded data\r\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\r\n * @param {string} type - The type of address: 'script' or 'pubkey'\r\n * @returns {boolean} The corresponding error message\r\n */\r\nAddress.isValid = function(data, network, type) {\r\n  return !Address.getValidationError(data, network, type);\r\n};\r\n\r\n/**\r\n * Returns true if an address is of pay to public key hash type\r\n * @return boolean\r\n */\r\nAddress.prototype.isPayToPublicKeyHash = function() {\r\n  return this.type === Address.PayToPublicKeyHash;\r\n};\r\n\r\n/**\r\n * Returns true if an address is of pay to script hash type\r\n * @return boolean\r\n */\r\nAddress.prototype.isPayToScriptHash = function() {\r\n  return this.type === Address.PayToScriptHash;\r\n};\r\n\r\n/**\r\n * Returns true if an address is of pay to witness public key hash type\r\n * @return boolean\r\n */\r\nAddress.prototype.isPayToWitnessPublicKeyHash = function() {\r\n  return this.type === Address.PayToWitnessPublicKeyHash;\r\n};\r\n\r\n/**\r\n * Returns true if an address is of pay to witness script hash type\r\n * @return boolean\r\n */\r\nAddress.prototype.isPayToWitnessScriptHash = function() {\r\n  return this.type === Address.PayToWitnessScriptHash;\r\n};\r\n\r\n/**\r\n * Returns true if an address is of pay to Taproot script hash type\r\n * @returns {boolean}\r\n */\r\nAddress.prototype.isPayToTaproot = function() {\r\n  return this.type === Address.PayToTaproot;\r\n}\r\n\r\n/**\r\n * Will return a buffer representation of the address\r\n *\r\n * @returns {Buffer} Bitcoin address buffer\r\n */\r\nAddress.prototype.toBuffer = function() {\r\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\r\n    return Buffer.from(this.toString(), 'utf8')\r\n  }\r\n  var version = Buffer.from([this.network[this.type]]);\r\n  return Buffer.concat([version, this.hashBuffer]);\r\n};\r\n\r\n/**\r\n * @returns {Object} A plain object with the address information\r\n */\r\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\r\n  return {\r\n    hash: this.hashBuffer.toString('hex'),\r\n    type: this.type,\r\n    network: this.network.toString()\r\n  };\r\n};\r\n\r\n/**\r\n * Will return a the string representation of the address\r\n *\r\n * @returns {string} Bitcoin address\r\n */\r\nAddress.prototype.toString = function() {\r\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash() || this.isPayToTaproot()) {\r\n    let prefix = this.network.bech32prefix;\r\n    let version = 0;\r\n    let encoding = Bech32.encodings.BECH32;\r\n    if (this.isPayToTaproot()) {\r\n      version = 1;\r\n      encoding = Bech32.encodings.BECH32M;\r\n    }\r\n    return Bech32.encode(prefix, version, this.hashBuffer, encoding);\r\n  }\r\n  return Base58Check.encode(this.toBuffer());\r\n};\r\n\r\n/**\r\n * Will return a string formatted for the console\r\n *\r\n * @returns {string} Bitcoin address\r\n */\r\nAddress.prototype.inspect = function() {\r\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\r\n};\r\n\r\nmodule.exports = Address;\r\n\r\nvar Script = __webpack_require__(/*! ./script */ \"../bitcore-lib/lib/script/index.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLG9EQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvYWRkcmVzcy5qcz9lZWZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XHJcbnZhciBCYXNlNThDaGVjayA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYmFzZTU4Y2hlY2snKTtcclxudmFyIEJlY2gzMiA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYmVjaDMyJyk7XHJcbnZhciBOZXR3b3JrcyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcclxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2NyeXB0by9oYXNoJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuL3V0aWwvanMnKTtcclxudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vcHVibGlja2V5Jyk7XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGFuIGFkZHJlc3MgU3RyaW5nIG9yIEJ1ZmZlciwgYSBwdWJsaWMga2V5IG9yIHNjcmlwdCBoYXNoIEJ1ZmZlcixcclxuICogb3IgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFB1YmxpY0tleX0gb3Ige0BsaW5rIFNjcmlwdH0uXHJcbiAqXHJcbiAqIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGNsYXNzLCBhbmQgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBwcm92aWRlZCB0byB0aGlzIGNvbnN0cnVjdG9yIGlzIGFuXHJcbiAqIGBBZGRyZXNzYCBpbnN0YW5jZSwgdGhlIHNhbWUgYXJndW1lbnQgd2lsbCBiZSByZXR1cm5lZC5cclxuICpcclxuICogQW4gYWRkcmVzcyBoYXMgdHdvIGtleSBwcm9wZXJ0aWVzOiBgbmV0d29ya2AgYW5kIGB0eXBlYC4gVGhlIHR5cGUgaXMgb25lIG9mXHJcbiAqIGBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaGAgKHZhbHVlIGlzIHRoZSBgJ3B1YmtleWhhc2gnYCBzdHJpbmcpLFxyXG4gKiBgQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2hgICh0aGUgc3RyaW5nIGAnc2NyaXB0aGFzaCdgKSxcclxuICogYEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaGAgKHRoZSBzdHJpbmcgYCd3aXRuZXNzcHVia2V5aGFzaCdgKSxcclxuICogb3IgYEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaGAgKHRoZSBzdHJpbmcgYCd3aXRuZXNzc2NyaXB0aGFzaCdgKS5cclxuICogVGhlIG5ldHdvcmsgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIE5ldHdvcmt9LlxyXG4gKiBZb3UgY2FuIHF1aWNrbHkgY2hlY2sgd2hldGhlciBhbiBhZGRyZXNzIGlzIG9mIGEgZ2l2ZW4ga2luZCBieSB1c2luZyB0aGUgbWV0aG9kc1xyXG4gKiBgaXNQYXlUb1B1YmxpY0tleUhhc2hgLCBgaXNQYXlUb1NjcmlwdEhhc2hgLCBgaXNQYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoYCxcclxuICogYW5kIGBpc1BheVRvV2l0bmVzc1NjcmlwdEhhc2hgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIHZhbGlkYXRlIHRoYXQgYW4gaW5wdXQgZmllbGQgaXMgdmFsaWRcclxuICogdmFyIGVycm9yID0gQWRkcmVzcy5nZXRWYWxpZGF0aW9uRXJyb3IoaW5wdXQsICd0ZXN0bmV0Jyk7XHJcbiAqIGlmICghZXJyb3IpIHtcclxuICogICB2YXIgYWRkcmVzcyA9IEFkZHJlc3MoaW5wdXQsICd0ZXN0bmV0Jyk7XHJcbiAqIH0gZWxzZSB7XHJcbiAqICAgLy8gaW52YWxpZCBuZXR3b3JrIG9yIGNoZWNrc3VtICh0eXBvPylcclxuICogICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NzYWdlO1xyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIGdldCBhbiBhZGRyZXNzIGZyb20gYSBwdWJsaWMga2V5XHJcbiAqIHZhciBhZGRyZXNzID0gQWRkcmVzcyhwdWJsaWNLZXksICd0ZXN0bmV0JykudG9TdHJpbmcoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSAtIFRoZSBlbmNvZGVkIGRhdGEgaW4gdmFyaW91cyBmb3JtYXRzXHJcbiAqIEBwYXJhbSB7TmV0d29ya3xTdHJpbmd8bnVtYmVyPX0gbmV0d29yayAtIFRoZSBuZXR3b3JrOiAnbGl2ZW5ldCcgb3IgJ3Rlc3RuZXQnXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIFRoZSB0eXBlIG9mIGFkZHJlc3M6ICdzY3JpcHRoYXNoJywgJ3B1YmtleWhhc2gnLCB3aXRuZXNzc2NyaXB0aGFzaCwgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3RhcHJvb3QnXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbXVsdGlzaWdUeXBlIC0gVGhlIHR5cGUgb2YgbXVsdGlzaWc6ICdzY3JpcHRoYXNoJyBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXHJcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBBZGRyZXNzKGRhdGEsIG5ldHdvcmssIHR5cGUsIG11bHRpc2lnVHlwZSkge1xyXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMiAqL1xyXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xyXG5cclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWRkcmVzcykpIHtcclxuICAgIHJldHVybiBuZXcgQWRkcmVzcyhkYXRhLCBuZXR3b3JrLCB0eXBlKTtcclxuICB9XHJcblxyXG4gIGlmIChfLmlzQXJyYXkoZGF0YSkgJiYgXy5pc051bWJlcihuZXR3b3JrKSkge1xyXG4gICAgcmV0dXJuIEFkZHJlc3MuY3JlYXRlTXVsdGlzaWcoZGF0YSwgbmV0d29yaywgdHlwZSwgZmFsc2UsIG11bHRpc2lnVHlwZSk7XHJcbiAgfVxyXG5cclxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFkZHJlc3MpIHtcclxuICAgIC8vIEltbXV0YWJsZSBpbnN0YW5jZVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICAkLmNoZWNrQXJndW1lbnQoZGF0YSwgJ0ZpcnN0IGFyZ3VtZW50IGlzIHJlcXVpcmVkLCBwbGVhc2UgaW5jbHVkZSBhZGRyZXNzIGRhdGEuJywgJ2d1aWRlL2FkZHJlc3MuaHRtbCcpO1xyXG5cclxuICBpZiAobmV0d29yayAmJiAhTmV0d29ya3MuZ2V0KG5ldHdvcmspKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBcImxpdmVuZXRcIiBvciBcInRlc3RuZXRcIi4nKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlICYmIChcclxuICAgIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoXHJcbiAgICAmJiB0eXBlICE9PSBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaFxyXG4gICAgJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoXHJcbiAgICAmJiB0eXBlICE9PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2hcclxuICAgICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9UYXByb290KSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcmQgYXJndW1lbnQgbXVzdCBiZSBcInB1YmtleWhhc2hcIiwgXCJzY3JpcHRoYXNoXCIsIFwid2l0bmVzc3B1YmtleWhhc2hcIiwgXCJ3aXRuZXNzc2NyaXB0aGFzaFwiLCBvciBcInRhcHJvb3RcIi4nKTtcclxuICB9XHJcblxyXG4gIHZhciBpbmZvID0gdGhpcy5fY2xhc3NpZnlBcmd1bWVudHMoZGF0YSwgbmV0d29yaywgdHlwZSk7XHJcblxyXG4gIC8vIHNldCBkZWZhdWx0cyBpZiBub3Qgc2V0XHJcbiAgaW5mby5uZXR3b3JrID0gaW5mby5uZXR3b3JrIHx8IE5ldHdvcmtzLmdldChuZXR3b3JrKSB8fCBOZXR3b3Jrcy5kZWZhdWx0TmV0d29yaztcclxuICBpbmZvLnR5cGUgPSBpbmZvLnR5cGUgfHwgdHlwZSB8fCBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcclxuXHJcbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XHJcbiAgICBoYXNoQnVmZmVyOiBpbmZvLmhhc2hCdWZmZXIsXHJcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmssXHJcbiAgICB0eXBlOiBpbmZvLnR5cGVcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHNwbGl0IGRpZmZlcmVudCBraW5kcyBvZiBhcmd1bWVudHMgb2YgdGhlIGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSAtIFRoZSBlbmNvZGVkIGRhdGEgaW4gdmFyaW91cyBmb3JtYXRzXHJcbiAqIEBwYXJhbSB7TmV0d29ya3xTdHJpbmd8bnVtYmVyPX0gbmV0d29yayAtIFRoZSBuZXR3b3JrOiAnbGl2ZW5ldCcgb3IgJ3Rlc3RuZXQnXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIFRoZSB0eXBlIG9mIGFkZHJlc3M6ICdzY3JpcHQnIG9yICdwdWJrZXknXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIFwiaW5mb1wiIG9iamVjdCB3aXRoIFwidHlwZVwiLCBcIm5ldHdvcmtcIiwgYW5kIFwiaGFzaEJ1ZmZlclwiXHJcbiAqL1xyXG5BZGRyZXNzLnByb3RvdHlwZS5fY2xhc3NpZnlBcmd1bWVudHMgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrLCB0eXBlKSB7XHJcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXHJcbiAgLy8gdHJhbnNmb3JtIGFuZCB2YWxpZGF0ZSBpbnB1dCBkYXRhXHJcbiAgaWYgKChkYXRhIGluc3RhbmNlb2YgQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJiAoZGF0YS5sZW5ndGggPT09IDIwIHx8IGRhdGEubGVuZ3RoID09PSAzMikpIHtcclxuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1IYXNoKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xyXG4gIH0gZWxzZSBpZiAoKGRhdGEgaW5zdGFuY2VvZiBCdWZmZXIgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmIGRhdGEubGVuZ3RoID49IDIxKSB7XHJcbiAgICByZXR1cm4gQWRkcmVzcy5fdHJhbnNmb3JtQnVmZmVyKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xyXG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFB1YmxpY0tleSkge1xyXG4gICAgcmV0dXJuIEFkZHJlc3MuX3RyYW5zZm9ybVB1YmxpY0tleShkYXRhLCBuZXR3b3JrLCB0eXBlKTtcclxuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBTY3JpcHQpIHtcclxuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1TY3JpcHQoZGF0YSwgbmV0d29yayk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YoZGF0YSkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gQWRkcmVzcy5fdHJhbnNmb3JtU3RyaW5nKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xyXG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChkYXRhKSkge1xyXG4gICAgcmV0dXJuIEFkZHJlc3MuX3RyYW5zZm9ybU9iamVjdChkYXRhKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgaXMgYW4gdW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0LicpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKiBAc3RhdGljICovXHJcbkFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoID0gJ3B1YmtleWhhc2gnO1xyXG4vKiogQHN0YXRpYyAqL1xyXG5BZGRyZXNzLlBheVRvU2NyaXB0SGFzaCA9ICdzY3JpcHRoYXNoJztcclxuLyoqIEBzdGF0aWMgKi9cclxuQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoID0gJ3dpdG5lc3NwdWJrZXloYXNoJztcclxuLyoqIEBzdGF0aWMgKi9cclxuQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoID0gJ3dpdG5lc3NzY3JpcHRoYXNoJztcclxuLyoqIEBzdGF0aWMgKi9cclxuQWRkcmVzcy5QYXlUb1RhcHJvb3QgPSAndGFwcm9vdCc7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtCdWZmZXJ9IGhhc2ggLSBBbiBpbnN0YW5jZSBvZiBhIGhhc2ggQnVmZmVyXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZWl0aGVyICdwdWJrZXloYXNoJywgJ3NjcmlwdGhhc2gnLCAnd2l0bmVzc3B1YmtleWhhc2gnLCBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXHJcbiAqIEBwYXJhbSB7TmV0d29yaz19IG5ldHdvcmsgLSB0aGUgbmFtZSBvZiB0aGUgbmV0d29yayBhc3NvY2lhdGVkXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGhhc2hCdWZmZXJcclxuICogQHByaXZhdGVcclxuICovXHJcbkFkZHJlc3MuX3RyYW5zZm9ybUhhc2ggPSBmdW5jdGlvbihoYXNoLCBuZXR3b3JrLCB0eXBlKSB7XHJcbiAgdmFyIGluZm8gPSB7fTtcclxuICBpZiAoIShoYXNoIGluc3RhbmNlb2YgQnVmZmVyKSAmJiAhKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRkcmVzcyBzdXBwbGllZCBpcyBub3QgYSBidWZmZXIuJyk7XHJcbiAgfVxyXG4gIGlmIChoYXNoLmxlbmd0aCAhPT0gMjAgJiYgaGFzaC5sZW5ndGggIT09IDMyKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBZGRyZXNzIGhhc2hidWZmZXJzIG11c3QgYmUgZWl0aGVyIDIwIG9yIDMyIGJ5dGVzLicpO1xyXG4gIH1cclxuICBpbmZvLmhhc2hCdWZmZXIgPSBoYXNoO1xyXG4gIGluZm8ubmV0d29yayA9IE5ldHdvcmtzLmdldChuZXR3b3JrKSB8fCBOZXR3b3Jrcy5kZWZhdWx0TmV0d29yaztcclxuICBpbmZvLnR5cGUgPSB0eXBlO1xyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc2VyaWFsaXplcyBhbiBhZGRyZXNzIHNlcmlhbGl6ZWQgdGhyb3VnaCBgQWRkcmVzcyN0b09iamVjdCgpYFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS5oYXNoIC0gdGhlIGhhc2ggdGhhdCB0aGlzIGFkZHJlc3MgZW5jb2Rlc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS50eXBlIC0gZWl0aGVyICdwdWJrZXloYXNoJywgJ3NjcmlwdGhhc2gnLCAnd2l0bmVzc3B1YmtleWhhc2gnLCBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXHJcbiAqIEBwYXJhbSB7TmV0d29yaz19IGRhdGEubmV0d29yayAtIHRoZSBuYW1lIG9mIHRoZSBuZXR3b3JrIGFzc29jaWF0ZWRcclxuICogQHJldHVybiB7QWRkcmVzc31cclxuICovXHJcbkFkZHJlc3MuX3RyYW5zZm9ybU9iamVjdCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoZGF0YS5oYXNoIHx8IGRhdGEuaGFzaEJ1ZmZlciwgJ011c3QgcHJvdmlkZSBhIGBoYXNoYCBvciBgaGFzaEJ1ZmZlcmAgcHJvcGVydHknKTtcclxuICAkLmNoZWNrQXJndW1lbnQoZGF0YS50eXBlLCAnTXVzdCBwcm92aWRlIGEgYHR5cGVgIHByb3BlcnR5Jyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGhhc2hCdWZmZXI6IGRhdGEuaGFzaCA/IEJ1ZmZlci5mcm9tKGRhdGEuaGFzaCwgJ2hleCcpIDogZGF0YS5oYXNoQnVmZmVyLFxyXG4gICAgbmV0d29yazogTmV0d29ya3MuZ2V0KGRhdGEubmV0d29yaykgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcmssXHJcbiAgICB0eXBlOiBkYXRhLnR5cGVcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGRpc2NvdmVyIHRoZSBuZXR3b3JrIGFuZCB0eXBlIGJhc2VkIG9uIHRoZSBmaXJzdCBkYXRhIGJ5dGVcclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIEFuIGluc3RhbmNlIG9mIGEgaGV4IGVuY29kZWQgYWRkcmVzcyBCdWZmZXJcclxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogbmV0d29yayBhbmQgdHlwZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQWRkcmVzcy5fY2xhc3NpZnlGcm9tVmVyc2lvbiA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gIHZhciB2ZXJzaW9uID0ge307XHJcblxyXG4gIGlmIChidWZmZXIubGVuZ3RoID4gMjEpIHtcclxuICAgIHZhciBpbmZvID0gQmVjaDMyLmRlY29kZShidWZmZXIudG9TdHJpbmcoJ3V0ZjgnKSk7XHJcbiAgICBpZiAoaW5mby52ZXJzaW9uICE9PSAwICYmIGluZm8udmVyc2lvbiAhPT0gMSkgeyAvLyB2MSA9PSB0YXByb290XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgd2l0bmVzcyB2MCBhbmQgdjEgYWRkcmVzc2VzIGFyZSBzdXBwb3J0ZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGluZm8udmVyc2lvbiA9PT0gMCkge1xyXG4gICAgICBpZiAoaW5mby5kYXRhLmxlbmd0aCA9PT0gMjApIHtcclxuICAgICAgICB2ZXJzaW9uLnR5cGUgPSBBZGRyZXNzLlBheVRvV2l0bmVzc1B1YmxpY0tleUhhc2g7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5mby5kYXRhLmxlbmd0aCA9PT0gMzIpIHtcclxuICAgICAgICB2ZXJzaW9uLnR5cGUgPSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2g7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBkYXRhIG11c3QgYmUgZWl0aGVyIDIwIG9yIDMyIGJ5dGVzLicpXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaW5mby52ZXJzaW9uID09PSAxKSB7XHJcbiAgICAgIGlmIChpbmZvLmRhdGEubGVuZ3RoID09PSAzMikge1xyXG4gICAgICAgIHZlcnNpb24udHlwZSA9IEFkZHJlc3MuUGF5VG9UYXByb290O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgZGF0YSBtdXN0IGJlIDMyIGJ5dGVzIGZvciB2MScpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgfVxyXG4gICAgdmVyc2lvbi5uZXR3b3JrID0gTmV0d29ya3MuZ2V0KGluZm8ucHJlZml4LCAnYmVjaDMycHJlZml4Jyk7XHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICB2YXIgcHVia2V5aGFzaE5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQoYnVmZmVyWzBdLCAncHVia2V5aGFzaCcpO1xyXG4gICAgdmFyIHNjcmlwdGhhc2hOZXR3b3JrID0gTmV0d29ya3MuZ2V0KGJ1ZmZlclswXSwgJ3NjcmlwdGhhc2gnKTtcclxuXHJcbiAgICBpZiAocHVia2V5aGFzaE5ldHdvcmspIHtcclxuICAgICAgdmVyc2lvbi5uZXR3b3JrID0gcHVia2V5aGFzaE5ldHdvcms7XHJcbiAgICAgIHZlcnNpb24udHlwZSA9IEFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoO1xyXG4gICAgfSBlbHNlIGlmIChzY3JpcHRoYXNoTmV0d29yaykge1xyXG4gICAgICB2ZXJzaW9uLm5ldHdvcmsgPSBzY3JpcHRoYXNoTmV0d29yaztcclxuICAgICAgdmVyc2lvbi50eXBlID0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmVyc2lvbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBiaXRjb2luIGFkZHJlc3MgYnVmZmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgLSBBbiBpbnN0YW5jZSBvZiBhIGhleCBlbmNvZGVkIGFkZHJlc3MgQnVmZmVyXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmV0d29yayAtIFRoZSBuZXR3b3JrOiAnbGl2ZW5ldCcgb3IgJ3Rlc3RuZXQnXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIFRoZSB0eXBlOiAncHVia2V5aGFzaCcsICdzY3JpcHRoYXNoJywgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3dpdG5lc3NzY3JpcHRoYXNoJ1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyLCBuZXR3b3JrIGFuZCB0eXBlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5BZGRyZXNzLl90cmFuc2Zvcm1CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIsIG5ldHdvcmssIHR5cGUpIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogOSAqL1xyXG4gIHZhciBpbmZvID0ge307XHJcbiAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgQnVmZmVyKSAmJiAhKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBZGRyZXNzIHN1cHBsaWVkIGlzIG5vdCBhIGJ1ZmZlci4nKTtcclxuICB9XHJcblxyXG4gIGlmIChidWZmZXIubGVuZ3RoIDwgMjEpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgYnVmZmVyIGlzIGluY29ycmVjdCBsZW5ndGguJyk7XHJcbiAgfVxyXG5cclxuICB2YXIgbmV0d29ya09iaiA9IE5ldHdvcmtzLmdldChuZXR3b3JrKTtcclxuICB2YXIgYnVmZmVyVmVyc2lvbiA9IEFkZHJlc3MuX2NsYXNzaWZ5RnJvbVZlcnNpb24oYnVmZmVyKTtcclxuXHJcbiAgaWYgKG5ldHdvcmsgJiYgIW5ldHdvcmtPYmopIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gbmV0d29yaycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFidWZmZXJWZXJzaW9uLm5ldHdvcmsgfHwgKG5ldHdvcmtPYmogJiYgbmV0d29ya09iai54cHVia2V5ICE9PSBidWZmZXJWZXJzaW9uLm5ldHdvcmsueHB1YmtleSkpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgaGFzIG1pc21hdGNoZWQgbmV0d29yayB0eXBlLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFidWZmZXJWZXJzaW9uLnR5cGUgfHwgKHR5cGUgJiYgdHlwZSAhPT0gYnVmZmVyVmVyc2lvbi50eXBlKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRkcmVzcyBoYXMgbWlzbWF0Y2hlZCB0eXBlLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPiAyMSkge1xyXG4gICAgaW5mby5oYXNoQnVmZmVyID0gQmVjaDMyLmRlY29kZShidWZmZXIudG9TdHJpbmcoJ3V0ZjgnKSkuZGF0YTtcclxuICB9IGVsc2Uge1xyXG4gICAgaW5mby5oYXNoQnVmZmVyID0gYnVmZmVyLnNsaWNlKDEpO1xyXG4gIH1cclxuICBpbmZvLm5ldHdvcmsgPSBuZXR3b3JrT2JqIHx8IGJ1ZmZlclZlcnNpb24ubmV0d29yaztcclxuICBpbmZvLnR5cGUgPSBidWZmZXJWZXJzaW9uLnR5cGU7XHJcbiAgcmV0dXJuIGluZm87XHJcbn07XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGEge0BsaW5rIFB1YmxpY0tleX1cclxuICpcclxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleSAtIEFuIGluc3RhbmNlIG9mIFB1YmxpY0tleVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEVpdGhlciAncHVia2V5aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsICdzY3JpcHRoYXNoJywgb3IgJ3RhcHJvb3QnXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGhhc2hCdWZmZXIsIHR5cGVcclxuICogQHByaXZhdGVcclxuICovXHJcbkFkZHJlc3MuX3RyYW5zZm9ybVB1YmxpY0tleSA9IGZ1bmN0aW9uKHB1YmtleSwgbmV0d29yaywgdHlwZSkge1xyXG4gIHZhciBpbmZvID0ge307XHJcbiAgaWYgKCEocHVia2V5IGluc3RhbmNlb2YgUHVibGljS2V5KSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRkcmVzcyBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFB1YmxpY0tleS4nKTtcclxuICB9XHJcbiAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2ggJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9UYXByb290KSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlIG11c3QgYmUgZWl0aGVyIHB1YmtleWhhc2gsIHdpdG5lc3NwdWJrZXloYXNoLCBzY3JpcHRoYXNoLCBvciB0YXByb290IHRvIHRyYW5zZm9ybSBwdWJsaWMga2V5LicpO1xyXG4gIH1cclxuICBpZiAoIXB1YmtleS5jb21wcmVzc2VkICYmICh0eXBlID09PSBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaCB8fCB0eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1B1YmxpY0tleUhhc2gpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGFkZHJlc3NlcyBtdXN0IHVzZSBjb21wcmVzc2VkIHB1YmxpYyBrZXlzLicpO1xyXG4gIH1cclxuICBpZiAodHlwZSA9PT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2gpIHtcclxuICAgIGluZm8uaGFzaEJ1ZmZlciA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKFNjcmlwdC5idWlsZFdpdG5lc3NWME91dChwdWJrZXkpLnRvQnVmZmVyKCkpO1xyXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gQWRkcmVzcy5QYXlUb1RhcHJvb3QpIHtcclxuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHB1YmtleS5jcmVhdGVUYXBUd2VhaygpLnR3ZWFrZWRQdWJLZXk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGluZm8uaGFzaEJ1ZmZlciA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKHB1YmtleS50b0J1ZmZlcigpKTtcclxuICB9XHJcbiAgaW5mby50eXBlID0gdHlwZSB8fCBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcclxuICByZXR1cm4gaW5mbztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSB7QGxpbmsgU2NyaXB0fSBpbnRvIGEgYGluZm9gIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtTY3JpcHR9IHNjcmlwdCAtIEFuIGluc3RhbmNlIG9mIFNjcmlwdFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyLCB0eXBlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5BZGRyZXNzLl90cmFuc2Zvcm1TY3JpcHQgPSBmdW5jdGlvbihzY3JpcHQsIG5ldHdvcmspIHtcclxuICAkLmNoZWNrQXJndW1lbnQoc2NyaXB0IGluc3RhbmNlb2YgU2NyaXB0LCAnc2NyaXB0IG11c3QgYmUgYSBTY3JpcHQgaW5zdGFuY2UnKTtcclxuICB2YXIgaW5mbyA9IHNjcmlwdC5nZXRBZGRyZXNzSW5mbyhuZXR3b3JrKTtcclxuICBpZiAoIWluZm8pIHtcclxuICAgIHRocm93IG5ldyBlcnJvcnMuU2NyaXB0LkNhbnREZXJpdmVBZGRyZXNzKHNjcmlwdCk7XHJcbiAgfVxyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBQMlNIIGFkZHJlc3MgZnJvbSBhIHNldCBvZiBwdWJsaWMga2V5cyBhbmQgYSB0aHJlc2hvbGQuXHJcbiAqXHJcbiAqIFRoZSBhZGRyZXNzZXMgd2lsbCBiZSBzb3J0ZWQgbGV4aWNvZ3JhcGhpY2FsbHksIGFzIHRoYXQgaXMgdGhlIHRyZW5kIGluIGJpdGNvaW4uXHJcbiAqIFRvIGNyZWF0ZSBhbiBhZGRyZXNzIGZyb20gdW5zb3J0ZWQgcHVibGljIGtleXMsIHVzZSB0aGUge0BsaW5rIFNjcmlwdCNidWlsZE11bHRpc2lnT3V0fVxyXG4gKiBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHB1YmxpY0tleXMgLSBhIHNldCBvZiBwdWJsaWMga2V5cyB0byBjcmVhdGUgYW4gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIC0gdGhlIG51bWJlciBvZiBzaWduYXR1cmVzIG5lZWRlZCB0byByZWxlYXNlIHRoZSBmdW5kc1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcclxuICogQHBhcmFtIHtib29sZWFuPX0gbmVzdGVkV2l0bmVzcyAtIGlmIHRoZSBhZGRyZXNzIHVzZXMgYSBuZXN0ZWQgcDJzaCB3aXRuZXNzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdzY3JpcHRoYXNoJyBvciAnd2l0bmVzc3NjcmlwdGhhc2gnLiBJZiBuZXN0ZWRXaXRuZXNzIGlzIHNldCwgdGhlbiB0aGlzIGlzIGlnbm9yZWRcclxuICogQHJldHVybiB7QWRkcmVzc31cclxuICovXHJcbkFkZHJlc3MuY3JlYXRlTXVsdGlzaWcgPSBmdW5jdGlvbihwdWJsaWNLZXlzLCB0aHJlc2hvbGQsIG5ldHdvcmssIG5lc3RlZFdpdG5lc3MsIHR5cGUpIHtcclxuICBuZXR3b3JrID0gbmV0d29yayB8fCBwdWJsaWNLZXlzWzBdLm5ldHdvcmsgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcms7XHJcbiAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2ggJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlIG11c3QgYmUgZWl0aGVyIHNjcmlwdGhhc2ggb3Igd2l0bmVzc3NjcmlwdGhhc2ggdG8gY3JlYXRlIG11bHRpc2lnLicpO1xyXG4gIH1cclxuICBpZiAobmVzdGVkV2l0bmVzcyB8fCB0eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2gpIHtcclxuICAgIHB1YmxpY0tleXMgPSBfLm1hcChwdWJsaWNLZXlzLCBQdWJsaWNLZXkpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICghcHVibGljS2V5c1tpXS5jb21wcmVzc2VkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBhZGRyZXNzZXMgbXVzdCB1c2UgY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgcmVkZWVtU2NyaXB0ID0gU2NyaXB0LmJ1aWxkTXVsdGlzaWdPdXQocHVibGljS2V5cywgdGhyZXNob2xkKTtcclxuICBpZiAobmVzdGVkV2l0bmVzcykge1xyXG4gICAgcmV0dXJuIEFkZHJlc3MucGF5aW5nVG8oU2NyaXB0LmJ1aWxkV2l0bmVzc011bHRpc2lnT3V0RnJvbVNjcmlwdChyZWRlZW1TY3JpcHQpLCBuZXR3b3JrKTtcclxuICB9XHJcbiAgcmV0dXJuIEFkZHJlc3MucGF5aW5nVG8ocmVkZWVtU2NyaXB0LCBuZXR3b3JrLCB0eXBlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBiaXRjb2luIGFkZHJlc3Mgc3RyaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE5ldHdvcms9fSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcclxuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0gVGhlIHR5cGU6ICdwdWJrZXloYXNoJywgJ3NjcmlwdGhhc2gnLCAnd2l0bmVzc3B1YmtleWhhc2gnLCBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGhhc2hCdWZmZXIsIG5ldHdvcmsgYW5kIHR5cGVcclxuICogQHByaXZhdGVcclxuICovXHJcbkFkZHJlc3MuX3RyYW5zZm9ybVN0cmluZyA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmssIHR5cGUpIHtcclxuICBpZiAodHlwZW9mKGRhdGEpICE9PSAnc3RyaW5nJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBwYXJhbWV0ZXIgc3VwcGxpZWQgaXMgbm90IGEgc3RyaW5nLicpO1xyXG4gIH1cclxuXHJcbiAgaWYoZGF0YS5sZW5ndGggPiAxMDApIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FkZHJlc3Mgc3RyaW5nIGlzIHRvbyBsb25nJyk7XHJcbiAgfVxyXG5cclxuICBpZiAobmV0d29yayAmJiAhTmV0d29ya3MuZ2V0KG5ldHdvcmspKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIG5ldHdvcmsnKTtcclxuICB9XHJcblxyXG4gIGRhdGEgPSBkYXRhLnRyaW0oKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtQnVmZmVyKEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JyksIG5ldHdvcmssIHR5cGUpO1xyXG4gICAgcmV0dXJuIGluZm87XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaWYgKHR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaCB8fCB0eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2ggfHwgdHlwZSA9PT0gQWRkcmVzcy5QYXlUb1RhcHJvb3QpIHtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBhZGRyZXNzQnVmZmVyID0gQmFzZTU4Q2hlY2suZGVjb2RlKGRhdGEpO1xyXG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtQnVmZmVyKGFkZHJlc3NCdWZmZXIsIG5ldHdvcmssIHR5cGUpO1xyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhIFB1YmxpY0tleSBpbnN0YW5jZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gZGF0YVxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBFaXRoZXIgJ3B1YmtleWhhc2gnLCAnd2l0bmVzc3B1YmtleWhhc2gnLCBvciAnc2NyaXB0aGFzaCdcclxuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xyXG4gKi9cclxuQWRkcmVzcy5mcm9tUHVibGljS2V5ID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaywgdHlwZSkge1xyXG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtUHVibGljS2V5KGRhdGEsIG5ldHdvcmssIHR5cGUpO1xyXG4gIG5ldHdvcmsgPSBuZXR3b3JrIHx8IE5ldHdvcmtzLmRlZmF1bHROZXR3b3JrO1xyXG4gIHJldHVybiBuZXcgQWRkcmVzcyhpbmZvLmhhc2hCdWZmZXIsIG5ldHdvcmssIGluZm8udHlwZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGEgcmlwZW1kMTYwIHB1YmxpYyBrZXkgaGFzaFxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaCAtIEFuIGluc3RhbmNlIG9mIGJ1ZmZlciBvZiB0aGUgaGFzaFxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcclxuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xyXG4gKi9cclxuQWRkcmVzcy5mcm9tUHVibGljS2V5SGFzaCA9IGZ1bmN0aW9uKGhhc2gsIG5ldHdvcmspIHtcclxuICB2YXIgaW5mbyA9IEFkZHJlc3MuX3RyYW5zZm9ybUhhc2goaGFzaCk7XHJcbiAgcmV0dXJuIG5ldyBBZGRyZXNzKGluZm8uaGFzaEJ1ZmZlciwgbmV0d29yaywgQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2gpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhIHJpcGVtZDE2MCBzY3JpcHQgaGFzaFxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaCAtIEFuIGluc3RhbmNlIG9mIGJ1ZmZlciBvZiB0aGUgaGFzaFxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBFaXRoZXIgJ3NjcmlwdGhhc2gnIG9yICd3aXRuZXNzc2NyaXB0aGFzaCdcclxuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xyXG4gKi9cclxuQWRkcmVzcy5mcm9tU2NyaXB0SGFzaCA9IGZ1bmN0aW9uKGhhc2gsIG5ldHdvcmssIHR5cGUpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoaGFzaCwgJ2hhc2ggcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XHJcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1IYXNoKGhhc2gpO1xyXG4gIGlmICh0eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2ggJiYgaGFzaC5sZW5ndGggIT09IDMyKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgaGFzaGJ1ZmZlciBtdXN0IGJlIGV4YWN0bHkgMzIgYnl0ZXMgZm9yIHYwIHdpdG5lc3Mgc2NyaXB0IGhhc2guJyk7XHJcbiAgfVxyXG4gIHZhciB0eXBlID0gdHlwZSB8fCBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaDtcclxuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mby5oYXNoQnVmZmVyLCBuZXR3b3JrLCB0eXBlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgYSBwMnNoIGFkZHJlc3MgcGF5aW5nIHRvIHNjcmlwdC4gVGhpcyB3aWxsIGhhc2ggdGhlIHNjcmlwdCBhbmRcclxuICogdXNlIHRoYXQgdG8gY3JlYXRlIHRoZSBhZGRyZXNzLlxyXG4gKiBJZiB5b3Ugd2FudCB0byBleHRyYWN0IGFuIGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIGEgc2NyaXB0IGluc3RlYWQsXHJcbiAqIHNlZSB7e0FkZHJlc3MjZnJvbVNjcmlwdH19XHJcbiAqXHJcbiAqIEBwYXJhbSB7U2NyaXB0fSBzY3JpcHQgLSBBbiBpbnN0YW5jZSBvZiBTY3JpcHRcclxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29ya30gbmV0d29yayAtIGVpdGhlciBhIE5ldHdvcmsgaW5zdGFuY2UsICdsaXZlbmV0Jywgb3IgJ3Rlc3RuZXQnXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdzY3JpcHRoYXNoJyBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXHJcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcclxuICovXHJcbkFkZHJlc3MucGF5aW5nVG8gPSBmdW5jdGlvbihzY3JpcHQsIG5ldHdvcmssIHR5cGUpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoc2NyaXB0LCAnc2NyaXB0IGlzIHJlcXVpcmVkJyk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCwgJ3NjcmlwdCBtdXN0IGJlIGluc3RhbmNlIG9mIFNjcmlwdCcpO1xyXG4gIHZhciBoYXNoO1xyXG4gIGlmICh0eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2gpIHtcclxuICAgIGhhc2ggPSBIYXNoLnNoYTI1NihzY3JpcHQudG9CdWZmZXIoKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGhhc2ggPSBIYXNoLnNoYTI1NnJpcGVtZDE2MChzY3JpcHQudG9CdWZmZXIoKSk7XHJcbiAgfVxyXG4gIHZhciB0eXBlID0gdHlwZSB8fCBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaDtcclxuICByZXR1cm4gQWRkcmVzcy5mcm9tU2NyaXB0SGFzaChoYXNoLCBuZXR3b3JrLCB0eXBlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IGFkZHJlc3MgZnJvbSBhIFNjcmlwdC4gVGhlIHNjcmlwdCBtdXN0IGJlIG9mIG9uZVxyXG4gKiBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOiBwMnBraCBpbnB1dCwgcDJwa2ggb3V0cHV0LCBwMnNoIGlucHV0XHJcbiAqIG9yIHAyc2ggb3V0cHV0LlxyXG4gKiBUaGlzIHdpbGwgYW5hbHl6ZSB0aGUgc2NyaXB0IGFuZCBleHRyYWN0IGFkZHJlc3MgaW5mb3JtYXRpb24gZnJvbSBpdC5cclxuICogSWYgeW91IHdhbnQgdG8gdHJhbnNmb3JtIGFueSBzY3JpcHQgdG8gYSBwMnNoIEFkZHJlc3MgcGF5aW5nXHJcbiAqIHRvIHRoYXQgc2NyaXB0J3MgaGFzaCBpbnN0ZWFkLCB1c2Uge3tBZGRyZXNzI3BheWluZ1RvfX1cclxuICpcclxuICogQHBhcmFtIHtTY3JpcHR9IHNjcmlwdCAtIEFuIGluc3RhbmNlIG9mIFNjcmlwdFxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcclxuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xyXG4gKi9cclxuQWRkcmVzcy5mcm9tU2NyaXB0ID0gZnVuY3Rpb24oc2NyaXB0LCBuZXR3b3JrKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCwgJ3NjcmlwdCBtdXN0IGJlIGEgU2NyaXB0IGluc3RhbmNlJyk7XHJcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1TY3JpcHQoc2NyaXB0LCBuZXR3b3JrKTtcclxuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mby5oYXNoQnVmZmVyLCBuZXR3b3JrLCBpbmZvLnR5cGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhIGJ1ZmZlciBvZiB0aGUgYWRkcmVzc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIC0gQW4gaW5zdGFuY2Ugb2YgYnVmZmVyIG9mIHRoZSBhZGRyZXNzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE5ldHdvcms9fSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcclxuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcclxuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xyXG4gKi9cclxuQWRkcmVzcy5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyLCBuZXR3b3JrLCB0eXBlKSB7XHJcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1CdWZmZXIoYnVmZmVyLCBuZXR3b3JrLCB0eXBlKTtcclxuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mby5oYXNoQnVmZmVyLCBpbmZvLm5ldHdvcmssIGluZm8udHlwZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGFuIGFkZHJlc3Mgc3RyaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBBbiBzdHJpbmcgb2YgdGhlIGJpdGNvaW4gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrPX0gbmV0d29yayAtIGVpdGhlciBhIE5ldHdvcmsgaW5zdGFuY2UsICdsaXZlbmV0Jywgb3IgJ3Rlc3RuZXQnXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIFRoZSB0eXBlIG9mIGFkZHJlc3M6ICdzY3JpcHQnIG9yICdwdWJrZXknXHJcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcclxuICovXHJcbkFkZHJlc3MuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgbmV0d29yaywgdHlwZSkge1xyXG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtU3RyaW5nKHN0ciwgbmV0d29yaywgdHlwZSk7XHJcbiAgcmV0dXJuIG5ldyBBZGRyZXNzKGluZm8uaGFzaEJ1ZmZlciwgaW5mby5uZXR3b3JrLCBpbmZvLnR5cGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhbiBPYmplY3RcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGpzb24gLSBBbiBKU09OIHN0cmluZyBvciBPYmplY3Qgd2l0aCBrZXlzOiBoYXNoLCBuZXR3b3JrIGFuZCB0eXBlXHJcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBIG5ldyB2YWxpZCBpbnN0YW5jZSBvZiBhbiBBZGRyZXNzXHJcbiAqL1xyXG5BZGRyZXNzLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikge1xyXG4gICQuY2hlY2tTdGF0ZShcclxuICAgIEpTVXRpbC5pc0hleGEob2JqLmhhc2gpLFxyXG4gICAgJ1VuZXhwZWN0ZWQgaGFzaCBwcm9wZXJ0eSwgXCInICsgb2JqLmhhc2ggKyAnXCIsIGV4cGVjdGVkIHRvIGJlIGhleC4nXHJcbiAgKTtcclxuICB2YXIgaGFzaEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG9iai5oYXNoLCAnaGV4Jyk7XHJcbiAgcmV0dXJuIG5ldyBBZGRyZXNzKGhhc2hCdWZmZXIsIG9iai5uZXR3b3JrLCBvYmoudHlwZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gYSB2YWxpZGF0aW9uIGVycm9yIGlmIGV4aXN0c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIGEgbmV0d29yayBtaXNtYXRjaCBlcnJvclxyXG4gKiB2YXIgZXJyb3IgPSBBZGRyZXNzLmdldFZhbGlkYXRpb25FcnJvcignMTV2a2NLZjdnQjIzd0xBblpMbWJWdU1paVZEYzFObTRhMicsICd0ZXN0bmV0Jyk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBlbmNvZGVkIGRhdGFcclxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29ya30gbmV0d29yayAtIGVpdGhlciBhIE5ldHdvcmsgaW5zdGFuY2UsICdsaXZlbmV0Jywgb3IgJ3Rlc3RuZXQnXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcclxuICogQHJldHVybnMge251bGx8RXJyb3J9IFRoZSBjb3JyZXNwb25kaW5nIGVycm9yIG1lc3NhZ2VcclxuICovXHJcbkFkZHJlc3MuZ2V0VmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaywgdHlwZSkge1xyXG4gIHZhciBlcnJvcjtcclxuICB0cnkge1xyXG4gICAgLyoganNoaW50IG5vbmV3OiBmYWxzZSAqL1xyXG4gICAgbmV3IEFkZHJlc3MoZGF0YSwgbmV0d29yaywgdHlwZSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgZXJyb3IgPSBlO1xyXG4gIH1cclxuICByZXR1cm4gZXJyb3I7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gYSBib29sZWFuIGlmIGFuIGFkZHJlc3MgaXMgdmFsaWRcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBhc3NlcnQoQWRkcmVzcy5pc1ZhbGlkKCcxNXZrY0tmN2dCMjN3TEFuWkxtYlZ1TWlpVkRjMU5tNGEyJywgJ2xpdmVuZXQnKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBlbmNvZGVkIGRhdGFcclxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29ya30gbmV0d29yayAtIGVpdGhlciBhIE5ldHdvcmsgaW5zdGFuY2UsICdsaXZlbmV0Jywgb3IgJ3Rlc3RuZXQnXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcclxuICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBjb3JyZXNwb25kaW5nIGVycm9yIG1lc3NhZ2VcclxuICovXHJcbkFkZHJlc3MuaXNWYWxpZCA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmssIHR5cGUpIHtcclxuICByZXR1cm4gIUFkZHJlc3MuZ2V0VmFsaWRhdGlvbkVycm9yKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byBwdWJsaWMga2V5IGhhc2ggdHlwZVxyXG4gKiBAcmV0dXJuIGJvb2xlYW5cclxuICovXHJcbkFkZHJlc3MucHJvdG90eXBlLmlzUGF5VG9QdWJsaWNLZXlIYXNoID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2g7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFkZHJlc3MgaXMgb2YgcGF5IHRvIHNjcmlwdCBoYXNoIHR5cGVcclxuICogQHJldHVybiBib29sZWFuXHJcbiAqL1xyXG5BZGRyZXNzLnByb3RvdHlwZS5pc1BheVRvU2NyaXB0SGFzaCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLnR5cGUgPT09IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byB3aXRuZXNzIHB1YmxpYyBrZXkgaGFzaCB0eXBlXHJcbiAqIEByZXR1cm4gYm9vbGVhblxyXG4gKi9cclxuQWRkcmVzcy5wcm90b3R5cGUuaXNQYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byB3aXRuZXNzIHNjcmlwdCBoYXNoIHR5cGVcclxuICogQHJldHVybiBib29sZWFuXHJcbiAqL1xyXG5BZGRyZXNzLnByb3RvdHlwZS5pc1BheVRvV2l0bmVzc1NjcmlwdEhhc2ggPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy50eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2g7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFkZHJlc3MgaXMgb2YgcGF5IHRvIFRhcHJvb3Qgc2NyaXB0IGhhc2ggdHlwZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkFkZHJlc3MucHJvdG90eXBlLmlzUGF5VG9UYXByb290ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1RhcHJvb3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXaWxsIHJldHVybiBhIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBCaXRjb2luIGFkZHJlc3MgYnVmZmVyXHJcbiAqL1xyXG5BZGRyZXNzLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICh0aGlzLmlzUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaCgpIHx8IHRoaXMuaXNQYXlUb1dpdG5lc3NTY3JpcHRIYXNoKCkpIHtcclxuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLnRvU3RyaW5nKCksICd1dGY4JylcclxuICB9XHJcbiAgdmFyIHZlcnNpb24gPSBCdWZmZXIuZnJvbShbdGhpcy5uZXR3b3JrW3RoaXMudHlwZV1dKTtcclxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdmVyc2lvbiwgdGhpcy5oYXNoQnVmZmVyXSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge09iamVjdH0gQSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgYWRkcmVzcyBpbmZvcm1hdGlvblxyXG4gKi9cclxuQWRkcmVzcy5wcm90b3R5cGUudG9PYmplY3QgPSBBZGRyZXNzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgaGFzaDogdGhpcy5oYXNoQnVmZmVyLnRvU3RyaW5nKCdoZXgnKSxcclxuICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgIG5ldHdvcms6IHRoaXMubmV0d29yay50b1N0cmluZygpXHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaWxsIHJldHVybiBhIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3NcclxuICpcclxuICogQHJldHVybnMge3N0cmluZ30gQml0Y29pbiBhZGRyZXNzXHJcbiAqL1xyXG5BZGRyZXNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICh0aGlzLmlzUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaCgpIHx8IHRoaXMuaXNQYXlUb1dpdG5lc3NTY3JpcHRIYXNoKCkgfHwgdGhpcy5pc1BheVRvVGFwcm9vdCgpKSB7XHJcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5uZXR3b3JrLmJlY2gzMnByZWZpeDtcclxuICAgIGxldCB2ZXJzaW9uID0gMDtcclxuICAgIGxldCBlbmNvZGluZyA9IEJlY2gzMi5lbmNvZGluZ3MuQkVDSDMyO1xyXG4gICAgaWYgKHRoaXMuaXNQYXlUb1RhcHJvb3QoKSkge1xyXG4gICAgICB2ZXJzaW9uID0gMTtcclxuICAgICAgZW5jb2RpbmcgPSBCZWNoMzIuZW5jb2RpbmdzLkJFQ0gzMk07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQmVjaDMyLmVuY29kZShwcmVmaXgsIHZlcnNpb24sIHRoaXMuaGFzaEJ1ZmZlciwgZW5jb2RpbmcpO1xyXG4gIH1cclxuICByZXR1cm4gQmFzZTU4Q2hlY2suZW5jb2RlKHRoaXMudG9CdWZmZXIoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gYSBzdHJpbmcgZm9ybWF0dGVkIGZvciB0aGUgY29uc29sZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCaXRjb2luIGFkZHJlc3NcclxuICovXHJcbkFkZHJlc3MucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gJzxBZGRyZXNzOiAnICsgdGhpcy50b1N0cmluZygpICsgJywgdHlwZTogJyArIHRoaXMudHlwZSArICcsIG5ldHdvcms6ICcgKyB0aGlzLm5ldHdvcmsgKyAnPic7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZHJlc3M7XHJcblxyXG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/address.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/block/block.js":
/*!*****************************************!*\
  !*** ../bitcore-lib/lib/block/block.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar BlockHeader = __webpack_require__(/*! ./blockheader */ \"../bitcore-lib/lib/block/blockheader.js\");\r\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar Transaction = __webpack_require__(/*! ../transaction */ \"../bitcore-lib/lib/transaction/index.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\n/**\r\n * Instantiate a Block from a Buffer, JSON object, or Object with\r\n * the properties of the Block\r\n *\r\n * @param {*} - A Buffer, JSON string, or Object\r\n * @returns {Block}\r\n * @constructor\r\n */\r\nfunction Block(arg) {\r\n  if (!(this instanceof Block)) {\r\n    return new Block(arg);\r\n  }\r\n  _.extend(this, Block._from(arg));\r\n  return this;\r\n}\r\n\r\n// https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14\r\nBlock.MAX_BLOCK_SIZE = 1000000;\r\n\r\n/**\r\n * @param {*} - A Buffer, JSON string or Object\r\n * @returns {Object} - An object representing block data\r\n * @throws {TypeError} - If the argument was not recognized\r\n * @private\r\n */\r\nBlock._from = function _from(arg) {\r\n  var info = {};\r\n  if (BufferUtil.isBuffer(arg)) {\r\n    info = Block._fromBufferReader(BufferReader(arg));\r\n  } else if (_.isObject(arg)) {\r\n    info = Block._fromObject(arg);\r\n  } else {\r\n    throw new TypeError('Unrecognized argument for Block');\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * @param {Object} - A plain JavaScript object\r\n * @returns {Object} - An object representing block data\r\n * @private\r\n */\r\nBlock._fromObject = function _fromObject(data) {\r\n  var transactions = [];\r\n  data.transactions.forEach(function(tx) {\r\n    if (tx instanceof Transaction) {\r\n      transactions.push(tx);\r\n    } else {\r\n      transactions.push(Transaction().fromObject(tx));\r\n    }\r\n  });\r\n  var info = {\r\n    header: BlockHeader.fromObject(data.header),\r\n    transactions: transactions\r\n  };\r\n  return info;\r\n};\r\n\r\n/**\r\n * @param {Object} - A plain JavaScript object\r\n * @returns {Block} - An instance of block\r\n */\r\nBlock.fromObject = function fromObject(obj) {\r\n  var info = Block._fromObject(obj);\r\n  return new Block(info);\r\n};\r\n\r\n/**\r\n * @param {BufferReader} - Block data\r\n * @returns {Object} - An object representing the block data\r\n * @private\r\n */\r\nBlock._fromBufferReader = function _fromBufferReader(br) {\r\n  var info = {};\r\n  $.checkState(!br.finished(), 'No block data received');\r\n  info.header = BlockHeader.fromBufferReader(br);\r\n  var transactions = br.readVarintNum();\r\n  info.transactions = [];\r\n  for (var i = 0; i < transactions; i++) {\r\n    info.transactions.push(Transaction().fromBufferReader(br));\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * @param {BufferReader} - A buffer reader of the block\r\n * @returns {Block} - An instance of block\r\n */\r\nBlock.fromBufferReader = function fromBufferReader(br) {\r\n  $.checkArgument(br, 'br is required');\r\n  var info = Block._fromBufferReader(br);\r\n  return new Block(info);\r\n};\r\n\r\n/**\r\n * @param {Buffer} - A buffer of the block\r\n * @returns {Block} - An instance of block\r\n */\r\nBlock.fromBuffer = function fromBuffer(buf) {\r\n  return Block.fromBufferReader(new BufferReader(buf));\r\n};\r\n\r\n/**\r\n * @param {string} - str - A hex encoded string of the block\r\n * @returns {Block} - A hex encoded string of the block\r\n */\r\nBlock.fromString = function fromString(str) {\r\n  var buf = Buffer.from(str, 'hex');\r\n  return Block.fromBuffer(buf);\r\n};\r\n\r\n/**\r\n * @param {Binary} - Raw block binary data or buffer\r\n * @returns {Block} - An instance of block\r\n */\r\nBlock.fromRawBlock = function fromRawBlock(data) {\r\n  if (!BufferUtil.isBuffer(data)) {\r\n    data = Buffer.from(data, 'binary');\r\n  }\r\n  var br = BufferReader(data);\r\n  br.pos = Block.Values.START_OF_BLOCK;\r\n  var info = Block._fromBufferReader(br);\r\n  return new Block(info);\r\n};\r\n\r\n/**\r\n * @returns {Object} - A plain object with the block properties\r\n */\r\nBlock.prototype.toObject = Block.prototype.toJSON = function toObject() {\r\n  var transactions = [];\r\n  this.transactions.forEach(function(tx) {\r\n    transactions.push(tx.toObject());\r\n  });\r\n  return {\r\n    header: this.header.toObject(),\r\n    transactions: transactions\r\n  };\r\n};\r\n\r\n/**\r\n * @returns {Buffer} - A buffer of the block\r\n */\r\nBlock.prototype.toBuffer = function toBuffer() {\r\n  return this.toBufferWriter().concat();\r\n};\r\n\r\n/**\r\n * @returns {string} - A hex encoded string of the block\r\n */\r\nBlock.prototype.toString = function toString() {\r\n  return this.toBuffer().toString('hex');\r\n};\r\n\r\n/**\r\n * @param {BufferWriter} - An existing instance of BufferWriter\r\n * @returns {BufferWriter} - An instance of BufferWriter representation of the Block\r\n */\r\nBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\r\n  if (!bw) {\r\n    bw = new BufferWriter();\r\n  }\r\n  bw.write(this.header.toBuffer());\r\n  bw.writeVarintNum(this.transactions.length);\r\n  for (var i = 0; i < this.transactions.length; i++) {\r\n    this.transactions[i].toBufferWriter(bw);\r\n  }\r\n  return bw;\r\n};\r\n\r\n/**\r\n * Will iterate through each transaction and return an array of hashes\r\n * @returns {Array} - An array with transaction hashes\r\n */\r\nBlock.prototype.getTransactionHashes = function getTransactionHashes() {\r\n  var hashes = [];\r\n  if (this.transactions.length === 0) {\r\n    return [Block.Values.NULL_HASH];\r\n  }\r\n  for (var t = 0; t < this.transactions.length; t++) {\r\n    hashes.push(this.transactions[t]._getHash());\r\n  }\r\n  return hashes;\r\n};\r\n\r\n/**\r\n * Will build a merkle tree of all the transactions, ultimately arriving at\r\n * a single point, the merkle root.\r\n * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees\r\n * @returns {Array} - An array with each level of the tree after the other.\r\n */\r\nBlock.prototype.getMerkleTree = function getMerkleTree() {\r\n\r\n  var tree = this.getTransactionHashes();\r\n\r\n  var j = 0;\r\n  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {\r\n    for (var i = 0; i < size; i += 2) {\r\n      var i2 = Math.min(i + 1, size - 1);\r\n      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);\r\n      tree.push(Hash.sha256sha256(buf));\r\n    }\r\n    j += size;\r\n  }\r\n\r\n  return tree;\r\n};\r\n\r\n/**\r\n * Calculates the merkleRoot from the transactions.\r\n * @returns {Buffer} - A buffer of the merkle root hash\r\n */\r\nBlock.prototype.getMerkleRoot = function getMerkleRoot() {\r\n  var tree = this.getMerkleTree();\r\n  return tree[tree.length - 1];\r\n};\r\n\r\n/**\r\n * Verifies that the transactions in the block match the header merkle root\r\n * @returns {Boolean} - If the merkle roots match\r\n */\r\nBlock.prototype.validMerkleRoot = function validMerkleRoot() {\r\n\r\n  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');\r\n  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');\r\n\r\n  if (h.cmp(c) !== 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * @returns {Buffer} - The little endian hash buffer of the header\r\n */\r\nBlock.prototype._getHash = function() {\r\n  return this.header._getHash();\r\n};\r\n\r\nvar idProperty = {\r\n  configurable: false,\r\n  enumerable: true,\r\n  /**\r\n   * @returns {string} - The big endian hash buffer of the header\r\n   */\r\n  get: function() {\r\n    if (!this._id) {\r\n      this._id = this.header.id;\r\n    }\r\n    return this._id;\r\n  },\r\n  set: _.noop\r\n};\r\nObject.defineProperty(Block.prototype, 'id', idProperty);\r\nObject.defineProperty(Block.prototype, 'hash', idProperty);\r\n\r\n/**\r\n * @returns {string} - A string formatted for the console\r\n */\r\nBlock.prototype.inspect = function inspect() {\r\n  return '<Block ' + this.id + '>';\r\n};\r\n\r\nBlock.Values = {\r\n  START_OF_BLOCK: 8, // Start of block in raw block data\r\n  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\r\n};\r\n\r\nmodule.exports = Block;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL2Jsb2NrL2Jsb2NrLmpzP2U4M2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIEJsb2NrSGVhZGVyID0gcmVxdWlyZSgnLi9ibG9ja2hlYWRlcicpO1xyXG52YXIgQk4gPSByZXF1aXJlKCcuLi9jcnlwdG8vYm4nKTtcclxudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xyXG52YXIgQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVycmVhZGVyJyk7XHJcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcclxudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xyXG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuLi90cmFuc2FjdGlvbicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRlIGEgQmxvY2sgZnJvbSBhIEJ1ZmZlciwgSlNPTiBvYmplY3QsIG9yIE9iamVjdCB3aXRoXHJcbiAqIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBCbG9ja1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nLCBvciBPYmplY3RcclxuICogQHJldHVybnMge0Jsb2NrfVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEJsb2NrKGFyZykge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCbG9jaykpIHtcclxuICAgIHJldHVybiBuZXcgQmxvY2soYXJnKTtcclxuICB9XHJcbiAgXy5leHRlbmQodGhpcywgQmxvY2suX2Zyb20oYXJnKSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpdGNvaW4vYmxvYi9iNWZhMTMyMzI5ZjAzNzdkNzg3YTRhMjFjMTY4NjYwOWMyYmZhZWNlL3NyYy9wcmltaXRpdmVzL2Jsb2NrLmgjTDE0XHJcbkJsb2NrLk1BWF9CTE9DS19TSVpFID0gMTAwMDAwMDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nIG9yIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYmxvY2sgZGF0YVxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IC0gSWYgdGhlIGFyZ3VtZW50IHdhcyBub3QgcmVjb2duaXplZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQmxvY2suX2Zyb20gPSBmdW5jdGlvbiBfZnJvbShhcmcpIHtcclxuICB2YXIgaW5mbyA9IHt9O1xyXG4gIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykpIHtcclxuICAgIGluZm8gPSBCbG9jay5fZnJvbUJ1ZmZlclJlYWRlcihCdWZmZXJSZWFkZXIoYXJnKSk7XHJcbiAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGFyZykpIHtcclxuICAgIGluZm8gPSBCbG9jay5fZnJvbU9iamVjdChhcmcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlY29nbml6ZWQgYXJndW1lbnQgZm9yIEJsb2NrJyk7XHJcbiAgfVxyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIEEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RcclxuICogQHJldHVybnMge09iamVjdH0gLSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGJsb2NrIGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcbkJsb2NrLl9mcm9tT2JqZWN0ID0gZnVuY3Rpb24gX2Zyb21PYmplY3QoZGF0YSkge1xyXG4gIHZhciB0cmFuc2FjdGlvbnMgPSBbXTtcclxuICBkYXRhLnRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHR4KSB7XHJcbiAgICBpZiAodHggaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikge1xyXG4gICAgICB0cmFuc2FjdGlvbnMucHVzaCh0eCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0cmFuc2FjdGlvbnMucHVzaChUcmFuc2FjdGlvbigpLmZyb21PYmplY3QodHgpKTtcclxuICAgIH1cclxuICB9KTtcclxuICB2YXIgaW5mbyA9IHtcclxuICAgIGhlYWRlcjogQmxvY2tIZWFkZXIuZnJvbU9iamVjdChkYXRhLmhlYWRlciksXHJcbiAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9uc1xyXG4gIH07XHJcbiAgcmV0dXJuIGluZm87XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtPYmplY3R9IC0gQSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdFxyXG4gKiBAcmV0dXJucyB7QmxvY2t9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2tcclxuICovXHJcbkJsb2NrLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikge1xyXG4gIHZhciBpbmZvID0gQmxvY2suX2Zyb21PYmplY3Qob2JqKTtcclxuICByZXR1cm4gbmV3IEJsb2NrKGluZm8pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QnVmZmVyUmVhZGVyfSAtIEJsb2NrIGRhdGFcclxuICogQHJldHVybnMge09iamVjdH0gLSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBibG9jayBkYXRhXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5CbG9jay5fZnJvbUJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uIF9mcm9tQnVmZmVyUmVhZGVyKGJyKSB7XHJcbiAgdmFyIGluZm8gPSB7fTtcclxuICAkLmNoZWNrU3RhdGUoIWJyLmZpbmlzaGVkKCksICdObyBibG9jayBkYXRhIHJlY2VpdmVkJyk7XHJcbiAgaW5mby5oZWFkZXIgPSBCbG9ja0hlYWRlci5mcm9tQnVmZmVyUmVhZGVyKGJyKTtcclxuICB2YXIgdHJhbnNhY3Rpb25zID0gYnIucmVhZFZhcmludE51bSgpO1xyXG4gIGluZm8udHJhbnNhY3Rpb25zID0gW107XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2FjdGlvbnM7IGkrKykge1xyXG4gICAgaW5mby50cmFuc2FjdGlvbnMucHVzaChUcmFuc2FjdGlvbigpLmZyb21CdWZmZXJSZWFkZXIoYnIpKTtcclxuICB9XHJcbiAgcmV0dXJuIGluZm87XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtCdWZmZXJSZWFkZXJ9IC0gQSBidWZmZXIgcmVhZGVyIG9mIHRoZSBibG9ja1xyXG4gKiBAcmV0dXJucyB7QmxvY2t9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2tcclxuICovXHJcbkJsb2NrLmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyUmVhZGVyKGJyKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KGJyLCAnYnIgaXMgcmVxdWlyZWQnKTtcclxuICB2YXIgaW5mbyA9IEJsb2NrLl9mcm9tQnVmZmVyUmVhZGVyKGJyKTtcclxuICByZXR1cm4gbmV3IEJsb2NrKGluZm8pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSAtIEEgYnVmZmVyIG9mIHRoZSBibG9ja1xyXG4gKiBAcmV0dXJucyB7QmxvY2t9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2tcclxuICovXHJcbkJsb2NrLmZyb21CdWZmZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1Zikge1xyXG4gIHJldHVybiBCbG9jay5mcm9tQnVmZmVyUmVhZGVyKG5ldyBCdWZmZXJSZWFkZXIoYnVmKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IC0gc3RyIC0gQSBoZXggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJsb2NrXHJcbiAqIEByZXR1cm5zIHtCbG9ja30gLSBBIGhleCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYmxvY2tcclxuICovXHJcbkJsb2NrLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xyXG4gIHZhciBidWYgPSBCdWZmZXIuZnJvbShzdHIsICdoZXgnKTtcclxuICByZXR1cm4gQmxvY2suZnJvbUJ1ZmZlcihidWYpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QmluYXJ5fSAtIFJhdyBibG9jayBiaW5hcnkgZGF0YSBvciBidWZmZXJcclxuICogQHJldHVybnMge0Jsb2NrfSAtIEFuIGluc3RhbmNlIG9mIGJsb2NrXHJcbiAqL1xyXG5CbG9jay5mcm9tUmF3QmxvY2sgPSBmdW5jdGlvbiBmcm9tUmF3QmxvY2soZGF0YSkge1xyXG4gIGlmICghQnVmZmVyVXRpbC5pc0J1ZmZlcihkYXRhKSkge1xyXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiaW5hcnknKTtcclxuICB9XHJcbiAgdmFyIGJyID0gQnVmZmVyUmVhZGVyKGRhdGEpO1xyXG4gIGJyLnBvcyA9IEJsb2NrLlZhbHVlcy5TVEFSVF9PRl9CTE9DSztcclxuICB2YXIgaW5mbyA9IEJsb2NrLl9mcm9tQnVmZmVyUmVhZGVyKGJyKTtcclxuICByZXR1cm4gbmV3IEJsb2NrKGluZm8pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgYmxvY2sgcHJvcGVydGllc1xyXG4gKi9cclxuQmxvY2sucHJvdG90eXBlLnRvT2JqZWN0ID0gQmxvY2sucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xyXG4gIHZhciB0cmFuc2FjdGlvbnMgPSBbXTtcclxuICB0aGlzLnRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHR4KSB7XHJcbiAgICB0cmFuc2FjdGlvbnMucHVzaCh0eC50b09iamVjdCgpKTtcclxuICB9KTtcclxuICByZXR1cm4ge1xyXG4gICAgaGVhZGVyOiB0aGlzLmhlYWRlci50b09iamVjdCgpLFxyXG4gICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnNcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IC0gQSBidWZmZXIgb2YgdGhlIGJsb2NrXHJcbiAqL1xyXG5CbG9jay5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcclxuICByZXR1cm4gdGhpcy50b0J1ZmZlcldyaXRlcigpLmNvbmNhdCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQSBoZXggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJsb2NrXHJcbiAqL1xyXG5CbG9jay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcldyaXRlcn0gLSBBbiBleGlzdGluZyBpbnN0YW5jZSBvZiBCdWZmZXJXcml0ZXJcclxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcn0gLSBBbiBpbnN0YW5jZSBvZiBCdWZmZXJXcml0ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJsb2NrXHJcbiAqL1xyXG5CbG9jay5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcldyaXRlcihidykge1xyXG4gIGlmICghYncpIHtcclxuICAgIGJ3ID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gIH1cclxuICBidy53cml0ZSh0aGlzLmhlYWRlci50b0J1ZmZlcigpKTtcclxuICBidy53cml0ZVZhcmludE51bSh0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGgpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLnRvQnVmZmVyV3JpdGVyKGJ3KTtcclxuICB9XHJcbiAgcmV0dXJuIGJ3O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgaXRlcmF0ZSB0aHJvdWdoIGVhY2ggdHJhbnNhY3Rpb24gYW5kIHJldHVybiBhbiBhcnJheSBvZiBoYXNoZXNcclxuICogQHJldHVybnMge0FycmF5fSAtIEFuIGFycmF5IHdpdGggdHJhbnNhY3Rpb24gaGFzaGVzXHJcbiAqL1xyXG5CbG9jay5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb25IYXNoZXMgPSBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkhhc2hlcygpIHtcclxuICB2YXIgaGFzaGVzID0gW107XHJcbiAgaWYgKHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIFtCbG9jay5WYWx1ZXMuTlVMTF9IQVNIXTtcclxuICB9XHJcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGg7IHQrKykge1xyXG4gICAgaGFzaGVzLnB1c2godGhpcy50cmFuc2FjdGlvbnNbdF0uX2dldEhhc2goKSk7XHJcbiAgfVxyXG4gIHJldHVybiBoYXNoZXM7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCBidWlsZCBhIG1lcmtsZSB0cmVlIG9mIGFsbCB0aGUgdHJhbnNhY3Rpb25zLCB1bHRpbWF0ZWx5IGFycml2aW5nIGF0XHJcbiAqIGEgc2luZ2xlIHBvaW50LCB0aGUgbWVya2xlIHJvb3QuXHJcbiAqIEBsaW5rIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL1Byb3RvY29sX3NwZWNpZmljYXRpb24jTWVya2xlX1RyZWVzXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBBbiBhcnJheSB3aXRoIGVhY2ggbGV2ZWwgb2YgdGhlIHRyZWUgYWZ0ZXIgdGhlIG90aGVyLlxyXG4gKi9cclxuQmxvY2sucHJvdG90eXBlLmdldE1lcmtsZVRyZWUgPSBmdW5jdGlvbiBnZXRNZXJrbGVUcmVlKCkge1xyXG5cclxuICB2YXIgdHJlZSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25IYXNoZXMoKTtcclxuXHJcbiAgdmFyIGogPSAwO1xyXG4gIGZvciAodmFyIHNpemUgPSB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGg7IHNpemUgPiAxOyBzaXplID0gTWF0aC5mbG9vcigoc2l6ZSArIDEpIC8gMikpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAyKSB7XHJcbiAgICAgIHZhciBpMiA9IE1hdGgubWluKGkgKyAxLCBzaXplIC0gMSk7XHJcbiAgICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KFt0cmVlW2ogKyBpXSwgdHJlZVtqICsgaTJdXSk7XHJcbiAgICAgIHRyZWUucHVzaChIYXNoLnNoYTI1NnNoYTI1NihidWYpKTtcclxuICAgIH1cclxuICAgIGogKz0gc2l6ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cmVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIG1lcmtsZVJvb3QgZnJvbSB0aGUgdHJhbnNhY3Rpb25zLlxyXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIEEgYnVmZmVyIG9mIHRoZSBtZXJrbGUgcm9vdCBoYXNoXHJcbiAqL1xyXG5CbG9jay5wcm90b3R5cGUuZ2V0TWVya2xlUm9vdCA9IGZ1bmN0aW9uIGdldE1lcmtsZVJvb3QoKSB7XHJcbiAgdmFyIHRyZWUgPSB0aGlzLmdldE1lcmtsZVRyZWUoKTtcclxuICByZXR1cm4gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIHRyYW5zYWN0aW9ucyBpbiB0aGUgYmxvY2sgbWF0Y2ggdGhlIGhlYWRlciBtZXJrbGUgcm9vdFxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBJZiB0aGUgbWVya2xlIHJvb3RzIG1hdGNoXHJcbiAqL1xyXG5CbG9jay5wcm90b3R5cGUudmFsaWRNZXJrbGVSb290ID0gZnVuY3Rpb24gdmFsaWRNZXJrbGVSb290KCkge1xyXG5cclxuICB2YXIgaCA9IG5ldyBCTih0aGlzLmhlYWRlci5tZXJrbGVSb290LnRvU3RyaW5nKCdoZXgnKSwgJ2hleCcpO1xyXG4gIHZhciBjID0gbmV3IEJOKHRoaXMuZ2V0TWVya2xlUm9vdCgpLnRvU3RyaW5nKCdoZXgnKSwgJ2hleCcpO1xyXG5cclxuICBpZiAoaC5jbXAoYykgIT09IDApIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IC0gVGhlIGxpdHRsZSBlbmRpYW4gaGFzaCBidWZmZXIgb2YgdGhlIGhlYWRlclxyXG4gKi9cclxuQmxvY2sucHJvdG90eXBlLl9nZXRIYXNoID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMuaGVhZGVyLl9nZXRIYXNoKCk7XHJcbn07XHJcblxyXG52YXIgaWRQcm9wZXJ0eSA9IHtcclxuICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgYmlnIGVuZGlhbiBoYXNoIGJ1ZmZlciBvZiB0aGUgaGVhZGVyXHJcbiAgICovXHJcbiAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5faWQpIHtcclxuICAgICAgdGhpcy5faWQgPSB0aGlzLmhlYWRlci5pZDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9pZDtcclxuICB9LFxyXG4gIHNldDogXy5ub29wXHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9jay5wcm90b3R5cGUsICdpZCcsIGlkUHJvcGVydHkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvY2sucHJvdG90eXBlLCAnaGFzaCcsIGlkUHJvcGVydHkpO1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQSBzdHJpbmcgZm9ybWF0dGVkIGZvciB0aGUgY29uc29sZVxyXG4gKi9cclxuQmxvY2sucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xyXG4gIHJldHVybiAnPEJsb2NrICcgKyB0aGlzLmlkICsgJz4nO1xyXG59O1xyXG5cclxuQmxvY2suVmFsdWVzID0ge1xyXG4gIFNUQVJUX09GX0JMT0NLOiA4LCAvLyBTdGFydCBvZiBibG9jayBpbiByYXcgYmxvY2sgZGF0YVxyXG4gIE5VTExfSEFTSDogQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAnaGV4JylcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxvY2s7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/block/block.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/block/blockheader.js":
/*!***********************************************!*\
  !*** ../bitcore-lib/lib/block/blockheader.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nvar GENESIS_BITS = 0x1d00ffff;\r\n\r\n/**\r\n * Instantiate a BlockHeader from a Buffer, JSON object, or Object with\r\n * the properties of the BlockHeader\r\n *\r\n * @param {*} - A Buffer, JSON string, or Object\r\n * @returns {BlockHeader} - An instance of block header\r\n * @constructor\r\n */\r\nvar BlockHeader = function BlockHeader(arg) {\r\n  if (!(this instanceof BlockHeader)) {\r\n    return new BlockHeader(arg);\r\n  }\r\n  var info = BlockHeader._from(arg);\r\n  this.version = info.version;\r\n  this.prevHash = info.prevHash;\r\n  this.merkleRoot = info.merkleRoot;\r\n  this.time = info.time;\r\n  this.timestamp = info.time;\r\n  this.bits = info.bits;\r\n  this.nonce = info.nonce;\r\n\r\n  if (info.hash) {\r\n    $.checkState(\r\n      this.hash === info.hash,\r\n      'Argument object hash property does not match block hash.'\r\n    );\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * @param {*} - A Buffer, JSON string or Object\r\n * @returns {Object} - An object representing block header data\r\n * @throws {TypeError} - If the argument was not recognized\r\n * @private\r\n */\r\nBlockHeader._from = function _from(arg) {\r\n  var info = {};\r\n  if (BufferUtil.isBuffer(arg)) {\r\n    info = BlockHeader._fromBufferReader(BufferReader(arg));\r\n  } else if (_.isObject(arg)) {\r\n    info = BlockHeader._fromObject(arg);\r\n  } else {\r\n    throw new TypeError('Unrecognized argument for BlockHeader');\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * @param {Object} - A JSON string\r\n * @returns {Object} - An object representing block header data\r\n * @private\r\n */\r\nBlockHeader._fromObject = function _fromObject(data) {\r\n  $.checkArgument(data, 'data is required');\r\n  var prevHash = data.prevHash;\r\n  var merkleRoot = data.merkleRoot;\r\n  if (_.isString(data.prevHash)) {\r\n    prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, 'hex'));\r\n  }\r\n  if (_.isString(data.merkleRoot)) {\r\n    merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, 'hex'));\r\n  }\r\n  var info = {\r\n    hash: data.hash,\r\n    version: data.version,\r\n    prevHash: prevHash,\r\n    merkleRoot: merkleRoot,\r\n    time: data.time,\r\n    timestamp: data.time,\r\n    bits: data.bits,\r\n    nonce: data.nonce\r\n  };\r\n  return info;\r\n};\r\n\r\n/**\r\n * @param {Object} - A plain JavaScript object\r\n * @returns {BlockHeader} - An instance of block header\r\n */\r\nBlockHeader.fromObject = function fromObject(obj) {\r\n  var info = BlockHeader._fromObject(obj);\r\n  return new BlockHeader(info);\r\n};\r\n\r\n/**\r\n * @param {Binary} - Raw block binary data or buffer\r\n * @returns {BlockHeader} - An instance of block header\r\n */\r\nBlockHeader.fromRawBlock = function fromRawBlock(data) {\r\n  if (!BufferUtil.isBuffer(data)) {\r\n    data = Buffer.from(data, 'binary');\r\n  }\r\n  var br = BufferReader(data);\r\n  br.pos = BlockHeader.Constants.START_OF_HEADER;\r\n  var info = BlockHeader._fromBufferReader(br);\r\n  return new BlockHeader(info);\r\n};\r\n\r\n/**\r\n * @param {Buffer} - A buffer of the block header\r\n * @returns {BlockHeader} - An instance of block header\r\n */\r\nBlockHeader.fromBuffer = function fromBuffer(buf) {\r\n  var info = BlockHeader._fromBufferReader(BufferReader(buf));\r\n  return new BlockHeader(info);\r\n};\r\n\r\n/**\r\n * @param {string} - A hex encoded buffer of the block header\r\n * @returns {BlockHeader} - An instance of block header\r\n */\r\nBlockHeader.fromString = function fromString(str) {\r\n  var buf = Buffer.from(str, 'hex');\r\n  return BlockHeader.fromBuffer(buf);\r\n};\r\n\r\n/**\r\n * @param {BufferReader} - A BufferReader of the block header\r\n * @returns {Object} - An object representing block header data\r\n * @private\r\n */\r\nBlockHeader._fromBufferReader = function _fromBufferReader(br) {\r\n  var info = {};\r\n  info.version = br.readInt32LE();\r\n  info.prevHash = br.read(32);\r\n  info.merkleRoot = br.read(32);\r\n  info.time = br.readUInt32LE();\r\n  info.bits = br.readUInt32LE();\r\n  info.nonce = br.readUInt32LE();\r\n  return info;\r\n};\r\n\r\n/**\r\n * @param {BufferReader} - A BufferReader of the block header\r\n * @returns {BlockHeader} - An instance of block header\r\n */\r\nBlockHeader.fromBufferReader = function fromBufferReader(br) {\r\n  var info = BlockHeader._fromBufferReader(br);\r\n  return new BlockHeader(info);\r\n};\r\n\r\n/**\r\n * @returns {Object} - A plain object of the BlockHeader\r\n */\r\nBlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() {\r\n  return {\r\n    hash: this.hash,\r\n    version: this.version,\r\n    prevHash: BufferUtil.reverse(this.prevHash).toString('hex'),\r\n    merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'),\r\n    time: this.time,\r\n    bits: this.bits,\r\n    nonce: this.nonce\r\n  };\r\n};\r\n\r\n/**\r\n * @returns {Buffer} - A Buffer of the BlockHeader\r\n */\r\nBlockHeader.prototype.toBuffer = function toBuffer() {\r\n  return this.toBufferWriter().concat();\r\n};\r\n\r\n/**\r\n * @returns {string} - A hex encoded string of the BlockHeader\r\n */\r\nBlockHeader.prototype.toString = function toString() {\r\n  return this.toBuffer().toString('hex');\r\n};\r\n\r\n/**\r\n * @param {BufferWriter} - An existing instance BufferWriter\r\n * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader\r\n */\r\nBlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {\r\n  if (!bw) {\r\n    bw = new BufferWriter();\r\n  }\r\n  bw.writeInt32LE(this.version);\r\n  bw.write(this.prevHash);\r\n  bw.write(this.merkleRoot);\r\n  bw.writeUInt32LE(this.time);\r\n  bw.writeUInt32LE(this.bits);\r\n  bw.writeUInt32LE(this.nonce);\r\n  return bw;\r\n};\r\n\r\n/**\r\n * Returns the target difficulty for this block\r\n * @param {Number} bits\r\n * @returns {BN} An instance of BN with the decoded difficulty bits\r\n */\r\nBlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {\r\n  bits = bits || this.bits;\r\n\r\n  var target = new BN(bits & 0xffffff);\r\n  var mov = 8 * ((bits >>> 24) - 3);\r\n  while (mov-- > 0) {\r\n    target = target.mul(new BN(2));\r\n  }\r\n  return target;\r\n};\r\n\r\n/**\r\n * @link https://en.bitcoin.it/wiki/Difficulty\r\n * @return {Number}\r\n */\r\nBlockHeader.prototype.getDifficulty = function getDifficulty() {\r\n  var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8)));\r\n  var currentTargetBN = this.getTargetDifficulty();\r\n\r\n  var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);\r\n  var decimalPos = difficultyString.length - 8;\r\n  difficultyString = difficultyString.slice(0, decimalPos) + '.' + difficultyString.slice(decimalPos);\r\n\r\n  return parseFloat(difficultyString);\r\n};\r\n\r\n/**\r\n * @returns {Buffer} - The little endian hash buffer of the header\r\n */\r\nBlockHeader.prototype._getHash = function hash() {\r\n  var buf = this.toBuffer();\r\n  return Hash.sha256sha256(buf);\r\n};\r\n\r\nvar idProperty = {\r\n  configurable: false,\r\n  enumerable: true,\r\n  /**\r\n   * @returns {string} - The big endian hash buffer of the header\r\n   */\r\n  get: function() {\r\n    if (!this._id) {\r\n      this._id = BufferReader(this._getHash()).readReverse().toString('hex');\r\n    }\r\n    return this._id;\r\n  },\r\n  set: _.noop\r\n};\r\nObject.defineProperty(BlockHeader.prototype, 'id', idProperty);\r\nObject.defineProperty(BlockHeader.prototype, 'hash', idProperty);\r\n\r\n/**\r\n * @returns {Boolean} - If timestamp is not too far in the future\r\n */\r\nBlockHeader.prototype.validTimestamp = function validTimestamp() {\r\n  var currentTime = Math.round(new Date().getTime() / 1000);\r\n  if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty\r\n */\r\nBlockHeader.prototype.validProofOfWork = function validProofOfWork() {\r\n  var pow = new BN(this.id, 'hex');\r\n  var target = this.getTargetDifficulty();\r\n\r\n  if (pow.cmp(target) > 0) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * @returns {string} - A string formatted for the console\r\n */\r\nBlockHeader.prototype.inspect = function inspect() {\r\n  return '<BlockHeader ' + this.id + '>';\r\n};\r\n\r\nBlockHeader.Constants = {\r\n  START_OF_HEADER: 8, // Start buffer position in raw block data\r\n  MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future\r\n  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')\r\n};\r\n\r\nmodule.exports = BlockHeader;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9ibG9jay9ibG9ja2hlYWRlci5qcz84NDhjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xyXG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XHJcbnZhciBCdWZmZXJSZWFkZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJyZWFkZXInKTtcclxudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xyXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by9oYXNoJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcblxyXG52YXIgR0VORVNJU19CSVRTID0gMHgxZDAwZmZmZjtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIEJsb2NrSGVhZGVyIGZyb20gYSBCdWZmZXIsIEpTT04gb2JqZWN0LCBvciBPYmplY3Qgd2l0aFxyXG4gKiB0aGUgcHJvcGVydGllcyBvZiB0aGUgQmxvY2tIZWFkZXJcclxuICpcclxuICogQHBhcmFtIHsqfSAtIEEgQnVmZmVyLCBKU09OIHN0cmluZywgb3IgT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtCbG9ja0hlYWRlcn0gLSBBbiBpbnN0YW5jZSBvZiBibG9jayBoZWFkZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgQmxvY2tIZWFkZXIgPSBmdW5jdGlvbiBCbG9ja0hlYWRlcihhcmcpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmxvY2tIZWFkZXIpKSB7XHJcbiAgICByZXR1cm4gbmV3IEJsb2NrSGVhZGVyKGFyZyk7XHJcbiAgfVxyXG4gIHZhciBpbmZvID0gQmxvY2tIZWFkZXIuX2Zyb20oYXJnKTtcclxuICB0aGlzLnZlcnNpb24gPSBpbmZvLnZlcnNpb247XHJcbiAgdGhpcy5wcmV2SGFzaCA9IGluZm8ucHJldkhhc2g7XHJcbiAgdGhpcy5tZXJrbGVSb290ID0gaW5mby5tZXJrbGVSb290O1xyXG4gIHRoaXMudGltZSA9IGluZm8udGltZTtcclxuICB0aGlzLnRpbWVzdGFtcCA9IGluZm8udGltZTtcclxuICB0aGlzLmJpdHMgPSBpbmZvLmJpdHM7XHJcbiAgdGhpcy5ub25jZSA9IGluZm8ubm9uY2U7XHJcblxyXG4gIGlmIChpbmZvLmhhc2gpIHtcclxuICAgICQuY2hlY2tTdGF0ZShcclxuICAgICAgdGhpcy5oYXNoID09PSBpbmZvLmhhc2gsXHJcbiAgICAgICdBcmd1bWVudCBvYmplY3QgaGFzaCBwcm9wZXJ0eSBkb2VzIG5vdCBtYXRjaCBibG9jayBoYXNoLidcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nIG9yIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYmxvY2sgaGVhZGVyIGRhdGFcclxuICogQHRocm93cyB7VHlwZUVycm9yfSAtIElmIHRoZSBhcmd1bWVudCB3YXMgbm90IHJlY29nbml6ZWRcclxuICogQHByaXZhdGVcclxuICovXHJcbkJsb2NrSGVhZGVyLl9mcm9tID0gZnVuY3Rpb24gX2Zyb20oYXJnKSB7XHJcbiAgdmFyIGluZm8gPSB7fTtcclxuICBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcpKSB7XHJcbiAgICBpbmZvID0gQmxvY2tIZWFkZXIuX2Zyb21CdWZmZXJSZWFkZXIoQnVmZmVyUmVhZGVyKGFyZykpO1xyXG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChhcmcpKSB7XHJcbiAgICBpbmZvID0gQmxvY2tIZWFkZXIuX2Zyb21PYmplY3QoYXJnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGFyZ3VtZW50IGZvciBCbG9ja0hlYWRlcicpO1xyXG4gIH1cclxuICByZXR1cm4gaW5mbztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIEpTT04gc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBibG9jayBoZWFkZXIgZGF0YVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQmxvY2tIZWFkZXIuX2Zyb21PYmplY3QgPSBmdW5jdGlvbiBfZnJvbU9iamVjdChkYXRhKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KGRhdGEsICdkYXRhIGlzIHJlcXVpcmVkJyk7XHJcbiAgdmFyIHByZXZIYXNoID0gZGF0YS5wcmV2SGFzaDtcclxuICB2YXIgbWVya2xlUm9vdCA9IGRhdGEubWVya2xlUm9vdDtcclxuICBpZiAoXy5pc1N0cmluZyhkYXRhLnByZXZIYXNoKSkge1xyXG4gICAgcHJldkhhc2ggPSBCdWZmZXJVdGlsLnJldmVyc2UoQnVmZmVyLmZyb20oZGF0YS5wcmV2SGFzaCwgJ2hleCcpKTtcclxuICB9XHJcbiAgaWYgKF8uaXNTdHJpbmcoZGF0YS5tZXJrbGVSb290KSkge1xyXG4gICAgbWVya2xlUm9vdCA9IEJ1ZmZlclV0aWwucmV2ZXJzZShCdWZmZXIuZnJvbShkYXRhLm1lcmtsZVJvb3QsICdoZXgnKSk7XHJcbiAgfVxyXG4gIHZhciBpbmZvID0ge1xyXG4gICAgaGFzaDogZGF0YS5oYXNoLFxyXG4gICAgdmVyc2lvbjogZGF0YS52ZXJzaW9uLFxyXG4gICAgcHJldkhhc2g6IHByZXZIYXNoLFxyXG4gICAgbWVya2xlUm9vdDogbWVya2xlUm9vdCxcclxuICAgIHRpbWU6IGRhdGEudGltZSxcclxuICAgIHRpbWVzdGFtcDogZGF0YS50aW1lLFxyXG4gICAgYml0czogZGF0YS5iaXRzLFxyXG4gICAgbm9uY2U6IGRhdGEubm9uY2VcclxuICB9O1xyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIEEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RcclxuICogQHJldHVybnMge0Jsb2NrSGVhZGVyfSAtIEFuIGluc3RhbmNlIG9mIGJsb2NrIGhlYWRlclxyXG4gKi9cclxuQmxvY2tIZWFkZXIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7XHJcbiAgdmFyIGluZm8gPSBCbG9ja0hlYWRlci5fZnJvbU9iamVjdChvYmopO1xyXG4gIHJldHVybiBuZXcgQmxvY2tIZWFkZXIoaW5mbyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtCaW5hcnl9IC0gUmF3IGJsb2NrIGJpbmFyeSBkYXRhIG9yIGJ1ZmZlclxyXG4gKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2sgaGVhZGVyXHJcbiAqL1xyXG5CbG9ja0hlYWRlci5mcm9tUmF3QmxvY2sgPSBmdW5jdGlvbiBmcm9tUmF3QmxvY2soZGF0YSkge1xyXG4gIGlmICghQnVmZmVyVXRpbC5pc0J1ZmZlcihkYXRhKSkge1xyXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiaW5hcnknKTtcclxuICB9XHJcbiAgdmFyIGJyID0gQnVmZmVyUmVhZGVyKGRhdGEpO1xyXG4gIGJyLnBvcyA9IEJsb2NrSGVhZGVyLkNvbnN0YW50cy5TVEFSVF9PRl9IRUFERVI7XHJcbiAgdmFyIGluZm8gPSBCbG9ja0hlYWRlci5fZnJvbUJ1ZmZlclJlYWRlcihicik7XHJcbiAgcmV0dXJuIG5ldyBCbG9ja0hlYWRlcihpbmZvKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgYmxvY2sgaGVhZGVyXHJcbiAqIEByZXR1cm5zIHtCbG9ja0hlYWRlcn0gLSBBbiBpbnN0YW5jZSBvZiBibG9jayBoZWFkZXJcclxuICovXHJcbkJsb2NrSGVhZGVyLmZyb21CdWZmZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1Zikge1xyXG4gIHZhciBpbmZvID0gQmxvY2tIZWFkZXIuX2Zyb21CdWZmZXJSZWFkZXIoQnVmZmVyUmVhZGVyKGJ1ZikpO1xyXG4gIHJldHVybiBuZXcgQmxvY2tIZWFkZXIoaW5mbyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IC0gQSBoZXggZW5jb2RlZCBidWZmZXIgb2YgdGhlIGJsb2NrIGhlYWRlclxyXG4gKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2sgaGVhZGVyXHJcbiAqL1xyXG5CbG9ja0hlYWRlci5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcclxuICB2YXIgYnVmID0gQnVmZmVyLmZyb20oc3RyLCAnaGV4Jyk7XHJcbiAgcmV0dXJuIEJsb2NrSGVhZGVyLmZyb21CdWZmZXIoYnVmKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBBIEJ1ZmZlclJlYWRlciBvZiB0aGUgYmxvY2sgaGVhZGVyXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBibG9jayBoZWFkZXIgZGF0YVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuQmxvY2tIZWFkZXIuX2Zyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBfZnJvbUJ1ZmZlclJlYWRlcihicikge1xyXG4gIHZhciBpbmZvID0ge307XHJcbiAgaW5mby52ZXJzaW9uID0gYnIucmVhZEludDMyTEUoKTtcclxuICBpbmZvLnByZXZIYXNoID0gYnIucmVhZCgzMik7XHJcbiAgaW5mby5tZXJrbGVSb290ID0gYnIucmVhZCgzMik7XHJcbiAgaW5mby50aW1lID0gYnIucmVhZFVJbnQzMkxFKCk7XHJcbiAgaW5mby5iaXRzID0gYnIucmVhZFVJbnQzMkxFKCk7XHJcbiAgaW5mby5ub25jZSA9IGJyLnJlYWRVSW50MzJMRSgpO1xyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QnVmZmVyUmVhZGVyfSAtIEEgQnVmZmVyUmVhZGVyIG9mIHRoZSBibG9jayBoZWFkZXJcclxuICogQHJldHVybnMge0Jsb2NrSGVhZGVyfSAtIEFuIGluc3RhbmNlIG9mIGJsb2NrIGhlYWRlclxyXG4gKi9cclxuQmxvY2tIZWFkZXIuZnJvbUJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uIGZyb21CdWZmZXJSZWFkZXIoYnIpIHtcclxuICB2YXIgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tQnVmZmVyUmVhZGVyKGJyKTtcclxuICByZXR1cm4gbmV3IEJsb2NrSGVhZGVyKGluZm8pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQSBwbGFpbiBvYmplY3Qgb2YgdGhlIEJsb2NrSGVhZGVyXHJcbiAqL1xyXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9PYmplY3QgPSBCbG9ja0hlYWRlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGhhc2g6IHRoaXMuaGFzaCxcclxuICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcclxuICAgIHByZXZIYXNoOiBCdWZmZXJVdGlsLnJldmVyc2UodGhpcy5wcmV2SGFzaCkudG9TdHJpbmcoJ2hleCcpLFxyXG4gICAgbWVya2xlUm9vdDogQnVmZmVyVXRpbC5yZXZlcnNlKHRoaXMubWVya2xlUm9vdCkudG9TdHJpbmcoJ2hleCcpLFxyXG4gICAgdGltZTogdGhpcy50aW1lLFxyXG4gICAgYml0czogdGhpcy5iaXRzLFxyXG4gICAgbm9uY2U6IHRoaXMubm9uY2VcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IC0gQSBCdWZmZXIgb2YgdGhlIEJsb2NrSGVhZGVyXHJcbiAqL1xyXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcclxuICByZXR1cm4gdGhpcy50b0J1ZmZlcldyaXRlcigpLmNvbmNhdCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQSBoZXggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIEJsb2NrSGVhZGVyXHJcbiAqL1xyXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcldyaXRlcn0gLSBBbiBleGlzdGluZyBpbnN0YW5jZSBCdWZmZXJXcml0ZXJcclxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcn0gLSBBbiBpbnN0YW5jZSBvZiBCdWZmZXJXcml0ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJsb2NrSGVhZGVyXHJcbiAqL1xyXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcldyaXRlcihidykge1xyXG4gIGlmICghYncpIHtcclxuICAgIGJ3ID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gIH1cclxuICBidy53cml0ZUludDMyTEUodGhpcy52ZXJzaW9uKTtcclxuICBidy53cml0ZSh0aGlzLnByZXZIYXNoKTtcclxuICBidy53cml0ZSh0aGlzLm1lcmtsZVJvb3QpO1xyXG4gIGJ3LndyaXRlVUludDMyTEUodGhpcy50aW1lKTtcclxuICBidy53cml0ZVVJbnQzMkxFKHRoaXMuYml0cyk7XHJcbiAgYncud3JpdGVVSW50MzJMRSh0aGlzLm5vbmNlKTtcclxuICByZXR1cm4gYnc7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdGFyZ2V0IGRpZmZpY3VsdHkgZm9yIHRoaXMgYmxvY2tcclxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHNcclxuICogQHJldHVybnMge0JOfSBBbiBpbnN0YW5jZSBvZiBCTiB3aXRoIHRoZSBkZWNvZGVkIGRpZmZpY3VsdHkgYml0c1xyXG4gKi9cclxuQmxvY2tIZWFkZXIucHJvdG90eXBlLmdldFRhcmdldERpZmZpY3VsdHkgPSBmdW5jdGlvbiBnZXRUYXJnZXREaWZmaWN1bHR5KGJpdHMpIHtcclxuICBiaXRzID0gYml0cyB8fCB0aGlzLmJpdHM7XHJcblxyXG4gIHZhciB0YXJnZXQgPSBuZXcgQk4oYml0cyAmIDB4ZmZmZmZmKTtcclxuICB2YXIgbW92ID0gOCAqICgoYml0cyA+Pj4gMjQpIC0gMyk7XHJcbiAgd2hpbGUgKG1vdi0tID4gMCkge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0Lm11bChuZXcgQk4oMikpO1xyXG4gIH1cclxuICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBsaW5rIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL0RpZmZpY3VsdHlcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuQmxvY2tIZWFkZXIucHJvdG90eXBlLmdldERpZmZpY3VsdHkgPSBmdW5jdGlvbiBnZXREaWZmaWN1bHR5KCkge1xyXG4gIHZhciBkaWZmaWN1bHR5MVRhcmdldEJOID0gdGhpcy5nZXRUYXJnZXREaWZmaWN1bHR5KEdFTkVTSVNfQklUUykubXVsKG5ldyBCTihNYXRoLnBvdygxMCwgOCkpKTtcclxuICB2YXIgY3VycmVudFRhcmdldEJOID0gdGhpcy5nZXRUYXJnZXREaWZmaWN1bHR5KCk7XHJcblxyXG4gIHZhciBkaWZmaWN1bHR5U3RyaW5nID0gZGlmZmljdWx0eTFUYXJnZXRCTi5kaXYoY3VycmVudFRhcmdldEJOKS50b1N0cmluZygxMCk7XHJcbiAgdmFyIGRlY2ltYWxQb3MgPSBkaWZmaWN1bHR5U3RyaW5nLmxlbmd0aCAtIDg7XHJcbiAgZGlmZmljdWx0eVN0cmluZyA9IGRpZmZpY3VsdHlTdHJpbmcuc2xpY2UoMCwgZGVjaW1hbFBvcykgKyAnLicgKyBkaWZmaWN1bHR5U3RyaW5nLnNsaWNlKGRlY2ltYWxQb3MpO1xyXG5cclxuICByZXR1cm4gcGFyc2VGbG9hdChkaWZmaWN1bHR5U3RyaW5nKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIFRoZSBsaXR0bGUgZW5kaWFuIGhhc2ggYnVmZmVyIG9mIHRoZSBoZWFkZXJcclxuICovXHJcbkJsb2NrSGVhZGVyLnByb3RvdHlwZS5fZ2V0SGFzaCA9IGZ1bmN0aW9uIGhhc2goKSB7XHJcbiAgdmFyIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcclxuICByZXR1cm4gSGFzaC5zaGEyNTZzaGEyNTYoYnVmKTtcclxufTtcclxuXHJcbnZhciBpZFByb3BlcnR5ID0ge1xyXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBiaWcgZW5kaWFuIGhhc2ggYnVmZmVyIG9mIHRoZSBoZWFkZXJcclxuICAgKi9cclxuICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLl9pZCkge1xyXG4gICAgICB0aGlzLl9pZCA9IEJ1ZmZlclJlYWRlcih0aGlzLl9nZXRIYXNoKCkpLnJlYWRSZXZlcnNlKCkudG9TdHJpbmcoJ2hleCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gIH0sXHJcbiAgc2V0OiBfLm5vb3BcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrSGVhZGVyLnByb3RvdHlwZSwgJ2lkJywgaWRQcm9wZXJ0eSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9ja0hlYWRlci5wcm90b3R5cGUsICdoYXNoJywgaWRQcm9wZXJ0eSk7XHJcblxyXG4vKipcclxuICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgdGltZXN0YW1wIGlzIG5vdCB0b28gZmFyIGluIHRoZSBmdXR1cmVcclxuICovXHJcbkJsb2NrSGVhZGVyLnByb3RvdHlwZS52YWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHZhbGlkVGltZXN0YW1wKCkge1xyXG4gIHZhciBjdXJyZW50VGltZSA9IE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuICBpZiAodGhpcy50aW1lID4gY3VycmVudFRpbWUgKyBCbG9ja0hlYWRlci5Db25zdGFudHMuTUFYX1RJTUVfT0ZGU0VUKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHRoZSBwcm9vZi1vZi13b3JrIGhhc2ggc2F0aXNmaWVzIHRoZSB0YXJnZXQgZGlmZmljdWx0eVxyXG4gKi9cclxuQmxvY2tIZWFkZXIucHJvdG90eXBlLnZhbGlkUHJvb2ZPZldvcmsgPSBmdW5jdGlvbiB2YWxpZFByb29mT2ZXb3JrKCkge1xyXG4gIHZhciBwb3cgPSBuZXcgQk4odGhpcy5pZCwgJ2hleCcpO1xyXG4gIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldERpZmZpY3VsdHkoKTtcclxuXHJcbiAgaWYgKHBvdy5jbXAodGFyZ2V0KSA+IDApIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge3N0cmluZ30gLSBBIHN0cmluZyBmb3JtYXR0ZWQgZm9yIHRoZSBjb25zb2xlXHJcbiAqL1xyXG5CbG9ja0hlYWRlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XHJcbiAgcmV0dXJuICc8QmxvY2tIZWFkZXIgJyArIHRoaXMuaWQgKyAnPic7XHJcbn07XHJcblxyXG5CbG9ja0hlYWRlci5Db25zdGFudHMgPSB7XHJcbiAgU1RBUlRfT0ZfSEVBREVSOiA4LCAvLyBTdGFydCBidWZmZXIgcG9zaXRpb24gaW4gcmF3IGJsb2NrIGRhdGFcclxuICBNQVhfVElNRV9PRkZTRVQ6IDIgKiA2MCAqIDYwLCAvLyBUaGUgbWF4IGEgdGltZXN0YW1wIGNhbiBiZSBpbiB0aGUgZnV0dXJlXHJcbiAgTEFSR0VTVF9IQVNIOiBuZXcgQk4oJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgJ2hleCcpXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJsb2NrSGVhZGVyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/block/blockheader.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/block/index.js":
/*!*****************************************!*\
  !*** ../bitcore-lib/lib/block/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./block */ \"../bitcore-lib/lib/block/block.js\");\r\n\r\nmodule.exports.BlockHeader = __webpack_require__(/*! ./blockheader */ \"../bitcore-lib/lib/block/blockheader.js\");\r\nmodule.exports.MerkleBlock = __webpack_require__(/*! ./merkleblock */ \"../bitcore-lib/lib/block/merkleblock.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2Jsb2NrL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHdGQUFtQztBQUNuQztBQUNBLGdIQUFxRDtBQUNyRCxnSEFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9ibG9jay9pbmRleC5qcz80YTk5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ibG9jaycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuQmxvY2tIZWFkZXIgPSByZXF1aXJlKCcuL2Jsb2NraGVhZGVyJyk7XHJcbm1vZHVsZS5leHBvcnRzLk1lcmtsZUJsb2NrID0gcmVxdWlyZSgnLi9tZXJrbGVibG9jaycpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/block/index.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/block/merkleblock.js":
/*!***********************************************!*\
  !*** ../bitcore-lib/lib/block/merkleblock.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar BlockHeader = __webpack_require__(/*! ./blockheader */ \"../bitcore-lib/lib/block/blockheader.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar Transaction = __webpack_require__(/*! ../transaction */ \"../bitcore-lib/lib/transaction/index.js\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\n/**\r\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\r\n * the properties of the Block\r\n *\r\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\r\n * @returns {MerkleBlock}\r\n * @constructor\r\n */\r\nfunction MerkleBlock(arg) {\r\n  /* jshint maxstatements: 18 */\r\n\r\n  if (!(this instanceof MerkleBlock)) {\r\n    return new MerkleBlock(arg);\r\n  }\r\n\r\n  var info = {};\r\n  if (BufferUtil.isBuffer(arg)) {\r\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\r\n  } else if (_.isObject(arg)) {\r\n    var header;\r\n    if(arg.header instanceof BlockHeader) {\r\n      header = arg.header;\r\n    } else {\r\n      header = BlockHeader.fromObject(arg.header);\r\n    }\r\n    info = {\r\n      /**\r\n       * @name MerkleBlock#header\r\n       * @type {BlockHeader}\r\n       */\r\n      header: header,\r\n      /**\r\n       * @name MerkleBlock#numTransactions\r\n       * @type {Number}\r\n       */\r\n      numTransactions: arg.numTransactions,\r\n      /**\r\n       * @name MerkleBlock#hashes\r\n       * @type {String[]}\r\n       */\r\n      hashes: arg.hashes,\r\n      /**\r\n       * @name MerkleBlock#flags\r\n       * @type {Number[]}\r\n       */\r\n      flags: arg.flags\r\n    };\r\n  } else {\r\n    throw new TypeError('Unrecognized argument for MerkleBlock');\r\n  }\r\n  _.extend(this,info);\r\n  this._flagBitsUsed = 0;\r\n  this._hashesUsed = 0;\r\n\r\n  return this;\r\n}\r\n\r\n/**\r\n * @param {Buffer} - MerkleBlock data in a Buffer object\r\n * @returns {MerkleBlock} - A MerkleBlock object\r\n */\r\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\r\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\r\n};\r\n\r\n/**\r\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\r\n * @returns {MerkleBlock} - A MerkleBlock object\r\n */\r\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\r\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\r\n};\r\n\r\n/**\r\n * @returns {Buffer} - A buffer of the block\r\n */\r\nMerkleBlock.prototype.toBuffer = function toBuffer() {\r\n  return this.toBufferWriter().concat();\r\n};\r\n\r\n/**\r\n * @param {BufferWriter} - An existing instance of BufferWriter\r\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\r\n */\r\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\r\n  if (!bw) {\r\n    bw = new BufferWriter();\r\n  }\r\n  bw.write(this.header.toBuffer());\r\n  bw.writeUInt32LE(this.numTransactions);\r\n  bw.writeVarintNum(this.hashes.length);\r\n  for (var i = 0; i < this.hashes.length; i++) {\r\n    bw.write(Buffer.from(this.hashes[i], 'hex'));\r\n  }\r\n  bw.writeVarintNum(this.flags.length);\r\n  for (i = 0; i < this.flags.length; i++) {\r\n    bw.writeUInt8(this.flags[i]);\r\n  }\r\n  return bw;\r\n};\r\n\r\n/**\r\n * @returns {Object} - A plain object with the MerkleBlock properties\r\n */\r\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\r\n  return {\r\n    header: this.header.toObject(),\r\n    numTransactions: this.numTransactions,\r\n    hashes: this.hashes,\r\n    flags: this.flags\r\n  };\r\n};\r\n\r\n/**\r\n * Verify that the MerkleBlock is valid\r\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\r\n */\r\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\r\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\r\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\r\n\r\n  // Can't have more hashes than numTransactions\r\n  if(this.hashes.length > this.numTransactions) {\r\n    return false;\r\n  }\r\n\r\n  // Can't have more flag bits than num hashes\r\n  if(this.flags.length * 8 < this.hashes.length) {\r\n    return false;\r\n  }\r\n\r\n  var height = this._calcTreeHeight();\r\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\r\n  var root = this._traverseMerkleTree(height, 0, opts);\r\n  if(opts.hashesUsed !== this.hashes.length) {\r\n    return false;\r\n  }\r\n  return BufferUtil.equals(root, this.header.merkleRoot);\r\n};\r\n\r\n/**\r\n * Return a list of all the txs hash that match the filter\r\n * @returns {Array} - txs hash that match the filter\r\n */\r\nMerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {\r\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\r\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\r\n\r\n  // Can't have more hashes than numTransactions\r\n  if(this.hashes.length > this.numTransactions) {\r\n    throw new errors.MerkleBlock.InvalidMerkleTree();\r\n  }\r\n\r\n  // Can't have more flag bits than num hashes\r\n  if(this.flags.length * 8 < this.hashes.length) {\r\n    throw new errors.MerkleBlock.InvalidMerkleTree();\r\n  }\r\n\r\n  // If there is only one hash the filter do not match any txs in the block\r\n  if(this.hashes.length === 1) {\r\n    return [];\r\n  };\r\n\r\n  var height = this._calcTreeHeight();\r\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\r\n  var txs = this._traverseMerkleTree(height, 0, opts, true);\r\n  if(opts.hashesUsed !== this.hashes.length) {\r\n    throw new errors.MerkleBlock.InvalidMerkleTree();\r\n  }\r\n  return txs;\r\n};\r\n\r\n/**\r\n * Traverse a the tree in this MerkleBlock, validating it along the way\r\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\r\n * @param {Number} - depth - Current height\r\n * @param {Number} - pos - Current position in the tree\r\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\r\n * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash\r\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\r\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\r\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter\r\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\r\n * @returns {Array} - transactions found during traversal that match the filter\r\n * @private\r\n */\r\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {\r\n  /* jshint maxcomplexity:  12*/\r\n  /* jshint maxstatements: 20 */\r\n\r\n  opts = opts || {};\r\n  opts.txs = opts.txs || [];\r\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\r\n  opts.hashesUsed = opts.hashesUsed || 0;\r\n  var checkForTxs = checkForTxs || false;\r\n\r\n  if(opts.flagBitsUsed > this.flags.length * 8) {\r\n    return null;\r\n  }\r\n  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;\r\n  if(depth === 0 || !isParentOfMatch) {\r\n    if(opts.hashesUsed >= this.hashes.length) {\r\n      return null;\r\n    }\r\n    var hash = this.hashes[opts.hashesUsed++];\r\n    if(depth === 0 && isParentOfMatch) {\r\n      opts.txs.push(hash);\r\n    }\r\n    return Buffer.from(hash, 'hex');\r\n  } else {\r\n    var left = this._traverseMerkleTree(depth-1, pos*2, opts);\r\n    var right = left;\r\n    if(pos*2+1 < this._calcTreeWidth(depth-1)) {\r\n      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);\r\n    }\r\n    if (checkForTxs){\r\n      return opts.txs;\r\n    } else {\r\n      return Hash.sha256sha256(new Buffer.concat([left, right]));\r\n    };\r\n  }\r\n};\r\n\r\n/** Calculates the width of a merkle tree at a given height.\r\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\r\n * @param {Number} - Height at which we want the tree width\r\n * @returns {Number} - Width of the tree at a given height\r\n * @private\r\n */\r\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\r\n  return (this.numTransactions + (1 << height) - 1) >> height;\r\n};\r\n\r\n/** Calculates the height of the merkle tree in this MerkleBlock\r\n * @param {Number} - Height at which we want the tree width\r\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\r\n * @private\r\n */\r\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\r\n  var height = 0;\r\n  while (this._calcTreeWidth(height) > 1) {\r\n    height++;\r\n  }\r\n  return height;\r\n};\r\n\r\n/**\r\n * @param {Transaction|String} - Transaction or Transaction ID Hash\r\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\r\n * @private\r\n */\r\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\r\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\r\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',\r\n      'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\r\n\r\n  var hash = tx;\r\n  if(tx instanceof Transaction) {\r\n    // We need to reverse the id hash for the lookup\r\n    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\r\n  }\r\n\r\n  var txs = [];\r\n  var height = this._calcTreeHeight();\r\n  this._traverseMerkleTree(height, 0, { txs: txs });\r\n  return txs.indexOf(hash) !== -1;\r\n};\r\n\r\n/**\r\n * @param {Buffer} - MerkleBlock data\r\n * @returns {Object} - An Object representing merkleblock data\r\n * @private\r\n */\r\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\r\n  $.checkState(!br.finished(), 'No merkleblock data received');\r\n  var info = {};\r\n  info.header = BlockHeader.fromBufferReader(br);\r\n  info.numTransactions = br.readUInt32LE();\r\n  var numHashes = br.readVarintNum();\r\n  info.hashes = [];\r\n  for (var i = 0; i < numHashes; i++) {\r\n    info.hashes.push(br.read(32).toString('hex'));\r\n  }\r\n  var numFlags = br.readVarintNum();\r\n  info.flags = [];\r\n  for (i = 0; i < numFlags; i++) {\r\n    info.flags.push(br.readUInt8());\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * @param {Object} - A plain JavaScript object\r\n * @returns {Block} - An instance of block\r\n */\r\nMerkleBlock.fromObject = function fromObject(obj) {\r\n  return new MerkleBlock(obj);\r\n};\r\n\r\nmodule.exports = MerkleBlock;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2Jsb2NrL21lcmtsZWJsb2NrLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLDREQUFRO0FBQ3hCLGtCQUFrQixtQkFBTyxDQUFDLDhEQUFlO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLHlEQUFnQjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBMEI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsNkVBQTBCO0FBQ3JELFdBQVcsbUJBQU8sQ0FBQyx5REFBZ0I7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLGlEQUFZO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLCtEQUFnQjtBQUMxQyxhQUFhLG1CQUFPLENBQUMscURBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLHVFQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUMsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL2Jsb2NrL21lcmtsZWJsb2NrLmpzPzZmOGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIEJsb2NrSGVhZGVyID0gcmVxdWlyZSgnLi9ibG9ja2hlYWRlcicpO1xyXG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XHJcbnZhciBCdWZmZXJSZWFkZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJyZWFkZXInKTtcclxudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xyXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by9oYXNoJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XHJcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uJyk7XHJcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcclxudmFyICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIE1lcmtsZUJsb2NrIGZyb20gYSBCdWZmZXIsIEpTT04gb2JqZWN0LCBvciBPYmplY3Qgd2l0aFxyXG4gKiB0aGUgcHJvcGVydGllcyBvZiB0aGUgQmxvY2tcclxuICpcclxuICogQHBhcmFtIHsqfSAtIEEgQnVmZmVyLCBKU09OIHN0cmluZywgb3IgT2JqZWN0IHJlcHJlc2VudGluZyBhIE1lcmtsZUJsb2NrXHJcbiAqIEByZXR1cm5zIHtNZXJrbGVCbG9ja31cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBNZXJrbGVCbG9jayhhcmcpIHtcclxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMTggKi9cclxuXHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1lcmtsZUJsb2NrKSkge1xyXG4gICAgcmV0dXJuIG5ldyBNZXJrbGVCbG9jayhhcmcpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGluZm8gPSB7fTtcclxuICBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcpKSB7XHJcbiAgICBpbmZvID0gTWVya2xlQmxvY2suX2Zyb21CdWZmZXJSZWFkZXIoQnVmZmVyUmVhZGVyKGFyZykpO1xyXG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChhcmcpKSB7XHJcbiAgICB2YXIgaGVhZGVyO1xyXG4gICAgaWYoYXJnLmhlYWRlciBpbnN0YW5jZW9mIEJsb2NrSGVhZGVyKSB7XHJcbiAgICAgIGhlYWRlciA9IGFyZy5oZWFkZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoZWFkZXIgPSBCbG9ja0hlYWRlci5mcm9tT2JqZWN0KGFyZy5oZWFkZXIpO1xyXG4gICAgfVxyXG4gICAgaW5mbyA9IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIE1lcmtsZUJsb2NrI2hlYWRlclxyXG4gICAgICAgKiBAdHlwZSB7QmxvY2tIZWFkZXJ9XHJcbiAgICAgICAqL1xyXG4gICAgICBoZWFkZXI6IGhlYWRlcixcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIE1lcmtsZUJsb2NrI251bVRyYW5zYWN0aW9uc1xyXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgKi9cclxuICAgICAgbnVtVHJhbnNhY3Rpb25zOiBhcmcubnVtVHJhbnNhY3Rpb25zLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgTWVya2xlQmxvY2sjaGFzaGVzXHJcbiAgICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cclxuICAgICAgICovXHJcbiAgICAgIGhhc2hlczogYXJnLmhhc2hlcyxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIE1lcmtsZUJsb2NrI2ZsYWdzXHJcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cclxuICAgICAgICovXHJcbiAgICAgIGZsYWdzOiBhcmcuZmxhZ3NcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVjb2duaXplZCBhcmd1bWVudCBmb3IgTWVya2xlQmxvY2snKTtcclxuICB9XHJcbiAgXy5leHRlbmQodGhpcyxpbmZvKTtcclxuICB0aGlzLl9mbGFnQml0c1VzZWQgPSAwO1xyXG4gIHRoaXMuX2hhc2hlc1VzZWQgPSAwO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSAtIE1lcmtsZUJsb2NrIGRhdGEgaW4gYSBCdWZmZXIgb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtNZXJrbGVCbG9ja30gLSBBIE1lcmtsZUJsb2NrIG9iamVjdFxyXG4gKi9cclxuTWVya2xlQmxvY2suZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmKSB7XHJcbiAgcmV0dXJuIE1lcmtsZUJsb2NrLmZyb21CdWZmZXJSZWFkZXIoQnVmZmVyUmVhZGVyKGJ1ZikpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QnVmZmVyUmVhZGVyfSAtIE1lcmtsZUJsb2NrIGRhdGEgaW4gYSBCdWZmZXJSZWFkZXIgb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtNZXJrbGVCbG9ja30gLSBBIE1lcmtsZUJsb2NrIG9iamVjdFxyXG4gKi9cclxuTWVya2xlQmxvY2suZnJvbUJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uIGZyb21CdWZmZXJSZWFkZXIoYnIpIHtcclxuICByZXR1cm4gbmV3IE1lcmtsZUJsb2NrKE1lcmtsZUJsb2NrLl9mcm9tQnVmZmVyUmVhZGVyKGJyKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgYmxvY2tcclxuICovXHJcbk1lcmtsZUJsb2NrLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyKCkge1xyXG4gIHJldHVybiB0aGlzLnRvQnVmZmVyV3JpdGVyKCkuY29uY2F0KCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtCdWZmZXJXcml0ZXJ9IC0gQW4gZXhpc3RpbmcgaW5zdGFuY2Ugb2YgQnVmZmVyV3JpdGVyXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgQnVmZmVyV3JpdGVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBNZXJrbGVCbG9ja1xyXG4gKi9cclxuTWVya2xlQmxvY2sucHJvdG90eXBlLnRvQnVmZmVyV3JpdGVyID0gZnVuY3Rpb24gdG9CdWZmZXJXcml0ZXIoYncpIHtcclxuICBpZiAoIWJ3KSB7XHJcbiAgICBidyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICB9XHJcbiAgYncud3JpdGUodGhpcy5oZWFkZXIudG9CdWZmZXIoKSk7XHJcbiAgYncud3JpdGVVSW50MzJMRSh0aGlzLm51bVRyYW5zYWN0aW9ucyk7XHJcbiAgYncud3JpdGVWYXJpbnROdW0odGhpcy5oYXNoZXMubGVuZ3RoKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFzaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBidy53cml0ZShCdWZmZXIuZnJvbSh0aGlzLmhhc2hlc1tpXSwgJ2hleCcpKTtcclxuICB9XHJcbiAgYncud3JpdGVWYXJpbnROdW0odGhpcy5mbGFncy5sZW5ndGgpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZsYWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBidy53cml0ZVVJbnQ4KHRoaXMuZmxhZ3NbaV0pO1xyXG4gIH1cclxuICByZXR1cm4gYnc7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge09iamVjdH0gLSBBIHBsYWluIG9iamVjdCB3aXRoIHRoZSBNZXJrbGVCbG9jayBwcm9wZXJ0aWVzXHJcbiAqL1xyXG5NZXJrbGVCbG9jay5wcm90b3R5cGUudG9PYmplY3QgPSBNZXJrbGVCbG9jay5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGhlYWRlcjogdGhpcy5oZWFkZXIudG9PYmplY3QoKSxcclxuICAgIG51bVRyYW5zYWN0aW9uczogdGhpcy5udW1UcmFuc2FjdGlvbnMsXHJcbiAgICBoYXNoZXM6IHRoaXMuaGFzaGVzLFxyXG4gICAgZmxhZ3M6IHRoaXMuZmxhZ3NcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZlcmlmeSB0aGF0IHRoZSBNZXJrbGVCbG9jayBpcyB2YWxpZFxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBUcnVlL0ZhbHNlIHdoZXRoZXIgdGhpcyBNZXJrbGVCbG9jayBpcyBWYWxpZFxyXG4gKi9cclxuTWVya2xlQmxvY2sucHJvdG90eXBlLnZhbGlkTWVya2xlVHJlZSA9IGZ1bmN0aW9uIHZhbGlkTWVya2xlVHJlZSgpIHtcclxuICAkLmNoZWNrU3RhdGUoXy5pc0FycmF5KHRoaXMuZmxhZ3MpLCAnTWVya2xlQmxvY2sgZmxhZ3MgaXMgbm90IGFuIGFycmF5Jyk7XHJcbiAgJC5jaGVja1N0YXRlKF8uaXNBcnJheSh0aGlzLmhhc2hlcyksICdNZXJrbGVCbG9jayBoYXNoZXMgaXMgbm90IGFuIGFycmF5Jyk7XHJcblxyXG4gIC8vIENhbid0IGhhdmUgbW9yZSBoYXNoZXMgdGhhbiBudW1UcmFuc2FjdGlvbnNcclxuICBpZih0aGlzLmhhc2hlcy5sZW5ndGggPiB0aGlzLm51bVRyYW5zYWN0aW9ucykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FuJ3QgaGF2ZSBtb3JlIGZsYWcgYml0cyB0aGFuIG51bSBoYXNoZXNcclxuICBpZih0aGlzLmZsYWdzLmxlbmd0aCAqIDggPCB0aGlzLmhhc2hlcy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBoZWlnaHQgPSB0aGlzLl9jYWxjVHJlZUhlaWdodCgpO1xyXG4gIHZhciBvcHRzID0geyBoYXNoZXNVc2VkOiAwLCBmbGFnQml0c1VzZWQ6IDAgfTtcclxuICB2YXIgcm9vdCA9IHRoaXMuX3RyYXZlcnNlTWVya2xlVHJlZShoZWlnaHQsIDAsIG9wdHMpO1xyXG4gIGlmKG9wdHMuaGFzaGVzVXNlZCAhPT0gdGhpcy5oYXNoZXMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBCdWZmZXJVdGlsLmVxdWFscyhyb290LCB0aGlzLmhlYWRlci5tZXJrbGVSb290KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGFsbCB0aGUgdHhzIGhhc2ggdGhhdCBtYXRjaCB0aGUgZmlsdGVyXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gLSB0eHMgaGFzaCB0aGF0IG1hdGNoIHRoZSBmaWx0ZXJcclxuICovXHJcbk1lcmtsZUJsb2NrLnByb3RvdHlwZS5maWx0ZXJkVHhzSGFzaCA9IGZ1bmN0aW9uIGZpbHRlcmRUeHNIYXNoKCkge1xyXG4gICQuY2hlY2tTdGF0ZShfLmlzQXJyYXkodGhpcy5mbGFncyksICdNZXJrbGVCbG9jayBmbGFncyBpcyBub3QgYW4gYXJyYXknKTtcclxuICAkLmNoZWNrU3RhdGUoXy5pc0FycmF5KHRoaXMuaGFzaGVzKSwgJ01lcmtsZUJsb2NrIGhhc2hlcyBpcyBub3QgYW4gYXJyYXknKTtcclxuXHJcbiAgLy8gQ2FuJ3QgaGF2ZSBtb3JlIGhhc2hlcyB0aGFuIG51bVRyYW5zYWN0aW9uc1xyXG4gIGlmKHRoaXMuaGFzaGVzLmxlbmd0aCA+IHRoaXMubnVtVHJhbnNhY3Rpb25zKSB7XHJcbiAgICB0aHJvdyBuZXcgZXJyb3JzLk1lcmtsZUJsb2NrLkludmFsaWRNZXJrbGVUcmVlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBDYW4ndCBoYXZlIG1vcmUgZmxhZyBiaXRzIHRoYW4gbnVtIGhhc2hlc1xyXG4gIGlmKHRoaXMuZmxhZ3MubGVuZ3RoICogOCA8IHRoaXMuaGFzaGVzLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IGVycm9ycy5NZXJrbGVCbG9jay5JbnZhbGlkTWVya2xlVHJlZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgaGFzaCB0aGUgZmlsdGVyIGRvIG5vdCBtYXRjaCBhbnkgdHhzIGluIHRoZSBibG9ja1xyXG4gIGlmKHRoaXMuaGFzaGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH07XHJcblxyXG4gIHZhciBoZWlnaHQgPSB0aGlzLl9jYWxjVHJlZUhlaWdodCgpO1xyXG4gIHZhciBvcHRzID0geyBoYXNoZXNVc2VkOiAwLCBmbGFnQml0c1VzZWQ6IDAgfTtcclxuICB2YXIgdHhzID0gdGhpcy5fdHJhdmVyc2VNZXJrbGVUcmVlKGhlaWdodCwgMCwgb3B0cywgdHJ1ZSk7XHJcbiAgaWYob3B0cy5oYXNoZXNVc2VkICE9PSB0aGlzLmhhc2hlcy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBlcnJvcnMuTWVya2xlQmxvY2suSW52YWxpZE1lcmtsZVRyZWUoKTtcclxuICB9XHJcbiAgcmV0dXJuIHR4cztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmF2ZXJzZSBhIHRoZSB0cmVlIGluIHRoaXMgTWVya2xlQmxvY2ssIHZhbGlkYXRpbmcgaXQgYWxvbmcgdGhlIHdheVxyXG4gKiBNb2RlbGVkIGFmdGVyIEJpdGNvaW4gQ29yZSBtZXJrbGVibG9jay5jcHAgVHJhdmVyc2VBbmRFeHRyYWN0KClcclxuICogQHBhcmFtIHtOdW1iZXJ9IC0gZGVwdGggLSBDdXJyZW50IGhlaWdodFxyXG4gKiBAcGFyYW0ge051bWJlcn0gLSBwb3MgLSBDdXJyZW50IHBvc2l0aW9uIGluIHRoZSB0cmVlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIG9wdHMgLSBPYmplY3Qgd2l0aCB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIG11dGF0ZWQgdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gLSBjaGVja0ZvclR4cyAtIGlmIHRydWUgcmV0dXJuIG9wdHMudHhzIGVsc2UgcmV0dXJuIHRoZSBNZXJrbGUgSGFzaFxyXG4gKiBAcGFyYW0ge051bWJlcn0gLSBvcHRzLmZsYWdCaXRzVXNlZCAtIE51bWJlciBvZiBmbGFnIGJpdHMgdXNlZCwgc2hvdWxkIHN0YXJ0IGF0IDBcclxuICogQHBhcmFtIHtOdW1iZXJ9IC0gb3B0cy5oYXNoZXNVc2VkIC0gTnVtYmVyIG9mIGhhc2hlcyB1c2VkLCBzaG91bGQgc3RhcnQgYXQgMFxyXG4gKiBAcGFyYW0ge0FycmF5fSAtIG9wdHMudHhzIC0gV2lsbCBmaW5pc2ggcG9wdWxhdGVkIGJ5IHRyYW5zYWN0aW9ucyBmb3VuZCBkdXJpbmcgdHJhdmVyc2FsIHRoYXQgbWF0Y2ggdGhlIGZpbHRlclxyXG4gKiBAcmV0dXJucyB7QnVmZmVyfG51bGx9IC0gQnVmZmVyIGNvbnRhaW5pbmcgdGhlIE1lcmtsZSBIYXNoIGZvciB0aGF0IGhlaWdodFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gdHJhbnNhY3Rpb25zIGZvdW5kIGR1cmluZyB0cmF2ZXJzYWwgdGhhdCBtYXRjaCB0aGUgZmlsdGVyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5NZXJrbGVCbG9jay5wcm90b3R5cGUuX3RyYXZlcnNlTWVya2xlVHJlZSA9IGZ1bmN0aW9uIHRyYXZlcnNlTWVya2xlVHJlZShkZXB0aCwgcG9zLCBvcHRzLCBjaGVja0ZvclR4cykge1xyXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAgMTIqL1xyXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xyXG5cclxuICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICBvcHRzLnR4cyA9IG9wdHMudHhzIHx8IFtdO1xyXG4gIG9wdHMuZmxhZ0JpdHNVc2VkID0gb3B0cy5mbGFnQml0c1VzZWQgfHwgMDtcclxuICBvcHRzLmhhc2hlc1VzZWQgPSBvcHRzLmhhc2hlc1VzZWQgfHwgMDtcclxuICB2YXIgY2hlY2tGb3JUeHMgPSBjaGVja0ZvclR4cyB8fCBmYWxzZTtcclxuXHJcbiAgaWYob3B0cy5mbGFnQml0c1VzZWQgPiB0aGlzLmZsYWdzLmxlbmd0aCAqIDgpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgaXNQYXJlbnRPZk1hdGNoID0gKHRoaXMuZmxhZ3Nbb3B0cy5mbGFnQml0c1VzZWQgPj4gM10gPj4+IChvcHRzLmZsYWdCaXRzVXNlZCsrICYgNykpICYgMTtcclxuICBpZihkZXB0aCA9PT0gMCB8fCAhaXNQYXJlbnRPZk1hdGNoKSB7XHJcbiAgICBpZihvcHRzLmhhc2hlc1VzZWQgPj0gdGhpcy5oYXNoZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc2ggPSB0aGlzLmhhc2hlc1tvcHRzLmhhc2hlc1VzZWQrK107XHJcbiAgICBpZihkZXB0aCA9PT0gMCAmJiBpc1BhcmVudE9mTWF0Y2gpIHtcclxuICAgICAgb3B0cy50eHMucHVzaChoYXNoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShoYXNoLCAnaGV4Jyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBsZWZ0ID0gdGhpcy5fdHJhdmVyc2VNZXJrbGVUcmVlKGRlcHRoLTEsIHBvcyoyLCBvcHRzKTtcclxuICAgIHZhciByaWdodCA9IGxlZnQ7XHJcbiAgICBpZihwb3MqMisxIDwgdGhpcy5fY2FsY1RyZWVXaWR0aChkZXB0aC0xKSkge1xyXG4gICAgICByaWdodCA9IHRoaXMuX3RyYXZlcnNlTWVya2xlVHJlZShkZXB0aC0xLCBwb3MqMisxLCBvcHRzKTtcclxuICAgIH1cclxuICAgIGlmIChjaGVja0ZvclR4cyl7XHJcbiAgICAgIHJldHVybiBvcHRzLnR4cztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBIYXNoLnNoYTI1NnNoYTI1NihuZXcgQnVmZmVyLmNvbmNhdChbbGVmdCwgcmlnaHRdKSk7XHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8qKiBDYWxjdWxhdGVzIHRoZSB3aWR0aCBvZiBhIG1lcmtsZSB0cmVlIGF0IGEgZ2l2ZW4gaGVpZ2h0LlxyXG4gKiAgTW9kZWxlZCBhZnRlciBCaXRjb2luIENvcmUgbWVya2xlYmxvY2suaCBDYWxjVHJlZVdpZHRoKClcclxuICogQHBhcmFtIHtOdW1iZXJ9IC0gSGVpZ2h0IGF0IHdoaWNoIHdlIHdhbnQgdGhlIHRyZWUgd2lkdGhcclxuICogQHJldHVybnMge051bWJlcn0gLSBXaWR0aCBvZiB0aGUgdHJlZSBhdCBhIGdpdmVuIGhlaWdodFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTWVya2xlQmxvY2sucHJvdG90eXBlLl9jYWxjVHJlZVdpZHRoID0gZnVuY3Rpb24gY2FsY1RyZWVXaWR0aChoZWlnaHQpIHtcclxuICByZXR1cm4gKHRoaXMubnVtVHJhbnNhY3Rpb25zICsgKDEgPDwgaGVpZ2h0KSAtIDEpID4+IGhlaWdodDtcclxufTtcclxuXHJcbi8qKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIG1lcmtsZSB0cmVlIGluIHRoaXMgTWVya2xlQmxvY2tcclxuICogQHBhcmFtIHtOdW1iZXJ9IC0gSGVpZ2h0IGF0IHdoaWNoIHdlIHdhbnQgdGhlIHRyZWUgd2lkdGhcclxuICogQHJldHVybnMge051bWJlcn0gLSBIZWlnaHQgb2YgdGhlIG1lcmtsZSB0cmVlIGluIHRoaXMgTWVya2xlQmxvY2tcclxuICogQHByaXZhdGVcclxuICovXHJcbk1lcmtsZUJsb2NrLnByb3RvdHlwZS5fY2FsY1RyZWVIZWlnaHQgPSBmdW5jdGlvbiBjYWxjVHJlZUhlaWdodCgpIHtcclxuICB2YXIgaGVpZ2h0ID0gMDtcclxuICB3aGlsZSAodGhpcy5fY2FsY1RyZWVXaWR0aChoZWlnaHQpID4gMSkge1xyXG4gICAgaGVpZ2h0Kys7XHJcbiAgfVxyXG4gIHJldHVybiBoZWlnaHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbnxTdHJpbmd9IC0gVHJhbnNhY3Rpb24gb3IgVHJhbnNhY3Rpb24gSUQgSGFzaFxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSByZXR1cm4gdHJ1ZS9mYWxzZSBpZiB0aGlzIE1lcmtsZUJsb2NrIGhhcyB0aGUgVFggb3Igbm90XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5NZXJrbGVCbG9jay5wcm90b3R5cGUuaGFzVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBoYXNUcmFuc2FjdGlvbih0eCkge1xyXG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZCh0eCksICd0eCBjYW5ub3QgYmUgdW5kZWZpbmVkJyk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHR4IGluc3RhbmNlb2YgVHJhbnNhY3Rpb24gfHwgdHlwZW9mIHR4ID09PSAnc3RyaW5nJyxcclxuICAgICAgJ0ludmFsaWQgdHggZ2l2ZW4sIHR4IG11c3QgYmUgYSBcInN0cmluZ1wiIG9yIFwiVHJhbnNhY3Rpb25cIicpO1xyXG5cclxuICB2YXIgaGFzaCA9IHR4O1xyXG4gIGlmKHR4IGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcclxuICAgIC8vIFdlIG5lZWQgdG8gcmV2ZXJzZSB0aGUgaWQgaGFzaCBmb3IgdGhlIGxvb2t1cFxyXG4gICAgaGFzaCA9IEJ1ZmZlclV0aWwucmV2ZXJzZShCdWZmZXIuZnJvbSh0eC5pZCwgJ2hleCcpKS50b1N0cmluZygnaGV4Jyk7XHJcbiAgfVxyXG5cclxuICB2YXIgdHhzID0gW107XHJcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbGNUcmVlSGVpZ2h0KCk7XHJcbiAgdGhpcy5fdHJhdmVyc2VNZXJrbGVUcmVlKGhlaWdodCwgMCwgeyB0eHM6IHR4cyB9KTtcclxuICByZXR1cm4gdHhzLmluZGV4T2YoaGFzaCkgIT09IC0xO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSAtIE1lcmtsZUJsb2NrIGRhdGFcclxuICogQHJldHVybnMge09iamVjdH0gLSBBbiBPYmplY3QgcmVwcmVzZW50aW5nIG1lcmtsZWJsb2NrIGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcbk1lcmtsZUJsb2NrLl9mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24gX2Zyb21CdWZmZXJSZWFkZXIoYnIpIHtcclxuICAkLmNoZWNrU3RhdGUoIWJyLmZpbmlzaGVkKCksICdObyBtZXJrbGVibG9jayBkYXRhIHJlY2VpdmVkJyk7XHJcbiAgdmFyIGluZm8gPSB7fTtcclxuICBpbmZvLmhlYWRlciA9IEJsb2NrSGVhZGVyLmZyb21CdWZmZXJSZWFkZXIoYnIpO1xyXG4gIGluZm8ubnVtVHJhbnNhY3Rpb25zID0gYnIucmVhZFVJbnQzMkxFKCk7XHJcbiAgdmFyIG51bUhhc2hlcyA9IGJyLnJlYWRWYXJpbnROdW0oKTtcclxuICBpbmZvLmhhc2hlcyA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtSGFzaGVzOyBpKyspIHtcclxuICAgIGluZm8uaGFzaGVzLnB1c2goYnIucmVhZCgzMikudG9TdHJpbmcoJ2hleCcpKTtcclxuICB9XHJcbiAgdmFyIG51bUZsYWdzID0gYnIucmVhZFZhcmludE51bSgpO1xyXG4gIGluZm8uZmxhZ3MgPSBbXTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbnVtRmxhZ3M7IGkrKykge1xyXG4gICAgaW5mby5mbGFncy5wdXNoKGJyLnJlYWRVSW50OCgpKTtcclxuICB9XHJcbiAgcmV0dXJuIGluZm87XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtPYmplY3R9IC0gQSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdFxyXG4gKiBAcmV0dXJucyB7QmxvY2t9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2tcclxuICovXHJcbk1lcmtsZUJsb2NrLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikge1xyXG4gIHJldHVybiBuZXcgTWVya2xlQmxvY2sob2JqKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVya2xlQmxvY2s7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/block/merkleblock.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/crypto/bn.js":
/*!***************************************!*\
  !*** ../bitcore-lib/lib/crypto/bn.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar BN = __webpack_require__(/*! bn.js */ \"../bitcore-lib/node_modules/bn.js/lib/bn.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\nvar reversebuf = function(buf) {\r\n  var buf2 = Buffer.alloc(buf.length);\r\n  for (var i = 0; i < buf.length; i++) {\r\n    buf2[i] = buf[buf.length - 1 - i];\r\n  }\r\n  return buf2;\r\n};\r\n\r\nBN.Zero = new BN(0);\r\nBN.One = new BN(1);\r\nBN.Minus1 = new BN(-1);\r\n\r\nBN.fromNumber = function(n) {\r\n  $.checkArgument(_.isNumber(n));\r\n  return new BN(n);\r\n};\r\n\r\nBN.fromString = function(str, base) {\r\n  $.checkArgument(_.isString(str));\r\n  return new BN(str, base);\r\n};\r\n\r\nBN.fromBuffer = function(buf, opts) {\r\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\r\n    buf = reversebuf(buf);\r\n  }\r\n  var hex = buf.toString('hex');\r\n  var bn = new BN(hex, 16);\r\n  return bn;\r\n};\r\n\r\n/**\r\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\r\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\r\n */\r\nBN.fromSM = function(buf, opts) {\r\n  var ret;\r\n  if (buf.length === 0) {\r\n    return BN.fromBuffer(Buffer.from([0]));\r\n  }\r\n\r\n  var endian = 'big';\r\n  if (opts) {\r\n    endian = opts.endian;\r\n  }\r\n  if (endian === 'little') {\r\n    buf = reversebuf(buf);\r\n  }\r\n\r\n  if (buf[0] & 0x80) {\r\n    buf[0] = buf[0] & 0x7f;\r\n    ret = BN.fromBuffer(buf);\r\n    ret.neg().copy(ret);\r\n  } else {\r\n    ret = BN.fromBuffer(buf);\r\n  }\r\n  return ret;\r\n};\r\n\r\n\r\nBN.prototype.toNumber = function() {\r\n  return parseInt(this.toString(10), 10);\r\n};\r\n\r\nBN.prototype.toBuffer = function(opts) {\r\n  var buf, hex;\r\n  if (opts && opts.size) {\r\n    hex = this.toString(16, 2);\r\n    var natlen = hex.length / 2;\r\n    buf = Buffer.from(hex, 'hex');\r\n\r\n    if (natlen === opts.size) {\r\n      buf = buf;\r\n    } else if (natlen > opts.size) {\r\n      buf = BN.trim(buf, natlen);\r\n    } else if (natlen < opts.size) {\r\n      buf = BN.pad(buf, natlen, opts.size);\r\n    }\r\n  } else {\r\n    hex = this.toString(16, 2);\r\n    buf = Buffer.from(hex, 'hex');\r\n  }\r\n\r\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\r\n    buf = reversebuf(buf);\r\n  }\r\n\r\n  return buf;\r\n};\r\n\r\nBN.prototype.toSMBigEndian = function() {\r\n  var buf;\r\n  if (this.cmp(BN.Zero) === -1) {\r\n    buf = this.neg().toBuffer();\r\n    if (buf[0] & 0x80) {\r\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\r\n    } else {\r\n      buf[0] = buf[0] | 0x80;\r\n    }\r\n  } else {\r\n    buf = this.toBuffer();\r\n    if (buf[0] & 0x80) {\r\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\r\n    }\r\n  }\r\n\r\n  if (buf.length === 1 & buf[0] === 0) {\r\n    buf = Buffer.from([]);\r\n  }\r\n  return buf;\r\n};\r\n\r\nBN.prototype.toSM = function(opts) {\r\n  var endian = opts ? opts.endian : 'big';\r\n  var buf = this.toSMBigEndian();\r\n\r\n  if (endian === 'little') {\r\n    buf = reversebuf(buf);\r\n  }\r\n  return buf;\r\n};\r\n\r\n/**\r\n * Create a BN from a \"ScriptNum\":\r\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\r\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\r\n * bignum. Instead, an error is thrown if trying to input a number bigger than\r\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\r\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\r\n */\r\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\r\n  var nMaxNumSize = size || 4;\r\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\r\n  if (fRequireMinimal && buf.length > 0) {\r\n    // Check that the number is encoded with the minimum possible\r\n    // number of bytes.\r\n    //\r\n    // If the most-significant-byte - excluding the sign bit - is zero\r\n    // then we're not minimal. Note how this test also rejects the\r\n    // negative-zero encoding, 0x80.\r\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\r\n      // One exception: if there's more than one byte and the most\r\n      // significant bit of the second-most-significant-byte is set\r\n      // it would conflict with the sign bit. An example of this case\r\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\r\n      // (big-endian).\r\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\r\n        throw new Error('non-minimally encoded script number');\r\n      }\r\n    }\r\n  }\r\n  return BN.fromSM(buf, {\r\n    endian: 'little'\r\n  });\r\n};\r\n\r\n/**\r\n * The corollary to the above, with the notable exception that we do not throw\r\n * an error if the output is larger than four bytes. (Which can happen if\r\n * performing a numerical operation that results in an overflow to more than 4\r\n * bytes).\r\n */\r\nBN.prototype.toScriptNumBuffer = function() {\r\n  return this.toSM({\r\n    endian: 'little'\r\n  });\r\n};\r\n\r\nBN.trim = function(buf, natlen) {\r\n  return buf.slice(natlen - buf.length, buf.length);\r\n};\r\n\r\nBN.pad = function(buf, natlen, size) {\r\n  var rbuf = Buffer.alloc(size);\r\n  for (var i = 0; i < buf.length; i++) {\r\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\r\n  }\r\n  for (i = 0; i < size - natlen; i++) {\r\n    rbuf[i] = 0;\r\n  }\r\n  return rbuf;\r\n};\r\n\r\nmodule.exports = BN;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by9ibi5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFNBQVMsbUJBQU8sQ0FBQywwREFBTztBQUN4QixRQUFRLG1CQUFPLENBQUMsdUVBQXVCO0FBQ3ZDLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QjtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU0sU0FBUyxNQUFNO0FBQ2pDLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLE1BQU0sU0FBUyxNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by9ibi5qcz8zMjM3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG52YXIgcmV2ZXJzZWJ1ZiA9IGZ1bmN0aW9uKGJ1Zikge1xyXG4gIHZhciBidWYyID0gQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGgpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBidWYyW2ldID0gYnVmW2J1Zi5sZW5ndGggLSAxIC0gaV07XHJcbiAgfVxyXG4gIHJldHVybiBidWYyO1xyXG59O1xyXG5cclxuQk4uWmVybyA9IG5ldyBCTigwKTtcclxuQk4uT25lID0gbmV3IEJOKDEpO1xyXG5CTi5NaW51czEgPSBuZXcgQk4oLTEpO1xyXG5cclxuQk4uZnJvbU51bWJlciA9IGZ1bmN0aW9uKG4pIHtcclxuICAkLmNoZWNrQXJndW1lbnQoXy5pc051bWJlcihuKSk7XHJcbiAgcmV0dXJuIG5ldyBCTihuKTtcclxufTtcclxuXHJcbkJOLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIsIGJhc2UpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoXy5pc1N0cmluZyhzdHIpKTtcclxuICByZXR1cm4gbmV3IEJOKHN0ciwgYmFzZSk7XHJcbn07XHJcblxyXG5CTi5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmLCBvcHRzKSB7XHJcbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmVuZGlhbiA9PT0gJ2xpdHRsZScpIHtcclxuICAgIGJ1ZiA9IHJldmVyc2VidWYoYnVmKTtcclxuICB9XHJcbiAgdmFyIGhleCA9IGJ1Zi50b1N0cmluZygnaGV4Jyk7XHJcbiAgdmFyIGJuID0gbmV3IEJOKGhleCwgMTYpO1xyXG4gIHJldHVybiBibjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIEJpZ051bWJlciBmcm9tIGEgXCJzaWduZWQgbWFnbml0dWRlIGJ1ZmZlclwiXHJcbiAqIChhIGJ1ZmZlciB3aGVyZSB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgcmVwcmVzZW50cyB0aGUgc2lnbiAoMCA9IHBvc2l0aXZlLCAtMSA9IG5lZ2F0aXZlKSlcclxuICovXHJcbkJOLmZyb21TTSA9IGZ1bmN0aW9uKGJ1Ziwgb3B0cykge1xyXG4gIHZhciByZXQ7XHJcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBCTi5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKFswXSkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVuZGlhbiA9ICdiaWcnO1xyXG4gIGlmIChvcHRzKSB7XHJcbiAgICBlbmRpYW4gPSBvcHRzLmVuZGlhbjtcclxuICB9XHJcbiAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpIHtcclxuICAgIGJ1ZiA9IHJldmVyc2VidWYoYnVmKTtcclxuICB9XHJcblxyXG4gIGlmIChidWZbMF0gJiAweDgwKSB7XHJcbiAgICBidWZbMF0gPSBidWZbMF0gJiAweDdmO1xyXG4gICAgcmV0ID0gQk4uZnJvbUJ1ZmZlcihidWYpO1xyXG4gICAgcmV0Lm5lZygpLmNvcHkocmV0KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0ID0gQk4uZnJvbUJ1ZmZlcihidWYpO1xyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuXHJcbkJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKDEwKSwgMTApO1xyXG59O1xyXG5cclxuQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24ob3B0cykge1xyXG4gIHZhciBidWYsIGhleDtcclxuICBpZiAob3B0cyAmJiBvcHRzLnNpemUpIHtcclxuICAgIGhleCA9IHRoaXMudG9TdHJpbmcoMTYsIDIpO1xyXG4gICAgdmFyIG5hdGxlbiA9IGhleC5sZW5ndGggLyAyO1xyXG4gICAgYnVmID0gQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XHJcblxyXG4gICAgaWYgKG5hdGxlbiA9PT0gb3B0cy5zaXplKSB7XHJcbiAgICAgIGJ1ZiA9IGJ1ZjtcclxuICAgIH0gZWxzZSBpZiAobmF0bGVuID4gb3B0cy5zaXplKSB7XHJcbiAgICAgIGJ1ZiA9IEJOLnRyaW0oYnVmLCBuYXRsZW4pO1xyXG4gICAgfSBlbHNlIGlmIChuYXRsZW4gPCBvcHRzLnNpemUpIHtcclxuICAgICAgYnVmID0gQk4ucGFkKGJ1ZiwgbmF0bGVuLCBvcHRzLnNpemUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBoZXggPSB0aGlzLnRvU3RyaW5nKDE2LCAyKTtcclxuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmVuZGlhbiA9PT0gJ2xpdHRsZScpIHtcclxuICAgIGJ1ZiA9IHJldmVyc2VidWYoYnVmKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBidWY7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUudG9TTUJpZ0VuZGlhbiA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBidWY7XHJcbiAgaWYgKHRoaXMuY21wKEJOLlplcm8pID09PSAtMSkge1xyXG4gICAgYnVmID0gdGhpcy5uZWcoKS50b0J1ZmZlcigpO1xyXG4gICAgaWYgKGJ1ZlswXSAmIDB4ODApIHtcclxuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzB4ODBdKSwgYnVmXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBidWZbMF0gPSBidWZbMF0gfCAweDgwO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XHJcbiAgICBpZiAoYnVmWzBdICYgMHg4MCkge1xyXG4gICAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMHgwMF0pLCBidWZdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChidWYubGVuZ3RoID09PSAxICYgYnVmWzBdID09PSAwKSB7XHJcbiAgICBidWYgPSBCdWZmZXIuZnJvbShbXSk7XHJcbiAgfVxyXG4gIHJldHVybiBidWY7XHJcbn07XHJcblxyXG5CTi5wcm90b3R5cGUudG9TTSA9IGZ1bmN0aW9uKG9wdHMpIHtcclxuICB2YXIgZW5kaWFuID0gb3B0cyA/IG9wdHMuZW5kaWFuIDogJ2JpZyc7XHJcbiAgdmFyIGJ1ZiA9IHRoaXMudG9TTUJpZ0VuZGlhbigpO1xyXG5cclxuICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJykge1xyXG4gICAgYnVmID0gcmV2ZXJzZWJ1ZihidWYpO1xyXG4gIH1cclxuICByZXR1cm4gYnVmO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIEJOIGZyb20gYSBcIlNjcmlwdE51bVwiOlxyXG4gKiBUaGlzIGlzIGFuYWxvZ291cyB0byB0aGUgY29uc3RydWN0b3IgZm9yIENTY3JpcHROdW0gaW4gYml0Y29pbmQuIE1hbnkgb3BzIGluXHJcbiAqIGJpdGNvaW5kJ3Mgc2NyaXB0IGludGVycHJldGVyIHVzZSBDU2NyaXB0TnVtLCB3aGljaCBpcyBub3QgcmVhbGx5IGEgcHJvcGVyXHJcbiAqIGJpZ251bS4gSW5zdGVhZCwgYW4gZXJyb3IgaXMgdGhyb3duIGlmIHRyeWluZyB0byBpbnB1dCBhIG51bWJlciBiaWdnZXIgdGhhblxyXG4gKiA0IGJ5dGVzLiBXZSBjb3B5IHRoYXQgYmVoYXZpb3IgaGVyZS4gQSB0aGlyZCBhcmd1bWVudCwgYHNpemVgLCBpcyBwcm92aWRlZCB0b1xyXG4gKiBleHRlbmQgdGhlIGhhcmQgbGltaXQgb2YgNCBieXRlcywgYXMgc29tZSB1c2FnZXMgcmVxdWlyZSBtb3JlIHRoYW4gNCBieXRlcy5cclxuICovXHJcbkJOLmZyb21TY3JpcHROdW1CdWZmZXIgPSBmdW5jdGlvbihidWYsIGZSZXF1aXJlTWluaW1hbCwgc2l6ZSkge1xyXG4gIHZhciBuTWF4TnVtU2l6ZSA9IHNpemUgfHwgNDtcclxuICAkLmNoZWNrQXJndW1lbnQoYnVmLmxlbmd0aCA8PSBuTWF4TnVtU2l6ZSwgbmV3IEVycm9yKCdzY3JpcHQgbnVtYmVyIG92ZXJmbG93JykpO1xyXG4gIGlmIChmUmVxdWlyZU1pbmltYWwgJiYgYnVmLmxlbmd0aCA+IDApIHtcclxuICAgIC8vIENoZWNrIHRoYXQgdGhlIG51bWJlciBpcyBlbmNvZGVkIHdpdGggdGhlIG1pbmltdW0gcG9zc2libGVcclxuICAgIC8vIG51bWJlciBvZiBieXRlcy5cclxuICAgIC8vXHJcbiAgICAvLyBJZiB0aGUgbW9zdC1zaWduaWZpY2FudC1ieXRlIC0gZXhjbHVkaW5nIHRoZSBzaWduIGJpdCAtIGlzIHplcm9cclxuICAgIC8vIHRoZW4gd2UncmUgbm90IG1pbmltYWwuIE5vdGUgaG93IHRoaXMgdGVzdCBhbHNvIHJlamVjdHMgdGhlXHJcbiAgICAvLyBuZWdhdGl2ZS16ZXJvIGVuY29kaW5nLCAweDgwLlxyXG4gICAgaWYgKChidWZbYnVmLmxlbmd0aCAtIDFdICYgMHg3ZikgPT09IDApIHtcclxuICAgICAgLy8gT25lIGV4Y2VwdGlvbjogaWYgdGhlcmUncyBtb3JlIHRoYW4gb25lIGJ5dGUgYW5kIHRoZSBtb3N0XHJcbiAgICAgIC8vIHNpZ25pZmljYW50IGJpdCBvZiB0aGUgc2Vjb25kLW1vc3Qtc2lnbmlmaWNhbnQtYnl0ZSBpcyBzZXRcclxuICAgICAgLy8gaXQgd291bGQgY29uZmxpY3Qgd2l0aCB0aGUgc2lnbiBiaXQuIEFuIGV4YW1wbGUgb2YgdGhpcyBjYXNlXHJcbiAgICAgIC8vIGlzICstMjU1LCB3aGljaCBlbmNvZGUgdG8gMHhmZjAwIGFuZCAweGZmODAgcmVzcGVjdGl2ZWx5LlxyXG4gICAgICAvLyAoYmlnLWVuZGlhbikuXHJcbiAgICAgIGlmIChidWYubGVuZ3RoIDw9IDEgfHwgKGJ1ZltidWYubGVuZ3RoIC0gMl0gJiAweDgwKSA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uLW1pbmltYWxseSBlbmNvZGVkIHNjcmlwdCBudW1iZXInKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gQk4uZnJvbVNNKGJ1Ziwge1xyXG4gICAgZW5kaWFuOiAnbGl0dGxlJ1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjb3JvbGxhcnkgdG8gdGhlIGFib3ZlLCB3aXRoIHRoZSBub3RhYmxlIGV4Y2VwdGlvbiB0aGF0IHdlIGRvIG5vdCB0aHJvd1xyXG4gKiBhbiBlcnJvciBpZiB0aGUgb3V0cHV0IGlzIGxhcmdlciB0aGFuIGZvdXIgYnl0ZXMuIChXaGljaCBjYW4gaGFwcGVuIGlmXHJcbiAqIHBlcmZvcm1pbmcgYSBudW1lcmljYWwgb3BlcmF0aW9uIHRoYXQgcmVzdWx0cyBpbiBhbiBvdmVyZmxvdyB0byBtb3JlIHRoYW4gNFxyXG4gKiBieXRlcykuXHJcbiAqL1xyXG5CTi5wcm90b3R5cGUudG9TY3JpcHROdW1CdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy50b1NNKHtcclxuICAgIGVuZGlhbjogJ2xpdHRsZSdcclxuICB9KTtcclxufTtcclxuXHJcbkJOLnRyaW0gPSBmdW5jdGlvbihidWYsIG5hdGxlbikge1xyXG4gIHJldHVybiBidWYuc2xpY2UobmF0bGVuIC0gYnVmLmxlbmd0aCwgYnVmLmxlbmd0aCk7XHJcbn07XHJcblxyXG5CTi5wYWQgPSBmdW5jdGlvbihidWYsIG5hdGxlbiwgc2l6ZSkge1xyXG4gIHZhciByYnVmID0gQnVmZmVyLmFsbG9jKHNpemUpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICByYnVmW3JidWYubGVuZ3RoIC0gMSAtIGldID0gYnVmW2J1Zi5sZW5ndGggLSAxIC0gaV07XHJcbiAgfVxyXG4gIGZvciAoaSA9IDA7IGkgPCBzaXplIC0gbmF0bGVuOyBpKyspIHtcclxuICAgIHJidWZbaV0gPSAwO1xyXG4gIH1cclxuICByZXR1cm4gcmJ1ZjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQk47XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/crypto/bn.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/crypto/ecdsa.js":
/*!******************************************!*\
  !*** ../bitcore-lib/lib/crypto/ecdsa.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar BN = __webpack_require__(/*! ./bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar Point = __webpack_require__(/*! ./point */ \"../bitcore-lib/lib/crypto/point.js\");\r\nvar Signature = __webpack_require__(/*! ./signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar PublicKey = __webpack_require__(/*! ../publickey */ \"../bitcore-lib/lib/publickey.js\");\r\nvar Random = __webpack_require__(/*! ./random */ \"../bitcore-lib/lib/crypto/random.js\");\r\nvar Hash = __webpack_require__(/*! ./hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nvar ECDSA = function ECDSA(obj) {\r\n  if (!(this instanceof ECDSA)) {\r\n    return new ECDSA(obj);\r\n  }\r\n  if (obj) {\r\n    this.set(obj);\r\n  }\r\n};\r\n\r\n/* jshint maxcomplexity: 9 */\r\nECDSA.prototype.set = function(obj) {\r\n  this.hashbuf = obj.hashbuf || this.hashbuf;\r\n  this.endian = obj.endian || this.endian; //the endianness of hashbuf\r\n  this.privkey = obj.privkey || this.privkey;\r\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\r\n  this.sig = obj.sig || this.sig;\r\n  this.k = obj.k || this.k;\r\n  this.verified = obj.verified || this.verified;\r\n  return this;\r\n};\r\n\r\nECDSA.prototype.privkey2pubkey = function() {\r\n  this.pubkey = this.privkey.toPublicKey();\r\n};\r\n\r\nECDSA.prototype.calci = function() {\r\n  for (var i = 0; i < 4; i++) {\r\n    this.sig.i = i;\r\n    var Qprime;\r\n    try {\r\n      Qprime = this.toPublicKey();\r\n    } catch (e) {\r\n      console.error(e);\r\n      continue;\r\n    }\r\n\r\n    if (Qprime.point.eq(this.pubkey.point)) {\r\n      this.sig.compressed = this.pubkey.compressed;\r\n      return this;\r\n    }\r\n  }\r\n\r\n  this.sig.i = undefined;\r\n  throw new Error('Unable to find valid recovery factor');\r\n};\r\n\r\nECDSA.fromString = function(str) {\r\n  var obj = JSON.parse(str);\r\n  return new ECDSA(obj);\r\n};\r\n\r\nECDSA.prototype.randomK = function() {\r\n  var N = Point.getN();\r\n  var k;\r\n  do {\r\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\r\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\r\n  this.k = k;\r\n  return this;\r\n};\r\n\r\n\r\n// https://tools.ietf.org/html/rfc6979#section-3.2\r\nECDSA.prototype.deterministicK = function(badrs) {\r\n  /* jshint maxstatements: 25 */\r\n  // if r or s were invalid when this function was used in signing,\r\n  // we do not want to actually compute r, s here for efficiency, so,\r\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\r\n  if (_.isUndefined(badrs)) {\r\n    badrs = 0;\r\n  }\r\n  var v = Buffer.alloc(32);\r\n  v.fill(0x01);\r\n  var k = Buffer.alloc(32);\r\n  k.fill(0x00);\r\n  var x = this.privkey.bn.toBuffer({\r\n    size: 32\r\n  });\r\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf\r\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);\r\n  v = Hash.sha256hmac(v, k);\r\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);\r\n  v = Hash.sha256hmac(v, k);\r\n  v = Hash.sha256hmac(v, k);\r\n  var T = BN.fromBuffer(v);\r\n  var N = Point.getN();\r\n\r\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\r\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\r\n    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);\r\n    v = Hash.sha256hmac(v, k);\r\n    v = Hash.sha256hmac(v, k);\r\n    T = BN.fromBuffer(v);\r\n  }\r\n\r\n  this.k = T;\r\n  return this;\r\n};\r\n\r\n// Information about public key recovery:\r\n// https://bitcointalk.org/index.php?topic=6430.0\r\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\r\nECDSA.prototype.toPublicKey = function() {\r\n  /* jshint maxstatements: 25 */\r\n  var i = this.sig.i;\r\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\r\n\r\n  var e = BN.fromBuffer(this.hashbuf);\r\n  var r = this.sig.r;\r\n  var s = this.sig.s;\r\n\r\n  // A set LSB signifies that the y-coordinate is odd\r\n  var isYOdd = i & 1;\r\n\r\n  // The more significant bit specifies whether we should use the\r\n  // first or second candidate key.\r\n  var isSecondKey = i >> 1;\r\n\r\n  var n = Point.getN();\r\n  var G = Point.getG();\r\n\r\n  // 1.1 Let x = r + jn\r\n  var x = isSecondKey ? r.add(n) : r;\r\n  var R = Point.fromX(isYOdd, x);\r\n\r\n  // 1.4 Check that nR is at infinity\r\n  var nR = R.mul(n);\r\n\r\n  if (!nR.isInfinity()) {\r\n    throw new Error('nR is not a valid curve point');\r\n  }\r\n\r\n  // Compute -e from e\r\n  var eNeg = e.neg().umod(n);\r\n\r\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\r\n  // Q = r^-1 (sR + -eG)\r\n  var rInv = r.invm(n);\r\n\r\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\r\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\r\n\r\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\r\n\r\n  return pubkey;\r\n};\r\n\r\nECDSA.prototype.sigError = function() {\r\n  /* jshint maxstatements: 25 */\r\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\r\n    return 'hashbuf must be a 32 byte buffer';\r\n  }\r\n\r\n  var r = this.sig.r;\r\n  var s = this.sig.s;\r\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\r\n    return 'r and s not in range';\r\n  }\r\n\r\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\r\n    endian: this.endian\r\n  } : undefined);\r\n  var n = Point.getN();\r\n  var sinv = s.invm(n);\r\n  var u1 = sinv.mul(e).umod(n);\r\n  var u2 = sinv.mul(r).umod(n);\r\n\r\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\r\n  if (p.isInfinity()) {\r\n    return 'p is infinity';\r\n  }\r\n\r\n  if (p.getX().umod(n).cmp(r) !== 0) {\r\n    return 'Invalid signature';\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nECDSA.toLowS = function(s) {\r\n  //enforce low s\r\n  //see BIP 62, \"low S values in signatures\"\r\n  if (s.gt(BN.fromBuffer(Buffer.from('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {\r\n    s = Point.getN().sub(s);\r\n  }\r\n  return s;\r\n};\r\n\r\nECDSA.prototype._findSignature = function(d, e) {\r\n  var N = Point.getN();\r\n  var G = Point.getG();\r\n  // try different values of k until r, s are valid\r\n  var badrs = 0;\r\n  var k, Q, r, s;\r\n  do {\r\n    if (!this.k || badrs > 0) {\r\n      this.deterministicK(badrs);\r\n    }\r\n    badrs++;\r\n    k = this.k;\r\n    Q = G.mul(k);\r\n    r = Q.x.umod(N);\r\n    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);\r\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\r\n\r\n  s = ECDSA.toLowS(s);\r\n  return {\r\n    s: s,\r\n    r: r\r\n  };\r\n\r\n};\r\n\r\nECDSA.prototype.sign = function() {\r\n  var hashbuf = this.hashbuf;\r\n  var privkey = this.privkey;\r\n  var d = privkey.bn;\r\n\r\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\r\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\r\n\r\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\r\n    endian: this.endian\r\n  } : undefined);\r\n\r\n  var obj = this._findSignature(d, e);\r\n  obj.compressed = this.pubkey.compressed;\r\n\r\n  this.sig = new Signature(obj);\r\n  return this;\r\n};\r\n\r\nECDSA.prototype.signRandomK = function() {\r\n  this.randomK();\r\n  return this.sign();\r\n};\r\n\r\nECDSA.prototype.toString = function() {\r\n  var obj = {};\r\n  if (this.hashbuf) {\r\n    obj.hashbuf = this.hashbuf.toString('hex');\r\n  }\r\n  if (this.privkey) {\r\n    obj.privkey = this.privkey.toString();\r\n  }\r\n  if (this.pubkey) {\r\n    obj.pubkey = this.pubkey.toString();\r\n  }\r\n  if (this.sig) {\r\n    obj.sig = this.sig.toString();\r\n  }\r\n  if (this.k) {\r\n    obj.k = this.k.toString();\r\n  }\r\n  return JSON.stringify(obj);\r\n};\r\n\r\nECDSA.prototype.verify = function() {\r\n  if (!this.sigError()) {\r\n    this.verified = true;\r\n  } else {\r\n    this.verified = false;\r\n  }\r\n  return this;\r\n};\r\n\r\nECDSA.sign = function(hashbuf, privkey, endian) {\r\n  return ECDSA().set({\r\n    hashbuf: hashbuf,\r\n    endian: endian,\r\n    privkey: privkey\r\n  }).sign().sig;\r\n};\r\n\r\nECDSA.verify = function(hashbuf, sig, pubkey, endian) {\r\n  return ECDSA().set({\r\n    hashbuf: hashbuf,\r\n    endian: endian,\r\n    sig: sig,\r\n    pubkey: pubkey\r\n  }).verify().verified;\r\n};\r\n\r\nmodule.exports = ECDSA;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by9lY2RzYS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTTtBQUN2QixZQUFZLG1CQUFPLENBQUMsbURBQVM7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQWE7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMscURBQWM7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHFEQUFVO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxpREFBUTtBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyx5REFBZ0I7QUFDekMsUUFBUSxtQkFBTyxDQUFDLDREQUFRO0FBQ3hCLFFBQVEsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQkFBc0IsTUFBTSxZQUFZLE1BQU07QUFDOUM7QUFDQSxzQkFBc0IsTUFBTSxZQUFZLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBDQUEwQztBQUM1RCx3QkFBd0IsTUFBTSxZQUFZLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by9lY2RzYS5qcz9lOWFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBCTiA9IHJlcXVpcmUoJy4vYm4nKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcclxudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4uL3B1YmxpY2tleScpO1xyXG52YXIgUmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcclxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcclxudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG5cclxudmFyIEVDRFNBID0gZnVuY3Rpb24gRUNEU0Eob2JqKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDRFNBKSkge1xyXG4gICAgcmV0dXJuIG5ldyBFQ0RTQShvYmopO1xyXG4gIH1cclxuICBpZiAob2JqKSB7XHJcbiAgICB0aGlzLnNldChvYmopO1xyXG4gIH1cclxufTtcclxuXHJcbi8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA5ICovXHJcbkVDRFNBLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvYmopIHtcclxuICB0aGlzLmhhc2hidWYgPSBvYmouaGFzaGJ1ZiB8fCB0aGlzLmhhc2hidWY7XHJcbiAgdGhpcy5lbmRpYW4gPSBvYmouZW5kaWFuIHx8IHRoaXMuZW5kaWFuOyAvL3RoZSBlbmRpYW5uZXNzIG9mIGhhc2hidWZcclxuICB0aGlzLnByaXZrZXkgPSBvYmoucHJpdmtleSB8fCB0aGlzLnByaXZrZXk7XHJcbiAgdGhpcy5wdWJrZXkgPSBvYmoucHVia2V5IHx8ICh0aGlzLnByaXZrZXkgPyB0aGlzLnByaXZrZXkucHVibGljS2V5IDogdGhpcy5wdWJrZXkpO1xyXG4gIHRoaXMuc2lnID0gb2JqLnNpZyB8fCB0aGlzLnNpZztcclxuICB0aGlzLmsgPSBvYmouayB8fCB0aGlzLms7XHJcbiAgdGhpcy52ZXJpZmllZCA9IG9iai52ZXJpZmllZCB8fCB0aGlzLnZlcmlmaWVkO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRUNEU0EucHJvdG90eXBlLnByaXZrZXkycHVia2V5ID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5wdWJrZXkgPSB0aGlzLnByaXZrZXkudG9QdWJsaWNLZXkoKTtcclxufTtcclxuXHJcbkVDRFNBLnByb3RvdHlwZS5jYWxjaSA9IGZ1bmN0aW9uKCkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICB0aGlzLnNpZy5pID0gaTtcclxuICAgIHZhciBRcHJpbWU7XHJcbiAgICB0cnkge1xyXG4gICAgICBRcHJpbWUgPSB0aGlzLnRvUHVibGljS2V5KCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChRcHJpbWUucG9pbnQuZXEodGhpcy5wdWJrZXkucG9pbnQpKSB7XHJcbiAgICAgIHRoaXMuc2lnLmNvbXByZXNzZWQgPSB0aGlzLnB1YmtleS5jb21wcmVzc2VkO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRoaXMuc2lnLmkgPSB1bmRlZmluZWQ7XHJcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcclxufTtcclxuXHJcbkVDRFNBLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICB2YXIgb2JqID0gSlNPTi5wYXJzZShzdHIpO1xyXG4gIHJldHVybiBuZXcgRUNEU0Eob2JqKTtcclxufTtcclxuXHJcbkVDRFNBLnByb3RvdHlwZS5yYW5kb21LID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIE4gPSBQb2ludC5nZXROKCk7XHJcbiAgdmFyIGs7XHJcbiAgZG8ge1xyXG4gICAgayA9IEJOLmZyb21CdWZmZXIoUmFuZG9tLmdldFJhbmRvbUJ1ZmZlcigzMikpO1xyXG4gIH0gd2hpbGUgKCEoay5sdChOKSAmJiBrLmd0KEJOLlplcm8pKSk7XHJcbiAgdGhpcy5rID0gaztcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjk3OSNzZWN0aW9uLTMuMlxyXG5FQ0RTQS5wcm90b3R5cGUuZGV0ZXJtaW5pc3RpY0sgPSBmdW5jdGlvbihiYWRycykge1xyXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyNSAqL1xyXG4gIC8vIGlmIHIgb3IgcyB3ZXJlIGludmFsaWQgd2hlbiB0aGlzIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHNpZ25pbmcsXHJcbiAgLy8gd2UgZG8gbm90IHdhbnQgdG8gYWN0dWFsbHkgY29tcHV0ZSByLCBzIGhlcmUgZm9yIGVmZmljaWVuY3ksIHNvLFxyXG4gIC8vIHdlIGNhbiBpbmNyZW1lbnQgYmFkcnMuIGV4cGxhaW5lZCBhdCBlbmQgb2YgUkZDIDY5Nzkgc2VjdGlvbiAzLjJcclxuICBpZiAoXy5pc1VuZGVmaW5lZChiYWRycykpIHtcclxuICAgIGJhZHJzID0gMDtcclxuICB9XHJcbiAgdmFyIHYgPSBCdWZmZXIuYWxsb2MoMzIpO1xyXG4gIHYuZmlsbCgweDAxKTtcclxuICB2YXIgayA9IEJ1ZmZlci5hbGxvYygzMik7XHJcbiAgay5maWxsKDB4MDApO1xyXG4gIHZhciB4ID0gdGhpcy5wcml2a2V5LmJuLnRvQnVmZmVyKHtcclxuICAgIHNpemU6IDMyXHJcbiAgfSk7XHJcbiAgdmFyIGhhc2hidWYgPSB0aGlzLmVuZGlhbiA9PT0gJ2xpdHRsZScgPyBCdWZmZXJVdGlsLnJldmVyc2UodGhpcy5oYXNoYnVmKSA6IHRoaXMuaGFzaGJ1ZlxyXG4gIGsgPSBIYXNoLnNoYTI1NmhtYWMoQnVmZmVyLmNvbmNhdChbdiwgQnVmZmVyLmZyb20oWzB4MDBdKSwgeCwgaGFzaGJ1Zl0pLCBrKTtcclxuICB2ID0gSGFzaC5zaGEyNTZobWFjKHYsIGspO1xyXG4gIGsgPSBIYXNoLnNoYTI1NmhtYWMoQnVmZmVyLmNvbmNhdChbdiwgQnVmZmVyLmZyb20oWzB4MDFdKSwgeCwgaGFzaGJ1Zl0pLCBrKTtcclxuICB2ID0gSGFzaC5zaGEyNTZobWFjKHYsIGspO1xyXG4gIHYgPSBIYXNoLnNoYTI1NmhtYWModiwgayk7XHJcbiAgdmFyIFQgPSBCTi5mcm9tQnVmZmVyKHYpO1xyXG4gIHZhciBOID0gUG9pbnQuZ2V0TigpO1xyXG5cclxuICAvLyBhbHNvIGV4cGxhaW5lZCBpbiAzLjIsIHdlIG11c3QgZW5zdXJlIFQgaXMgaW4gdGhlIHByb3BlciByYW5nZSAoMCwgTilcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhZHJzIHx8ICEoVC5sdChOKSAmJiBULmd0KEJOLlplcm8pKTsgaSsrKSB7XHJcbiAgICBrID0gSGFzaC5zaGEyNTZobWFjKEJ1ZmZlci5jb25jYXQoW3YsIEJ1ZmZlci5mcm9tKFsweDAwXSldKSwgayk7XHJcbiAgICB2ID0gSGFzaC5zaGEyNTZobWFjKHYsIGspO1xyXG4gICAgdiA9IEhhc2guc2hhMjU2aG1hYyh2LCBrKTtcclxuICAgIFQgPSBCTi5mcm9tQnVmZmVyKHYpO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5rID0gVDtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEluZm9ybWF0aW9uIGFib3V0IHB1YmxpYyBrZXkgcmVjb3Zlcnk6XHJcbi8vIGh0dHBzOi8vYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz02NDMwLjBcclxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTY2NTQ5MS9ob3ctZG8taS1nZXQtYW4tZWNkc2EtcHVibGljLWtleS1mcm9tLWp1c3QtYS1iaXRjb2luLXNpZ25hdHVyZS1zZWMxLTQtMS02LWtcclxuRUNEU0EucHJvdG90eXBlLnRvUHVibGljS2V5ID0gZnVuY3Rpb24oKSB7XHJcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDI1ICovXHJcbiAgdmFyIGkgPSB0aGlzLnNpZy5pO1xyXG4gICQuY2hlY2tBcmd1bWVudChpID09PSAwIHx8IGkgPT09IDEgfHwgaSA9PT0gMiB8fCBpID09PSAzLCBuZXcgRXJyb3IoJ2kgbXVzdCBiZSBlcXVhbCB0byAwLCAxLCAyLCBvciAzJykpO1xyXG5cclxuICB2YXIgZSA9IEJOLmZyb21CdWZmZXIodGhpcy5oYXNoYnVmKTtcclxuICB2YXIgciA9IHRoaXMuc2lnLnI7XHJcbiAgdmFyIHMgPSB0aGlzLnNpZy5zO1xyXG5cclxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcclxuICB2YXIgaXNZT2RkID0gaSAmIDE7XHJcblxyXG4gIC8vIFRoZSBtb3JlIHNpZ25pZmljYW50IGJpdCBzcGVjaWZpZXMgd2hldGhlciB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gIC8vIGZpcnN0IG9yIHNlY29uZCBjYW5kaWRhdGUga2V5LlxyXG4gIHZhciBpc1NlY29uZEtleSA9IGkgPj4gMTtcclxuXHJcbiAgdmFyIG4gPSBQb2ludC5nZXROKCk7XHJcbiAgdmFyIEcgPSBQb2ludC5nZXRHKCk7XHJcblxyXG4gIC8vIDEuMSBMZXQgeCA9IHIgKyBqblxyXG4gIHZhciB4ID0gaXNTZWNvbmRLZXkgPyByLmFkZChuKSA6IHI7XHJcbiAgdmFyIFIgPSBQb2ludC5mcm9tWChpc1lPZGQsIHgpO1xyXG5cclxuICAvLyAxLjQgQ2hlY2sgdGhhdCBuUiBpcyBhdCBpbmZpbml0eVxyXG4gIHZhciBuUiA9IFIubXVsKG4pO1xyXG5cclxuICBpZiAoIW5SLmlzSW5maW5pdHkoKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCduUiBpcyBub3QgYSB2YWxpZCBjdXJ2ZSBwb2ludCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcHV0ZSAtZSBmcm9tIGVcclxuICB2YXIgZU5lZyA9IGUubmVnKCkudW1vZChuKTtcclxuXHJcbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSBlRylcclxuICAvLyBRID0gcl4tMSAoc1IgKyAtZUcpXHJcbiAgdmFyIHJJbnYgPSByLmludm0obik7XHJcblxyXG4gIC8vdmFyIFEgPSBSLm11bHRpcGx5VHdvKHMsIEcsIGVOZWcpLm11bChySW52KTtcclxuICB2YXIgUSA9IFIubXVsKHMpLmFkZChHLm11bChlTmVnKSkubXVsKHJJbnYpO1xyXG5cclxuICB2YXIgcHVia2V5ID0gUHVibGljS2V5LmZyb21Qb2ludChRLCB0aGlzLnNpZy5jb21wcmVzc2VkKTtcclxuXHJcbiAgcmV0dXJuIHB1YmtleTtcclxufTtcclxuXHJcbkVDRFNBLnByb3RvdHlwZS5zaWdFcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyNSAqL1xyXG4gIGlmICghQnVmZmVyVXRpbC5pc0J1ZmZlcih0aGlzLmhhc2hidWYpIHx8IHRoaXMuaGFzaGJ1Zi5sZW5ndGggIT09IDMyKSB7XHJcbiAgICByZXR1cm4gJ2hhc2hidWYgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJztcclxuICB9XHJcblxyXG4gIHZhciByID0gdGhpcy5zaWcucjtcclxuICB2YXIgcyA9IHRoaXMuc2lnLnM7XHJcbiAgaWYgKCEoci5ndChCTi5aZXJvKSAmJiByLmx0KFBvaW50LmdldE4oKSkpIHx8ICEocy5ndChCTi5aZXJvKSAmJiBzLmx0KFBvaW50LmdldE4oKSkpKSB7XHJcbiAgICByZXR1cm4gJ3IgYW5kIHMgbm90IGluIHJhbmdlJztcclxuICB9XHJcblxyXG4gIHZhciBlID0gQk4uZnJvbUJ1ZmZlcih0aGlzLmhhc2hidWYsIHRoaXMuZW5kaWFuID8ge1xyXG4gICAgZW5kaWFuOiB0aGlzLmVuZGlhblxyXG4gIH0gOiB1bmRlZmluZWQpO1xyXG4gIHZhciBuID0gUG9pbnQuZ2V0TigpO1xyXG4gIHZhciBzaW52ID0gcy5pbnZtKG4pO1xyXG4gIHZhciB1MSA9IHNpbnYubXVsKGUpLnVtb2Qobik7XHJcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZChuKTtcclxuXHJcbiAgdmFyIHAgPSBQb2ludC5nZXRHKCkubXVsQWRkKHUxLCB0aGlzLnB1YmtleS5wb2ludCwgdTIpO1xyXG4gIGlmIChwLmlzSW5maW5pdHkoKSkge1xyXG4gICAgcmV0dXJuICdwIGlzIGluZmluaXR5JztcclxuICB9XHJcblxyXG4gIGlmIChwLmdldFgoKS51bW9kKG4pLmNtcChyKSAhPT0gMCkge1xyXG4gICAgcmV0dXJuICdJbnZhbGlkIHNpZ25hdHVyZSc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5FQ0RTQS50b0xvd1MgPSBmdW5jdGlvbihzKSB7XHJcbiAgLy9lbmZvcmNlIGxvdyBzXHJcbiAgLy9zZWUgQklQIDYyLCBcImxvdyBTIHZhbHVlcyBpbiBzaWduYXR1cmVzXCJcclxuICBpZiAocy5ndChCTi5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKCc3RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjVENTc2RTczNTdBNDUwMURERkU5MkY0NjY4MUIyMEEwJywgJ2hleCcpKSkpIHtcclxuICAgIHMgPSBQb2ludC5nZXROKCkuc3ViKHMpO1xyXG4gIH1cclxuICByZXR1cm4gcztcclxufTtcclxuXHJcbkVDRFNBLnByb3RvdHlwZS5fZmluZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKGQsIGUpIHtcclxuICB2YXIgTiA9IFBvaW50LmdldE4oKTtcclxuICB2YXIgRyA9IFBvaW50LmdldEcoKTtcclxuICAvLyB0cnkgZGlmZmVyZW50IHZhbHVlcyBvZiBrIHVudGlsIHIsIHMgYXJlIHZhbGlkXHJcbiAgdmFyIGJhZHJzID0gMDtcclxuICB2YXIgaywgUSwgciwgcztcclxuICBkbyB7XHJcbiAgICBpZiAoIXRoaXMuayB8fCBiYWRycyA+IDApIHtcclxuICAgICAgdGhpcy5kZXRlcm1pbmlzdGljSyhiYWRycyk7XHJcbiAgICB9XHJcbiAgICBiYWRycysrO1xyXG4gICAgayA9IHRoaXMuaztcclxuICAgIFEgPSBHLm11bChrKTtcclxuICAgIHIgPSBRLngudW1vZChOKTtcclxuICAgIHMgPSBrLmludm0oTikubXVsKGUuYWRkKGQubXVsKHIpKSkudW1vZChOKTtcclxuICB9IHdoaWxlIChyLmNtcChCTi5aZXJvKSA8PSAwIHx8IHMuY21wKEJOLlplcm8pIDw9IDApO1xyXG5cclxuICBzID0gRUNEU0EudG9Mb3dTKHMpO1xyXG4gIHJldHVybiB7XHJcbiAgICBzOiBzLFxyXG4gICAgcjogclxyXG4gIH07XHJcblxyXG59O1xyXG5cclxuRUNEU0EucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbigpIHtcclxuICB2YXIgaGFzaGJ1ZiA9IHRoaXMuaGFzaGJ1ZjtcclxuICB2YXIgcHJpdmtleSA9IHRoaXMucHJpdmtleTtcclxuICB2YXIgZCA9IHByaXZrZXkuYm47XHJcblxyXG4gICQuY2hlY2tTdGF0ZShoYXNoYnVmICYmIHByaXZrZXkgJiYgZCwgbmV3IEVycm9yKCdpbnZhbGlkIHBhcmFtZXRlcnMnKSk7XHJcbiAgJC5jaGVja1N0YXRlKEJ1ZmZlclV0aWwuaXNCdWZmZXIoaGFzaGJ1ZikgJiYgaGFzaGJ1Zi5sZW5ndGggPT09IDMyLCBuZXcgRXJyb3IoJ2hhc2hidWYgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJykpO1xyXG5cclxuICB2YXIgZSA9IEJOLmZyb21CdWZmZXIoaGFzaGJ1ZiwgdGhpcy5lbmRpYW4gPyB7XHJcbiAgICBlbmRpYW46IHRoaXMuZW5kaWFuXHJcbiAgfSA6IHVuZGVmaW5lZCk7XHJcblxyXG4gIHZhciBvYmogPSB0aGlzLl9maW5kU2lnbmF0dXJlKGQsIGUpO1xyXG4gIG9iai5jb21wcmVzc2VkID0gdGhpcy5wdWJrZXkuY29tcHJlc3NlZDtcclxuXHJcbiAgdGhpcy5zaWcgPSBuZXcgU2lnbmF0dXJlKG9iaik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5FQ0RTQS5wcm90b3R5cGUuc2lnblJhbmRvbUsgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLnJhbmRvbUsoKTtcclxuICByZXR1cm4gdGhpcy5zaWduKCk7XHJcbn07XHJcblxyXG5FQ0RTQS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgb2JqID0ge307XHJcbiAgaWYgKHRoaXMuaGFzaGJ1Zikge1xyXG4gICAgb2JqLmhhc2hidWYgPSB0aGlzLmhhc2hidWYudG9TdHJpbmcoJ2hleCcpO1xyXG4gIH1cclxuICBpZiAodGhpcy5wcml2a2V5KSB7XHJcbiAgICBvYmoucHJpdmtleSA9IHRoaXMucHJpdmtleS50b1N0cmluZygpO1xyXG4gIH1cclxuICBpZiAodGhpcy5wdWJrZXkpIHtcclxuICAgIG9iai5wdWJrZXkgPSB0aGlzLnB1YmtleS50b1N0cmluZygpO1xyXG4gIH1cclxuICBpZiAodGhpcy5zaWcpIHtcclxuICAgIG9iai5zaWcgPSB0aGlzLnNpZy50b1N0cmluZygpO1xyXG4gIH1cclxuICBpZiAodGhpcy5rKSB7XHJcbiAgICBvYmouayA9IHRoaXMuay50b1N0cmluZygpO1xyXG4gIH1cclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcclxufTtcclxuXHJcbkVDRFNBLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbigpIHtcclxuICBpZiAoIXRoaXMuc2lnRXJyb3IoKSkge1xyXG4gICAgdGhpcy52ZXJpZmllZCA9IHRydWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMudmVyaWZpZWQgPSBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5FQ0RTQS5zaWduID0gZnVuY3Rpb24oaGFzaGJ1ZiwgcHJpdmtleSwgZW5kaWFuKSB7XHJcbiAgcmV0dXJuIEVDRFNBKCkuc2V0KHtcclxuICAgIGhhc2hidWY6IGhhc2hidWYsXHJcbiAgICBlbmRpYW46IGVuZGlhbixcclxuICAgIHByaXZrZXk6IHByaXZrZXlcclxuICB9KS5zaWduKCkuc2lnO1xyXG59O1xyXG5cclxuRUNEU0EudmVyaWZ5ID0gZnVuY3Rpb24oaGFzaGJ1Ziwgc2lnLCBwdWJrZXksIGVuZGlhbikge1xyXG4gIHJldHVybiBFQ0RTQSgpLnNldCh7XHJcbiAgICBoYXNoYnVmOiBoYXNoYnVmLFxyXG4gICAgZW5kaWFuOiBlbmRpYW4sXHJcbiAgICBzaWc6IHNpZyxcclxuICAgIHB1YmtleTogcHVia2V5XHJcbiAgfSkudmVyaWZ5KCkudmVyaWZpZWQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVDRFNBO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/crypto/ecdsa.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/crypto/hash.js":
/*!*****************************************!*\
  !*** ../bitcore-lib/lib/crypto/hash.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nvar Hash = module.exports;\r\n\r\nHash.sha1 = function(buf) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf));\r\n  return crypto.createHash('sha1').update(buf).digest();\r\n};\r\n\r\nHash.sha1.blocksize = 512;\r\n\r\nHash.sha256 = function(buf) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf));\r\n  return crypto.createHash('sha256').update(buf).digest();\r\n};\r\n\r\nHash.sha256.blocksize = 512;\r\n\r\nHash.sha256sha256 = function(buf) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf));\r\n  return Hash.sha256(Hash.sha256(buf));\r\n};\r\n\r\nHash.ripemd160 = function(buf) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf));\r\n  return crypto.createHash('ripemd160').update(buf).digest();\r\n};\r\n\r\nHash.sha256ripemd160 = function(buf) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf));\r\n  return Hash.ripemd160(Hash.sha256(buf));\r\n};\r\n\r\nHash.sha512 = function(buf) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf));\r\n  return crypto.createHash('sha512').update(buf).digest();\r\n};\r\n\r\nHash.sha512.blocksize = 1024;\r\n\r\nHash.hmac = function(hashf, data, key) {\r\n  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\r\n  //http://tools.ietf.org/html/rfc4868#section-2\r\n  $.checkArgument(BufferUtil.isBuffer(data));\r\n  $.checkArgument(BufferUtil.isBuffer(key));\r\n  $.checkArgument(hashf.blocksize);\r\n\r\n  var blocksize = hashf.blocksize / 8;\r\n\r\n  if (key.length > blocksize) {\r\n    key = hashf(key);\r\n  } else if (key < blocksize) {\r\n    var fill = Buffer.alloc(blocksize);\r\n    fill.fill(0);\r\n    key.copy(fill);\r\n    key = fill;\r\n  }\r\n\r\n  var o_key = Buffer.alloc(blocksize);\r\n  o_key.fill(0x5c);\r\n\r\n  var i_key = Buffer.alloc(blocksize);\r\n  i_key.fill(0x36);\r\n\r\n  var o_key_pad = Buffer.alloc(blocksize);\r\n  var i_key_pad = Buffer.alloc(blocksize);\r\n  for (var i = 0; i < blocksize; i++) {\r\n    o_key_pad[i] = o_key[i] ^ key[i];\r\n    i_key_pad[i] = i_key[i] ^ key[i];\r\n  }\r\n\r\n  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));\r\n};\r\n\r\nHash.sha256hmac = function(data, key) {\r\n  return Hash.hmac(Hash.sha256, data, key);\r\n};\r\n\r\nHash.sha512hmac = function(data, key) {\r\n  return Hash.hmac(Hash.sha512, data, key);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by9oYXNoLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHlEQUFnQjtBQUN6QyxRQUFRLG1CQUFPLENBQUMsdUVBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEIsa0JBQWtCLE1BQU07QUFDeEIsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU0sMEJBQTBCLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL2hhc2guanM/ZmY2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcclxudmFyICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxuXHJcbnZhciBIYXNoID0gbW9kdWxlLmV4cG9ydHM7XHJcblxyXG5IYXNoLnNoYTEgPSBmdW5jdGlvbihidWYpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpKTtcclxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnVmKS5kaWdlc3QoKTtcclxufTtcclxuXHJcbkhhc2guc2hhMS5ibG9ja3NpemUgPSA1MTI7XHJcblxyXG5IYXNoLnNoYTI1NiA9IGZ1bmN0aW9uKGJ1Zikge1xyXG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZikpO1xyXG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGJ1ZikuZGlnZXN0KCk7XHJcbn07XHJcblxyXG5IYXNoLnNoYTI1Ni5ibG9ja3NpemUgPSA1MTI7XHJcblxyXG5IYXNoLnNoYTI1NnNoYTI1NiA9IGZ1bmN0aW9uKGJ1Zikge1xyXG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZikpO1xyXG4gIHJldHVybiBIYXNoLnNoYTI1NihIYXNoLnNoYTI1NihidWYpKTtcclxufTtcclxuXHJcbkhhc2gucmlwZW1kMTYwID0gZnVuY3Rpb24oYnVmKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XHJcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdyaXBlbWQxNjAnKS51cGRhdGUoYnVmKS5kaWdlc3QoKTtcclxufTtcclxuXHJcbkhhc2guc2hhMjU2cmlwZW1kMTYwID0gZnVuY3Rpb24oYnVmKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XHJcbiAgcmV0dXJuIEhhc2gucmlwZW1kMTYwKEhhc2guc2hhMjU2KGJ1ZikpO1xyXG59O1xyXG5cclxuSGFzaC5zaGE1MTIgPSBmdW5jdGlvbihidWYpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpKTtcclxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTUxMicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xyXG59O1xyXG5cclxuSGFzaC5zaGE1MTIuYmxvY2tzaXplID0gMTAyNDtcclxuXHJcbkhhc2guaG1hYyA9IGZ1bmN0aW9uKGhhc2hmLCBkYXRhLCBrZXkpIHtcclxuICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFzaC1iYXNlZF9tZXNzYWdlX2F1dGhlbnRpY2F0aW9uX2NvZGVcclxuICAvL2h0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ4Njgjc2VjdGlvbi0yXHJcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoZGF0YSkpO1xyXG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGtleSkpO1xyXG4gICQuY2hlY2tBcmd1bWVudChoYXNoZi5ibG9ja3NpemUpO1xyXG5cclxuICB2YXIgYmxvY2tzaXplID0gaGFzaGYuYmxvY2tzaXplIC8gODtcclxuXHJcbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcclxuICAgIGtleSA9IGhhc2hmKGtleSk7XHJcbiAgfSBlbHNlIGlmIChrZXkgPCBibG9ja3NpemUpIHtcclxuICAgIHZhciBmaWxsID0gQnVmZmVyLmFsbG9jKGJsb2Nrc2l6ZSk7XHJcbiAgICBmaWxsLmZpbGwoMCk7XHJcbiAgICBrZXkuY29weShmaWxsKTtcclxuICAgIGtleSA9IGZpbGw7XHJcbiAgfVxyXG5cclxuICB2YXIgb19rZXkgPSBCdWZmZXIuYWxsb2MoYmxvY2tzaXplKTtcclxuICBvX2tleS5maWxsKDB4NWMpO1xyXG5cclxuICB2YXIgaV9rZXkgPSBCdWZmZXIuYWxsb2MoYmxvY2tzaXplKTtcclxuICBpX2tleS5maWxsKDB4MzYpO1xyXG5cclxuICB2YXIgb19rZXlfcGFkID0gQnVmZmVyLmFsbG9jKGJsb2Nrc2l6ZSk7XHJcbiAgdmFyIGlfa2V5X3BhZCA9IEJ1ZmZlci5hbGxvYyhibG9ja3NpemUpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcclxuICAgIG9fa2V5X3BhZFtpXSA9IG9fa2V5W2ldIF4ga2V5W2ldO1xyXG4gICAgaV9rZXlfcGFkW2ldID0gaV9rZXlbaV0gXiBrZXlbaV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaGFzaGYoQnVmZmVyLmNvbmNhdChbb19rZXlfcGFkLCBoYXNoZihCdWZmZXIuY29uY2F0KFtpX2tleV9wYWQsIGRhdGFdKSldKSk7XHJcbn07XHJcblxyXG5IYXNoLnNoYTI1NmhtYWMgPSBmdW5jdGlvbihkYXRhLCBrZXkpIHtcclxuICByZXR1cm4gSGFzaC5obWFjKEhhc2guc2hhMjU2LCBkYXRhLCBrZXkpO1xyXG59O1xyXG5cclxuSGFzaC5zaGE1MTJobWFjID0gZnVuY3Rpb24oZGF0YSwga2V5KSB7XHJcbiAgcmV0dXJuIEhhc2guaG1hYyhIYXNoLnNoYTUxMiwgZGF0YSwga2V5KTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/crypto/hash.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/crypto/point.js":
/*!******************************************!*\
  !*** ../bitcore-lib/lib/crypto/point.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar BN = __webpack_require__(/*! ./bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\n\r\nvar EC = (__webpack_require__(/*! elliptic */ \"../bitcore-lib/node_modules/elliptic/lib/elliptic.js\").ec);\r\nvar ec = new EC('secp256k1');\r\nvar ecPoint = ec.curve.point.bind(ec.curve);\r\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\r\n\r\n/**\r\n *\r\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\r\n *\r\n * @param {BN|String} x - The X coordinate\r\n * @param {BN|String} y - The Y coordinate\r\n * @link https://github.com/indutny/elliptic\r\n * @augments elliptic.curve.point\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of Point\r\n * @constructor\r\n */\r\nvar Point = function Point(x, y, isRed) {\r\n  try {\r\n    var point = ecPoint(x, y, isRed);\r\n  } catch (e) {\r\n    throw new Error('Invalid Point');\r\n  }\r\n  point.validate();\r\n  return point;\r\n};\r\n\r\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\r\n\r\n/**\r\n *\r\n * Instantiate a valid secp256k1 Point from only the X coordinate\r\n *\r\n * @param {boolean} odd - If the Y coordinate is odd\r\n * @param {BN|String} x - The X coordinate\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of Point\r\n */\r\nPoint.fromX = function fromX(odd, x){\r\n  try {\r\n    var point = ecPointFromX(x, odd);\r\n  } catch (e) {\r\n    throw new Error('Invalid X');\r\n  }\r\n  point.validate();\r\n  return point;\r\n};\r\n\r\n/**\r\n *\r\n * Will return a secp256k1 ECDSA base point.\r\n *\r\n * @link https://en.bitcoin.it/wiki/Secp256k1\r\n * @returns {Point} An instance of the base point.\r\n */\r\nPoint.getG = function getG() {\r\n  return ec.curve.g;\r\n};\r\n\r\n/**\r\n *\r\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\r\n * (A.K.A curve order)\r\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\r\n * @returns {BN} A BN instance of the number of points on the curve\r\n */\r\nPoint.getN = function getN() {\r\n  return new BN(ec.curve.n.toArray());\r\n};\r\n\r\n/**\r\n * Secp256k1 field size\r\n * @returns {BN} A BN instance of the field size\r\n */\r\nPoint.getP = function() {\r\n  return ec.curve.p.clone();\r\n};\r\n\r\nPoint.prototype._getX = Point.prototype.getX;\r\n\r\n/**\r\n *\r\n * Will return the X coordinate of the Point\r\n *\r\n * @returns {BN} A BN instance of the X coordinate\r\n */\r\nPoint.prototype.getX = function getX() {\r\n  return new BN(this._getX().toArray());\r\n};\r\n\r\nPoint.prototype._getY = Point.prototype.getY;\r\n\r\n/**\r\n *\r\n * Will return the Y coordinate of the Point\r\n *\r\n * @returns {BN} A BN instance of the Y coordinate\r\n */\r\nPoint.prototype.getY = function getY() {\r\n  return new BN(this._getY().toArray());\r\n};\r\n\r\n/**\r\n *\r\n * Will determine if the point is valid\r\n *\r\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\r\n * @param {Point} An instance of Point\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of the same Point\r\n */\r\nPoint.prototype.validate = function validate() {\r\n\r\n  if (this.isInfinity()){\r\n    throw new Error('Point cannot be equal to Infinity');\r\n  }\r\n\r\n  var p2;\r\n  try {\r\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\r\n  } catch (e) {\r\n    throw new Error('Point does not lie on the curve');\r\n  }\r\n\r\n  if (p2.y.cmp(this.y) !== 0) {\r\n    throw new Error('Invalid y value for curve.');\r\n  }\r\n\r\n\r\n  //todo: needs test case\r\n  if (!(this.mul(Point.getN()).isInfinity())) {\r\n    throw new Error('Point times N must be infinity');\r\n  }\r\n\r\n  return this;\r\n\r\n};\r\n\r\nPoint.pointToCompressed = function pointToCompressed(point) {\r\n  var xbuf = point.getX().toBuffer({size: 32});\r\n  var ybuf = point.getY().toBuffer({size: 32});\r\n\r\n  var prefix;\r\n  var odd = ybuf[ybuf.length - 1] % 2;\r\n  if (odd) {\r\n    prefix = Buffer.from([0x03]);\r\n  } else {\r\n    prefix = Buffer.from([0x02]);\r\n  }\r\n  return BufferUtil.concat([prefix, xbuf]);\r\n};\r\n\r\n\r\nPoint.prototype.liftX = function() {\r\n  const fieldSize = Point.getP();\r\n  const zero = new BN(0);\r\n  const one = new BN(1);\r\n  const two = new BN(2);\r\n  const three = new BN(3);\r\n  const four = new BN(4);\r\n  const seven = new BN(7);\r\n  const red = BN.red('k256');\r\n\r\n  const c = this.x.pow(three).add(seven).mod(fieldSize);\r\n  const y = c.toRed(red).redPow(fieldSize.add(one).div(four)).mod(fieldSize);\r\n  \r\n  if (!c.eq(y.pow(two).mod(fieldSize))) {\r\n    throw new Error('liftX failed');\r\n  }\r\n  \r\n  const pointX = this.x.red ? this.x.fromRed() : this.x;\r\n  const pointY = y.mod(two).eq(zero) ? y.fromRed() : fieldSize.sub(y)\r\n  return new Point(pointX, pointY, true);\r\n};\r\n\r\nmodule.exports = Point;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by9wb2ludC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTTtBQUN2QixpQkFBaUIsbUJBQU8sQ0FBQyx5REFBZ0I7QUFDekM7QUFDQSxTQUFTLGdHQUFzQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFdBQVc7QUFDdEIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLElBQUk7QUFDSixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vcG9pbnQuanM/NzFjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQk4gPSByZXF1aXJlKCcuL2JuJyk7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcclxuXHJcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWM7XHJcbnZhciBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJyk7XHJcbnZhciBlY1BvaW50ID0gZWMuY3VydmUucG9pbnQuYmluZChlYy5jdXJ2ZSk7XHJcbnZhciBlY1BvaW50RnJvbVggPSBlYy5jdXJ2ZS5wb2ludEZyb21YLmJpbmQoZWMuY3VydmUpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEluc3RhbnRpYXRlIGEgdmFsaWQgc2VjcDI1NmsxIFBvaW50IGZyb20gdGhlIFggYW5kIFkgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Qk58U3RyaW5nfSB4IC0gVGhlIFggY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0ge0JOfFN0cmluZ30geSAtIFRoZSBZIGNvb3JkaW5hdGVcclxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWNcclxuICogQGF1Z21lbnRzIGVsbGlwdGljLmN1cnZlLnBvaW50XHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBBIHZhbGlkYXRpb24gZXJyb3IgaWYgZXhpc3RzXHJcbiAqIEByZXR1cm5zIHtQb2ludH0gQW4gaW5zdGFuY2Ugb2YgUG9pbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgUG9pbnQgPSBmdW5jdGlvbiBQb2ludCh4LCB5LCBpc1JlZCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgcG9pbnQgPSBlY1BvaW50KHgsIHksIGlzUmVkKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUG9pbnQnKTtcclxuICB9XHJcbiAgcG9pbnQudmFsaWRhdGUoKTtcclxuICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZWMuY3VydmUucG9pbnQoKSk7XHJcblxyXG4vKipcclxuICpcclxuICogSW5zdGFudGlhdGUgYSB2YWxpZCBzZWNwMjU2azEgUG9pbnQgZnJvbSBvbmx5IHRoZSBYIGNvb3JkaW5hdGVcclxuICpcclxuICogQHBhcmFtIHtib29sZWFufSBvZGQgLSBJZiB0aGUgWSBjb29yZGluYXRlIGlzIG9kZFxyXG4gKiBAcGFyYW0ge0JOfFN0cmluZ30geCAtIFRoZSBYIGNvb3JkaW5hdGVcclxuICogQHRocm93cyB7RXJyb3J9IEEgdmFsaWRhdGlvbiBlcnJvciBpZiBleGlzdHNcclxuICogQHJldHVybnMge1BvaW50fSBBbiBpbnN0YW5jZSBvZiBQb2ludFxyXG4gKi9cclxuUG9pbnQuZnJvbVggPSBmdW5jdGlvbiBmcm9tWChvZGQsIHgpe1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgcG9pbnQgPSBlY1BvaW50RnJvbVgoeCwgb2RkKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgWCcpO1xyXG4gIH1cclxuICBwb2ludC52YWxpZGF0ZSgpO1xyXG4gIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBXaWxsIHJldHVybiBhIHNlY3AyNTZrMSBFQ0RTQSBiYXNlIHBvaW50LlxyXG4gKlxyXG4gKiBAbGluayBodHRwczovL2VuLmJpdGNvaW4uaXQvd2lraS9TZWNwMjU2azFcclxuICogQHJldHVybnMge1BvaW50fSBBbiBpbnN0YW5jZSBvZiB0aGUgYmFzZSBwb2ludC5cclxuICovXHJcblBvaW50LmdldEcgPSBmdW5jdGlvbiBnZXRHKCkge1xyXG4gIHJldHVybiBlYy5jdXJ2ZS5nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFdpbGwgcmV0dXJuIHRoZSBtYXggb2YgcmFuZ2Ugb2YgdmFsaWQgcHJpdmF0ZSBrZXlzIGFzIGdvdmVybmVkIGJ5IHRoZSBzZWNwMjU2azEgRUNEU0Egc3RhbmRhcmQuXHJcbiAqIChBLksuQSBjdXJ2ZSBvcmRlcilcclxuICogQGxpbmsgaHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvUHJpdmF0ZV9rZXkjUmFuZ2Vfb2ZfdmFsaWRfRUNEU0FfcHJpdmF0ZV9rZXlzXHJcbiAqIEByZXR1cm5zIHtCTn0gQSBCTiBpbnN0YW5jZSBvZiB0aGUgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVcclxuICovXHJcblBvaW50LmdldE4gPSBmdW5jdGlvbiBnZXROKCkge1xyXG4gIHJldHVybiBuZXcgQk4oZWMuY3VydmUubi50b0FycmF5KCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNlY3AyNTZrMSBmaWVsZCBzaXplXHJcbiAqIEByZXR1cm5zIHtCTn0gQSBCTiBpbnN0YW5jZSBvZiB0aGUgZmllbGQgc2l6ZVxyXG4gKi9cclxuUG9pbnQuZ2V0UCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBlYy5jdXJ2ZS5wLmNsb25lKCk7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUuX2dldFggPSBQb2ludC5wcm90b3R5cGUuZ2V0WDtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBXaWxsIHJldHVybiB0aGUgWCBjb29yZGluYXRlIG9mIHRoZSBQb2ludFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Qk59IEEgQk4gaW5zdGFuY2Ugb2YgdGhlIFggY29vcmRpbmF0ZVxyXG4gKi9cclxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xyXG4gIHJldHVybiBuZXcgQk4odGhpcy5fZ2V0WCgpLnRvQXJyYXkoKSk7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUuX2dldFkgPSBQb2ludC5wcm90b3R5cGUuZ2V0WTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBXaWxsIHJldHVybiB0aGUgWSBjb29yZGluYXRlIG9mIHRoZSBQb2ludFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Qk59IEEgQk4gaW5zdGFuY2Ugb2YgdGhlIFkgY29vcmRpbmF0ZVxyXG4gKi9cclxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xyXG4gIHJldHVybiBuZXcgQk4odGhpcy5fZ2V0WSgpLnRvQXJyYXkoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogV2lsbCBkZXRlcm1pbmUgaWYgdGhlIHBvaW50IGlzIHZhbGlkXHJcbiAqXHJcbiAqIEBsaW5rIGh0dHBzOi8vd3d3LmlhY3Iub3JnL2FyY2hpdmUvcGtjMjAwMy8yNTY3MDIxMS8yNTY3MDIxMS5wZGZcclxuICogQHBhcmFtIHtQb2ludH0gQW4gaW5zdGFuY2Ugb2YgUG9pbnRcclxuICogQHRocm93cyB7RXJyb3J9IEEgdmFsaWRhdGlvbiBlcnJvciBpZiBleGlzdHNcclxuICogQHJldHVybnMge1BvaW50fSBBbiBpbnN0YW5jZSBvZiB0aGUgc2FtZSBQb2ludFxyXG4gKi9cclxuUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XHJcblxyXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSl7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGNhbm5vdCBiZSBlcXVhbCB0byBJbmZpbml0eScpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHAyO1xyXG4gIHRyeSB7XHJcbiAgICBwMiA9IGVjUG9pbnRGcm9tWCh0aGlzLmdldFgoKSwgdGhpcy5nZXRZKCkuaXNPZGQoKSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBkb2VzIG5vdCBsaWUgb24gdGhlIGN1cnZlJyk7XHJcbiAgfVxyXG5cclxuICBpZiAocDIueS5jbXAodGhpcy55KSAhPT0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHkgdmFsdWUgZm9yIGN1cnZlLicpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vdG9kbzogbmVlZHMgdGVzdCBjYXNlXHJcbiAgaWYgKCEodGhpcy5tdWwoUG9pbnQuZ2V0TigpKS5pc0luZmluaXR5KCkpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IHRpbWVzIE4gbXVzdCBiZSBpbmZpbml0eScpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuUG9pbnQucG9pbnRUb0NvbXByZXNzZWQgPSBmdW5jdGlvbiBwb2ludFRvQ29tcHJlc3NlZChwb2ludCkge1xyXG4gIHZhciB4YnVmID0gcG9pbnQuZ2V0WCgpLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xyXG4gIHZhciB5YnVmID0gcG9pbnQuZ2V0WSgpLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xyXG5cclxuICB2YXIgcHJlZml4O1xyXG4gIHZhciBvZGQgPSB5YnVmW3lidWYubGVuZ3RoIC0gMV0gJSAyO1xyXG4gIGlmIChvZGQpIHtcclxuICAgIHByZWZpeCA9IEJ1ZmZlci5mcm9tKFsweDAzXSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHByZWZpeCA9IEJ1ZmZlci5mcm9tKFsweDAyXSk7XHJcbiAgfVxyXG4gIHJldHVybiBCdWZmZXJVdGlsLmNvbmNhdChbcHJlZml4LCB4YnVmXSk7XHJcbn07XHJcblxyXG5cclxuUG9pbnQucHJvdG90eXBlLmxpZnRYID0gZnVuY3Rpb24oKSB7XHJcbiAgY29uc3QgZmllbGRTaXplID0gUG9pbnQuZ2V0UCgpO1xyXG4gIGNvbnN0IHplcm8gPSBuZXcgQk4oMCk7XHJcbiAgY29uc3Qgb25lID0gbmV3IEJOKDEpO1xyXG4gIGNvbnN0IHR3byA9IG5ldyBCTigyKTtcclxuICBjb25zdCB0aHJlZSA9IG5ldyBCTigzKTtcclxuICBjb25zdCBmb3VyID0gbmV3IEJOKDQpO1xyXG4gIGNvbnN0IHNldmVuID0gbmV3IEJOKDcpO1xyXG4gIGNvbnN0IHJlZCA9IEJOLnJlZCgnazI1NicpO1xyXG5cclxuICBjb25zdCBjID0gdGhpcy54LnBvdyh0aHJlZSkuYWRkKHNldmVuKS5tb2QoZmllbGRTaXplKTtcclxuICBjb25zdCB5ID0gYy50b1JlZChyZWQpLnJlZFBvdyhmaWVsZFNpemUuYWRkKG9uZSkuZGl2KGZvdXIpKS5tb2QoZmllbGRTaXplKTtcclxuICBcclxuICBpZiAoIWMuZXEoeS5wb3codHdvKS5tb2QoZmllbGRTaXplKSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignbGlmdFggZmFpbGVkJyk7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHBvaW50WCA9IHRoaXMueC5yZWQgPyB0aGlzLnguZnJvbVJlZCgpIDogdGhpcy54O1xyXG4gIGNvbnN0IHBvaW50WSA9IHkubW9kKHR3bykuZXEoemVybykgPyB5LmZyb21SZWQoKSA6IGZpZWxkU2l6ZS5zdWIoeSlcclxuICByZXR1cm4gbmV3IFBvaW50KHBvaW50WCwgcG9pbnRZLCB0cnVlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/crypto/point.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/crypto/random.js":
/*!*******************************************!*\
  !*** ../bitcore-lib/lib/crypto/random.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nfunction Random() {\r\n}\r\n\r\n/* secure random bytes that sometimes throws an error due to lack of entropy */\r\nRandom.getRandomBuffer = function(size) {\r\n  if (false)\r\n    {}\r\n  else\r\n    return Random.getRandomBufferNode(size);\r\n};\r\n\r\nRandom.getRandomBufferNode = function(size) {\r\n  var crypto = __webpack_require__(/*! crypto */ \"crypto\");\r\n  return crypto.randomBytes(size);\r\n};\r\n\r\nRandom.getRandomBufferBrowser = function(size) {\r\n  if (!window.crypto && !window.msCrypto)\r\n    throw new Error('window.crypto not available');\r\n\r\n  if (window.crypto && window.crypto.getRandomValues)\r\n    var crypto = window.crypto;\r\n  else if (window.msCrypto && window.msCrypto.getRandomValues) //internet explorer\r\n    var crypto = window.msCrypto;\r\n  else\r\n    throw new Error('window.crypto.getRandomValues not available');\r\n\r\n  var bbuf = new Uint8Array(size);\r\n  crypto.getRandomValues(bbuf);\r\n  var buf = Buffer.from(bbuf);\r\n\r\n  return buf;\r\n};\r\n\r\n/* insecure random bytes, but it never fails */\r\nRandom.getPseudoRandomBuffer = function(size) {\r\n  var b32 = 0x100000000;\r\n  var b = Buffer.alloc(size);\r\n  var r;\r\n\r\n  for (var i = 0; i <= size; i++) {\r\n    var j = Math.floor(i / 4);\r\n    var k = i - j * 4;\r\n    if (k === 0) {\r\n      r = Math.random() * b32;\r\n      b[i] = r & 0xff;\r\n    } else {\r\n      b[i] = (r = r >>> 8) & 0xff;\r\n    }\r\n  }\r\n\r\n  return b;\r\n};\r\n\r\nmodule.exports = Random;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by9yYW5kb20uanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFlO0FBQ3JCLElBQUksRUFBMkM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL3JhbmRvbS5qcz9hNzU2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIFJhbmRvbSgpIHtcclxufVxyXG5cclxuLyogc2VjdXJlIHJhbmRvbSBieXRlcyB0aGF0IHNvbWV0aW1lcyB0aHJvd3MgYW4gZXJyb3IgZHVlIHRvIGxhY2sgb2YgZW50cm9weSAqL1xyXG5SYW5kb20uZ2V0UmFuZG9tQnVmZmVyID0gZnVuY3Rpb24oc2l6ZSkge1xyXG4gIGlmIChwcm9jZXNzLmJyb3dzZXIpXHJcbiAgICByZXR1cm4gUmFuZG9tLmdldFJhbmRvbUJ1ZmZlckJyb3dzZXIoc2l6ZSk7XHJcbiAgZWxzZVxyXG4gICAgcmV0dXJuIFJhbmRvbS5nZXRSYW5kb21CdWZmZXJOb2RlKHNpemUpO1xyXG59O1xyXG5cclxuUmFuZG9tLmdldFJhbmRvbUJ1ZmZlck5vZGUgPSBmdW5jdGlvbihzaXplKSB7XHJcbiAgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG4gIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoc2l6ZSk7XHJcbn07XHJcblxyXG5SYW5kb20uZ2V0UmFuZG9tQnVmZmVyQnJvd3NlciA9IGZ1bmN0aW9uKHNpemUpIHtcclxuICBpZiAoIXdpbmRvdy5jcnlwdG8gJiYgIXdpbmRvdy5tc0NyeXB0bylcclxuICAgIHRocm93IG5ldyBFcnJvcignd2luZG93LmNyeXB0byBub3QgYXZhaWxhYmxlJyk7XHJcblxyXG4gIGlmICh3aW5kb3cuY3J5cHRvICYmIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKVxyXG4gICAgdmFyIGNyeXB0byA9IHdpbmRvdy5jcnlwdG87XHJcbiAgZWxzZSBpZiAod2luZG93Lm1zQ3J5cHRvICYmIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIC8vaW50ZXJuZXQgZXhwbG9yZXJcclxuICAgIHZhciBjcnlwdG8gPSB3aW5kb3cubXNDcnlwdG87XHJcbiAgZWxzZVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBub3QgYXZhaWxhYmxlJyk7XHJcblxyXG4gIHZhciBiYnVmID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XHJcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhiYnVmKTtcclxuICB2YXIgYnVmID0gQnVmZmVyLmZyb20oYmJ1Zik7XHJcblxyXG4gIHJldHVybiBidWY7XHJcbn07XHJcblxyXG4vKiBpbnNlY3VyZSByYW5kb20gYnl0ZXMsIGJ1dCBpdCBuZXZlciBmYWlscyAqL1xyXG5SYW5kb20uZ2V0UHNldWRvUmFuZG9tQnVmZmVyID0gZnVuY3Rpb24oc2l6ZSkge1xyXG4gIHZhciBiMzIgPSAweDEwMDAwMDAwMDtcclxuICB2YXIgYiA9IEJ1ZmZlci5hbGxvYyhzaXplKTtcclxuICB2YXIgcjtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2l6ZTsgaSsrKSB7XHJcbiAgICB2YXIgaiA9IE1hdGguZmxvb3IoaSAvIDQpO1xyXG4gICAgdmFyIGsgPSBpIC0gaiAqIDQ7XHJcbiAgICBpZiAoayA9PT0gMCkge1xyXG4gICAgICByID0gTWF0aC5yYW5kb20oKSAqIGIzMjtcclxuICAgICAgYltpXSA9IHIgJiAweGZmO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYltpXSA9IChyID0gciA+Pj4gOCkgJiAweGZmO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/crypto/random.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/crypto/schnorr.js":
/*!********************************************!*\
  !*** ../bitcore-lib/lib/crypto/schnorr.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\r\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nconst JS = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nconst BN = __webpack_require__(/*! ./bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nconst Point = __webpack_require__(/*! ./point */ \"../bitcore-lib/lib/crypto/point.js\");\r\nconst TaggedHash = __webpack_require__(/*! ./taggedhash */ \"../bitcore-lib/lib/crypto/taggedhash.js\");\r\n\r\nconst Schnorr = function Schnorr() {\r\n  if (!(this instanceof Schnorr)) {\r\n    return new Schnorr();\r\n  }\r\n  return this;\r\n};\r\n\r\nSchnorr.prototype.set = function() {};\r\n\r\n/**\r\n * Create a schnorr signature\r\n * @param {PrivateKey|Buffer|BN} privateKey\r\n * @param {String|Buffer} message Hex string or buffer\r\n * @param {String|Buffer} aux Hex string or buffer\r\n * @returns {Buffer}\r\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Default_Signing\r\n */\r\nSchnorr.sign = function(privateKey, message, aux) {\r\n  privateKey = Buffer.isBuffer(privateKey) ? privateKey : privateKey.toBuffer();\r\n  if (privateKey.length !== 32) {\r\n    throw new Error('Private key should be 32 bytes for schnorr signatures');\r\n  }\r\n\r\n  if (typeof message === 'string') {\r\n    $.checkArgument(JS.isHexaString(message), 'Schnorr message string is not hex');\r\n    message = Buffer.from(message, 'hex')\r\n  }\r\n  $.checkArgument($.isType(message, 'Buffer'), 'Schnorr message must be a hex string or buffer');\r\n\r\n  if (!aux) {\r\n    aux = crypto.randomBytes(32);\r\n  }\r\n  if (typeof aux === 'string') {\r\n    $.checkArgument(JS.isHexaString(aux), 'Schnorr aux string is not hex');\r\n    aux = Buffer.from(aux, 'hex')\r\n  }\r\n  $.checkArgument($.isType(aux, 'Buffer'), 'Schnorr aux must be a hex string or buffer');\r\n\r\n  const G = Point.getG();\r\n  const n = Point.getN();\r\n\r\n  const dPrime = new BN(privateKey);\r\n  if (dPrime.eqn(0) || dPrime.gte(n)) {\r\n    throw new Error('Invalid private key for schnorr signing');\r\n  }\r\n  const P = G.mul(dPrime);\r\n  const Pbuf = Buffer.from(P.encodeCompressed().slice(1)); // slice(1) removes the encoding prefix byte\r\n  const d = P.y.isEven() ? dPrime : n.sub(dPrime);\r\n  const t = d.xor(new BN(new TaggedHash('BIP0340/aux', aux).finalize()));\r\n  const rand = new TaggedHash('BIP0340/nonce', Buffer.concat([t.toBuffer(), Pbuf, message])).finalize();\r\n  const kPrime = new BN(rand).mod(n);\r\n  if (kPrime.eqn(0)) {\r\n    throw new Error('Error creating schnorr signature');\r\n  }\r\n  const R = G.mul(kPrime);\r\n  const Rbuf = Buffer.from(R.encodeCompressed().slice(1)); // slice(1) removes the encoding prefix byte\r\n  const k = R.y.isEven() ? kPrime : n.sub(kPrime);\r\n  const e = new BN(new TaggedHash('BIP0340/challenge', Buffer.concat([Rbuf, Pbuf, message])).finalize()).mod(n);\r\n  const sig = Buffer.concat([Rbuf, k.add(e.mul(d)).mod(n).toBuffer()]);\r\n\r\n  if (!Schnorr.verify(Pbuf, message, sig)) {\r\n    throw new Error('Error creating schnorr signature. Verification failed');\r\n  }\r\n  return sig;\r\n};\r\n\r\n\r\n/**\r\n * Verify a schnorr signature\r\n * @param {PublicKey|Buffer} publicKey \r\n * @param {String|Buffer} message Hex string or buffer\r\n * @param {String|Signature|Buffer} signature Hex string, Signature instance, or buffer\r\n * @returns {Boolean}\r\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Verification\r\n */\r\nSchnorr.verify = function(publicKey, message, signature) {\r\n  if ($.isType(publicKey, 'PublicKey')) {\r\n    publicKey = publicKey.point.x.toBuffer();\r\n  }\r\n  if (publicKey.length !== 32) {\r\n    throw new Error('Public key should be 32 bytes for schnorr signatures');\r\n  }\r\n\r\n  if (typeof message === 'string') {\r\n    $.checkArgument(JS.isHexaString(message), 'Schnorr message string is not hex');\r\n    message = Buffer.from(message, 'hex');\r\n  }\r\n  if (message.length !== 32) {\r\n    throw new Error('Message should be a 32 byte buffer');\r\n  }\r\n\r\n  if (typeof signature === 'string') {\r\n    $.checkArgument(JS.isHexaString(signature), 'Schnorr signature string is not hex');\r\n    signature = Buffer.from(signature, 'hex');\r\n  }\r\n  if (typeof signature.toBuffer === 'function') {\r\n    signature = signature.toBuffer();\r\n    if (signature.length === 65) {\r\n      signature = signature.slice(0, 64); // remove the sighashType byte\r\n    }\r\n  }\r\n  if (signature.length !== 64) {\r\n    throw new Error('Signature should be a 64 byte buffer');\r\n  }\r\n\r\n  try {\r\n    const p = Point.getP();\r\n    const n = Point.getN();\r\n\r\n    const P = Point.fromX(false, publicKey).liftX();\r\n    const r = new BN(signature.slice(0, 32));\r\n    const s = new BN(signature.slice(32, 64));\r\n    if (r.gte(p) || s.gte(n)) {\r\n      return false;\r\n    }\r\n    const e = getE(r, P, message);\r\n    const G = Point.getG();\r\n    const R = G.mul(s).add(P.mul(e).neg());\r\n    if (R.inf || !R.y.isEven() || !R.x.eq(r)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n};\r\n\r\n/* Utility function used in Verify() */\r\nconst getE = function(r, P, message) {\r\n  const n = Point.getN();\r\n  const hash = new TaggedHash('BIP0340/challenge', Buffer.concat([r.toBuffer({ size: 32 }), P.x.toBuffer({ size: 32 }), message])).finalize();\r\n  return new BN(hash).mod(n);\r\n};\r\n\r\nmodule.exports = Schnorr;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by9zY2hub3JyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLHVFQUF1QjtBQUN6QyxXQUFXLG1CQUFPLENBQUMsaURBQVk7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLDZDQUFNO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQyxtREFBUztBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyw2REFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTSxzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU0sc0NBQXNDO0FBQzNEO0FBQ0EsdURBQXVELE1BQU07QUFDN0QsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxlQUFlO0FBQzFCLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU0sc0JBQXNCLFVBQVUsa0JBQWtCLFVBQVU7QUFDckg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vc2Nobm9yci5qcz8xYzMwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5jb25zdCAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcbmNvbnN0IEpTID0gcmVxdWlyZSgnLi4vdXRpbC9qcycpO1xyXG5jb25zdCBCTiA9IHJlcXVpcmUoJy4vYm4nKTtcclxuY29uc3QgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcbmNvbnN0IFRhZ2dlZEhhc2ggPSByZXF1aXJlKCcuL3RhZ2dlZGhhc2gnKTtcclxuXHJcbmNvbnN0IFNjaG5vcnIgPSBmdW5jdGlvbiBTY2hub3JyKCkge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY2hub3JyKSkge1xyXG4gICAgcmV0dXJuIG5ldyBTY2hub3JyKCk7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuU2Nobm9yci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBzY2hub3JyIHNpZ25hdHVyZVxyXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl8QnVmZmVyfEJOfSBwcml2YXRlS2V5XHJcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gbWVzc2FnZSBIZXggc3RyaW5nIG9yIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGF1eCBIZXggc3RyaW5nIG9yIGJ1ZmZlclxyXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxyXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraSNEZWZhdWx0X1NpZ25pbmdcclxuICovXHJcblNjaG5vcnIuc2lnbiA9IGZ1bmN0aW9uKHByaXZhdGVLZXksIG1lc3NhZ2UsIGF1eCkge1xyXG4gIHByaXZhdGVLZXkgPSBCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleSkgPyBwcml2YXRlS2V5IDogcHJpdmF0ZUtleS50b0J1ZmZlcigpO1xyXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUHJpdmF0ZSBrZXkgc2hvdWxkIGJlIDMyIGJ5dGVzIGZvciBzY2hub3JyIHNpZ25hdHVyZXMnKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICQuY2hlY2tBcmd1bWVudChKUy5pc0hleGFTdHJpbmcobWVzc2FnZSksICdTY2hub3JyIG1lc3NhZ2Ugc3RyaW5nIGlzIG5vdCBoZXgnKTtcclxuICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlLCAnaGV4JylcclxuICB9XHJcbiAgJC5jaGVja0FyZ3VtZW50KCQuaXNUeXBlKG1lc3NhZ2UsICdCdWZmZXInKSwgJ1NjaG5vcnIgbWVzc2FnZSBtdXN0IGJlIGEgaGV4IHN0cmluZyBvciBidWZmZXInKTtcclxuXHJcbiAgaWYgKCFhdXgpIHtcclxuICAgIGF1eCA9IGNyeXB0by5yYW5kb21CeXRlcygzMik7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgYXV4ID09PSAnc3RyaW5nJykge1xyXG4gICAgJC5jaGVja0FyZ3VtZW50KEpTLmlzSGV4YVN0cmluZyhhdXgpLCAnU2Nobm9yciBhdXggc3RyaW5nIGlzIG5vdCBoZXgnKTtcclxuICAgIGF1eCA9IEJ1ZmZlci5mcm9tKGF1eCwgJ2hleCcpXHJcbiAgfVxyXG4gICQuY2hlY2tBcmd1bWVudCgkLmlzVHlwZShhdXgsICdCdWZmZXInKSwgJ1NjaG5vcnIgYXV4IG11c3QgYmUgYSBoZXggc3RyaW5nIG9yIGJ1ZmZlcicpO1xyXG5cclxuICBjb25zdCBHID0gUG9pbnQuZ2V0RygpO1xyXG4gIGNvbnN0IG4gPSBQb2ludC5nZXROKCk7XHJcblxyXG4gIGNvbnN0IGRQcmltZSA9IG5ldyBCTihwcml2YXRlS2V5KTtcclxuICBpZiAoZFByaW1lLmVxbigwKSB8fCBkUHJpbWUuZ3RlKG4pKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXkgZm9yIHNjaG5vcnIgc2lnbmluZycpO1xyXG4gIH1cclxuICBjb25zdCBQID0gRy5tdWwoZFByaW1lKTtcclxuICBjb25zdCBQYnVmID0gQnVmZmVyLmZyb20oUC5lbmNvZGVDb21wcmVzc2VkKCkuc2xpY2UoMSkpOyAvLyBzbGljZSgxKSByZW1vdmVzIHRoZSBlbmNvZGluZyBwcmVmaXggYnl0ZVxyXG4gIGNvbnN0IGQgPSBQLnkuaXNFdmVuKCkgPyBkUHJpbWUgOiBuLnN1YihkUHJpbWUpO1xyXG4gIGNvbnN0IHQgPSBkLnhvcihuZXcgQk4obmV3IFRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYXV4KS5maW5hbGl6ZSgpKSk7XHJcbiAgY29uc3QgcmFuZCA9IG5ldyBUYWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgQnVmZmVyLmNvbmNhdChbdC50b0J1ZmZlcigpLCBQYnVmLCBtZXNzYWdlXSkpLmZpbmFsaXplKCk7XHJcbiAgY29uc3Qga1ByaW1lID0gbmV3IEJOKHJhbmQpLm1vZChuKTtcclxuICBpZiAoa1ByaW1lLmVxbigwKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjcmVhdGluZyBzY2hub3JyIHNpZ25hdHVyZScpO1xyXG4gIH1cclxuICBjb25zdCBSID0gRy5tdWwoa1ByaW1lKTtcclxuICBjb25zdCBSYnVmID0gQnVmZmVyLmZyb20oUi5lbmNvZGVDb21wcmVzc2VkKCkuc2xpY2UoMSkpOyAvLyBzbGljZSgxKSByZW1vdmVzIHRoZSBlbmNvZGluZyBwcmVmaXggYnl0ZVxyXG4gIGNvbnN0IGsgPSBSLnkuaXNFdmVuKCkgPyBrUHJpbWUgOiBuLnN1YihrUHJpbWUpO1xyXG4gIGNvbnN0IGUgPSBuZXcgQk4obmV3IFRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgQnVmZmVyLmNvbmNhdChbUmJ1ZiwgUGJ1ZiwgbWVzc2FnZV0pKS5maW5hbGl6ZSgpKS5tb2Qobik7XHJcbiAgY29uc3Qgc2lnID0gQnVmZmVyLmNvbmNhdChbUmJ1Ziwgay5hZGQoZS5tdWwoZCkpLm1vZChuKS50b0J1ZmZlcigpXSk7XHJcblxyXG4gIGlmICghU2Nobm9yci52ZXJpZnkoUGJ1ZiwgbWVzc2FnZSwgc2lnKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjcmVhdGluZyBzY2hub3JyIHNpZ25hdHVyZS4gVmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xyXG4gIH1cclxuICByZXR1cm4gc2lnO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBWZXJpZnkgYSBzY2hub3JyIHNpZ25hdHVyZVxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleXxCdWZmZXJ9IHB1YmxpY0tleSBcclxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBtZXNzYWdlIEhleCBzdHJpbmcgb3IgYnVmZmVyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfFNpZ25hdHVyZXxCdWZmZXJ9IHNpZ25hdHVyZSBIZXggc3RyaW5nLCBTaWduYXR1cmUgaW5zdGFuY2UsIG9yIGJ1ZmZlclxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2kjVmVyaWZpY2F0aW9uXHJcbiAqL1xyXG5TY2hub3JyLnZlcmlmeSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgbWVzc2FnZSwgc2lnbmF0dXJlKSB7XHJcbiAgaWYgKCQuaXNUeXBlKHB1YmxpY0tleSwgJ1B1YmxpY0tleScpKSB7XHJcbiAgICBwdWJsaWNLZXkgPSBwdWJsaWNLZXkucG9pbnQueC50b0J1ZmZlcigpO1xyXG4gIH1cclxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUHVibGljIGtleSBzaG91bGQgYmUgMzIgYnl0ZXMgZm9yIHNjaG5vcnIgc2lnbmF0dXJlcycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgJC5jaGVja0FyZ3VtZW50KEpTLmlzSGV4YVN0cmluZyhtZXNzYWdlKSwgJ1NjaG5vcnIgbWVzc2FnZSBzdHJpbmcgaXMgbm90IGhleCcpO1xyXG4gICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsICdoZXgnKTtcclxuICB9XHJcbiAgaWYgKG1lc3NhZ2UubGVuZ3RoICE9PSAzMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIHNob3VsZCBiZSBhIDMyIGJ5dGUgYnVmZmVyJyk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICQuY2hlY2tBcmd1bWVudChKUy5pc0hleGFTdHJpbmcoc2lnbmF0dXJlKSwgJ1NjaG5vcnIgc2lnbmF0dXJlIHN0cmluZyBpcyBub3QgaGV4Jyk7XHJcbiAgICBzaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUsICdoZXgnKTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBzaWduYXR1cmUudG9CdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS50b0J1ZmZlcigpO1xyXG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggPT09IDY1KSB7XHJcbiAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5zbGljZSgwLCA2NCk7IC8vIHJlbW92ZSB0aGUgc2lnaGFzaFR5cGUgYnl0ZVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gNjQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIHNob3VsZCBiZSBhIDY0IGJ5dGUgYnVmZmVyJyk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgcCA9IFBvaW50LmdldFAoKTtcclxuICAgIGNvbnN0IG4gPSBQb2ludC5nZXROKCk7XHJcblxyXG4gICAgY29uc3QgUCA9IFBvaW50LmZyb21YKGZhbHNlLCBwdWJsaWNLZXkpLmxpZnRYKCk7XHJcbiAgICBjb25zdCByID0gbmV3IEJOKHNpZ25hdHVyZS5zbGljZSgwLCAzMikpO1xyXG4gICAgY29uc3QgcyA9IG5ldyBCTihzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSk7XHJcbiAgICBpZiAoci5ndGUocCkgfHwgcy5ndGUobikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZSA9IGdldEUociwgUCwgbWVzc2FnZSk7XHJcbiAgICBjb25zdCBHID0gUG9pbnQuZ2V0RygpO1xyXG4gICAgY29uc3QgUiA9IEcubXVsKHMpLmFkZChQLm11bChlKS5uZWcoKSk7XHJcbiAgICBpZiAoUi5pbmYgfHwgIVIueS5pc0V2ZW4oKSB8fCAhUi54LmVxKHIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG4vKiBVdGlsaXR5IGZ1bmN0aW9uIHVzZWQgaW4gVmVyaWZ5KCkgKi9cclxuY29uc3QgZ2V0RSA9IGZ1bmN0aW9uKHIsIFAsIG1lc3NhZ2UpIHtcclxuICBjb25zdCBuID0gUG9pbnQuZ2V0TigpO1xyXG4gIGNvbnN0IGhhc2ggPSBuZXcgVGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCBCdWZmZXIuY29uY2F0KFtyLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSksIFAueC50b0J1ZmZlcih7IHNpemU6IDMyIH0pLCBtZXNzYWdlXSkpLmZpbmFsaXplKCk7XHJcbiAgcmV0dXJuIG5ldyBCTihoYXNoKS5tb2Qobik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjaG5vcnI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/crypto/schnorr.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/crypto/signature.js":
/*!**********************************************!*\
  !*** ../bitcore-lib/lib/crypto/signature.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar BN = __webpack_require__(/*! ./bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\n\r\nvar Signature = function Signature(r, s, isSchnorr) {\r\n  if (!(this instanceof Signature)) {\r\n    return new Signature(r, s, isSchnorr);\r\n  }\r\n  if (r instanceof BN) {\r\n    this.set({\r\n      r: r,\r\n      s: s,\r\n      isSchnorr: isSchnorr\r\n    });\r\n  } else if (r) {\r\n    var obj = r;\r\n    this.set(obj);\r\n  }\r\n};\r\n\r\n/* jshint maxcomplexity: 7 */\r\nSignature.prototype.set = function(obj) {\r\n  this.r = obj.r || this.r || undefined;\r\n  this.s = obj.s || this.s || undefined;\r\n\r\n  // public key recovery parameter in range [0, 3]\r\n  this.i = typeof obj.i === 'undefined' ? this.i : obj.i;\r\n  // whether the recovered pubkey is compressed\r\n  this.compressed = typeof obj.compressed === 'undefined' ? this.compressed : obj.compressed;\r\n  this.isSchnorr = typeof obj.isSchnorr === 'undefined' ? this.isSchnorr : obj.isSchnorr;\r\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\r\n  return this;\r\n};\r\n\r\nSignature.fromCompact = function(buf) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\r\n\r\n  var sig = new Signature();\r\n\r\n  var compressed = true;\r\n  var i = buf.slice(0, 1)[0] - 27 - 4;\r\n  if (i < 0) {\r\n    compressed = false;\r\n    i = i + 4;\r\n  }\r\n\r\n  var b2 = buf.slice(1, 33);\r\n  var b3 = buf.slice(33, 65);\r\n\r\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\r\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\r\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\r\n\r\n  sig.compressed = compressed;\r\n  sig.i = i;\r\n  sig.r = BN.fromBuffer(b2);\r\n  sig.s = BN.fromBuffer(b3);\r\n\r\n  return sig;\r\n};\r\n\r\nSignature.fromDER = Signature.fromBuffer = function(buf, strict) {\r\n  var sig = new Signature();\r\n\r\n  // Schnorr Signatures use 65 byte for in tx r [len] 32 , s [len] 32, nhashtype\r\n  // NOTE: this check is not very reliable. You should use .fromSchnorr directly if you know it's a schnorr sig.\r\n  if((buf.length === 64 || buf.length === 65) && buf[0] != 0x30) {\r\n    return Signature.fromSchnorr(buf);\r\n  }\r\n  \r\n  $.checkArgument(!(buf.length === 64 && buf[0] === 0x30), new Error('64 DER (ecdsa) signatures not allowed'));\r\n  \r\n  var obj = Signature.parseDER(buf, strict);\r\n\r\n  sig.r = obj.r;\r\n  sig.s = obj.s;\r\n\r\n  return sig;\r\n};\r\n\r\n// The format used in a tx\r\nSignature.fromTxFormat = function(buf) {\r\n  var nhashtype = buf.readUInt8(buf.length - 1);\r\n  var derbuf = buf.slice(0, buf.length - 1);\r\n  var sig = new Signature.fromDER(derbuf, false);\r\n  sig.nhashtype = nhashtype;\r\n  return sig;\r\n};\r\n\r\nSignature.fromString = function(str) {\r\n  var buf = Buffer.from(str, 'hex');\r\n  return Signature.fromDER(buf);\r\n};\r\n\r\n\r\n/**\r\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\r\n */\r\nSignature.parseDER = function(buf, strict) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\r\n  if (_.isUndefined(strict)) {\r\n    strict = true;\r\n  }\r\n\r\n  var header = buf[0];\r\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\r\n\r\n  var length = buf[1];\r\n  var buflength = buf.slice(2).length;\r\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\r\n\r\n  length = length < buflength ? length : buflength;\r\n\r\n  var rheader = buf[2 + 0];\r\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\r\n\r\n  var rlength = buf[2 + 1];\r\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\r\n  var r = BN.fromBuffer(rbuf);\r\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\r\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\r\n\r\n  var sheader = buf[2 + 2 + rlength + 0];\r\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\r\n\r\n  var slength = buf[2 + 2 + rlength + 1];\r\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\r\n  var s = BN.fromBuffer(sbuf);\r\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\r\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\r\n\r\n  var sumlength = 2 + 2 + rlength + 2 + slength;\r\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\r\n\r\n  var obj = {\r\n    header: header,\r\n    length: length,\r\n    rheader: rheader,\r\n    rlength: rlength,\r\n    rneg: rneg,\r\n    rbuf: rbuf,\r\n    r: r,\r\n    sheader: sheader,\r\n    slength: slength,\r\n    sneg: sneg,\r\n    sbuf: sbuf,\r\n    s: s\r\n  };\r\n\r\n  return obj;\r\n};\r\n\r\n\r\nSignature.prototype.toCompact = function(i, compressed) {\r\n  i = typeof i === 'number' ? i : this.i;\r\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\r\n\r\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\r\n    throw new Error('i must be equal to 0, 1, 2, or 3');\r\n  }\r\n\r\n  var val = i + 27 + 4;\r\n  if (compressed === false) {\r\n    val = val - 4;\r\n  }\r\n  var b1 = Buffer.from([val]);\r\n  var b2 = this.r.toBuffer({\r\n    size: 32\r\n  });\r\n  var b3 = this.s.toBuffer({\r\n    size: 32\r\n  });\r\n  return Buffer.concat([b1, b2, b3]);\r\n};\r\n\r\n/**\r\n * Returns either a DER encoded buffer or a Schnorr encoded buffer if isSchnor == true\r\n */\r\nSignature.prototype.toBuffer = Signature.prototype.toDER = function() {\r\n  if(this.isSchnorr) {\r\n    const hashTypeBuf = !this.nhashtype || this.nhashtype === Signature.SIGHASH_DEFAULT ? Buffer.alloc(0) : Buffer.from([this.nhashtype]);\r\n    return Buffer.concat([this.r.toBuffer({ size: 32 }), this.s.toBuffer({ size: 32 }), hashTypeBuf]);\r\n  }\r\n\r\n  var rnbuf = this.r.toBuffer();\r\n  var snbuf = this.s.toBuffer();\r\n\r\n  var rneg = rnbuf[0] & 0x80 ? true : false;\r\n  var sneg = snbuf[0] & 0x80 ? true : false;\r\n\r\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\r\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\r\n\r\n  var rlength = rbuf.length;\r\n  var slength = sbuf.length;\r\n  var length = 2 + rlength + 2 + slength;\r\n  var rheader = 0x02;\r\n  var sheader = 0x02;\r\n  var header = 0x30;\r\n\r\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\r\n  return der;\r\n};\r\n\r\nSignature.prototype.toString = function() {\r\n  var buf = this.toDER();\r\n  return buf.toString('hex');\r\n};\r\n\r\n/**\r\n * This function is translated from bitcoind's IsDERSignature and is used in\r\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\r\n * the nhashtype, at the end. It is really the tx format, not DER format.\r\n *\r\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\r\n * Where R and S are not negative (their first byte has its highest bit not set), and not\r\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\r\n * in which case a single 0 byte is necessary and even required).\r\n *\r\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\r\n */\r\nSignature.isTxDER = function(buf) {\r\n  if (buf.length < 9) {\r\n    //  Non-canonical signature: too short\r\n    return false;\r\n  }\r\n  if (buf.length > 73) {\r\n    // Non-canonical signature: too long\r\n    return false;\r\n  }\r\n  if (buf[0] !== 0x30) {\r\n    //  Non-canonical signature: wrong type\r\n    return false;\r\n  }\r\n  if (buf[1] !== buf.length - 3) {\r\n    //  Non-canonical signature: wrong length marker\r\n    return false;\r\n  }\r\n  var nLenR = buf[3];\r\n  if (5 + nLenR >= buf.length) {\r\n    //  Non-canonical signature: S length misplaced\r\n    return false;\r\n  }\r\n  var nLenS = buf[5 + nLenR];\r\n  if ((nLenR + nLenS + 7) !== buf.length) {\r\n    //  Non-canonical signature: R+S length mismatch\r\n    return false;\r\n  }\r\n\r\n  var R = buf.slice(4);\r\n  if (buf[4 - 2] !== 0x02) {\r\n    //  Non-canonical signature: R value type mismatch\r\n    return false;\r\n  }\r\n  if (nLenR === 0) {\r\n    //  Non-canonical signature: R length is zero\r\n    return false;\r\n  }\r\n  if (R[0] & 0x80) {\r\n    //  Non-canonical signature: R value negative\r\n    return false;\r\n  }\r\n  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {\r\n    //  Non-canonical signature: R value excessively padded\r\n    return false;\r\n  }\r\n\r\n  var S = buf.slice(6 + nLenR);\r\n  if (buf[6 + nLenR - 2] !== 0x02) {\r\n    //  Non-canonical signature: S value type mismatch\r\n    return false;\r\n  }\r\n  if (nLenS === 0) {\r\n    //  Non-canonical signature: S length is zero\r\n    return false;\r\n  }\r\n  if (S[0] & 0x80) {\r\n    //  Non-canonical signature: S value negative\r\n    return false;\r\n  }\r\n  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {\r\n    //  Non-canonical signature: S value excessively padded\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Compares to bitcoind's IsLowDERSignature\r\n * See also ECDSA signature algorithm which enforces this.\r\n * See also BIP 62, \"low S values in signatures\"\r\n */\r\nSignature.prototype.hasLowS = function() {\r\n  if (this.s.lt(new BN(1)) ||\r\n    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\r\n * Translated from bitcoind's IsDefinedHashtypeSignature\r\n */\r\nSignature.prototype.hasDefinedHashtype = function() {\r\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\r\n    return false;\r\n  }\r\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\r\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\r\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nSignature.prototype.toTxFormat = function() {\r\n  var derbuf = this.toDER();\r\n  var buf = Buffer.alloc(1);\r\n  buf.writeUInt8(this.nhashtype, 0);\r\n  return Buffer.concat([derbuf, buf]);\r\n};\r\n\r\n/**\r\n * Creates a Signature instance from a Schnorr sig\r\n * @param {Buffer} buf Schnorr signature buffer\r\n * @returns {Signature}\r\n */\r\nSignature.fromSchnorr = function(buf) {\r\n  $.checkArgument(Buffer.isBuffer(buf), 'Schnorr signature argument must be a buffer');\r\n  $.checkArgument(buf.length === 64 || buf.length === 65, 'Schnorr signatures must be 64 or 65 bytes');\r\n\r\n  const sig = new Signature();\r\n  let r = buf.slice(0,32);\r\n  let s = buf.slice(32, 64);\r\n  if (buf.length === 65) {\r\n    sig.nhashtype = buf[buf.length - 1];\r\n    $.checkState(sig.nhashtype !== Signature.SIGHASH_DEFAULT, new Error('invalid hashtype'));\r\n  } else {\r\n    sig.nhashtype = Signature.SIGHASH_DEFAULT;\r\n  }\r\n  sig.r = BN.fromBuffer(r);\r\n  sig.s = BN.fromBuffer(s);\r\n  sig.isSchnorr = true;\r\n  return sig;\r\n};\r\n\r\nSignature.SIGHASH_DEFAULT       = 0x00; //!< Taproot only; implied when sighash byte is missing, and equivalent to SIGHASH_ALL\r\nSignature.SIGHASH_ALL           = 0x01;\r\nSignature.SIGHASH_NONE          = 0x02;\r\nSignature.SIGHASH_SINGLE        = 0x03;\r\nSignature.SIGHASH_ANYONECANPAY  = 0x80;\r\n\r\nSignature.SIGHASH_OUTPUT_MASK = 3;\r\nSignature.SIGHASH_INPUT_MASK  = 128; // 0x80,\r\n\r\nSignature.Version = {};\r\nSignature.Version.BASE       = 0;\r\nSignature.Version.WITNESS_V0 = 1;\r\nSignature.Version.TAPROOT    = 2;\r\nSignature.Version.TAPSCRIPT  = 3;\r\n\r\nmodule.exports = Signature;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vc2lnbmF0dXJlLmpzPzIwZWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEJOID0gcmVxdWlyZSgnLi9ibicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XHJcblxyXG52YXIgU2lnbmF0dXJlID0gZnVuY3Rpb24gU2lnbmF0dXJlKHIsIHMsIGlzU2Nobm9ycikge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTaWduYXR1cmUpKSB7XHJcbiAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzLCBpc1NjaG5vcnIpO1xyXG4gIH1cclxuICBpZiAociBpbnN0YW5jZW9mIEJOKSB7XHJcbiAgICB0aGlzLnNldCh7XHJcbiAgICAgIHI6IHIsXHJcbiAgICAgIHM6IHMsXHJcbiAgICAgIGlzU2Nobm9ycjogaXNTY2hub3JyXHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKHIpIHtcclxuICAgIHZhciBvYmogPSByO1xyXG4gICAgdGhpcy5zZXQob2JqKTtcclxuICB9XHJcbn07XHJcblxyXG4vKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogNyAqL1xyXG5TaWduYXR1cmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gIHRoaXMuciA9IG9iai5yIHx8IHRoaXMuciB8fCB1bmRlZmluZWQ7XHJcbiAgdGhpcy5zID0gb2JqLnMgfHwgdGhpcy5zIHx8IHVuZGVmaW5lZDtcclxuXHJcbiAgLy8gcHVibGljIGtleSByZWNvdmVyeSBwYXJhbWV0ZXIgaW4gcmFuZ2UgWzAsIDNdXHJcbiAgdGhpcy5pID0gdHlwZW9mIG9iai5pID09PSAndW5kZWZpbmVkJyA/IHRoaXMuaSA6IG9iai5pO1xyXG4gIC8vIHdoZXRoZXIgdGhlIHJlY292ZXJlZCBwdWJrZXkgaXMgY29tcHJlc3NlZFxyXG4gIHRoaXMuY29tcHJlc3NlZCA9IHR5cGVvZiBvYmouY29tcHJlc3NlZCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvbXByZXNzZWQgOiBvYmouY29tcHJlc3NlZDtcclxuICB0aGlzLmlzU2Nobm9yciA9IHR5cGVvZiBvYmouaXNTY2hub3JyID09PSAndW5kZWZpbmVkJyA/IHRoaXMuaXNTY2hub3JyIDogb2JqLmlzU2Nobm9ycjtcclxuICB0aGlzLm5oYXNodHlwZSA9IG9iai5uaGFzaHR5cGUgfHwgdGhpcy5uaGFzaHR5cGUgfHwgdW5kZWZpbmVkO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuU2lnbmF0dXJlLmZyb21Db21wYWN0ID0gZnVuY3Rpb24oYnVmKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSwgJ0FyZ3VtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgQnVmZmVyJyk7XHJcblxyXG4gIHZhciBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XHJcblxyXG4gIHZhciBjb21wcmVzc2VkID0gdHJ1ZTtcclxuICB2YXIgaSA9IGJ1Zi5zbGljZSgwLCAxKVswXSAtIDI3IC0gNDtcclxuICBpZiAoaSA8IDApIHtcclxuICAgIGNvbXByZXNzZWQgPSBmYWxzZTtcclxuICAgIGkgPSBpICsgNDtcclxuICB9XHJcblxyXG4gIHZhciBiMiA9IGJ1Zi5zbGljZSgxLCAzMyk7XHJcbiAgdmFyIGIzID0gYnVmLnNsaWNlKDMzLCA2NSk7XHJcblxyXG4gICQuY2hlY2tBcmd1bWVudChpID09PSAwIHx8IGkgPT09IDEgfHwgaSA9PT0gMiB8fCBpID09PSAzLCBuZXcgRXJyb3IoJ2kgbXVzdCBiZSAwLCAxLCAyLCBvciAzJykpO1xyXG4gICQuY2hlY2tBcmd1bWVudChiMi5sZW5ndGggPT09IDMyLCBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAzMiBieXRlcycpKTtcclxuICAkLmNoZWNrQXJndW1lbnQoYjMubGVuZ3RoID09PSAzMiwgbmV3IEVycm9yKCdzIG11c3QgYmUgMzIgYnl0ZXMnKSk7XHJcblxyXG4gIHNpZy5jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcclxuICBzaWcuaSA9IGk7XHJcbiAgc2lnLnIgPSBCTi5mcm9tQnVmZmVyKGIyKTtcclxuICBzaWcucyA9IEJOLmZyb21CdWZmZXIoYjMpO1xyXG5cclxuICByZXR1cm4gc2lnO1xyXG59O1xyXG5cclxuU2lnbmF0dXJlLmZyb21ERVIgPSBTaWduYXR1cmUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Ziwgc3RyaWN0KSB7XHJcbiAgdmFyIHNpZyA9IG5ldyBTaWduYXR1cmUoKTtcclxuXHJcbiAgLy8gU2Nobm9yciBTaWduYXR1cmVzIHVzZSA2NSBieXRlIGZvciBpbiB0eCByIFtsZW5dIDMyICwgcyBbbGVuXSAzMiwgbmhhc2h0eXBlXHJcbiAgLy8gTk9URTogdGhpcyBjaGVjayBpcyBub3QgdmVyeSByZWxpYWJsZS4gWW91IHNob3VsZCB1c2UgLmZyb21TY2hub3JyIGRpcmVjdGx5IGlmIHlvdSBrbm93IGl0J3MgYSBzY2hub3JyIHNpZy5cclxuICBpZigoYnVmLmxlbmd0aCA9PT0gNjQgfHwgYnVmLmxlbmd0aCA9PT0gNjUpICYmIGJ1ZlswXSAhPSAweDMwKSB7XHJcbiAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21TY2hub3JyKGJ1Zik7XHJcbiAgfVxyXG4gIFxyXG4gICQuY2hlY2tBcmd1bWVudCghKGJ1Zi5sZW5ndGggPT09IDY0ICYmIGJ1ZlswXSA9PT0gMHgzMCksIG5ldyBFcnJvcignNjQgREVSIChlY2RzYSkgc2lnbmF0dXJlcyBub3QgYWxsb3dlZCcpKTtcclxuICBcclxuICB2YXIgb2JqID0gU2lnbmF0dXJlLnBhcnNlREVSKGJ1Ziwgc3RyaWN0KTtcclxuXHJcbiAgc2lnLnIgPSBvYmoucjtcclxuICBzaWcucyA9IG9iai5zO1xyXG5cclxuICByZXR1cm4gc2lnO1xyXG59O1xyXG5cclxuLy8gVGhlIGZvcm1hdCB1c2VkIGluIGEgdHhcclxuU2lnbmF0dXJlLmZyb21UeEZvcm1hdCA9IGZ1bmN0aW9uKGJ1Zikge1xyXG4gIHZhciBuaGFzaHR5cGUgPSBidWYucmVhZFVJbnQ4KGJ1Zi5sZW5ndGggLSAxKTtcclxuICB2YXIgZGVyYnVmID0gYnVmLnNsaWNlKDAsIGJ1Zi5sZW5ndGggLSAxKTtcclxuICB2YXIgc2lnID0gbmV3IFNpZ25hdHVyZS5mcm9tREVSKGRlcmJ1ZiwgZmFsc2UpO1xyXG4gIHNpZy5uaGFzaHR5cGUgPSBuaGFzaHR5cGU7XHJcbiAgcmV0dXJuIHNpZztcclxufTtcclxuXHJcblNpZ25hdHVyZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpO1xyXG4gIHJldHVybiBTaWduYXR1cmUuZnJvbURFUihidWYpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbiBvcmRlciB0byBtaW1pYyB0aGUgbm9uLXN0cmljdCBERVIgZW5jb2Rpbmcgb2YgT3BlblNTTCwgc2V0IHN0cmljdCA9IGZhbHNlLlxyXG4gKi9cclxuU2lnbmF0dXJlLnBhcnNlREVSID0gZnVuY3Rpb24oYnVmLCBzdHJpY3QpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpLCBuZXcgRXJyb3IoJ0RFUiBmb3JtYXR0ZWQgc2lnbmF0dXJlIHNob3VsZCBiZSBhIGJ1ZmZlcicpKTtcclxuICBpZiAoXy5pc1VuZGVmaW5lZChzdHJpY3QpKSB7XHJcbiAgICBzdHJpY3QgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdmFyIGhlYWRlciA9IGJ1ZlswXTtcclxuICAkLmNoZWNrQXJndW1lbnQoaGVhZGVyID09PSAweDMwLCBuZXcgRXJyb3IoJ0hlYWRlciBieXRlIHNob3VsZCBiZSAweDMwJykpO1xyXG5cclxuICB2YXIgbGVuZ3RoID0gYnVmWzFdO1xyXG4gIHZhciBidWZsZW5ndGggPSBidWYuc2xpY2UoMikubGVuZ3RoO1xyXG4gICQuY2hlY2tBcmd1bWVudCghc3RyaWN0IHx8IGxlbmd0aCA9PT0gYnVmbGVuZ3RoLCBuZXcgRXJyb3IoJ0xlbmd0aCBieXRlIHNob3VsZCBsZW5ndGggb2Ygd2hhdCBmb2xsb3dzJykpO1xyXG5cclxuICBsZW5ndGggPSBsZW5ndGggPCBidWZsZW5ndGggPyBsZW5ndGggOiBidWZsZW5ndGg7XHJcblxyXG4gIHZhciByaGVhZGVyID0gYnVmWzIgKyAwXTtcclxuICAkLmNoZWNrQXJndW1lbnQocmhlYWRlciA9PT0gMHgwMiwgbmV3IEVycm9yKCdJbnRlZ2VyIGJ5dGUgZm9yIHIgc2hvdWxkIGJlIDB4MDInKSk7XHJcblxyXG4gIHZhciBybGVuZ3RoID0gYnVmWzIgKyAxXTtcclxuICB2YXIgcmJ1ZiA9IGJ1Zi5zbGljZSgyICsgMiwgMiArIDIgKyBybGVuZ3RoKTtcclxuICB2YXIgciA9IEJOLmZyb21CdWZmZXIocmJ1Zik7XHJcbiAgdmFyIHJuZWcgPSBidWZbMiArIDEgKyAxXSA9PT0gMHgwMCA/IHRydWUgOiBmYWxzZTtcclxuICAkLmNoZWNrQXJndW1lbnQocmxlbmd0aCA9PT0gcmJ1Zi5sZW5ndGgsIG5ldyBFcnJvcignTGVuZ3RoIG9mIHIgaW5jb3JyZWN0JykpO1xyXG5cclxuICB2YXIgc2hlYWRlciA9IGJ1ZlsyICsgMiArIHJsZW5ndGggKyAwXTtcclxuICAkLmNoZWNrQXJndW1lbnQoc2hlYWRlciA9PT0gMHgwMiwgbmV3IEVycm9yKCdJbnRlZ2VyIGJ5dGUgZm9yIHMgc2hvdWxkIGJlIDB4MDInKSk7XHJcblxyXG4gIHZhciBzbGVuZ3RoID0gYnVmWzIgKyAyICsgcmxlbmd0aCArIDFdO1xyXG4gIHZhciBzYnVmID0gYnVmLnNsaWNlKDIgKyAyICsgcmxlbmd0aCArIDIsIDIgKyAyICsgcmxlbmd0aCArIDIgKyBzbGVuZ3RoKTtcclxuICB2YXIgcyA9IEJOLmZyb21CdWZmZXIoc2J1Zik7XHJcbiAgdmFyIHNuZWcgPSBidWZbMiArIDIgKyBybGVuZ3RoICsgMiArIDJdID09PSAweDAwID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICQuY2hlY2tBcmd1bWVudChzbGVuZ3RoID09PSBzYnVmLmxlbmd0aCwgbmV3IEVycm9yKCdMZW5ndGggb2YgcyBpbmNvcnJlY3QnKSk7XHJcblxyXG4gIHZhciBzdW1sZW5ndGggPSAyICsgMiArIHJsZW5ndGggKyAyICsgc2xlbmd0aDtcclxuICAkLmNoZWNrQXJndW1lbnQobGVuZ3RoID09PSBzdW1sZW5ndGggLSAyLCBuZXcgRXJyb3IoJ0xlbmd0aCBvZiBzaWduYXR1cmUgaW5jb3JyZWN0JykpO1xyXG5cclxuICB2YXIgb2JqID0ge1xyXG4gICAgaGVhZGVyOiBoZWFkZXIsXHJcbiAgICBsZW5ndGg6IGxlbmd0aCxcclxuICAgIHJoZWFkZXI6IHJoZWFkZXIsXHJcbiAgICBybGVuZ3RoOiBybGVuZ3RoLFxyXG4gICAgcm5lZzogcm5lZyxcclxuICAgIHJidWY6IHJidWYsXHJcbiAgICByOiByLFxyXG4gICAgc2hlYWRlcjogc2hlYWRlcixcclxuICAgIHNsZW5ndGg6IHNsZW5ndGgsXHJcbiAgICBzbmVnOiBzbmVnLFxyXG4gICAgc2J1Zjogc2J1ZixcclxuICAgIHM6IHNcclxuICB9O1xyXG5cclxuICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuXHJcblNpZ25hdHVyZS5wcm90b3R5cGUudG9Db21wYWN0ID0gZnVuY3Rpb24oaSwgY29tcHJlc3NlZCkge1xyXG4gIGkgPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgPyBpIDogdGhpcy5pO1xyXG4gIGNvbXByZXNzZWQgPSB0eXBlb2YgY29tcHJlc3NlZCA9PT0gJ2Jvb2xlYW4nID8gY29tcHJlc3NlZCA6IHRoaXMuY29tcHJlc3NlZDtcclxuXHJcbiAgaWYgKCEoaSA9PT0gMCB8fCBpID09PSAxIHx8IGkgPT09IDIgfHwgaSA9PT0gMykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignaSBtdXN0IGJlIGVxdWFsIHRvIDAsIDEsIDIsIG9yIDMnKTtcclxuICB9XHJcblxyXG4gIHZhciB2YWwgPSBpICsgMjcgKyA0O1xyXG4gIGlmIChjb21wcmVzc2VkID09PSBmYWxzZSkge1xyXG4gICAgdmFsID0gdmFsIC0gNDtcclxuICB9XHJcbiAgdmFyIGIxID0gQnVmZmVyLmZyb20oW3ZhbF0pO1xyXG4gIHZhciBiMiA9IHRoaXMuci50b0J1ZmZlcih7XHJcbiAgICBzaXplOiAzMlxyXG4gIH0pO1xyXG4gIHZhciBiMyA9IHRoaXMucy50b0J1ZmZlcih7XHJcbiAgICBzaXplOiAzMlxyXG4gIH0pO1xyXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtiMSwgYjIsIGIzXSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBlaXRoZXIgYSBERVIgZW5jb2RlZCBidWZmZXIgb3IgYSBTY2hub3JyIGVuY29kZWQgYnVmZmVyIGlmIGlzU2Nobm9yID09IHRydWVcclxuICovXHJcblNpZ25hdHVyZS5wcm90b3R5cGUudG9CdWZmZXIgPSBTaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYodGhpcy5pc1NjaG5vcnIpIHtcclxuICAgIGNvbnN0IGhhc2hUeXBlQnVmID0gIXRoaXMubmhhc2h0eXBlIHx8IHRoaXMubmhhc2h0eXBlID09PSBTaWduYXR1cmUuU0lHSEFTSF9ERUZBVUxUID8gQnVmZmVyLmFsbG9jKDApIDogQnVmZmVyLmZyb20oW3RoaXMubmhhc2h0eXBlXSk7XHJcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy5yLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSksIHRoaXMucy50b0J1ZmZlcih7IHNpemU6IDMyIH0pLCBoYXNoVHlwZUJ1Zl0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJuYnVmID0gdGhpcy5yLnRvQnVmZmVyKCk7XHJcbiAgdmFyIHNuYnVmID0gdGhpcy5zLnRvQnVmZmVyKCk7XHJcblxyXG4gIHZhciBybmVnID0gcm5idWZbMF0gJiAweDgwID8gdHJ1ZSA6IGZhbHNlO1xyXG4gIHZhciBzbmVnID0gc25idWZbMF0gJiAweDgwID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuICB2YXIgcmJ1ZiA9IHJuZWcgPyBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMHgwMF0pLCBybmJ1Zl0pIDogcm5idWY7XHJcbiAgdmFyIHNidWYgPSBzbmVnID8gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzB4MDBdKSwgc25idWZdKSA6IHNuYnVmO1xyXG5cclxuICB2YXIgcmxlbmd0aCA9IHJidWYubGVuZ3RoO1xyXG4gIHZhciBzbGVuZ3RoID0gc2J1Zi5sZW5ndGg7XHJcbiAgdmFyIGxlbmd0aCA9IDIgKyBybGVuZ3RoICsgMiArIHNsZW5ndGg7XHJcbiAgdmFyIHJoZWFkZXIgPSAweDAyO1xyXG4gIHZhciBzaGVhZGVyID0gMHgwMjtcclxuICB2YXIgaGVhZGVyID0gMHgzMDtcclxuXHJcbiAgdmFyIGRlciA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFtoZWFkZXIsIGxlbmd0aCwgcmhlYWRlciwgcmxlbmd0aF0pLCByYnVmLCBCdWZmZXIuZnJvbShbc2hlYWRlciwgc2xlbmd0aF0pLCBzYnVmXSk7XHJcbiAgcmV0dXJuIGRlcjtcclxufTtcclxuXHJcblNpZ25hdHVyZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgYnVmID0gdGhpcy50b0RFUigpO1xyXG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2hleCcpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgSXNERVJTaWduYXR1cmUgYW5kIGlzIHVzZWQgaW5cclxuICogdGhlIHNjcmlwdCBpbnRlcnByZXRlci4gIFRoaXMgXCJERVJcIiBmb3JtYXQgYWN0dWFsbHkgaW5jbHVkZXMgYW4gZXh0cmEgYnl0ZSxcclxuICogdGhlIG5oYXNodHlwZSwgYXQgdGhlIGVuZC4gSXQgaXMgcmVhbGx5IHRoZSB0eCBmb3JtYXQsIG5vdCBERVIgZm9ybWF0LlxyXG4gKlxyXG4gKiBBIGNhbm9uaWNhbCBzaWduYXR1cmUgZXhpc3RzIG9mOiBbMzBdIFt0b3RhbCBsZW5dIFswMl0gW2xlbiBSXSBbUl0gWzAyXSBbbGVuIFNdIFtTXSBbaGFzaHR5cGVdXHJcbiAqIFdoZXJlIFIgYW5kIFMgYXJlIG5vdCBuZWdhdGl2ZSAodGhlaXIgZmlyc3QgYnl0ZSBoYXMgaXRzIGhpZ2hlc3QgYml0IG5vdCBzZXQpLCBhbmQgbm90XHJcbiAqIGV4Y2Vzc2l2ZWx5IHBhZGRlZCAoZG8gbm90IHN0YXJ0IHdpdGggYSAwIGJ5dGUsIHVubGVzcyBhbiBvdGhlcndpc2UgbmVnYXRpdmUgbnVtYmVyIGZvbGxvd3MsXHJcbiAqIGluIHdoaWNoIGNhc2UgYSBzaW5nbGUgMCBieXRlIGlzIG5lY2Vzc2FyeSBhbmQgZXZlbiByZXF1aXJlZCkuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9ODM5Mi5tc2cxMjc2MjMjbXNnMTI3NjIzXHJcbiAqL1xyXG5TaWduYXR1cmUuaXNUeERFUiA9IGZ1bmN0aW9uKGJ1Zikge1xyXG4gIGlmIChidWYubGVuZ3RoIDwgOSkge1xyXG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB0b28gc2hvcnRcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKGJ1Zi5sZW5ndGggPiA3Mykge1xyXG4gICAgLy8gTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IHRvbyBsb25nXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChidWZbMF0gIT09IDB4MzApIHtcclxuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogd3JvbmcgdHlwZVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoYnVmWzFdICE9PSBidWYubGVuZ3RoIC0gMykge1xyXG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB3cm9uZyBsZW5ndGggbWFya2VyXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBuTGVuUiA9IGJ1ZlszXTtcclxuICBpZiAoNSArIG5MZW5SID49IGJ1Zi5sZW5ndGgpIHtcclxuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUyBsZW5ndGggbWlzcGxhY2VkXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBuTGVuUyA9IGJ1Zls1ICsgbkxlblJdO1xyXG4gIGlmICgobkxlblIgKyBuTGVuUyArIDcpICE9PSBidWYubGVuZ3RoKSB7XHJcbiAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFIrUyBsZW5ndGggbWlzbWF0Y2hcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBSID0gYnVmLnNsaWNlKDQpO1xyXG4gIGlmIChidWZbNCAtIDJdICE9PSAweDAyKSB7XHJcbiAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFIgdmFsdWUgdHlwZSBtaXNtYXRjaFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAobkxlblIgPT09IDApIHtcclxuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUiBsZW5ndGggaXMgemVyb1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoUlswXSAmIDB4ODApIHtcclxuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUiB2YWx1ZSBuZWdhdGl2ZVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAobkxlblIgPiAxICYmIChSWzBdID09PSAweDAwKSAmJiAhKFJbMV0gJiAweDgwKSkge1xyXG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmFyIFMgPSBidWYuc2xpY2UoNiArIG5MZW5SKTtcclxuICBpZiAoYnVmWzYgKyBuTGVuUiAtIDJdICE9PSAweDAyKSB7XHJcbiAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFMgdmFsdWUgdHlwZSBtaXNtYXRjaFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAobkxlblMgPT09IDApIHtcclxuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUyBsZW5ndGggaXMgemVyb1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoU1swXSAmIDB4ODApIHtcclxuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUyB2YWx1ZSBuZWdhdGl2ZVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAobkxlblMgPiAxICYmIChTWzBdID09PSAweDAwKSAmJiAhKFNbMV0gJiAweDgwKSkge1xyXG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0byBiaXRjb2luZCdzIElzTG93REVSU2lnbmF0dXJlXHJcbiAqIFNlZSBhbHNvIEVDRFNBIHNpZ25hdHVyZSBhbGdvcml0aG0gd2hpY2ggZW5mb3JjZXMgdGhpcy5cclxuICogU2VlIGFsc28gQklQIDYyLCBcImxvdyBTIHZhbHVlcyBpbiBzaWduYXR1cmVzXCJcclxuICovXHJcblNpZ25hdHVyZS5wcm90b3R5cGUuaGFzTG93UyA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICh0aGlzLnMubHQobmV3IEJOKDEpKSB8fFxyXG4gICAgdGhpcy5zLmd0KG5ldyBCTignN0ZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY1RDU3NkU3MzU3QTQ1MDFEREZFOTJGNDY2ODFCMjBBMCcsICdoZXgnKSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbmhhc2h0eXBlIGlzIGV4YWN0bHkgZXF1YWwgdG8gb25lIG9mIHRoZSBzdGFuZGFyZCBvcHRpb25zIG9yIGNvbWJpbmF0aW9ucyB0aGVyZW9mLlxyXG4gKiBUcmFuc2xhdGVkIGZyb20gYml0Y29pbmQncyBJc0RlZmluZWRIYXNodHlwZVNpZ25hdHVyZVxyXG4gKi9cclxuU2lnbmF0dXJlLnByb3RvdHlwZS5oYXNEZWZpbmVkSGFzaHR5cGUgPSBmdW5jdGlvbigpIHtcclxuICBpZiAoIUpTVXRpbC5pc05hdHVyYWxOdW1iZXIodGhpcy5uaGFzaHR5cGUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8vIGFjY2VwdCB3aXRoIG9yIHdpdGhvdXQgU2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZIGJ5IGlnbm9yaW5nIHRoZSBiaXRcclxuICB2YXIgdGVtcCA9IHRoaXMubmhhc2h0eXBlICYgflNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWTtcclxuICBpZiAodGVtcCA8IFNpZ25hdHVyZS5TSUdIQVNIX0FMTCB8fCB0ZW1wID4gU2lnbmF0dXJlLlNJR0hBU0hfU0lOR0xFKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuU2lnbmF0dXJlLnByb3RvdHlwZS50b1R4Rm9ybWF0ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGRlcmJ1ZiA9IHRoaXMudG9ERVIoKTtcclxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDEpO1xyXG4gIGJ1Zi53cml0ZVVJbnQ4KHRoaXMubmhhc2h0eXBlLCAwKTtcclxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZGVyYnVmLCBidWZdKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgU2lnbmF0dXJlIGluc3RhbmNlIGZyb20gYSBTY2hub3JyIHNpZ1xyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFNjaG5vcnIgc2lnbmF0dXJlIGJ1ZmZlclxyXG4gKiBAcmV0dXJucyB7U2lnbmF0dXJlfVxyXG4gKi9cclxuU2lnbmF0dXJlLmZyb21TY2hub3JyID0gZnVuY3Rpb24oYnVmKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlci5pc0J1ZmZlcihidWYpLCAnU2Nobm9yciBzaWduYXR1cmUgYXJndW1lbnQgbXVzdCBiZSBhIGJ1ZmZlcicpO1xyXG4gICQuY2hlY2tBcmd1bWVudChidWYubGVuZ3RoID09PSA2NCB8fCBidWYubGVuZ3RoID09PSA2NSwgJ1NjaG5vcnIgc2lnbmF0dXJlcyBtdXN0IGJlIDY0IG9yIDY1IGJ5dGVzJyk7XHJcblxyXG4gIGNvbnN0IHNpZyA9IG5ldyBTaWduYXR1cmUoKTtcclxuICBsZXQgciA9IGJ1Zi5zbGljZSgwLDMyKTtcclxuICBsZXQgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xyXG4gIGlmIChidWYubGVuZ3RoID09PSA2NSkge1xyXG4gICAgc2lnLm5oYXNodHlwZSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XHJcbiAgICAkLmNoZWNrU3RhdGUoc2lnLm5oYXNodHlwZSAhPT0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCwgbmV3IEVycm9yKCdpbnZhbGlkIGhhc2h0eXBlJykpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzaWcubmhhc2h0eXBlID0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVDtcclxuICB9XHJcbiAgc2lnLnIgPSBCTi5mcm9tQnVmZmVyKHIpO1xyXG4gIHNpZy5zID0gQk4uZnJvbUJ1ZmZlcihzKTtcclxuICBzaWcuaXNTY2hub3JyID0gdHJ1ZTtcclxuICByZXR1cm4gc2lnO1xyXG59O1xyXG5cclxuU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCAgICAgICA9IDB4MDA7IC8vITwgVGFwcm9vdCBvbmx5OyBpbXBsaWVkIHdoZW4gc2lnaGFzaCBieXRlIGlzIG1pc3NpbmcsIGFuZCBlcXVpdmFsZW50IHRvIFNJR0hBU0hfQUxMXHJcblNpZ25hdHVyZS5TSUdIQVNIX0FMTCAgICAgICAgICAgPSAweDAxO1xyXG5TaWduYXR1cmUuU0lHSEFTSF9OT05FICAgICAgICAgID0gMHgwMjtcclxuU2lnbmF0dXJlLlNJR0hBU0hfU0lOR0xFICAgICAgICA9IDB4MDM7XHJcblNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSAgPSAweDgwO1xyXG5cclxuU2lnbmF0dXJlLlNJR0hBU0hfT1VUUFVUX01BU0sgPSAzO1xyXG5TaWduYXR1cmUuU0lHSEFTSF9JTlBVVF9NQVNLICA9IDEyODsgLy8gMHg4MCxcclxuXHJcblNpZ25hdHVyZS5WZXJzaW9uID0ge307XHJcblNpZ25hdHVyZS5WZXJzaW9uLkJBU0UgICAgICAgPSAwO1xyXG5TaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwID0gMTtcclxuU2lnbmF0dXJlLlZlcnNpb24uVEFQUk9PVCAgICA9IDI7XHJcblNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVCAgPSAzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/crypto/signature.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/crypto/taggedhash.js":
/*!***********************************************!*\
  !*** ../bitcore-lib/lib/crypto/taggedhash.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\nconst Hash = __webpack_require__(/*! ./hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nconst inherits = __webpack_require__(/*! inherits */ \"../bitcore-lib/node_modules/inherits/inherits.js\");\r\n\r\n/**\r\n * Creates a tag hash to ensure uniqueness of a message between purposes.\r\n * For example, if there's a potential for a collision of messages between\r\n *   multiple purposes, a tag can be added to guard against such collisions.\r\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Design (see 'Tagged Hashes')\r\n * @param {String} tag The tag to prevent message collisions. Should uniquely reflect the purpose of the message.\r\n * @param {Buffer|String} message (optional)\r\n * @param {String} messageEncoding (default: 'hex') If `message` is a string, provide the encoding\r\n * @returns {TaggedHash} Instance of a BufferWriter with the written tag and `finalize` method\r\n */\r\nfunction TaggedHash(tag, message, messageEncoding = 'hex') {\r\n  if (!(this instanceof TaggedHash)) {\r\n    return new TaggedHash(tag, message, messageEncoding);\r\n  }\r\n  BufferWriter.apply(this);\r\n  tag = Buffer.from(tag);\r\n\r\n  const taghash = Hash.sha256(tag);\r\n  this.write(taghash);\r\n  this.write(taghash);\r\n  if (message) {\r\n    message = Buffer.isBuffer(message) ? message : Buffer.from(message, messageEncoding);\r\n    this.write(message);\r\n  }\r\n  return this;\r\n};\r\n\r\ninherits(TaggedHash, BufferWriter);\r\n\r\n/**\r\n * Returns a 32-byte SHA256 hash of the double tagged hashes concat'd with the message\r\n * as defined by BIP-340: SHA256(SHA256(tag), SHA256(tag), message)\r\n * @returns {Buffer}\r\n */\r\nTaggedHash.prototype.finalize = function() {\r\n  return Buffer.from(Hash.sha256(this.toBuffer()));\r\n};\r\n\r\n/**\r\n * Commonly used tags\r\n */\r\nObject.defineProperties(TaggedHash, {\r\n  TAPSIGHASH: { get: () => new TaggedHash('TapSighash') },\r\n  TAPLEAF:    { get: () => new TaggedHash('TapLeaf') },\r\n  TAPBRANCH:  { get: () => new TaggedHash('TapBranch') }\r\n});\r\n\r\nmodule.exports = TaggedHash;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2NyeXB0by90YWdnZWRoYXNoLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxhQUFhLG1CQUFPLENBQUMsaURBQVE7QUFDN0IscUJBQXFCLG1CQUFPLENBQUMsNkVBQTBCO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLGtFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNLCtCQUErQixNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pELGdCQUFnQixzQ0FBc0M7QUFDdEQsZ0JBQWdCO0FBQ2hCLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL3RhZ2dlZGhhc2guanM/OWFjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XHJcbmNvbnN0IEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xyXG5jb25zdCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHRhZyBoYXNoIHRvIGVuc3VyZSB1bmlxdWVuZXNzIG9mIGEgbWVzc2FnZSBiZXR3ZWVuIHB1cnBvc2VzLlxyXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlcmUncyBhIHBvdGVudGlhbCBmb3IgYSBjb2xsaXNpb24gb2YgbWVzc2FnZXMgYmV0d2VlblxyXG4gKiAgIG11bHRpcGxlIHB1cnBvc2VzLCBhIHRhZyBjYW4gYmUgYWRkZWQgdG8gZ3VhcmQgYWdhaW5zdCBzdWNoIGNvbGxpc2lvbnMuXHJcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpI0Rlc2lnbiAoc2VlICdUYWdnZWQgSGFzaGVzJylcclxuICogQHBhcmFtIHtTdHJpbmd9IHRhZyBUaGUgdGFnIHRvIHByZXZlbnQgbWVzc2FnZSBjb2xsaXNpb25zLiBTaG91bGQgdW5pcXVlbHkgcmVmbGVjdCB0aGUgcHVycG9zZSBvZiB0aGUgbWVzc2FnZS5cclxuICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBtZXNzYWdlIChvcHRpb25hbClcclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VFbmNvZGluZyAoZGVmYXVsdDogJ2hleCcpIElmIGBtZXNzYWdlYCBpcyBhIHN0cmluZywgcHJvdmlkZSB0aGUgZW5jb2RpbmdcclxuICogQHJldHVybnMge1RhZ2dlZEhhc2h9IEluc3RhbmNlIG9mIGEgQnVmZmVyV3JpdGVyIHdpdGggdGhlIHdyaXR0ZW4gdGFnIGFuZCBgZmluYWxpemVgIG1ldGhvZFxyXG4gKi9cclxuZnVuY3Rpb24gVGFnZ2VkSGFzaCh0YWcsIG1lc3NhZ2UsIG1lc3NhZ2VFbmNvZGluZyA9ICdoZXgnKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRhZ2dlZEhhc2gpKSB7XHJcbiAgICByZXR1cm4gbmV3IFRhZ2dlZEhhc2godGFnLCBtZXNzYWdlLCBtZXNzYWdlRW5jb2RpbmcpO1xyXG4gIH1cclxuICBCdWZmZXJXcml0ZXIuYXBwbHkodGhpcyk7XHJcbiAgdGFnID0gQnVmZmVyLmZyb20odGFnKTtcclxuXHJcbiAgY29uc3QgdGFnaGFzaCA9IEhhc2guc2hhMjU2KHRhZyk7XHJcbiAgdGhpcy53cml0ZSh0YWdoYXNoKTtcclxuICB0aGlzLndyaXRlKHRhZ2hhc2gpO1xyXG4gIGlmIChtZXNzYWdlKSB7XHJcbiAgICBtZXNzYWdlID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpID8gbWVzc2FnZSA6IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIG1lc3NhZ2VFbmNvZGluZyk7XHJcbiAgICB0aGlzLndyaXRlKG1lc3NhZ2UpO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmluaGVyaXRzKFRhZ2dlZEhhc2gsIEJ1ZmZlcldyaXRlcik7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIDMyLWJ5dGUgU0hBMjU2IGhhc2ggb2YgdGhlIGRvdWJsZSB0YWdnZWQgaGFzaGVzIGNvbmNhdCdkIHdpdGggdGhlIG1lc3NhZ2VcclxuICogYXMgZGVmaW5lZCBieSBCSVAtMzQwOiBTSEEyNTYoU0hBMjU2KHRhZyksIFNIQTI1Nih0YWcpLCBtZXNzYWdlKVxyXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxyXG4gKi9cclxuVGFnZ2VkSGFzaC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gQnVmZmVyLmZyb20oSGFzaC5zaGEyNTYodGhpcy50b0J1ZmZlcigpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tbW9ubHkgdXNlZCB0YWdzXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUYWdnZWRIYXNoLCB7XHJcbiAgVEFQU0lHSEFTSDogeyBnZXQ6ICgpID0+IG5ldyBUYWdnZWRIYXNoKCdUYXBTaWdoYXNoJykgfSxcclxuICBUQVBMRUFGOiAgICB7IGdldDogKCkgPT4gbmV3IFRhZ2dlZEhhc2goJ1RhcExlYWYnKSB9LFxyXG4gIFRBUEJSQU5DSDogIHsgZ2V0OiAoKSA9PiBuZXcgVGFnZ2VkSGFzaCgnVGFwQnJhbmNoJykgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGFnZ2VkSGFzaDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/crypto/taggedhash.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/encoding/base58.js":
/*!*********************************************!*\
  !*** ../bitcore-lib/lib/encoding/base58.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar bs58 = __webpack_require__(/*! bs58 */ \"../bitcore-lib/node_modules/bs58/src/cjs/index.cjs\");\r\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\r\n\r\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');\r\n\r\nvar Base58 = function Base58(obj) {\r\n  /* jshint maxcomplexity: 8 */\r\n  if (!(this instanceof Base58)) {\r\n    return new Base58(obj);\r\n  }\r\n  if (Buffer.isBuffer(obj)) {\r\n    var buf = obj;\r\n    this.fromBuffer(buf);\r\n  } else if (typeof obj === 'string') {\r\n    var str = obj;\r\n    this.fromString(str);\r\n  } else if (obj) {\r\n    this.set(obj);\r\n  }\r\n};\r\n\r\nBase58.validCharacters = function validCharacters(chars) {\r\n  if (buffer.Buffer.isBuffer(chars)) {\r\n    chars = chars.toString();\r\n  }\r\n  return _.every(_.map(chars, function(char) { return _.includes(ALPHABET, char); }));\r\n};\r\n\r\nBase58.prototype.set = function(obj) {\r\n  this.buf = obj.buf || this.buf || undefined;\r\n  return this;\r\n};\r\n\r\nBase58.encode = function(buf) {\r\n  if (!buffer.Buffer.isBuffer(buf)) {\r\n    throw new Error('Input should be a buffer');\r\n  }\r\n  return bs58.encode(buf);\r\n};\r\n\r\nBase58.decode = function(str) {\r\n  if (typeof str !== 'string') {\r\n    throw new Error('Input should be a string');\r\n  }\r\n  return Buffer.from(bs58.decode(str));\r\n};\r\n\r\nBase58.prototype.fromBuffer = function(buf) {\r\n  this.buf = buf;\r\n  return this;\r\n};\r\n\r\nBase58.prototype.fromString = function(str) {\r\n  var buf = Base58.decode(str);\r\n  this.buf = buf;\r\n  return this;\r\n};\r\n\r\nBase58.prototype.toBuffer = function() {\r\n  return this.buf;\r\n};\r\n\r\nBase58.prototype.toString = function() {\r\n  return Base58.encode(this.buf);\r\n};\r\n\r\nmodule.exports = Base58;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2Jhc2U1OC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QixXQUFXLG1CQUFPLENBQUMsZ0VBQU07QUFDekIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQU07QUFDWjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQ0FBb0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9lbmNvZGluZy9iYXNlNTguanM/OTNjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKTtcclxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xyXG5cclxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonLnNwbGl0KCcnKTtcclxuXHJcbnZhciBCYXNlNTggPSBmdW5jdGlvbiBCYXNlNTgob2JqKSB7XHJcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDggKi9cclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmFzZTU4KSkge1xyXG4gICAgcmV0dXJuIG5ldyBCYXNlNTgob2JqKTtcclxuICB9XHJcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XHJcbiAgICB2YXIgYnVmID0gb2JqO1xyXG4gICAgdGhpcy5mcm9tQnVmZmVyKGJ1Zik7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIHN0ciA9IG9iajtcclxuICAgIHRoaXMuZnJvbVN0cmluZyhzdHIpO1xyXG4gIH0gZWxzZSBpZiAob2JqKSB7XHJcbiAgICB0aGlzLnNldChvYmopO1xyXG4gIH1cclxufTtcclxuXHJcbkJhc2U1OC52YWxpZENoYXJhY3RlcnMgPSBmdW5jdGlvbiB2YWxpZENoYXJhY3RlcnMoY2hhcnMpIHtcclxuICBpZiAoYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihjaGFycykpIHtcclxuICAgIGNoYXJzID0gY2hhcnMudG9TdHJpbmcoKTtcclxuICB9XHJcbiAgcmV0dXJuIF8uZXZlcnkoXy5tYXAoY2hhcnMsIGZ1bmN0aW9uKGNoYXIpIHsgcmV0dXJuIF8uaW5jbHVkZXMoQUxQSEFCRVQsIGNoYXIpOyB9KSk7XHJcbn07XHJcblxyXG5CYXNlNTgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gIHRoaXMuYnVmID0gb2JqLmJ1ZiB8fCB0aGlzLmJ1ZiB8fCB1bmRlZmluZWQ7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CYXNlNTguZW5jb2RlID0gZnVuY3Rpb24oYnVmKSB7XHJcbiAgaWYgKCFidWZmZXIuQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hvdWxkIGJlIGEgYnVmZmVyJyk7XHJcbiAgfVxyXG4gIHJldHVybiBiczU4LmVuY29kZShidWYpO1xyXG59O1xyXG5cclxuQmFzZTU4LmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcclxuICB9XHJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJzNTguZGVjb2RlKHN0cikpO1xyXG59O1xyXG5cclxuQmFzZTU4LnByb3RvdHlwZS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XHJcbiAgdGhpcy5idWYgPSBidWY7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CYXNlNTgucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICB2YXIgYnVmID0gQmFzZTU4LmRlY29kZShzdHIpO1xyXG4gIHRoaXMuYnVmID0gYnVmO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQmFzZTU4LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmJ1ZjtcclxufTtcclxuXHJcbkJhc2U1OC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gQmFzZTU4LmVuY29kZSh0aGlzLmJ1Zik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U1ODtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/encoding/base58.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/encoding/base58check.js":
/*!**************************************************!*\
  !*** ../bitcore-lib/lib/encoding/base58check.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar Base58 = __webpack_require__(/*! ./base58 */ \"../bitcore-lib/lib/encoding/base58.js\");\r\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\r\nvar sha256sha256 = (__webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\").sha256sha256);\r\n\r\nvar Base58Check = function Base58Check(obj) {\r\n  if (!(this instanceof Base58Check))\r\n    return new Base58Check(obj);\r\n  if (Buffer.isBuffer(obj)) {\r\n    var buf = obj;\r\n    this.fromBuffer(buf);\r\n  } else if (typeof obj === 'string') {\r\n    var str = obj;\r\n    this.fromString(str);\r\n  } else if (obj) {\r\n    this.set(obj);\r\n  }\r\n};\r\n\r\nBase58Check.prototype.set = function(obj) {\r\n  this.buf = obj.buf || this.buf || undefined;\r\n  return this;\r\n};\r\n\r\nBase58Check.validChecksum = function validChecksum(data, checksum) {\r\n  if (_.isString(data)) {\r\n    data = Buffer.from(Base58.decode(data));\r\n  }\r\n  if (_.isString(checksum)) {\r\n    checksum =  Buffer.from(Base58.decode(checksum));\r\n  }\r\n  if (!checksum) {\r\n    checksum = data.slice(-4);\r\n    data = data.slice(0, -4);\r\n  }\r\n  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');\r\n};\r\n\r\nBase58Check.decode = function(s) {\r\n  if (typeof s !== 'string')\r\n    throw new Error('Input must be a string');\r\n\r\n  var buf = Buffer.from(Base58.decode(s));\r\n\r\n  if (buf.length < 4)\r\n    throw new Error(\"Input string too short\");\r\n\r\n  var data = buf.slice(0, -4);\r\n  var csum = buf.slice(-4);\r\n\r\n  var hash = sha256sha256(data);\r\n  var hash4 = hash.slice(0, 4);\r\n\r\n  if (csum.toString('hex') !== hash4.toString('hex'))\r\n    throw new Error(\"Checksum mismatch\");\r\n\r\n  return data;\r\n};\r\n\r\nBase58Check.checksum = function(buffer) {\r\n  return sha256sha256(buffer).slice(0, 4);\r\n};\r\n\r\nBase58Check.encode = function(buf) {\r\n  if (!Buffer.isBuffer(buf))\r\n    throw new Error('Input must be a buffer');\r\n  var checkedBuf = Buffer.alloc(buf.length + 4);\r\n  var hash = Base58Check.checksum(buf);\r\n  buf.copy(checkedBuf);\r\n  hash.copy(checkedBuf, buf.length);\r\n  return Base58.encode(checkedBuf);\r\n};\r\n\r\nBase58Check.prototype.fromBuffer = function(buf) {\r\n  this.buf = buf;\r\n  return this;\r\n};\r\n\r\nBase58Check.prototype.fromString = function(str) {\r\n  var buf = Base58Check.decode(str);\r\n  this.buf = buf;\r\n  return this;\r\n};\r\n\r\nBase58Check.prototype.toBuffer = function() {\r\n  return this.buf;\r\n};\r\n\r\nBase58Check.prototype.toString = function() {\r\n  return Base58Check.encode(this.buf);\r\n};\r\n\r\nmodule.exports = Base58Check;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2Jhc2U1OGNoZWNrLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLDREQUFRO0FBQ3hCLGFBQWEsbUJBQU8sQ0FBQyx1REFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsbUJBQW1CLDZGQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBTTtBQUNaO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFNO0FBQ2I7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvZW5jb2RpbmcvYmFzZTU4Y2hlY2suanM/ODRjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgQmFzZTU4ID0gcmVxdWlyZSgnLi9iYXNlNTgnKTtcclxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xyXG52YXIgc2hhMjU2c2hhMjU2ID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKS5zaGEyNTZzaGEyNTY7XHJcblxyXG52YXIgQmFzZTU4Q2hlY2sgPSBmdW5jdGlvbiBCYXNlNThDaGVjayhvYmopIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmFzZTU4Q2hlY2spKVxyXG4gICAgcmV0dXJuIG5ldyBCYXNlNThDaGVjayhvYmopO1xyXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xyXG4gICAgdmFyIGJ1ZiA9IG9iajtcclxuICAgIHRoaXMuZnJvbUJ1ZmZlcihidWYpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBzdHIgPSBvYmo7XHJcbiAgICB0aGlzLmZyb21TdHJpbmcoc3RyKTtcclxuICB9IGVsc2UgaWYgKG9iaikge1xyXG4gICAgdGhpcy5zZXQob2JqKTtcclxuICB9XHJcbn07XHJcblxyXG5CYXNlNThDaGVjay5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgdGhpcy5idWYgPSBvYmouYnVmIHx8IHRoaXMuYnVmIHx8IHVuZGVmaW5lZDtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkJhc2U1OENoZWNrLnZhbGlkQ2hlY2tzdW0gPSBmdW5jdGlvbiB2YWxpZENoZWNrc3VtKGRhdGEsIGNoZWNrc3VtKSB7XHJcbiAgaWYgKF8uaXNTdHJpbmcoZGF0YSkpIHtcclxuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShCYXNlNTguZGVjb2RlKGRhdGEpKTtcclxuICB9XHJcbiAgaWYgKF8uaXNTdHJpbmcoY2hlY2tzdW0pKSB7XHJcbiAgICBjaGVja3N1bSA9ICBCdWZmZXIuZnJvbShCYXNlNTguZGVjb2RlKGNoZWNrc3VtKSk7XHJcbiAgfVxyXG4gIGlmICghY2hlY2tzdW0pIHtcclxuICAgIGNoZWNrc3VtID0gZGF0YS5zbGljZSgtNCk7XHJcbiAgICBkYXRhID0gZGF0YS5zbGljZSgwLCAtNCk7XHJcbiAgfVxyXG4gIHJldHVybiBCYXNlNThDaGVjay5jaGVja3N1bShkYXRhKS50b1N0cmluZygnaGV4JykgPT09IGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKTtcclxufTtcclxuXHJcbkJhc2U1OENoZWNrLmRlY29kZSA9IGZ1bmN0aW9uKHMpIHtcclxuICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcblxyXG4gIHZhciBidWYgPSBCdWZmZXIuZnJvbShCYXNlNTguZGVjb2RlKHMpKTtcclxuXHJcbiAgaWYgKGJ1Zi5sZW5ndGggPCA0KVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc3RyaW5nIHRvbyBzaG9ydFwiKTtcclxuXHJcbiAgdmFyIGRhdGEgPSBidWYuc2xpY2UoMCwgLTQpO1xyXG4gIHZhciBjc3VtID0gYnVmLnNsaWNlKC00KTtcclxuXHJcbiAgdmFyIGhhc2ggPSBzaGEyNTZzaGEyNTYoZGF0YSk7XHJcbiAgdmFyIGhhc2g0ID0gaGFzaC5zbGljZSgwLCA0KTtcclxuXHJcbiAgaWYgKGNzdW0udG9TdHJpbmcoJ2hleCcpICE9PSBoYXNoNC50b1N0cmluZygnaGV4JykpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGVja3N1bSBtaXNtYXRjaFwiKTtcclxuXHJcbiAgcmV0dXJuIGRhdGE7XHJcbn07XHJcblxyXG5CYXNlNThDaGVjay5jaGVja3N1bSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gIHJldHVybiBzaGEyNTZzaGEyNTYoYnVmZmVyKS5zbGljZSgwLCA0KTtcclxufTtcclxuXHJcbkJhc2U1OENoZWNrLmVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xyXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBidWZmZXInKTtcclxuICB2YXIgY2hlY2tlZEJ1ZiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgNCk7XHJcbiAgdmFyIGhhc2ggPSBCYXNlNThDaGVjay5jaGVja3N1bShidWYpO1xyXG4gIGJ1Zi5jb3B5KGNoZWNrZWRCdWYpO1xyXG4gIGhhc2guY29weShjaGVja2VkQnVmLCBidWYubGVuZ3RoKTtcclxuICByZXR1cm4gQmFzZTU4LmVuY29kZShjaGVja2VkQnVmKTtcclxufTtcclxuXHJcbkJhc2U1OENoZWNrLnByb3RvdHlwZS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XHJcbiAgdGhpcy5idWYgPSBidWY7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CYXNlNThDaGVjay5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gIHZhciBidWYgPSBCYXNlNThDaGVjay5kZWNvZGUoc3RyKTtcclxuICB0aGlzLmJ1ZiA9IGJ1ZjtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkJhc2U1OENoZWNrLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmJ1ZjtcclxufTtcclxuXHJcbkJhc2U1OENoZWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBCYXNlNThDaGVjay5lbmNvZGUodGhpcy5idWYpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlNThDaGVjaztcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/encoding/base58check.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/encoding/bech32.js":
/*!*********************************************!*\
  !*** ../bitcore-lib/lib/encoding/bech32.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar bech32 = __webpack_require__(/*! bech32 */ \"../bitcore-lib/node_modules/bech32/dist/index.js\");\r\n\r\n/**\r\n * Decode bech32/bech32m string\r\n * @param {String} str String to decode\r\n * @returns {Object} Decoded string info\r\n */\r\nvar decode = function(str) {\r\n  if (typeof str !== 'string') {\r\n    throw new Error('Input should be a string');\r\n  }\r\n\r\n  var decoded;\r\n  let fromWords = bech32.bech32.fromWords;\r\n  let encoding = encodings.BECH32;\r\n  try {\r\n    decoded = bech32.bech32.decode(str);\r\n  } catch (e) {\r\n    if (e.message.indexOf('Invalid checksum') > -1) {\r\n      decoded = bech32.bech32m.decode(str);\r\n      encoding = encodings.BECH32M;\r\n      fromWords = bech32.bech32m.fromWords;\r\n    } else {\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  const version = decoded.words[0];\r\n  if (version >= 1 && encoding !== encodings.BECH32M) {\r\n    throw new Error('Version 1+ witness address must use Bech32m checksum');\r\n  }\r\n\r\n  return {\r\n    prefix: decoded.prefix,\r\n    data: Buffer.from(fromWords(decoded.words.slice(1))),\r\n    version\r\n  };\r\n};\r\n\r\n/**\r\n * Encode using BECH32 encoding\r\n * @param {String} prefix bech32 prefix\r\n * @param {Number} version\r\n * @param {String|Buffer} data \r\n * @param {String|Number} encoding (optional, default=bech32) Valid encodings are 'bech32', 'bech32m', 0, and 1.\r\n * @returns {String} encoded string\r\n */\r\nvar encode = function(prefix, version, data, encoding) {\r\n\tif (typeof prefix !== 'string') {\r\n\t\tthrow new Error('Prefix should be a string');\r\n\t}\r\n\tif (typeof version !== 'number') {\r\n\t\tthrow new Error('version should be a number');\r\n\t}\r\n  // convert string to number\r\n  if (encoding && typeof encoding == 'string') {\r\n    encoding = encodings[encoding.toUpperCase()] || -1; // fallback to -1 so it throws invalid encoding below\r\n  }\r\n  if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {\r\n    throw new Error('Invalid encoding specified');\r\n  }\r\n  \r\n  let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;\r\n  let words = b32Variety.toWords(data);\r\n\r\n  words.unshift(version);\r\n\treturn b32Variety.encode(prefix, words);\r\n}\r\n\r\nconst encodings = {\r\n  BECH32: 1,\r\n  BECH32M: 2\r\n}\r\n\r\nmodule.exports = { decode: decode, encode: encode, encodings };\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2JlY2gzMi5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxnRUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9lbmNvZGluZy9iZWNoMzIuanM/ZmEzYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYmVjaDMyID0gcmVxdWlyZSgnYmVjaDMyJyk7XHJcblxyXG4vKipcclxuICogRGVjb2RlIGJlY2gzMi9iZWNoMzJtIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcclxuICogQHJldHVybnMge09iamVjdH0gRGVjb2RlZCBzdHJpbmcgaW5mb1xyXG4gKi9cclxudmFyIGRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcclxuICB9XHJcblxyXG4gIHZhciBkZWNvZGVkO1xyXG4gIGxldCBmcm9tV29yZHMgPSBiZWNoMzIuYmVjaDMyLmZyb21Xb3JkcztcclxuICBsZXQgZW5jb2RpbmcgPSBlbmNvZGluZ3MuQkVDSDMyO1xyXG4gIHRyeSB7XHJcbiAgICBkZWNvZGVkID0gYmVjaDMyLmJlY2gzMi5kZWNvZGUoc3RyKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAoZS5tZXNzYWdlLmluZGV4T2YoJ0ludmFsaWQgY2hlY2tzdW0nKSA+IC0xKSB7XHJcbiAgICAgIGRlY29kZWQgPSBiZWNoMzIuYmVjaDMybS5kZWNvZGUoc3RyKTtcclxuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZ3MuQkVDSDMyTTtcclxuICAgICAgZnJvbVdvcmRzID0gYmVjaDMyLmJlY2gzMm0uZnJvbVdvcmRzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHZlcnNpb24gPSBkZWNvZGVkLndvcmRzWzBdO1xyXG4gIGlmICh2ZXJzaW9uID49IDEgJiYgZW5jb2RpbmcgIT09IGVuY29kaW5ncy5CRUNIMzJNKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnNpb24gMSsgd2l0bmVzcyBhZGRyZXNzIG11c3QgdXNlIEJlY2gzMm0gY2hlY2tzdW0nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBwcmVmaXg6IGRlY29kZWQucHJlZml4LFxyXG4gICAgZGF0YTogQnVmZmVyLmZyb20oZnJvbVdvcmRzKGRlY29kZWQud29yZHMuc2xpY2UoMSkpKSxcclxuICAgIHZlcnNpb25cclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZSB1c2luZyBCRUNIMzIgZW5jb2RpbmdcclxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBiZWNoMzIgcHJlZml4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gZGF0YSBcclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBlbmNvZGluZyAob3B0aW9uYWwsIGRlZmF1bHQ9YmVjaDMyKSBWYWxpZCBlbmNvZGluZ3MgYXJlICdiZWNoMzInLCAnYmVjaDMybScsIDAsIGFuZCAxLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxudmFyIGVuY29kZSA9IGZ1bmN0aW9uKHByZWZpeCwgdmVyc2lvbiwgZGF0YSwgZW5jb2RpbmcpIHtcclxuXHRpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignUHJlZml4IHNob3VsZCBiZSBhIHN0cmluZycpO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHZlcnNpb24gIT09ICdudW1iZXInKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3ZlcnNpb24gc2hvdWxkIGJlIGEgbnVtYmVyJyk7XHJcblx0fVxyXG4gIC8vIGNvbnZlcnQgc3RyaW5nIHRvIG51bWJlclxyXG4gIGlmIChlbmNvZGluZyAmJiB0eXBlb2YgZW5jb2RpbmcgPT0gJ3N0cmluZycpIHtcclxuICAgIGVuY29kaW5nID0gZW5jb2RpbmdzW2VuY29kaW5nLnRvVXBwZXJDYXNlKCldIHx8IC0xOyAvLyBmYWxsYmFjayB0byAtMSBzbyBpdCB0aHJvd3MgaW52YWxpZCBlbmNvZGluZyBiZWxvd1xyXG4gIH1cclxuICBpZiAoZW5jb2RpbmcgJiYgIShlbmNvZGluZyA9PSBlbmNvZGluZ3MuQkVDSDMyIHx8IGVuY29kaW5nID09IGVuY29kaW5ncy5CRUNIMzJNKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nIHNwZWNpZmllZCcpO1xyXG4gIH1cclxuICBcclxuICBsZXQgYjMyVmFyaWV0eSA9IGVuY29kaW5nID09IGVuY29kaW5ncy5CRUNIMzJNID8gYmVjaDMyLmJlY2gzMm0gOiBiZWNoMzIuYmVjaDMyO1xyXG4gIGxldCB3b3JkcyA9IGIzMlZhcmlldHkudG9Xb3JkcyhkYXRhKTtcclxuXHJcbiAgd29yZHMudW5zaGlmdCh2ZXJzaW9uKTtcclxuXHRyZXR1cm4gYjMyVmFyaWV0eS5lbmNvZGUocHJlZml4LCB3b3Jkcyk7XHJcbn1cclxuXHJcbmNvbnN0IGVuY29kaW5ncyA9IHtcclxuICBCRUNIMzI6IDEsXHJcbiAgQkVDSDMyTTogMlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVjb2RlOiBkZWNvZGUsIGVuY29kZTogZW5jb2RlLCBlbmNvZGluZ3MgfTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/encoding/bech32.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/encoding/bufferreader.js":
/*!***************************************************!*\
  !*** ../bitcore-lib/lib/encoding/bufferreader.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\n\r\nvar BufferReader = function BufferReader(buf) {\r\n  if (!(this instanceof BufferReader)) {\r\n    return new BufferReader(buf);\r\n  }\r\n  if (_.isUndefined(buf)) {\r\n    return;\r\n  }\r\n  if (Buffer.isBuffer(buf)) {\r\n    this.set({\r\n      buf: buf\r\n    });\r\n  } else if (_.isString(buf)) {\r\n    this.set({\r\n      buf: Buffer.from(buf, 'hex'),\r\n    });\r\n  } else if (_.isObject(buf)) {\r\n    var obj = buf;\r\n    this.set(obj);\r\n  } else {\r\n    throw new TypeError('Unrecognized argument for BufferReader');\r\n  }\r\n};\r\n\r\nBufferReader.prototype.set = function(obj) {\r\n  this.buf = obj.buf || this.buf || undefined;\r\n  this.pos = obj.pos || this.pos || 0;\r\n  return this;\r\n};\r\n\r\nBufferReader.prototype.eof = function() {\r\n  if(this.buf) {\r\n    return this.pos >= this.buf.length;\r\n  } else {\r\n    return true;\r\n  }\r\n};\r\n\r\nBufferReader.prototype.finished = BufferReader.prototype.eof;\r\n\r\nBufferReader.prototype.read = function(len) {\r\n  $.checkArgument(!_.isUndefined(len), 'Must specify a length');\r\n  var buf = this.buf.slice(this.pos, this.pos + len);\r\n  this.pos = this.pos + len;\r\n  return buf;\r\n};\r\n\r\nBufferReader.prototype.readAll = function() {\r\n  var buf = this.buf.slice(this.pos, this.buf.length);\r\n  this.pos = this.buf.length;\r\n  return buf;\r\n};\r\n\r\nBufferReader.prototype.readUInt8 = function() {\r\n  var val = this.buf.readUInt8(this.pos);\r\n  this.pos = this.pos + 1;\r\n  return val;\r\n};\r\n\r\nBufferReader.prototype.readUInt16BE = function() {\r\n  var val = this.buf.readUInt16BE(this.pos);\r\n  this.pos = this.pos + 2;\r\n  return val;\r\n};\r\n\r\nBufferReader.prototype.readUInt16LE = function() {\r\n  var val = this.buf.readUInt16LE(this.pos);\r\n  this.pos = this.pos + 2;\r\n  return val;\r\n};\r\n\r\nBufferReader.prototype.readUInt32BE = function() {\r\n  var val = this.buf.readUInt32BE(this.pos);\r\n  this.pos = this.pos + 4;\r\n  return val;\r\n};\r\n\r\nBufferReader.prototype.readUInt32LE = function() {\r\n  var val = this.buf.readUInt32LE(this.pos);\r\n  this.pos = this.pos + 4;\r\n  return val;\r\n};\r\n\r\nBufferReader.prototype.readInt32LE = function() {\r\n  var val = this.buf.readInt32LE(this.pos);\r\n  this.pos = this.pos + 4;\r\n  return val;\r\n};\r\n\r\nBufferReader.prototype.readUInt64BEBN = function() {\r\n  var buf = this.buf.slice(this.pos, this.pos + 8);\r\n  var bn = BN.fromBuffer(buf);\r\n  this.pos = this.pos + 8;\r\n  return bn;\r\n};\r\n\r\nBufferReader.prototype.readUInt64LEBN = function() {\r\n  var second = this.buf.readUInt32LE(this.pos);\r\n  var first = this.buf.readUInt32LE(this.pos + 4);\r\n  var combined = (first * 0x100000000) + second;\r\n  // Instantiating an instance of BN with a number is faster than with an\r\n  // array or string. However, the maximum safe number for a double precision\r\n  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use\r\n  // non-floating point numbers less than this amount (52 bits). And in the case\r\n  // that the number is larger, we can instatiate an instance of BN by passing\r\n  // an array from the buffer (slower) and specifying the endianness.\r\n  var bn;\r\n  if (combined <= 0x1fffffffffffff) {\r\n    bn = new BN(combined);\r\n  } else {\r\n    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);\r\n    bn = new BN(data, 10, 'le');\r\n  }\r\n  this.pos = this.pos + 8;\r\n  return bn;\r\n};\r\n\r\nBufferReader.prototype.readVarintNum = function() {\r\n  var first = this.readUInt8();\r\n  switch (first) {\r\n    case 0xFD:\r\n      return this.readUInt16LE();\r\n    case 0xFE:\r\n      return this.readUInt32LE();\r\n    case 0xFF:\r\n      var bn = this.readUInt64LEBN();\r\n      var n = bn.toNumber();\r\n      if (n <= Math.pow(2, 53)) {\r\n        return n;\r\n      } else {\r\n        throw new Error('number too large to retain precision - use readVarintBN');\r\n      }\r\n      break;\r\n    default:\r\n      return first;\r\n  }\r\n};\r\n\r\n/**\r\n * reads a length prepended buffer\r\n */\r\nBufferReader.prototype.readVarLengthBuffer = function() {\r\n  var len = this.readVarintNum();\r\n  var buf = this.read(len);\r\n  $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' +\r\n    'Expected to read: ' + len + ' and read ' + buf.length);\r\n  return buf;\r\n};\r\n\r\nBufferReader.prototype.readVarintBuf = function() {\r\n  var first = this.buf.readUInt8(this.pos);\r\n  switch (first) {\r\n    case 0xFD:\r\n      return this.read(1 + 2);\r\n    case 0xFE:\r\n      return this.read(1 + 4);\r\n    case 0xFF:\r\n      return this.read(1 + 8);\r\n    default:\r\n      return this.read(1);\r\n  }\r\n};\r\n\r\nBufferReader.prototype.readVarintBN = function() {\r\n  var first = this.readUInt8();\r\n  switch (first) {\r\n    case 0xFD:\r\n      return new BN(this.readUInt16LE());\r\n    case 0xFE:\r\n      return new BN(this.readUInt32LE());\r\n    case 0xFF:\r\n      return this.readUInt64LEBN();\r\n    default:\r\n      return new BN(first);\r\n  }\r\n};\r\n\r\nBufferReader.prototype.reverse = function() {\r\n  var buf = Buffer.alloc(this.buf.length);\r\n  for (var i = 0; i < buf.length; i++) {\r\n    buf[i] = this.buf[this.buf.length - 1 - i];\r\n  }\r\n  this.buf = buf;\r\n  return this;\r\n};\r\n\r\nBufferReader.prototype.readReverse = function(len) {\r\n  if (_.isUndefined(len)) {\r\n    len = this.buf.length;\r\n  }\r\n  var buf = this.buf.slice(this.pos, this.pos + len);\r\n  this.pos = this.pos + len;\r\n  return BufferUtil.reverse(buf);\r\n};\r\n\r\nmodule.exports = BufferReader;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2J1ZmZlcnJlYWRlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMsdUVBQXVCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHlEQUFnQjtBQUN6QyxTQUFTLG1CQUFPLENBQUMscURBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBTTtBQUNaO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9lbmNvZGluZy9idWZmZXJyZWFkZXIuanM/NzcxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XHJcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xyXG5cclxudmFyIEJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWYpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyUmVhZGVyKSkge1xyXG4gICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIoYnVmKTtcclxuICB9XHJcbiAgaWYgKF8uaXNVbmRlZmluZWQoYnVmKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcclxuICAgIHRoaXMuc2V0KHtcclxuICAgICAgYnVmOiBidWZcclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhidWYpKSB7XHJcbiAgICB0aGlzLnNldCh7XHJcbiAgICAgIGJ1ZjogQnVmZmVyLmZyb20oYnVmLCAnaGV4JyksXHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYnVmKSkge1xyXG4gICAgdmFyIG9iaiA9IGJ1ZjtcclxuICAgIHRoaXMuc2V0KG9iaik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVjb2duaXplZCBhcmd1bWVudCBmb3IgQnVmZmVyUmVhZGVyJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvYmopIHtcclxuICB0aGlzLmJ1ZiA9IG9iai5idWYgfHwgdGhpcy5idWYgfHwgdW5kZWZpbmVkO1xyXG4gIHRoaXMucG9zID0gb2JqLnBvcyB8fCB0aGlzLnBvcyB8fCAwO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5lb2YgPSBmdW5jdGlvbigpIHtcclxuICBpZih0aGlzLmJ1Zikge1xyXG4gICAgcmV0dXJuIHRoaXMucG9zID49IHRoaXMuYnVmLmxlbmd0aDtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59O1xyXG5cclxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5maW5pc2hlZCA9IEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuZW9mO1xyXG5cclxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obGVuKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KCFfLmlzVW5kZWZpbmVkKGxlbiksICdNdXN0IHNwZWNpZnkgYSBsZW5ndGgnKTtcclxuICB2YXIgYnVmID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgbGVuKTtcclxuICB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuO1xyXG4gIHJldHVybiBidWY7XHJcbn07XHJcblxyXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRBbGwgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgYnVmID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIHRoaXMuYnVmLmxlbmd0aCk7XHJcbiAgdGhpcy5wb3MgPSB0aGlzLmJ1Zi5sZW5ndGg7XHJcbiAgcmV0dXJuIGJ1ZjtcclxufTtcclxuXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50OCh0aGlzLnBvcyk7XHJcbiAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDE7XHJcbiAgcmV0dXJuIHZhbDtcclxufTtcclxuXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MTZCRSh0aGlzLnBvcyk7XHJcbiAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDI7XHJcbiAgcmV0dXJuIHZhbDtcclxufTtcclxuXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MTZMRSh0aGlzLnBvcyk7XHJcbiAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDI7XHJcbiAgcmV0dXJuIHZhbDtcclxufTtcclxuXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJCRSh0aGlzLnBvcyk7XHJcbiAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDQ7XHJcbiAgcmV0dXJuIHZhbDtcclxufTtcclxuXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XHJcbiAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDQ7XHJcbiAgcmV0dXJuIHZhbDtcclxufTtcclxuXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MpO1xyXG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyA0O1xyXG4gIHJldHVybiB2YWw7XHJcbn07XHJcblxyXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRVSW50NjRCRUJOID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGJ1ZiA9IHRoaXMuYnVmLnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIDgpO1xyXG4gIHZhciBibiA9IEJOLmZyb21CdWZmZXIoYnVmKTtcclxuICB0aGlzLnBvcyA9IHRoaXMucG9zICsgODtcclxuICByZXR1cm4gYm47XHJcbn07XHJcblxyXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRVSW50NjRMRUJOID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHNlY29uZCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XHJcbiAgdmFyIGZpcnN0ID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCk7XHJcbiAgdmFyIGNvbWJpbmVkID0gKGZpcnN0ICogMHgxMDAwMDAwMDApICsgc2Vjb25kO1xyXG4gIC8vIEluc3RhbnRpYXRpbmcgYW4gaW5zdGFuY2Ugb2YgQk4gd2l0aCBhIG51bWJlciBpcyBmYXN0ZXIgdGhhbiB3aXRoIGFuXHJcbiAgLy8gYXJyYXkgb3Igc3RyaW5nLiBIb3dldmVyLCB0aGUgbWF4aW11bSBzYWZlIG51bWJlciBmb3IgYSBkb3VibGUgcHJlY2lzaW9uXHJcbiAgLy8gZmxvYXRpbmcgcG9pbnQgaXMgMiBeIDUyIC0gMSAoMHgxZmZmZmZmZmZmZmZmZiksIHRodXMgd2UgY2FuIHNhZmVseSB1c2VcclxuICAvLyBub24tZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBsZXNzIHRoYW4gdGhpcyBhbW91bnQgKDUyIGJpdHMpLiBBbmQgaW4gdGhlIGNhc2VcclxuICAvLyB0aGF0IHRoZSBudW1iZXIgaXMgbGFyZ2VyLCB3ZSBjYW4gaW5zdGF0aWF0ZSBhbiBpbnN0YW5jZSBvZiBCTiBieSBwYXNzaW5nXHJcbiAgLy8gYW4gYXJyYXkgZnJvbSB0aGUgYnVmZmVyIChzbG93ZXIpIGFuZCBzcGVjaWZ5aW5nIHRoZSBlbmRpYW5uZXNzLlxyXG4gIHZhciBibjtcclxuICBpZiAoY29tYmluZWQgPD0gMHgxZmZmZmZmZmZmZmZmZikge1xyXG4gICAgYm4gPSBuZXcgQk4oY29tYmluZWQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuYnVmLCB0aGlzLnBvcywgdGhpcy5wb3MgKyA4KTtcclxuICAgIGJuID0gbmV3IEJOKGRhdGEsIDEwLCAnbGUnKTtcclxuICB9XHJcbiAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDg7XHJcbiAgcmV0dXJuIGJuO1xyXG59O1xyXG5cclxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVmFyaW50TnVtID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGZpcnN0ID0gdGhpcy5yZWFkVUludDgoKTtcclxuICBzd2l0Y2ggKGZpcnN0KSB7XHJcbiAgICBjYXNlIDB4RkQ6XHJcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVSW50MTZMRSgpO1xyXG4gICAgY2FzZSAweEZFOlxyXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVUludDMyTEUoKTtcclxuICAgIGNhc2UgMHhGRjpcclxuICAgICAgdmFyIGJuID0gdGhpcy5yZWFkVUludDY0TEVCTigpO1xyXG4gICAgICB2YXIgbiA9IGJuLnRvTnVtYmVyKCk7XHJcbiAgICAgIGlmIChuIDw9IE1hdGgucG93KDIsIDUzKSkge1xyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIHRvbyBsYXJnZSB0byByZXRhaW4gcHJlY2lzaW9uIC0gdXNlIHJlYWRWYXJpbnRCTicpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZpcnN0O1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiByZWFkcyBhIGxlbmd0aCBwcmVwZW5kZWQgYnVmZmVyXHJcbiAqL1xyXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRWYXJMZW5ndGhCdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgbGVuID0gdGhpcy5yZWFkVmFyaW50TnVtKCk7XHJcbiAgdmFyIGJ1ZiA9IHRoaXMucmVhZChsZW4pO1xyXG4gICQuY2hlY2tTdGF0ZShidWYubGVuZ3RoID09PSBsZW4sICdJbnZhbGlkIGxlbmd0aCB3aGlsZSByZWFkaW5nIHZhcmxlbmd0aCBidWZmZXIuICcgK1xyXG4gICAgJ0V4cGVjdGVkIHRvIHJlYWQ6ICcgKyBsZW4gKyAnIGFuZCByZWFkICcgKyBidWYubGVuZ3RoKTtcclxuICByZXR1cm4gYnVmO1xyXG59O1xyXG5cclxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVmFyaW50QnVmID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGZpcnN0ID0gdGhpcy5idWYucmVhZFVJbnQ4KHRoaXMucG9zKTtcclxuICBzd2l0Y2ggKGZpcnN0KSB7XHJcbiAgICBjYXNlIDB4RkQ6XHJcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoMSArIDIpO1xyXG4gICAgY2FzZSAweEZFOlxyXG4gICAgICByZXR1cm4gdGhpcy5yZWFkKDEgKyA0KTtcclxuICAgIGNhc2UgMHhGRjpcclxuICAgICAgcmV0dXJuIHRoaXMucmVhZCgxICsgOCk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gdGhpcy5yZWFkKDEpO1xyXG4gIH1cclxufTtcclxuXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZFZhcmludEJOID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGZpcnN0ID0gdGhpcy5yZWFkVUludDgoKTtcclxuICBzd2l0Y2ggKGZpcnN0KSB7XHJcbiAgICBjYXNlIDB4RkQ6XHJcbiAgICAgIHJldHVybiBuZXcgQk4odGhpcy5yZWFkVUludDE2TEUoKSk7XHJcbiAgICBjYXNlIDB4RkU6XHJcbiAgICAgIHJldHVybiBuZXcgQk4odGhpcy5yZWFkVUludDMyTEUoKSk7XHJcbiAgICBjYXNlIDB4RkY6XHJcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVSW50NjRMRUJOKCk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gbmV3IEJOKGZpcnN0KTtcclxuICB9XHJcbn07XHJcblxyXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKHRoaXMuYnVmLmxlbmd0aCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcclxuICAgIGJ1ZltpXSA9IHRoaXMuYnVmW3RoaXMuYnVmLmxlbmd0aCAtIDEgLSBpXTtcclxuICB9XHJcbiAgdGhpcy5idWYgPSBidWY7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRSZXZlcnNlID0gZnVuY3Rpb24obGVuKSB7XHJcbiAgaWYgKF8uaXNVbmRlZmluZWQobGVuKSkge1xyXG4gICAgbGVuID0gdGhpcy5idWYubGVuZ3RoO1xyXG4gIH1cclxuICB2YXIgYnVmID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgbGVuKTtcclxuICB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuO1xyXG4gIHJldHVybiBCdWZmZXJVdGlsLnJldmVyc2UoYnVmKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/encoding/bufferreader.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/encoding/bufferwriter.js":
/*!***************************************************!*\
  !*** ../bitcore-lib/lib/encoding/bufferwriter.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar bufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar assert = __webpack_require__(/*! assert */ \"assert\");\r\n\r\nvar BufferWriter = function BufferWriter(obj) {\r\n  if (!(this instanceof BufferWriter))\r\n    return new BufferWriter(obj);\r\n  this.bufLen = 0;\r\n  if (obj)\r\n    this.set(obj);\r\n  else\r\n    this.bufs = [];\r\n};\r\n\r\nBufferWriter.prototype.set = function(obj) {\r\n  this.bufs = obj.bufs || this.bufs || [];\r\n  this.bufLen = this.bufs.reduce(function(prev, buf){ return prev + buf.length; }, 0);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.toBuffer = function() {\r\n  return this.concat();\r\n};\r\n\r\nBufferWriter.prototype.concat = function() {\r\n  return Buffer.concat(this.bufs, this.bufLen);\r\n};\r\n\r\nBufferWriter.prototype.write = function(buf) {\r\n  assert(bufferUtil.isBuffer(buf));\r\n  this.bufs.push(buf);\r\n  this.bufLen += buf.length;\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeReverse = function(buf) {\r\n  assert(bufferUtil.isBuffer(buf));\r\n  this.bufs.push(bufferUtil.reverse(buf));\r\n  this.bufLen += buf.length;\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeUInt8 = function(n) {\r\n  if (n < 0) {\r\n    n = n >>> 0; // Convert signed int to unsigned int\r\n  }\r\n  var buf = Buffer.alloc(1);\r\n  buf.writeUInt8(n, 0);\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeUInt16BE = function(n) {\r\n  if (n < 0) {\r\n    n = n >>> 0; // Convert signed int to unsigned int\r\n  }\r\n  var buf = Buffer.alloc(2);\r\n  buf.writeUInt16BE(n, 0);\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeUInt16LE = function(n) {\r\n  if (n < 0) {\r\n    n = n >>> 0; // Convert signed int to unsigned int\r\n  }\r\n  var buf = Buffer.alloc(2);\r\n  buf.writeUInt16LE(n, 0);\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeUInt32BE = function(n) {\r\n  if (n < 0) {\r\n    n = n >>> 0; // Convert signed int to unsigned int\r\n  }\r\n  var buf = Buffer.alloc(4);\r\n  buf.writeUInt32BE(n, 0);\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeInt32LE = function(n) {\r\n  var buf = Buffer.alloc(4);\r\n  buf.writeInt32LE(n, 0);\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeUInt32LE = function(n) {\r\n  if (n < 0) {\r\n    n = n >>> 0; // Convert signed int to unsigned int\r\n  }\r\n  var buf = Buffer.alloc(4);\r\n  buf.writeUInt32LE(n, 0);\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeUInt64BEBN = function(bn) {\r\n  var buf = bn.toBuffer({size: 8});\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeUInt64LEBN = function(bn) {\r\n  var buf = bn.toBuffer({size: 8});\r\n  this.writeReverse(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeVarintNum = function(n) {\r\n  var buf = BufferWriter.varintBufNum(n);\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.prototype.writeVarintBN = function(bn) {\r\n  var buf = BufferWriter.varintBufBN(bn);\r\n  this.write(buf);\r\n  return this;\r\n};\r\n\r\nBufferWriter.varintBufNum = function(n) {\r\n  var buf = undefined;\r\n  if (n < 253) {\r\n    buf = Buffer.alloc(1);\r\n    buf.writeUInt8(n, 0);\r\n  } else if (n < 0x10000) {\r\n    buf = Buffer.alloc(1 + 2);\r\n    buf.writeUInt8(253, 0);\r\n    buf.writeUInt16LE(n, 1);\r\n  } else if (n < 0x100000000) {\r\n    buf = Buffer.alloc(1 + 4);\r\n    buf.writeUInt8(254, 0);\r\n    buf.writeUInt32LE(n, 1);\r\n  } else {\r\n    buf = Buffer.alloc(1 + 8);\r\n    buf.writeUInt8(255, 0);\r\n    buf.writeInt32LE(n & -1, 1);\r\n    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);\r\n  }\r\n  return buf;\r\n};\r\n\r\nBufferWriter.varintBufBN = function(bn) {\r\n  var buf = undefined;\r\n  var n = bn.toNumber();\r\n  if (n < 253) {\r\n    buf = Buffer.alloc(1);\r\n    buf.writeUInt8(n, 0);\r\n  } else if (n < 0x10000) {\r\n    buf = Buffer.alloc(1 + 2);\r\n    buf.writeUInt8(253, 0);\r\n    buf.writeUInt16LE(n, 1);\r\n  } else if (n < 0x100000000) {\r\n    buf = Buffer.alloc(1 + 4);\r\n    buf.writeUInt8(254, 0);\r\n    buf.writeUInt32LE(n, 1);\r\n  } else {\r\n    var bw = new BufferWriter();\r\n    bw.writeUInt8(255);\r\n    bw.writeUInt64LEBN(bn);\r\n    var buf = bw.concat();\r\n  }\r\n  return buf;\r\n};\r\n\r\nmodule.exports = BufferWriter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2J1ZmZlcndyaXRlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHlEQUFnQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMkJBQTJCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBLElBQUk7QUFDSixVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBLElBQUk7QUFDSixVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9lbmNvZGluZy9idWZmZXJ3cml0ZXIuanM/NGRlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcclxuXHJcbnZhciBCdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiBCdWZmZXJXcml0ZXIob2JqKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcldyaXRlcikpXHJcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcihvYmopO1xyXG4gIHRoaXMuYnVmTGVuID0gMDtcclxuICBpZiAob2JqKVxyXG4gICAgdGhpcy5zZXQob2JqKTtcclxuICBlbHNlXHJcbiAgICB0aGlzLmJ1ZnMgPSBbXTtcclxufTtcclxuXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgdGhpcy5idWZzID0gb2JqLmJ1ZnMgfHwgdGhpcy5idWZzIHx8IFtdO1xyXG4gIHRoaXMuYnVmTGVuID0gdGhpcy5idWZzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBidWYpeyByZXR1cm4gcHJldiArIGJ1Zi5sZW5ndGg7IH0sIDApO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmNvbmNhdCgpO1xyXG59O1xyXG5cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZnMsIHRoaXMuYnVmTGVuKTtcclxufTtcclxuXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWYpIHtcclxuICBhc3NlcnQoYnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpKTtcclxuICB0aGlzLmJ1ZnMucHVzaChidWYpO1xyXG4gIHRoaXMuYnVmTGVuICs9IGJ1Zi5sZW5ndGg7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlUmV2ZXJzZSA9IGZ1bmN0aW9uKGJ1Zikge1xyXG4gIGFzc2VydChidWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZikpO1xyXG4gIHRoaXMuYnVmcy5wdXNoKGJ1ZmZlclV0aWwucmV2ZXJzZShidWYpKTtcclxuICB0aGlzLmJ1ZkxlbiArPSBidWYubGVuZ3RoO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24obikge1xyXG4gIGlmIChuIDwgMCkge1xyXG4gICAgbiA9IG4gPj4+IDA7IC8vIENvbnZlcnQgc2lnbmVkIGludCB0byB1bnNpZ25lZCBpbnRcclxuICB9XHJcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcclxuICBidWYud3JpdGVVSW50OChuLCAwKTtcclxuICB0aGlzLndyaXRlKGJ1Zik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbihuKSB7XHJcbiAgaWYgKG4gPCAwKSB7XHJcbiAgICBuID0gbiA+Pj4gMDsgLy8gQ29udmVydCBzaWduZWQgaW50IHRvIHVuc2lnbmVkIGludFxyXG4gIH1cclxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDIpO1xyXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKG4sIDApO1xyXG4gIHRoaXMud3JpdGUoYnVmKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uKG4pIHtcclxuICBpZiAobiA8IDApIHtcclxuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XHJcbiAgfVxyXG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoMik7XHJcbiAgYnVmLndyaXRlVUludDE2TEUobiwgMCk7XHJcbiAgdGhpcy53cml0ZShidWYpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24obikge1xyXG4gIGlmIChuIDwgMCkge1xyXG4gICAgbiA9IG4gPj4+IDA7IC8vIENvbnZlcnQgc2lnbmVkIGludCB0byB1bnNpZ25lZCBpbnRcclxuICB9XHJcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcclxuICBidWYud3JpdGVVSW50MzJCRShuLCAwKTtcclxuICB0aGlzLndyaXRlKGJ1Zik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKG4pIHtcclxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDQpO1xyXG4gIGJ1Zi53cml0ZUludDMyTEUobiwgMCk7XHJcbiAgdGhpcy53cml0ZShidWYpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24obikge1xyXG4gIGlmIChuIDwgMCkge1xyXG4gICAgbiA9IG4gPj4+IDA7IC8vIENvbnZlcnQgc2lnbmVkIGludCB0byB1bnNpZ25lZCBpbnRcclxuICB9XHJcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcclxuICBidWYud3JpdGVVSW50MzJMRShuLCAwKTtcclxuICB0aGlzLndyaXRlKGJ1Zik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDY0QkVCTiA9IGZ1bmN0aW9uKGJuKSB7XHJcbiAgdmFyIGJ1ZiA9IGJuLnRvQnVmZmVyKHtzaXplOiA4fSk7XHJcbiAgdGhpcy53cml0ZShidWYpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQ2NExFQk4gPSBmdW5jdGlvbihibikge1xyXG4gIHZhciBidWYgPSBibi50b0J1ZmZlcih7c2l6ZTogOH0pO1xyXG4gIHRoaXMud3JpdGVSZXZlcnNlKGJ1Zik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVmFyaW50TnVtID0gZnVuY3Rpb24obikge1xyXG4gIHZhciBidWYgPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKG4pO1xyXG4gIHRoaXMud3JpdGUoYnVmKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVWYXJpbnRCTiA9IGZ1bmN0aW9uKGJuKSB7XHJcbiAgdmFyIGJ1ZiA9IEJ1ZmZlcldyaXRlci52YXJpbnRCdWZCTihibik7XHJcbiAgdGhpcy53cml0ZShidWYpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQnVmZmVyV3JpdGVyLnZhcmludEJ1Zk51bSA9IGZ1bmN0aW9uKG4pIHtcclxuICB2YXIgYnVmID0gdW5kZWZpbmVkO1xyXG4gIGlmIChuIDwgMjUzKSB7XHJcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSk7XHJcbiAgICBidWYud3JpdGVVSW50OChuLCAwKTtcclxuICB9IGVsc2UgaWYgKG4gPCAweDEwMDAwKSB7XHJcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSArIDIpO1xyXG4gICAgYnVmLndyaXRlVUludDgoMjUzLCAwKTtcclxuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKG4sIDEpO1xyXG4gIH0gZWxzZSBpZiAobiA8IDB4MTAwMDAwMDAwKSB7XHJcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSArIDQpO1xyXG4gICAgYnVmLndyaXRlVUludDgoMjU0LCAwKTtcclxuICAgIGJ1Zi53cml0ZVVJbnQzMkxFKG4sIDEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSArIDgpO1xyXG4gICAgYnVmLndyaXRlVUludDgoMjU1LCAwKTtcclxuICAgIGJ1Zi53cml0ZUludDMyTEUobiAmIC0xLCAxKTtcclxuICAgIGJ1Zi53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IobiAvIDB4MTAwMDAwMDAwKSwgNSk7XHJcbiAgfVxyXG4gIHJldHVybiBidWY7XHJcbn07XHJcblxyXG5CdWZmZXJXcml0ZXIudmFyaW50QnVmQk4gPSBmdW5jdGlvbihibikge1xyXG4gIHZhciBidWYgPSB1bmRlZmluZWQ7XHJcbiAgdmFyIG4gPSBibi50b051bWJlcigpO1xyXG4gIGlmIChuIDwgMjUzKSB7XHJcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSk7XHJcbiAgICBidWYud3JpdGVVSW50OChuLCAwKTtcclxuICB9IGVsc2UgaWYgKG4gPCAweDEwMDAwKSB7XHJcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSArIDIpO1xyXG4gICAgYnVmLndyaXRlVUludDgoMjUzLCAwKTtcclxuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKG4sIDEpO1xyXG4gIH0gZWxzZSBpZiAobiA8IDB4MTAwMDAwMDAwKSB7XHJcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSArIDQpO1xyXG4gICAgYnVmLndyaXRlVUludDgoMjU0LCAwKTtcclxuICAgIGJ1Zi53cml0ZVVJbnQzMkxFKG4sIDEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XHJcbiAgICBidy53cml0ZVVJbnQ4KDI1NSk7XHJcbiAgICBidy53cml0ZVVJbnQ2NExFQk4oYm4pO1xyXG4gICAgdmFyIGJ1ZiA9IGJ3LmNvbmNhdCgpO1xyXG4gIH1cclxuICByZXR1cm4gYnVmO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/encoding/bufferwriter.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/encoding/varint.js":
/*!*********************************************!*\
  !*** ../bitcore-lib/lib/encoding/varint.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar BufferWriter = __webpack_require__(/*! ./bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar BufferReader = __webpack_require__(/*! ./bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\n\r\nvar Varint = function Varint(buf) {\r\n  if (!(this instanceof Varint))\r\n    return new Varint(buf);\r\n  if (Buffer.isBuffer(buf)) {\r\n    this.buf = buf;\r\n  } else if (typeof buf === 'number') {\r\n    var num = buf;\r\n    this.fromNumber(num);\r\n  } else if (buf instanceof BN) {\r\n    var bn = buf;\r\n    this.fromBN(bn);\r\n  } else if (buf) {\r\n    var obj = buf;\r\n    this.set(obj);\r\n  }\r\n};\r\n\r\nVarint.prototype.set = function(obj) {\r\n  this.buf = obj.buf || this.buf;\r\n  return this;\r\n};\r\n\r\nVarint.prototype.fromString = function(str) {\r\n  this.set({\r\n    buf: Buffer.from(str, 'hex')\r\n  });\r\n  return this;\r\n};\r\n\r\nVarint.prototype.toString = function() {\r\n  return this.buf.toString('hex');\r\n};\r\n\r\nVarint.prototype.fromBuffer = function(buf) {\r\n  this.buf = buf;\r\n  return this;\r\n};\r\n\r\nVarint.prototype.fromBufferReader = function(br) {\r\n  this.buf = br.readVarintBuf();\r\n  return this;\r\n};\r\n\r\nVarint.prototype.fromBN = function(bn) {\r\n  this.buf = BufferWriter().writeVarintBN(bn).concat();\r\n  return this;\r\n};\r\n\r\nVarint.prototype.fromNumber = function(num) {\r\n  this.buf = BufferWriter().writeVarintNum(num).concat();\r\n  return this;\r\n};\r\n\r\nVarint.prototype.toBuffer = function() {\r\n  return this.buf;\r\n};\r\n\r\nVarint.prototype.toBN = function() {\r\n  return BufferReader(this.buf).readVarintBN();\r\n};\r\n\r\nVarint.prototype.toNumber = function() {\r\n  return BufferReader(this.buf).readVarintNum();\r\n};\r\n\r\nmodule.exports = Varint;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2VuY29kaW5nL3ZhcmludC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLG1FQUFnQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDM0MsU0FBUyxtQkFBTyxDQUFDLHFEQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFNO0FBQ1o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL2VuY29kaW5nL3ZhcmludC5qcz8zYjUwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuL2J1ZmZlcndyaXRlcicpO1xyXG52YXIgQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9idWZmZXJyZWFkZXInKTtcclxudmFyIEJOID0gcmVxdWlyZSgnLi4vY3J5cHRvL2JuJyk7XHJcblxyXG52YXIgVmFyaW50ID0gZnVuY3Rpb24gVmFyaW50KGJ1Zikge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWYXJpbnQpKVxyXG4gICAgcmV0dXJuIG5ldyBWYXJpbnQoYnVmKTtcclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcclxuICAgIHRoaXMuYnVmID0gYnVmO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ1ZiA9PT0gJ251bWJlcicpIHtcclxuICAgIHZhciBudW0gPSBidWY7XHJcbiAgICB0aGlzLmZyb21OdW1iZXIobnVtKTtcclxuICB9IGVsc2UgaWYgKGJ1ZiBpbnN0YW5jZW9mIEJOKSB7XHJcbiAgICB2YXIgYm4gPSBidWY7XHJcbiAgICB0aGlzLmZyb21CTihibik7XHJcbiAgfSBlbHNlIGlmIChidWYpIHtcclxuICAgIHZhciBvYmogPSBidWY7XHJcbiAgICB0aGlzLnNldChvYmopO1xyXG4gIH1cclxufTtcclxuXHJcblZhcmludC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgdGhpcy5idWYgPSBvYmouYnVmIHx8IHRoaXMuYnVmO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVmFyaW50LnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgdGhpcy5zZXQoe1xyXG4gICAgYnVmOiBCdWZmZXIuZnJvbShzdHIsICdoZXgnKVxyXG4gIH0pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVmFyaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmJ1Zi50b1N0cmluZygnaGV4Jyk7XHJcbn07XHJcblxyXG5WYXJpbnQucHJvdG90eXBlLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcclxuICB0aGlzLmJ1ZiA9IGJ1ZjtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblZhcmludC5wcm90b3R5cGUuZnJvbUJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uKGJyKSB7XHJcbiAgdGhpcy5idWYgPSBici5yZWFkVmFyaW50QnVmKCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5WYXJpbnQucHJvdG90eXBlLmZyb21CTiA9IGZ1bmN0aW9uKGJuKSB7XHJcbiAgdGhpcy5idWYgPSBCdWZmZXJXcml0ZXIoKS53cml0ZVZhcmludEJOKGJuKS5jb25jYXQoKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblZhcmludC5wcm90b3R5cGUuZnJvbU51bWJlciA9IGZ1bmN0aW9uKG51bSkge1xyXG4gIHRoaXMuYnVmID0gQnVmZmVyV3JpdGVyKCkud3JpdGVWYXJpbnROdW0obnVtKS5jb25jYXQoKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblZhcmludC5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5idWY7XHJcbn07XHJcblxyXG5WYXJpbnQucHJvdG90eXBlLnRvQk4gPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gQnVmZmVyUmVhZGVyKHRoaXMuYnVmKS5yZWFkVmFyaW50Qk4oKTtcclxufTtcclxuXHJcblZhcmludC5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gQnVmZmVyUmVhZGVyKHRoaXMuYnVmKS5yZWFkVmFyaW50TnVtKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZhcmludDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/encoding/varint.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/errors/index.js":
/*!******************************************!*\
  !*** ../bitcore-lib/lib/errors/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\nfunction format(message, args) {\r\n  return message\r\n    .replace('{0}', args[0])\r\n    .replace('{1}', args[1])\r\n    .replace('{2}', args[2]);\r\n}\r\nvar traverseNode = function(parent, errorDefinition) {\r\n  var NodeError = function() {\r\n    if (_.isString(errorDefinition.message)) {\r\n      this.message = format(errorDefinition.message, arguments);\r\n    } else if (_.isFunction(errorDefinition.message)) {\r\n      this.message = errorDefinition.message.apply(null, arguments);\r\n    } else {\r\n      throw new Error('Invalid error definition for ' + errorDefinition.name);\r\n    }\r\n    this.stack = this.message + '\\n' + (new Error()).stack;\r\n  };\r\n  NodeError.prototype = Object.create(parent.prototype);\r\n  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;\r\n  parent[errorDefinition.name] = NodeError;\r\n  if (errorDefinition.errors) {\r\n    childDefinitions(NodeError, errorDefinition.errors);\r\n  }\r\n  return NodeError;\r\n};\r\n\r\n/* jshint latedef: false */\r\nvar childDefinitions = function(parent, childDefinitions) {\r\n  _.each(childDefinitions, function(childDefinition) {\r\n    traverseNode(parent, childDefinition);\r\n  });\r\n};\r\n/* jshint latedef: true */\r\n\r\nvar traverseRoot = function(parent, errorsDefinition) {\r\n  childDefinitions(parent, errorsDefinition);\r\n  return parent;\r\n};\r\n\r\n\r\nvar bitcore = {};\r\nbitcore.Error = function() {\r\n  this.message = 'Internal error';\r\n  this.stack = this.message + '\\n' + (new Error()).stack;\r\n};\r\nbitcore.Error.prototype = Object.create(Error.prototype);\r\nbitcore.Error.prototype.name = 'bitcore.Error';\r\n\r\n\r\nvar data = __webpack_require__(/*! ./spec */ \"../bitcore-lib/lib/errors/spec.js\");\r\ntraverseRoot(bitcore.Error, data);\r\n\r\nmodule.exports = bitcore.Error;\r\n\r\nmodule.exports.extend = function(spec) {\r\n  return traverseNode(bitcore.Error, spec);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2Vycm9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLDREQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsaURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL2Vycm9ycy9pbmRleC5qcz9hOGYxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG5mdW5jdGlvbiBmb3JtYXQobWVzc2FnZSwgYXJncykge1xyXG4gIHJldHVybiBtZXNzYWdlXHJcbiAgICAucmVwbGFjZSgnezB9JywgYXJnc1swXSlcclxuICAgIC5yZXBsYWNlKCd7MX0nLCBhcmdzWzFdKVxyXG4gICAgLnJlcGxhY2UoJ3syfScsIGFyZ3NbMl0pO1xyXG59XHJcbnZhciB0cmF2ZXJzZU5vZGUgPSBmdW5jdGlvbihwYXJlbnQsIGVycm9yRGVmaW5pdGlvbikge1xyXG4gIHZhciBOb2RlRXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmIChfLmlzU3RyaW5nKGVycm9yRGVmaW5pdGlvbi5tZXNzYWdlKSkge1xyXG4gICAgICB0aGlzLm1lc3NhZ2UgPSBmb3JtYXQoZXJyb3JEZWZpbml0aW9uLm1lc3NhZ2UsIGFyZ3VtZW50cyk7XHJcbiAgICB9IGVsc2UgaWYgKF8uaXNGdW5jdGlvbihlcnJvckRlZmluaXRpb24ubWVzc2FnZSkpIHtcclxuICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JEZWZpbml0aW9uLm1lc3NhZ2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlcnJvciBkZWZpbml0aW9uIGZvciAnICsgZXJyb3JEZWZpbml0aW9uLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdGFjayA9IHRoaXMubWVzc2FnZSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjaztcclxuICB9O1xyXG4gIE5vZGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xyXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IHBhcmVudC5wcm90b3R5cGUubmFtZSArIGVycm9yRGVmaW5pdGlvbi5uYW1lO1xyXG4gIHBhcmVudFtlcnJvckRlZmluaXRpb24ubmFtZV0gPSBOb2RlRXJyb3I7XHJcbiAgaWYgKGVycm9yRGVmaW5pdGlvbi5lcnJvcnMpIHtcclxuICAgIGNoaWxkRGVmaW5pdGlvbnMoTm9kZUVycm9yLCBlcnJvckRlZmluaXRpb24uZXJyb3JzKTtcclxuICB9XHJcbiAgcmV0dXJuIE5vZGVFcnJvcjtcclxufTtcclxuXHJcbi8qIGpzaGludCBsYXRlZGVmOiBmYWxzZSAqL1xyXG52YXIgY2hpbGREZWZpbml0aW9ucyA9IGZ1bmN0aW9uKHBhcmVudCwgY2hpbGREZWZpbml0aW9ucykge1xyXG4gIF8uZWFjaChjaGlsZERlZmluaXRpb25zLCBmdW5jdGlvbihjaGlsZERlZmluaXRpb24pIHtcclxuICAgIHRyYXZlcnNlTm9kZShwYXJlbnQsIGNoaWxkRGVmaW5pdGlvbik7XHJcbiAgfSk7XHJcbn07XHJcbi8qIGpzaGludCBsYXRlZGVmOiB0cnVlICovXHJcblxyXG52YXIgdHJhdmVyc2VSb290ID0gZnVuY3Rpb24ocGFyZW50LCBlcnJvcnNEZWZpbml0aW9uKSB7XHJcbiAgY2hpbGREZWZpbml0aW9ucyhwYXJlbnQsIGVycm9yc0RlZmluaXRpb24pO1xyXG4gIHJldHVybiBwYXJlbnQ7XHJcbn07XHJcblxyXG5cclxudmFyIGJpdGNvcmUgPSB7fTtcclxuYml0Y29yZS5FcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMubWVzc2FnZSA9ICdJbnRlcm5hbCBlcnJvcic7XHJcbiAgdGhpcy5zdGFjayA9IHRoaXMubWVzc2FnZSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjaztcclxufTtcclxuYml0Y29yZS5FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcbmJpdGNvcmUuRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnYml0Y29yZS5FcnJvcic7XHJcblxyXG5cclxudmFyIGRhdGEgPSByZXF1aXJlKCcuL3NwZWMnKTtcclxudHJhdmVyc2VSb290KGJpdGNvcmUuRXJyb3IsIGRhdGEpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBiaXRjb3JlLkVycm9yO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oc3BlYykge1xyXG4gIHJldHVybiB0cmF2ZXJzZU5vZGUoYml0Y29yZS5FcnJvciwgc3BlYyk7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/errors/index.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/errors/spec.js":
/*!*****************************************!*\
  !*** ../bitcore-lib/lib/errors/spec.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nvar docsURL = 'http://bitcore.io/';\r\n\r\nmodule.exports = [{\r\n  name: 'InvalidB58Char',\r\n  message: 'Invalid Base58 character: {0} in {1}'\r\n}, {\r\n  name: 'InvalidB58Checksum',\r\n  message: 'Invalid Base58 checksum for {0}'\r\n}, {\r\n  name: 'InvalidNetwork',\r\n  message: 'Invalid version for network: got {0}'\r\n}, {\r\n  name: 'InvalidState',\r\n  message: 'Invalid state: {0}'\r\n}, {\r\n  name: 'NotImplemented',\r\n  message: 'Function {0} was not implemented yet'\r\n}, {\r\n  name: 'InvalidNetworkArgument',\r\n  message: 'Invalid network: must be \"livenet\" or \"testnet\", got {0}'\r\n}, {\r\n  name: 'InvalidArgument',\r\n  message: function() {\r\n    return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '') +\r\n      (arguments[1] ? (' Documentation: ' + docsURL + arguments[1]) : '');\r\n  }\r\n}, {\r\n  name: 'AbstractMethodInvoked',\r\n  message: 'Abstract Method Invocation: {0}'\r\n}, {\r\n  name: 'InvalidArgumentType',\r\n  message: function() {\r\n    return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0];\r\n  }\r\n}, {\r\n  name: 'Unit',\r\n  message: 'Internal Error on Unit {0}',\r\n  errors: [{\r\n    'name': 'UnknownCode',\r\n    'message': 'Unrecognized unit code: {0}'\r\n  }, {\r\n    'name': 'InvalidRate',\r\n    'message': 'Invalid exchange rate: {0}'\r\n  }]\r\n}, {\r\n  name: 'MerkleBlock',\r\n  message: 'Internal Error on MerkleBlock {0}',\r\n  errors: [{\r\n    'name': 'InvalidMerkleTree',\r\n    'message': 'This MerkleBlock contain an invalid Merkle Tree'\r\n  }]\r\n}, {\r\n  name: 'Transaction',\r\n  message: 'Internal Error on Transaction {0}',\r\n  errors: [{\r\n    name: 'Input',\r\n    message: 'Internal Error on Input {0}',\r\n    errors: [{\r\n      name: 'MissingScript',\r\n      message: 'Need a script to create an input'\r\n    }, {\r\n      name: 'UnsupportedScript',\r\n      message: 'Unsupported input script type: {0}'\r\n    }, {\r\n      name: 'MissingPreviousOutput',\r\n      message: 'No previous output information.'\r\n    }, {\r\n      name: 'BlockHeightOutOfRange',\r\n      message: 'Block Height can only be between 0 and 65535'\r\n    } , {\r\n      name: 'LockTimeRange',\r\n      message: 'Seconds needs to be more that 0 and less that 33553920'\r\n    }\r\n    ]\r\n  }, {\r\n    name: 'NeedMoreInfo',\r\n    message: '{0}'\r\n  }, {\r\n    name: 'InvalidSorting',\r\n    message: 'The sorting function provided did not return the change output as one of the array elements'\r\n  }, {\r\n    name: 'InvalidOutputAmountSum',\r\n    message: '{0}'\r\n  }, {\r\n    name: 'MissingSignatures',\r\n    message: 'Some inputs have not been fully signed'\r\n  }, {\r\n    name: 'InvalidIndex',\r\n    message: 'Invalid index: {0} is not between 0, {1}'\r\n  }, {\r\n    name: 'UnableToVerifySignature',\r\n    message: 'Unable to verify signature: {0}'\r\n  }, {\r\n    name: 'DustOutputs',\r\n    message: 'Dust amount detected in one output'\r\n  }, {\r\n    name: 'InvalidSatoshis',\r\n    message: 'Output satoshis are invalid',\r\n  }, {\r\n    name: 'FeeError',\r\n    message: 'Internal Error on Fee {0}',\r\n    errors: [{\r\n      name: 'TooSmall',\r\n      message: 'Fee is too small: {0}',\r\n    }, {\r\n      name: 'TooLarge',\r\n      message: 'Fee is too large: {0}',\r\n    }, {\r\n      name: 'Different',\r\n      message: 'Unspent value is different from specified fee: {0}',\r\n    }]\r\n  }, {\r\n    name: 'ChangeAddressMissing',\r\n    message: 'Change address is missing'\r\n  }, {\r\n    name: 'BlockHeightTooHigh',\r\n    message: 'Block Height can be at most 2^32 -1'\r\n  }, {\r\n    name: 'NLockTimeOutOfRange',\r\n    message: 'Block Height can only be between 0 and 499 999 999'\r\n  }, {\r\n    name: 'LockTimeTooEarly',\r\n    message: 'Lock Time can\\'t be earlier than UNIX date 500 000 000'\r\n  }]\r\n}, {\r\n  name: 'Script',\r\n  message: 'Internal Error on Script {0}',\r\n  errors: [{\r\n    name: 'UnrecognizedAddress',\r\n    message: 'Expected argument {0} to be an address'\r\n  }, {\r\n    name: 'CantDeriveAddress',\r\n    message: 'Can\\'t derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.'\r\n  }, {\r\n    name: 'InvalidBuffer',\r\n    message: 'Invalid script buffer: can\\'t parse valid script from given buffer {0}'\r\n  }]\r\n}, {\r\n  name: 'HDPrivateKey',\r\n  message: 'Internal Error on HDPrivateKey {0}',\r\n  errors: [{\r\n    name: 'InvalidDerivationArgument',\r\n    message: 'Invalid derivation argument {0}, expected string, or number and boolean'\r\n  }, {\r\n    name: 'InvalidEntropyArgument',\r\n    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',\r\n    errors: [{\r\n      name: 'TooMuchEntropy',\r\n      message: 'Invalid entropy: more than 512 bits is non standard, got \"{0}\"'\r\n    }, {\r\n      name: 'NotEnoughEntropy',\r\n      message: 'Invalid entropy: at least 128 bits needed, got \"{0}\"'\r\n    }]\r\n  }, {\r\n    name: 'InvalidLength',\r\n    message: 'Invalid length for xprivkey string in {0}'\r\n  }, {\r\n    name: 'InvalidPath',\r\n    message: 'Invalid derivation path: {0}'\r\n  }, {\r\n    name: 'UnrecognizedArgument',\r\n    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got \"{0}\"'\r\n  }]\r\n}, {\r\n  name: 'HDPublicKey',\r\n  message: 'Internal Error on HDPublicKey {0}',\r\n  errors: [{\r\n    name: 'ArgumentIsPrivateExtended',\r\n    message: 'Argument is an extended private key: {0}'\r\n  }, {\r\n    name: 'InvalidDerivationArgument',\r\n    message: 'Invalid derivation argument: got {0}'\r\n  }, {\r\n    name: 'InvalidLength',\r\n    message: 'Invalid length for xpubkey: got \"{0}\"'\r\n  }, {\r\n    name: 'InvalidPath',\r\n    message: 'Invalid derivation path, it should look like: \"m/1/100\", got \"{0}\"'\r\n  }, {\r\n    name: 'InvalidIndexCantDeriveHardened',\r\n    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'\r\n  }, {\r\n    name: 'MustSupplyArgument',\r\n    message: 'Must supply an argument to create a HDPublicKey'\r\n  }, {\r\n    name: 'UnrecognizedArgument',\r\n    message: 'Invalid argument for creation, must be string, json, buffer, or object'\r\n  }]\r\n}];\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvZXJyb3JzL3NwZWMuanM/ZWY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZG9jc1VSTCA9ICdodHRwOi8vYml0Y29yZS5pby8nO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBbe1xyXG4gIG5hbWU6ICdJbnZhbGlkQjU4Q2hhcicsXHJcbiAgbWVzc2FnZTogJ0ludmFsaWQgQmFzZTU4IGNoYXJhY3RlcjogezB9IGluIHsxfSdcclxufSwge1xyXG4gIG5hbWU6ICdJbnZhbGlkQjU4Q2hlY2tzdW0nLFxyXG4gIG1lc3NhZ2U6ICdJbnZhbGlkIEJhc2U1OCBjaGVja3N1bSBmb3IgezB9J1xyXG59LCB7XHJcbiAgbmFtZTogJ0ludmFsaWROZXR3b3JrJyxcclxuICBtZXNzYWdlOiAnSW52YWxpZCB2ZXJzaW9uIGZvciBuZXR3b3JrOiBnb3QgezB9J1xyXG59LCB7XHJcbiAgbmFtZTogJ0ludmFsaWRTdGF0ZScsXHJcbiAgbWVzc2FnZTogJ0ludmFsaWQgc3RhdGU6IHswfSdcclxufSwge1xyXG4gIG5hbWU6ICdOb3RJbXBsZW1lbnRlZCcsXHJcbiAgbWVzc2FnZTogJ0Z1bmN0aW9uIHswfSB3YXMgbm90IGltcGxlbWVudGVkIHlldCdcclxufSwge1xyXG4gIG5hbWU6ICdJbnZhbGlkTmV0d29ya0FyZ3VtZW50JyxcclxuICBtZXNzYWdlOiAnSW52YWxpZCBuZXR3b3JrOiBtdXN0IGJlIFwibGl2ZW5ldFwiIG9yIFwidGVzdG5ldFwiLCBnb3QgezB9J1xyXG59LCB7XHJcbiAgbmFtZTogJ0ludmFsaWRBcmd1bWVudCcsXHJcbiAgbWVzc2FnZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJ0ludmFsaWQgQXJndW1lbnQnICsgKGFyZ3VtZW50c1swXSA/ICgnOiAnICsgYXJndW1lbnRzWzBdKSA6ICcnKSArXHJcbiAgICAgIChhcmd1bWVudHNbMV0gPyAoJyBEb2N1bWVudGF0aW9uOiAnICsgZG9jc1VSTCArIGFyZ3VtZW50c1sxXSkgOiAnJyk7XHJcbiAgfVxyXG59LCB7XHJcbiAgbmFtZTogJ0Fic3RyYWN0TWV0aG9kSW52b2tlZCcsXHJcbiAgbWVzc2FnZTogJ0Fic3RyYWN0IE1ldGhvZCBJbnZvY2F0aW9uOiB7MH0nXHJcbn0sIHtcclxuICBuYW1lOiAnSW52YWxpZEFyZ3VtZW50VHlwZScsXHJcbiAgbWVzc2FnZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJ0ludmFsaWQgQXJndW1lbnQgZm9yICcgKyBhcmd1bWVudHNbMl0gKyAnLCBleHBlY3RlZCAnICsgYXJndW1lbnRzWzFdICsgJyBidXQgZ290ICcgKyB0eXBlb2YgYXJndW1lbnRzWzBdO1xyXG4gIH1cclxufSwge1xyXG4gIG5hbWU6ICdVbml0JyxcclxuICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gVW5pdCB7MH0nLFxyXG4gIGVycm9yczogW3tcclxuICAgICduYW1lJzogJ1Vua25vd25Db2RlJyxcclxuICAgICdtZXNzYWdlJzogJ1VucmVjb2duaXplZCB1bml0IGNvZGU6IHswfSdcclxuICB9LCB7XHJcbiAgICAnbmFtZSc6ICdJbnZhbGlkUmF0ZScsXHJcbiAgICAnbWVzc2FnZSc6ICdJbnZhbGlkIGV4Y2hhbmdlIHJhdGU6IHswfSdcclxuICB9XVxyXG59LCB7XHJcbiAgbmFtZTogJ01lcmtsZUJsb2NrJyxcclxuICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gTWVya2xlQmxvY2sgezB9JyxcclxuICBlcnJvcnM6IFt7XHJcbiAgICAnbmFtZSc6ICdJbnZhbGlkTWVya2xlVHJlZScsXHJcbiAgICAnbWVzc2FnZSc6ICdUaGlzIE1lcmtsZUJsb2NrIGNvbnRhaW4gYW4gaW52YWxpZCBNZXJrbGUgVHJlZSdcclxuICB9XVxyXG59LCB7XHJcbiAgbmFtZTogJ1RyYW5zYWN0aW9uJyxcclxuICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gVHJhbnNhY3Rpb24gezB9JyxcclxuICBlcnJvcnM6IFt7XHJcbiAgICBuYW1lOiAnSW5wdXQnLFxyXG4gICAgbWVzc2FnZTogJ0ludGVybmFsIEVycm9yIG9uIElucHV0IHswfScsXHJcbiAgICBlcnJvcnM6IFt7XHJcbiAgICAgIG5hbWU6ICdNaXNzaW5nU2NyaXB0JyxcclxuICAgICAgbWVzc2FnZTogJ05lZWQgYSBzY3JpcHQgdG8gY3JlYXRlIGFuIGlucHV0J1xyXG4gICAgfSwge1xyXG4gICAgICBuYW1lOiAnVW5zdXBwb3J0ZWRTY3JpcHQnLFxyXG4gICAgICBtZXNzYWdlOiAnVW5zdXBwb3J0ZWQgaW5wdXQgc2NyaXB0IHR5cGU6IHswfSdcclxuICAgIH0sIHtcclxuICAgICAgbmFtZTogJ01pc3NpbmdQcmV2aW91c091dHB1dCcsXHJcbiAgICAgIG1lc3NhZ2U6ICdObyBwcmV2aW91cyBvdXRwdXQgaW5mb3JtYXRpb24uJ1xyXG4gICAgfSwge1xyXG4gICAgICBuYW1lOiAnQmxvY2tIZWlnaHRPdXRPZlJhbmdlJyxcclxuICAgICAgbWVzc2FnZTogJ0Jsb2NrIEhlaWdodCBjYW4gb25seSBiZSBiZXR3ZWVuIDAgYW5kIDY1NTM1J1xyXG4gICAgfSAsIHtcclxuICAgICAgbmFtZTogJ0xvY2tUaW1lUmFuZ2UnLFxyXG4gICAgICBtZXNzYWdlOiAnU2Vjb25kcyBuZWVkcyB0byBiZSBtb3JlIHRoYXQgMCBhbmQgbGVzcyB0aGF0IDMzNTUzOTIwJ1xyXG4gICAgfVxyXG4gICAgXVxyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdOZWVkTW9yZUluZm8nLFxyXG4gICAgbWVzc2FnZTogJ3swfSdcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnSW52YWxpZFNvcnRpbmcnLFxyXG4gICAgbWVzc2FnZTogJ1RoZSBzb3J0aW5nIGZ1bmN0aW9uIHByb3ZpZGVkIGRpZCBub3QgcmV0dXJuIHRoZSBjaGFuZ2Ugb3V0cHV0IGFzIG9uZSBvZiB0aGUgYXJyYXkgZWxlbWVudHMnXHJcbiAgfSwge1xyXG4gICAgbmFtZTogJ0ludmFsaWRPdXRwdXRBbW91bnRTdW0nLFxyXG4gICAgbWVzc2FnZTogJ3swfSdcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnTWlzc2luZ1NpZ25hdHVyZXMnLFxyXG4gICAgbWVzc2FnZTogJ1NvbWUgaW5wdXRzIGhhdmUgbm90IGJlZW4gZnVsbHkgc2lnbmVkJ1xyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdJbnZhbGlkSW5kZXgnLFxyXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgaW5kZXg6IHswfSBpcyBub3QgYmV0d2VlbiAwLCB7MX0nXHJcbiAgfSwge1xyXG4gICAgbmFtZTogJ1VuYWJsZVRvVmVyaWZ5U2lnbmF0dXJlJyxcclxuICAgIG1lc3NhZ2U6ICdVbmFibGUgdG8gdmVyaWZ5IHNpZ25hdHVyZTogezB9J1xyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdEdXN0T3V0cHV0cycsXHJcbiAgICBtZXNzYWdlOiAnRHVzdCBhbW91bnQgZGV0ZWN0ZWQgaW4gb25lIG91dHB1dCdcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnSW52YWxpZFNhdG9zaGlzJyxcclxuICAgIG1lc3NhZ2U6ICdPdXRwdXQgc2F0b3NoaXMgYXJlIGludmFsaWQnLFxyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdGZWVFcnJvcicsXHJcbiAgICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gRmVlIHswfScsXHJcbiAgICBlcnJvcnM6IFt7XHJcbiAgICAgIG5hbWU6ICdUb29TbWFsbCcsXHJcbiAgICAgIG1lc3NhZ2U6ICdGZWUgaXMgdG9vIHNtYWxsOiB7MH0nLFxyXG4gICAgfSwge1xyXG4gICAgICBuYW1lOiAnVG9vTGFyZ2UnLFxyXG4gICAgICBtZXNzYWdlOiAnRmVlIGlzIHRvbyBsYXJnZTogezB9JyxcclxuICAgIH0sIHtcclxuICAgICAgbmFtZTogJ0RpZmZlcmVudCcsXHJcbiAgICAgIG1lc3NhZ2U6ICdVbnNwZW50IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHNwZWNpZmllZCBmZWU6IHswfScsXHJcbiAgICB9XVxyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdDaGFuZ2VBZGRyZXNzTWlzc2luZycsXHJcbiAgICBtZXNzYWdlOiAnQ2hhbmdlIGFkZHJlc3MgaXMgbWlzc2luZydcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnQmxvY2tIZWlnaHRUb29IaWdoJyxcclxuICAgIG1lc3NhZ2U6ICdCbG9jayBIZWlnaHQgY2FuIGJlIGF0IG1vc3QgMl4zMiAtMSdcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnTkxvY2tUaW1lT3V0T2ZSYW5nZScsXHJcbiAgICBtZXNzYWdlOiAnQmxvY2sgSGVpZ2h0IGNhbiBvbmx5IGJlIGJldHdlZW4gMCBhbmQgNDk5IDk5OSA5OTknXHJcbiAgfSwge1xyXG4gICAgbmFtZTogJ0xvY2tUaW1lVG9vRWFybHknLFxyXG4gICAgbWVzc2FnZTogJ0xvY2sgVGltZSBjYW5cXCd0IGJlIGVhcmxpZXIgdGhhbiBVTklYIGRhdGUgNTAwIDAwMCAwMDAnXHJcbiAgfV1cclxufSwge1xyXG4gIG5hbWU6ICdTY3JpcHQnLFxyXG4gIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBTY3JpcHQgezB9JyxcclxuICBlcnJvcnM6IFt7XHJcbiAgICBuYW1lOiAnVW5yZWNvZ25pemVkQWRkcmVzcycsXHJcbiAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgYXJndW1lbnQgezB9IHRvIGJlIGFuIGFkZHJlc3MnXHJcbiAgfSwge1xyXG4gICAgbmFtZTogJ0NhbnREZXJpdmVBZGRyZXNzJyxcclxuICAgIG1lc3NhZ2U6ICdDYW5cXCd0IGRlcml2ZSBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBzY3JpcHQgezB9LCBuZWVkcyB0byBiZSBwMnBraCBpbiwgcDJwa2ggb3V0LCBwMnNoIGluLCBvciBwMnNoIG91dC4nXHJcbiAgfSwge1xyXG4gICAgbmFtZTogJ0ludmFsaWRCdWZmZXInLFxyXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgc2NyaXB0IGJ1ZmZlcjogY2FuXFwndCBwYXJzZSB2YWxpZCBzY3JpcHQgZnJvbSBnaXZlbiBidWZmZXIgezB9J1xyXG4gIH1dXHJcbn0sIHtcclxuICBuYW1lOiAnSERQcml2YXRlS2V5JyxcclxuICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gSERQcml2YXRlS2V5IHswfScsXHJcbiAgZXJyb3JzOiBbe1xyXG4gICAgbmFtZTogJ0ludmFsaWREZXJpdmF0aW9uQXJndW1lbnQnLFxyXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZGVyaXZhdGlvbiBhcmd1bWVudCB7MH0sIGV4cGVjdGVkIHN0cmluZywgb3IgbnVtYmVyIGFuZCBib29sZWFuJ1xyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdJbnZhbGlkRW50cm9weUFyZ3VtZW50JyxcclxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGVudHJvcHk6IG11c3QgYmUgYW4gaGV4YSBzdHJpbmcgb3IgYmluYXJ5IGJ1ZmZlciwgZ290IHswfScsXHJcbiAgICBlcnJvcnM6IFt7XHJcbiAgICAgIG5hbWU6ICdUb29NdWNoRW50cm9weScsXHJcbiAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGVudHJvcHk6IG1vcmUgdGhhbiA1MTIgYml0cyBpcyBub24gc3RhbmRhcmQsIGdvdCBcInswfVwiJ1xyXG4gICAgfSwge1xyXG4gICAgICBuYW1lOiAnTm90RW5vdWdoRW50cm9weScsXHJcbiAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGVudHJvcHk6IGF0IGxlYXN0IDEyOCBiaXRzIG5lZWRlZCwgZ290IFwiezB9XCInXHJcbiAgICB9XVxyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdJbnZhbGlkTGVuZ3RoJyxcclxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGxlbmd0aCBmb3IgeHByaXZrZXkgc3RyaW5nIGluIHswfSdcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnSW52YWxpZFBhdGgnLFxyXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXRoOiB7MH0nXHJcbiAgfSwge1xyXG4gICAgbmFtZTogJ1VucmVjb2duaXplZEFyZ3VtZW50JyxcclxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGFyZ3VtZW50OiBjcmVhdGluZyBhIEhEUHJpdmF0ZUtleSByZXF1aXJlcyBhIHN0cmluZywgYnVmZmVyLCBqc29uIG9yIG9iamVjdCwgZ290IFwiezB9XCInXHJcbiAgfV1cclxufSwge1xyXG4gIG5hbWU6ICdIRFB1YmxpY0tleScsXHJcbiAgbWVzc2FnZTogJ0ludGVybmFsIEVycm9yIG9uIEhEUHVibGljS2V5IHswfScsXHJcbiAgZXJyb3JzOiBbe1xyXG4gICAgbmFtZTogJ0FyZ3VtZW50SXNQcml2YXRlRXh0ZW5kZWQnLFxyXG4gICAgbWVzc2FnZTogJ0FyZ3VtZW50IGlzIGFuIGV4dGVuZGVkIHByaXZhdGUga2V5OiB7MH0nXHJcbiAgfSwge1xyXG4gICAgbmFtZTogJ0ludmFsaWREZXJpdmF0aW9uQXJndW1lbnQnLFxyXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZGVyaXZhdGlvbiBhcmd1bWVudDogZ290IHswfSdcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnSW52YWxpZExlbmd0aCcsXHJcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBsZW5ndGggZm9yIHhwdWJrZXk6IGdvdCBcInswfVwiJ1xyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdJbnZhbGlkUGF0aCcsXHJcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBkZXJpdmF0aW9uIHBhdGgsIGl0IHNob3VsZCBsb29rIGxpa2U6IFwibS8xLzEwMFwiLCBnb3QgXCJ7MH1cIidcclxuICB9LCB7XHJcbiAgICBuYW1lOiAnSW52YWxpZEluZGV4Q2FudERlcml2ZUhhcmRlbmVkJyxcclxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGFyZ3VtZW50OiBjcmVhdGluZyBhIGhhcmRlbmVkIHBhdGggcmVxdWlyZXMgYW4gSERQcml2YXRlS2V5J1xyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdNdXN0U3VwcGx5QXJndW1lbnQnLFxyXG4gICAgbWVzc2FnZTogJ011c3Qgc3VwcGx5IGFuIGFyZ3VtZW50IHRvIGNyZWF0ZSBhIEhEUHVibGljS2V5J1xyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdVbnJlY29nbml6ZWRBcmd1bWVudCcsXHJcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBhcmd1bWVudCBmb3IgY3JlYXRpb24sIG11c3QgYmUgc3RyaW5nLCBqc29uLCBidWZmZXIsIG9yIG9iamVjdCdcclxuICB9XVxyXG59XTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/errors/spec.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/hdprivatekey.js":
/*!******************************************!*\
  !*** ../bitcore-lib/lib/hdprivatekey.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\n\r\nvar assert = __webpack_require__(/*! assert */ \"assert\");\r\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar Base58 = __webpack_require__(/*! ./encoding/base58 */ \"../bitcore-lib/lib/encoding/base58.js\");\r\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"../bitcore-lib/lib/encoding/base58check.js\");\r\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar Network = __webpack_require__(/*! ./networks */ \"../bitcore-lib/lib/networks.js\");\r\nvar Point = __webpack_require__(/*! ./crypto/point */ \"../bitcore-lib/lib/crypto/point.js\");\r\nvar PrivateKey = __webpack_require__(/*! ./privatekey */ \"../bitcore-lib/lib/privatekey.js\");\r\nvar Random = __webpack_require__(/*! ./crypto/random */ \"../bitcore-lib/lib/crypto/random.js\");\r\n\r\nvar errors = __webpack_require__(/*! ./errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar hdErrors = errors.HDPrivateKey;\r\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"../bitcore-lib/lib/util/js.js\");\r\n\r\nvar MINIMUM_ENTROPY_BITS = 128;\r\nvar BITS_TO_BYTES = 1 / 8;\r\nvar MAXIMUM_ENTROPY_BITS = 512;\r\n\r\n\r\n/**\r\n * Represents an instance of an hierarchically derived private key.\r\n *\r\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\r\n *\r\n * @constructor\r\n * @param {string|Buffer|Object} arg\r\n */\r\nfunction HDPrivateKey(arg) {\r\n  /* jshint maxcomplexity: 10 */\r\n  if (arg instanceof HDPrivateKey) {\r\n    return arg;\r\n  }\r\n  if (!(this instanceof HDPrivateKey)) {\r\n    return new HDPrivateKey(arg);\r\n  }\r\n  if (!arg) {\r\n    return this._generateRandomly();\r\n  }\r\n\r\n  if (Network.get(arg)) {\r\n    return this._generateRandomly(arg);\r\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\r\n    if (HDPrivateKey.isValidSerialized(arg)) {\r\n      this._buildFromSerialized(arg);\r\n    } else if (JSUtil.isValidJSON(arg)) {\r\n      this._buildFromJSON(arg);\r\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\r\n      this._buildFromSerialized(arg.toString());\r\n    } else {\r\n      throw HDPrivateKey.getSerializedError(arg);\r\n    }\r\n  } else if (_.isObject(arg)) {\r\n    this._buildFromObject(arg);\r\n  } else {\r\n    throw new hdErrors.UnrecognizedArgument(arg);\r\n  }\r\n}\r\n\r\n/**\r\n * Verifies that a given path is valid.\r\n *\r\n * @param {string|number} arg\r\n * @param {boolean?} hardened\r\n * @return {boolean}\r\n */\r\nHDPrivateKey.isValidPath = function(arg, hardened) {\r\n  if (_.isString(arg)) {\r\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\r\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\r\n  }\r\n\r\n  if (_.isNumber(arg)) {\r\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\r\n      arg += HDPrivateKey.Hardened;\r\n    }\r\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Internal function that splits a string path into a derivation index array.\r\n * It will return null if the string path is malformed.\r\n * It does not validate if indexes are in bounds.\r\n *\r\n * @param {string} path\r\n * @return {Array}\r\n */\r\nHDPrivateKey._getDerivationIndexes = function(path) {\r\n  var steps = path.split('/');\r\n\r\n  // Special cases:\r\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\r\n    return [];\r\n  }\r\n\r\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\r\n    return null;\r\n  }\r\n\r\n  var indexes = steps.slice(1).map(function(step) {\r\n    var isHardened = step.slice(-1) === '\\'';\r\n    if (isHardened) {\r\n      step = step.slice(0, -1);\r\n    }\r\n    if (!step || step[0] === '-') {\r\n      return NaN;\r\n    }\r\n    var index = +step; // cast to number\r\n    if (isHardened) {\r\n      index += HDPrivateKey.Hardened;\r\n    }\r\n\r\n    return index;\r\n  });\r\n\r\n  return _.some(indexes, isNaN) ? null : indexes;\r\n};\r\n\r\n/**\r\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant\r\n *\r\n *\r\n * Get a derived child based on a string or number.\r\n *\r\n * If the first argument is a string, it's parsed as the full path of\r\n * derivation. Valid values for this argument include \"m\" (which returns the\r\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\r\n * derivation.\r\n *\r\n * If the first argument is a number, the child with that index will be\r\n * derived. If the second argument is truthy, the hardened version will be\r\n * derived. See the example usage for clarification.\r\n *\r\n * @example\r\n * ```javascript\r\n * var parent = new HDPrivateKey('xprv...');\r\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\r\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\r\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\r\n * ```\r\n *\r\n * @param {string|number} arg\r\n * @param {boolean?} hardened\r\n */\r\nHDPrivateKey.prototype.derive = function(arg, hardened) {\r\n  return this.deriveNonCompliantChild(arg, hardened);\r\n};\r\n\r\n/**\r\n * WARNING: This method will not be officially supported until v1.0.0.\r\n *\r\n *\r\n * Get a derived child based on a string or number.\r\n *\r\n * If the first argument is a string, it's parsed as the full path of\r\n * derivation. Valid values for this argument include \"m\" (which returns the\r\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\r\n * derivation.\r\n *\r\n * If the first argument is a number, the child with that index will be\r\n * derived. If the second argument is truthy, the hardened version will be\r\n * derived. See the example usage for clarification.\r\n *\r\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\r\n * that used a derivation strategy that used a non-zero padded private key.\r\n *\r\n * @example\r\n * ```javascript\r\n * var parent = new HDPrivateKey('xprv...');\r\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\r\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\r\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\r\n * ```\r\n *\r\n * @param {string|number} arg\r\n * @param {boolean?} hardened\r\n */\r\nHDPrivateKey.prototype.deriveChild = function(arg, hardened) {\r\n  if (_.isNumber(arg)) {\r\n    return this._deriveWithNumber(arg, hardened);\r\n  } else if (_.isString(arg)) {\r\n    return this._deriveFromString(arg);\r\n  } else {\r\n    throw new hdErrors.InvalidDerivationArgument(arg);\r\n  }\r\n};\r\n\r\n/**\r\n * WARNING: This method will not be officially supported until v1.0.0\r\n *\r\n *\r\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\r\n * `derive` instead.\r\n *\r\n * This method is explicitly for use and compatibility with an implementation that\r\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\r\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\r\n * serialization of a private key, such that it's still possible to derive the privateKey\r\n * to recover those funds.\r\n *\r\n * @param {string|number} arg\r\n * @param {boolean?} hardened\r\n */\r\nHDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {\r\n  if (_.isNumber(arg)) {\r\n    return this._deriveWithNumber(arg, hardened, true);\r\n  } else if (_.isString(arg)) {\r\n    return this._deriveFromString(arg, true);\r\n  } else {\r\n    throw new hdErrors.InvalidDerivationArgument(arg);\r\n  }\r\n};\r\n\r\nHDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {\r\n  /* jshint maxstatements: 20 */\r\n  /* jshint maxcomplexity: 10 */\r\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\r\n    throw new hdErrors.InvalidPath(index);\r\n  }\r\n\r\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\r\n  if (index < HDPrivateKey.Hardened && hardened === true) {\r\n    index += HDPrivateKey.Hardened;\r\n  }\r\n\r\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\r\n  var data;\r\n  if (hardened && nonCompliant) {\r\n    // The private key serialization in this case will not be exactly 32 bytes and can be\r\n    // any value less, and the value is not zero-padded.\r\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\r\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\r\n  } else if (hardened) {\r\n    // This will use a 32 byte zero padded serialization of the private key\r\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});\r\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\r\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\r\n  } else {\r\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\r\n  }\r\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\r\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\r\n    size: 32\r\n  });\r\n  var chainCode = hash.slice(32, 64);\r\n\r\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\r\n    size: 32\r\n  });\r\n\r\n  if (!PrivateKey.isValid(privateKey)) {\r\n    // Index at this point is already hardened, we can pass null as the hardened arg\r\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\r\n  }\r\n\r\n  var derived = new HDPrivateKey({\r\n    network: this.network,\r\n    depth: this.depth + 1,\r\n    parentFingerPrint: this.fingerPrint,\r\n    childIndex: index,\r\n    chainCode: chainCode,\r\n    privateKey: privateKey\r\n  });\r\n\r\n  return derived;\r\n};\r\n\r\nHDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {\r\n  if (!HDPrivateKey.isValidPath(path)) {\r\n    throw new hdErrors.InvalidPath(path);\r\n  }\r\n\r\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\r\n  var derived = indexes.reduce(function(prev, index) {\r\n    return prev._deriveWithNumber(index, null, nonCompliant);\r\n  }, this);\r\n\r\n  return derived;\r\n};\r\n\r\n/**\r\n * Verifies that a given serialized private key in base58 with checksum format\r\n * is valid.\r\n *\r\n * @param {string|Buffer} data - the serialized private key\r\n * @param {string|Network=} network - optional, if present, checks that the\r\n *     network provided matches the network serialized.\r\n * @return {boolean}\r\n */\r\nHDPrivateKey.isValidSerialized = function(data, network) {\r\n  return !HDPrivateKey.getSerializedError(data, network);\r\n};\r\n\r\n/**\r\n * Checks what's the error that causes the validation of a serialized private key\r\n * in base58 with checksum to fail.\r\n *\r\n * @param {string|Buffer} data - the serialized private key\r\n * @param {string|Network=} network - optional, if present, checks that the\r\n *     network provided matches the network serialized.\r\n * @return {errors.InvalidArgument|null}\r\n */\r\nHDPrivateKey.getSerializedError = function(data, network) {\r\n  /* jshint maxcomplexity: 10 */\r\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\r\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\r\n  }\r\n  if (!Base58.validCharacters(data)) {\r\n    return new errors.InvalidB58Char('(unknown)', data);\r\n  }\r\n  try {\r\n    data = Base58Check.decode(data);\r\n  } catch (e) {\r\n    return new errors.InvalidB58Checksum(data);\r\n  }\r\n  if (data.length !== HDPrivateKey.DataLength) {\r\n    return new hdErrors.InvalidLength(data);\r\n  }\r\n  if (!_.isUndefined(network)) {\r\n    var error = HDPrivateKey._validateNetwork(data, network);\r\n    if (error) {\r\n      return error;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nHDPrivateKey._validateNetwork = function(data, networkArg) {\r\n  var network = Network.get(networkArg);\r\n  if (!network) {\r\n    return new errors.InvalidNetworkArgument(networkArg);\r\n  }\r\n  var version = data.slice(0, 4);\r\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\r\n    return new errors.InvalidNetwork(version);\r\n  }\r\n  return null;\r\n};\r\n\r\nHDPrivateKey.fromString = function(arg) {\r\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\r\n  return new HDPrivateKey(arg);\r\n};\r\n\r\nHDPrivateKey.fromObject = function(arg) {\r\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\r\n  return new HDPrivateKey(arg);\r\n};\r\n\r\nHDPrivateKey.prototype._buildFromJSON = function(arg) {\r\n  return this._buildFromObject(JSON.parse(arg));\r\n};\r\n\r\nHDPrivateKey.prototype._buildFromObject = function(arg) {\r\n  /* jshint maxcomplexity: 12 */\r\n  // TODO: Type validation\r\n  var buffers = {\r\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\r\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\r\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\r\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\r\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\r\n    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey,'hex') : arg.privateKey,\r\n    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined\r\n  };\r\n  return this._buildFromBuffers(buffers);\r\n};\r\n\r\nHDPrivateKey.prototype._buildFromSerialized = function(arg) {\r\n  var decoded = Base58Check.decode(arg);\r\n  var buffers = {\r\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\r\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\r\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,\r\n      HDPrivateKey.ParentFingerPrintEnd),\r\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\r\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\r\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\r\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\r\n    xprivkey: arg\r\n  };\r\n  return this._buildFromBuffers(buffers);\r\n};\r\n\r\nHDPrivateKey.prototype._generateRandomly = function(network) {\r\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\r\n};\r\n\r\n/**\r\n * Generate a private key from a seed, as described in BIP32\r\n *\r\n * @param {string|Buffer} hexa\r\n * @param {*} network\r\n * @return HDPrivateKey\r\n */\r\nHDPrivateKey.fromSeed = function(hexa, network) {\r\n  /* jshint maxcomplexity: 8 */\r\n  if (JSUtil.isHexaString(hexa)) {\r\n    hexa = Buffer.from(hexa, 'hex');\r\n  }\r\n  if (!Buffer.isBuffer(hexa)) {\r\n    throw new hdErrors.InvalidEntropyArgument(hexa);\r\n  }\r\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\r\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\r\n  }\r\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\r\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\r\n  }\r\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\r\n\r\n  return new HDPrivateKey({\r\n    network: Network.get(network) || Network.defaultNetwork,\r\n    depth: 0,\r\n    parentFingerPrint: 0,\r\n    childIndex: 0,\r\n    privateKey: hash.slice(0, 32),\r\n    chainCode: hash.slice(32, 64)\r\n  });\r\n};\r\n\r\n\r\n\r\nHDPrivateKey.prototype._calcHDPublicKey = function() {\r\n  if (!this._hdPublicKey) {\r\n    var HDPublicKey = __webpack_require__(/*! ./hdpublickey */ \"../bitcore-lib/lib/hdpublickey.js\");\r\n    this._hdPublicKey = new HDPublicKey(this);\r\n  }\r\n};\r\n\r\n/**\r\n * Receives a object with buffers in all the properties and populates the\r\n * internal structure\r\n *\r\n * @param {Object} arg\r\n * @param {buffer.Buffer} arg.version\r\n * @param {buffer.Buffer} arg.depth\r\n * @param {buffer.Buffer} arg.parentFingerPrint\r\n * @param {buffer.Buffer} arg.childIndex\r\n * @param {buffer.Buffer} arg.chainCode\r\n * @param {buffer.Buffer} arg.privateKey\r\n * @param {buffer.Buffer} arg.checksum\r\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\r\n *      representation\r\n * @return {HDPrivateKey} this\r\n */\r\nHDPrivateKey.prototype._buildFromBuffers = function(arg) {\r\n  /* jshint maxcomplexity: 8 */\r\n  /* jshint maxstatements: 20 */\r\n\r\n  HDPrivateKey._validateBufferArguments(arg);\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    _buffers: arg\r\n  });\r\n\r\n  var sequence = [\r\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\r\n    BufferUtil.emptyBuffer(1), arg.privateKey\r\n  ];\r\n  var concat = buffer.Buffer.concat(sequence);\r\n  if (!arg.checksum || !arg.checksum.length) {\r\n    arg.checksum = Base58Check.checksum(concat);\r\n  } else {\r\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\r\n      throw new errors.InvalidB58Checksum(concat);\r\n    }\r\n  }\r\n\r\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\r\n  var xprivkey;\r\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\r\n  arg.xprivkey = Buffer.from(xprivkey);\r\n\r\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\r\n  var publicKey = privateKey.toPublicKey();\r\n  var size = HDPrivateKey.ParentFingerPrintSize;\r\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    xprivkey: xprivkey,\r\n    network: network,\r\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\r\n    privateKey: privateKey,\r\n    publicKey: publicKey,\r\n    fingerPrint: fingerPrint\r\n  });\r\n\r\n  this._hdPublicKey = null;\r\n\r\n  Object.defineProperty(this, 'hdPublicKey', {\r\n    configurable: false,\r\n    enumerable: true,\r\n    get: function() {\r\n      this._calcHDPublicKey();\r\n      return this._hdPublicKey;\r\n    }\r\n  });\r\n  Object.defineProperty(this, 'xpubkey', {\r\n    configurable: false,\r\n    enumerable: true,\r\n    get: function() {\r\n      this._calcHDPublicKey();\r\n      return this._hdPublicKey.xpubkey;\r\n    }\r\n  });\r\n  return this;\r\n};\r\n\r\nHDPrivateKey._validateBufferArguments = function(arg) {\r\n  var checkBuffer = function(name, size) {\r\n    var buff = arg[name];\r\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\r\n    assert(\r\n      buff.length === size,\r\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\r\n    );\r\n  };\r\n  checkBuffer('version', HDPrivateKey.VersionSize);\r\n  checkBuffer('depth', HDPrivateKey.DepthSize);\r\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\r\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\r\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\r\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\r\n  if (arg.checksum && arg.checksum.length) {\r\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the string representation of this private key (a string starting\r\n * with \"xprv...\"\r\n *\r\n * @return string\r\n */\r\nHDPrivateKey.prototype.toString = function() {\r\n  return this.xprivkey;\r\n};\r\n\r\n/**\r\n * Returns the console representation of this extended private key.\r\n * @return string\r\n */\r\nHDPrivateKey.prototype.inspect = function() {\r\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\r\n};\r\n\r\n/**\r\n * Returns a plain object with a representation of this private key.\r\n *\r\n * Fields include:<ul>\r\n * <li> network: either 'livenet' or 'testnet'\r\n * <li> depth: a number ranging from 0 to 255\r\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\r\n * <li>     associated public key\r\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\r\n * <li>     of this parent's associated public key or zero.\r\n * <li> childIndex: the index from which this child was derived (or zero)\r\n * <li> chainCode: an hexa string representing a number used in the derivation\r\n * <li> privateKey: the private key associated, in hexa representation\r\n * <li> xprivkey: the representation of this extended private key in checksum\r\n * <li>     base58 format\r\n * <li> checksum: the base58 checksum of xprivkey\r\n * </ul>\r\n *  @return {Object}\r\n */\r\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\r\n  return {\r\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\r\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\r\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\r\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\r\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\r\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\r\n    privateKey: this.privateKey.toBuffer().toString('hex'),\r\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\r\n    xprivkey: this.xprivkey\r\n  };\r\n};\r\n\r\n/**\r\n * Build a HDPrivateKey from a buffer\r\n *\r\n * @param {Buffer} arg\r\n * @return {HDPrivateKey}\r\n */\r\nHDPrivateKey.fromBuffer = function(arg) {\r\n  return new HDPrivateKey(arg.toString());\r\n};\r\n\r\n/**\r\n * Returns a buffer representation of the HDPrivateKey\r\n *\r\n * @return {string}\r\n */\r\nHDPrivateKey.prototype.toBuffer = function() {\r\n  return BufferUtil.copy(this._buffers.xprivkey);\r\n};\r\n\r\nHDPrivateKey.DefaultDepth = 0;\r\nHDPrivateKey.DefaultFingerprint = 0;\r\nHDPrivateKey.DefaultChildIndex = 0;\r\nHDPrivateKey.Hardened = 0x80000000;\r\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\r\n\r\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\r\n\r\nHDPrivateKey.VersionSize = 4;\r\nHDPrivateKey.DepthSize = 1;\r\nHDPrivateKey.ParentFingerPrintSize = 4;\r\nHDPrivateKey.ChildIndexSize = 4;\r\nHDPrivateKey.ChainCodeSize = 32;\r\nHDPrivateKey.PrivateKeySize = 32;\r\nHDPrivateKey.CheckSumSize = 4;\r\n\r\nHDPrivateKey.DataLength = 78;\r\nHDPrivateKey.SerializedByteSize = 82;\r\n\r\nHDPrivateKey.VersionStart = 0;\r\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\r\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\r\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\r\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\r\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\r\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\r\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\r\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\r\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\r\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\r\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\r\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\r\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\r\n\r\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\r\n\r\nmodule.exports = HDPrivateKey;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL2hkcHJpdmF0ZWtleS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixRQUFRLG1CQUFPLENBQUMsNERBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHNFQUFzQjtBQUN0QztBQUNBLFNBQVMsbUJBQU8sQ0FBQyxvREFBYTtBQUM5QixhQUFhLG1CQUFPLENBQUMsZ0VBQW1CO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLDBFQUF3QjtBQUNsRCxXQUFXLG1CQUFPLENBQUMsd0RBQWU7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLGtEQUFZO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQywwREFBZ0I7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsc0RBQWM7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLDREQUFpQjtBQUN0QztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvREFBVTtBQUMvQjtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdEQUFlO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxnREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEMsSUFBSTtBQUNKO0FBQ0Esd0RBQXdELFNBQVM7QUFDakU7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRCxnRkFBZ0YsTUFBTTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd0RBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvaGRwcml2YXRla2V5LmpzPzNlMWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcclxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcblxyXG52YXIgQk4gPSByZXF1aXJlKCcuL2NyeXB0by9ibicpO1xyXG52YXIgQmFzZTU4ID0gcmVxdWlyZSgnLi9lbmNvZGluZy9iYXNlNTgnKTtcclxudmFyIEJhc2U1OENoZWNrID0gcmVxdWlyZSgnLi9lbmNvZGluZy9iYXNlNThjaGVjaycpO1xyXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vY3J5cHRvL2hhc2gnKTtcclxudmFyIE5ldHdvcmsgPSByZXF1aXJlKCcuL25ldHdvcmtzJyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vY3J5cHRvL3BvaW50Jyk7XHJcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRla2V5Jyk7XHJcbnZhciBSYW5kb20gPSByZXF1aXJlKCcuL2NyeXB0by9yYW5kb20nKTtcclxuXHJcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xyXG52YXIgaGRFcnJvcnMgPSBlcnJvcnMuSERQcml2YXRlS2V5O1xyXG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9idWZmZXInKTtcclxudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9qcycpO1xyXG5cclxudmFyIE1JTklNVU1fRU5UUk9QWV9CSVRTID0gMTI4O1xyXG52YXIgQklUU19UT19CWVRFUyA9IDEgLyA4O1xyXG52YXIgTUFYSU1VTV9FTlRST1BZX0JJVFMgPSA1MTI7XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gaW5zdGFuY2Ugb2YgYW4gaGllcmFyY2hpY2FsbHkgZGVyaXZlZCBwcml2YXRlIGtleS5cclxuICpcclxuICogTW9yZSBpbmZvIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwMzIubWVkaWF3aWtpXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8T2JqZWN0fSBhcmdcclxuICovXHJcbmZ1bmN0aW9uIEhEUHJpdmF0ZUtleShhcmcpIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cclxuICBpZiAoYXJnIGluc3RhbmNlb2YgSERQcml2YXRlS2V5KSB7XHJcbiAgICByZXR1cm4gYXJnO1xyXG4gIH1cclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSERQcml2YXRlS2V5KSkge1xyXG4gICAgcmV0dXJuIG5ldyBIRFByaXZhdGVLZXkoYXJnKTtcclxuICB9XHJcbiAgaWYgKCFhcmcpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVJhbmRvbWx5KCk7XHJcbiAgfVxyXG5cclxuICBpZiAoTmV0d29yay5nZXQoYXJnKSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRlUmFuZG9tbHkoYXJnKTtcclxuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXJnKSB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykpIHtcclxuICAgIGlmIChIRFByaXZhdGVLZXkuaXNWYWxpZFNlcmlhbGl6ZWQoYXJnKSkge1xyXG4gICAgICB0aGlzLl9idWlsZEZyb21TZXJpYWxpemVkKGFyZyk7XHJcbiAgICB9IGVsc2UgaWYgKEpTVXRpbC5pc1ZhbGlkSlNPTihhcmcpKSB7XHJcbiAgICAgIHRoaXMuX2J1aWxkRnJvbUpTT04oYXJnKTtcclxuICAgIH0gZWxzZSBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcpICYmIEhEUHJpdmF0ZUtleS5pc1ZhbGlkU2VyaWFsaXplZChhcmcudG9TdHJpbmcoKSkpIHtcclxuICAgICAgdGhpcy5fYnVpbGRGcm9tU2VyaWFsaXplZChhcmcudG9TdHJpbmcoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBIRFByaXZhdGVLZXkuZ2V0U2VyaWFsaXplZEVycm9yKGFyZyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGFyZykpIHtcclxuICAgIHRoaXMuX2J1aWxkRnJvbU9iamVjdChhcmcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuVW5yZWNvZ25pemVkQXJndW1lbnQoYXJnKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGF0IGEgZ2l2ZW4gcGF0aCBpcyB2YWxpZC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhcmdcclxuICogQHBhcmFtIHtib29sZWFuP30gaGFyZGVuZWRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbkhEUHJpdmF0ZUtleS5pc1ZhbGlkUGF0aCA9IGZ1bmN0aW9uKGFyZywgaGFyZGVuZWQpIHtcclxuICBpZiAoXy5pc1N0cmluZyhhcmcpKSB7XHJcbiAgICB2YXIgaW5kZXhlcyA9IEhEUHJpdmF0ZUtleS5fZ2V0RGVyaXZhdGlvbkluZGV4ZXMoYXJnKTtcclxuICAgIHJldHVybiBpbmRleGVzICE9PSBudWxsICYmIF8uZXZlcnkoaW5kZXhlcywgSERQcml2YXRlS2V5LmlzVmFsaWRQYXRoKTtcclxuICB9XHJcblxyXG4gIGlmIChfLmlzTnVtYmVyKGFyZykpIHtcclxuICAgIGlmIChhcmcgPCBIRFByaXZhdGVLZXkuSGFyZGVuZWQgJiYgaGFyZGVuZWQgPT09IHRydWUpIHtcclxuICAgICAgYXJnICs9IEhEUHJpdmF0ZUtleS5IYXJkZW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmcgPj0gMCAmJiBhcmcgPCBIRFByaXZhdGVLZXkuTWF4SW5kZXg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCBzcGxpdHMgYSBzdHJpbmcgcGF0aCBpbnRvIGEgZGVyaXZhdGlvbiBpbmRleCBhcnJheS5cclxuICogSXQgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgc3RyaW5nIHBhdGggaXMgbWFsZm9ybWVkLlxyXG4gKiBJdCBkb2VzIG5vdCB2YWxpZGF0ZSBpZiBpbmRleGVzIGFyZSBpbiBib3VuZHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuSERQcml2YXRlS2V5Ll9nZXREZXJpdmF0aW9uSW5kZXhlcyA9IGZ1bmN0aW9uKHBhdGgpIHtcclxuICB2YXIgc3RlcHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcblxyXG4gIC8vIFNwZWNpYWwgY2FzZXM6XHJcbiAgaWYgKF8uaW5jbHVkZXMoSERQcml2YXRlS2V5LlJvb3RFbGVtZW50QWxpYXMsIHBhdGgpKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICBpZiAoIV8uaW5jbHVkZXMoSERQcml2YXRlS2V5LlJvb3RFbGVtZW50QWxpYXMsIHN0ZXBzWzBdKSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB2YXIgaW5kZXhlcyA9IHN0ZXBzLnNsaWNlKDEpLm1hcChmdW5jdGlvbihzdGVwKSB7XHJcbiAgICB2YXIgaXNIYXJkZW5lZCA9IHN0ZXAuc2xpY2UoLTEpID09PSAnXFwnJztcclxuICAgIGlmIChpc0hhcmRlbmVkKSB7XHJcbiAgICAgIHN0ZXAgPSBzdGVwLnNsaWNlKDAsIC0xKTtcclxuICAgIH1cclxuICAgIGlmICghc3RlcCB8fCBzdGVwWzBdID09PSAnLScpIHtcclxuICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIHZhciBpbmRleCA9ICtzdGVwOyAvLyBjYXN0IHRvIG51bWJlclxyXG4gICAgaWYgKGlzSGFyZGVuZWQpIHtcclxuICAgICAgaW5kZXggKz0gSERQcml2YXRlS2V5LkhhcmRlbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbmRleDtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIF8uc29tZShpbmRleGVzLCBpc05hTikgPyBudWxsIDogaW5kZXhlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBVc2UgZGVyaXZlQ2hpbGQgb3IgZGVyaXZlTm9uQ29tcGxpYW50Q2hpbGQgaW5zdGVhZC4gVGhpcyBpcyBub3QgQklQMzIgY29tcGxpYW50XHJcbiAqXHJcbiAqXHJcbiAqIEdldCBhIGRlcml2ZWQgY2hpbGQgYmFzZWQgb24gYSBzdHJpbmcgb3IgbnVtYmVyLlxyXG4gKlxyXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGl0J3MgcGFyc2VkIGFzIHRoZSBmdWxsIHBhdGggb2ZcclxuICogZGVyaXZhdGlvbi4gVmFsaWQgdmFsdWVzIGZvciB0aGlzIGFyZ3VtZW50IGluY2x1ZGUgXCJtXCIgKHdoaWNoIHJldHVybnMgdGhlXHJcbiAqIHNhbWUgcHJpdmF0ZSBrZXkpLCBcIm0vMC8xLzQwLzInLzEwMDBcIiwgd2hlcmUgdGhlICcgcXVvdGUgbWVhbnMgYSBoYXJkZW5lZFxyXG4gKiBkZXJpdmF0aW9uLlxyXG4gKlxyXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBudW1iZXIsIHRoZSBjaGlsZCB3aXRoIHRoYXQgaW5kZXggd2lsbCBiZVxyXG4gKiBkZXJpdmVkLiBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRydXRoeSwgdGhlIGhhcmRlbmVkIHZlcnNpb24gd2lsbCBiZVxyXG4gKiBkZXJpdmVkLiBTZWUgdGhlIGV4YW1wbGUgdXNhZ2UgZm9yIGNsYXJpZmljYXRpb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogdmFyIHBhcmVudCA9IG5ldyBIRFByaXZhdGVLZXkoJ3hwcnYuLi4nKTtcclxuICogdmFyIGNoaWxkXzBfMV8yaCA9IHBhcmVudC5kZXJpdmUoMCkuZGVyaXZlKDEpLmRlcml2ZSgyLCB0cnVlKTtcclxuICogdmFyIGNvcHlfb2ZfY2hpbGRfMF8xXzJoID0gcGFyZW50LmRlcml2ZShcIm0vMC8xLzInXCIpO1xyXG4gKiBhc3NlcnQoY2hpbGRfMF8xXzJoLnhwcml2a2V5ID09PSBjb3B5X29mX2NoaWxkXzBfMV8yaCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGFyZ1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBoYXJkZW5lZFxyXG4gKi9cclxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbihhcmcsIGhhcmRlbmVkKSB7XHJcbiAgcmV0dXJuIHRoaXMuZGVyaXZlTm9uQ29tcGxpYW50Q2hpbGQoYXJnLCBoYXJkZW5lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogV0FSTklORzogVGhpcyBtZXRob2Qgd2lsbCBub3QgYmUgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgdW50aWwgdjEuMC4wLlxyXG4gKlxyXG4gKlxyXG4gKiBHZXQgYSBkZXJpdmVkIGNoaWxkIGJhc2VkIG9uIGEgc3RyaW5nIG9yIG51bWJlci5cclxuICpcclxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLCBpdCdzIHBhcnNlZCBhcyB0aGUgZnVsbCBwYXRoIG9mXHJcbiAqIGRlcml2YXRpb24uIFZhbGlkIHZhbHVlcyBmb3IgdGhpcyBhcmd1bWVudCBpbmNsdWRlIFwibVwiICh3aGljaCByZXR1cm5zIHRoZVxyXG4gKiBzYW1lIHByaXZhdGUga2V5KSwgXCJtLzAvMS80MC8yJy8xMDAwXCIsIHdoZXJlIHRoZSAnIHF1b3RlIG1lYW5zIGEgaGFyZGVuZWRcclxuICogZGVyaXZhdGlvbi5cclxuICpcclxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgbnVtYmVyLCB0aGUgY2hpbGQgd2l0aCB0aGF0IGluZGV4IHdpbGwgYmVcclxuICogZGVyaXZlZC4gSWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyB0cnV0aHksIHRoZSBoYXJkZW5lZCB2ZXJzaW9uIHdpbGwgYmVcclxuICogZGVyaXZlZC4gU2VlIHRoZSBleGFtcGxlIHVzYWdlIGZvciBjbGFyaWZpY2F0aW9uLlxyXG4gKlxyXG4gKiBXQVJOSU5HOiBUaGUgYG5vbkNvbXBsaWFudGAgb3B0aW9uIHNob3VsZCBOT1QgYmUgdXNlZCwgZXhjZXB0IGZvciBvbGRlciBpbXBsZW1lbnRhdGlvblxyXG4gKiB0aGF0IHVzZWQgYSBkZXJpdmF0aW9uIHN0cmF0ZWd5IHRoYXQgdXNlZCBhIG5vbi16ZXJvIHBhZGRlZCBwcml2YXRlIGtleS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiB2YXIgcGFyZW50ID0gbmV3IEhEUHJpdmF0ZUtleSgneHBydi4uLicpO1xyXG4gKiB2YXIgY2hpbGRfMF8xXzJoID0gcGFyZW50LmRlcml2ZUNoaWxkKDApLmRlcml2ZUNoaWxkKDEpLmRlcml2ZUNoaWxkKDIsIHRydWUpO1xyXG4gKiB2YXIgY29weV9vZl9jaGlsZF8wXzFfMmggPSBwYXJlbnQuZGVyaXZlQ2hpbGQoXCJtLzAvMS8yJ1wiKTtcclxuICogYXNzZXJ0KGNoaWxkXzBfMV8yaC54cHJpdmtleSA9PT0gY29weV9vZl9jaGlsZF8wXzFfMmgpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhcmdcclxuICogQHBhcmFtIHtib29sZWFuP30gaGFyZGVuZWRcclxuICovXHJcbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuZGVyaXZlQ2hpbGQgPSBmdW5jdGlvbihhcmcsIGhhcmRlbmVkKSB7XHJcbiAgaWYgKF8uaXNOdW1iZXIoYXJnKSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Rlcml2ZVdpdGhOdW1iZXIoYXJnLCBoYXJkZW5lZCk7XHJcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGFyZykpIHtcclxuICAgIHJldHVybiB0aGlzLl9kZXJpdmVGcm9tU3RyaW5nKGFyZyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkRGVyaXZhdGlvbkFyZ3VtZW50KGFyZyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgbm90IGJlIG9mZmljaWFsbHkgc3VwcG9ydGVkIHVudGlsIHYxLjAuMFxyXG4gKlxyXG4gKlxyXG4gKiBXQVJOSU5HOiBJZiB0aGlzIGlzIGEgbmV3IGltcGxlbWVudGF0aW9uIHlvdSBzaG91bGQgTk9UIHVzZSB0aGlzIG1ldGhvZCwgeW91IHNob3VsZCBiZSB1c2luZ1xyXG4gKiBgZGVyaXZlYCBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBleHBsaWNpdGx5IGZvciB1c2UgYW5kIGNvbXBhdGliaWxpdHkgd2l0aCBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0XHJcbiAqIHdhcyBub3QgY29tcGxpYW50IHdpdGggQklQMzIgcmVnYXJkaW5nIHRoZSBkZXJpdmF0aW9uIGFsZ29yaXRobS4gVGhlIHByaXZhdGUga2V5XHJcbiAqIG11c3QgYmUgMzIgYnl0ZXMgaGFzaGluZywgYW5kIHRoaXMgaW1wbGVtZW50YXRpb24gd2lsbCB1c2UgdGhlIG5vbi16ZXJvIHBhZGRlZFxyXG4gKiBzZXJpYWxpemF0aW9uIG9mIGEgcHJpdmF0ZSBrZXksIHN1Y2ggdGhhdCBpdCdzIHN0aWxsIHBvc3NpYmxlIHRvIGRlcml2ZSB0aGUgcHJpdmF0ZUtleVxyXG4gKiB0byByZWNvdmVyIHRob3NlIGZ1bmRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGFyZ1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBoYXJkZW5lZFxyXG4gKi9cclxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5kZXJpdmVOb25Db21wbGlhbnRDaGlsZCA9IGZ1bmN0aW9uKGFyZywgaGFyZGVuZWQpIHtcclxuICBpZiAoXy5pc051bWJlcihhcmcpKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVyaXZlV2l0aE51bWJlcihhcmcsIGhhcmRlbmVkLCB0cnVlKTtcclxuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXJnKSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Rlcml2ZUZyb21TdHJpbmcoYXJnLCB0cnVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWREZXJpdmF0aW9uQXJndW1lbnQoYXJnKTtcclxuICB9XHJcbn07XHJcblxyXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLl9kZXJpdmVXaXRoTnVtYmVyID0gZnVuY3Rpb24oaW5kZXgsIGhhcmRlbmVkLCBub25Db21wbGlhbnQpIHtcclxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cclxuICBpZiAoIUhEUHJpdmF0ZUtleS5pc1ZhbGlkUGF0aChpbmRleCwgaGFyZGVuZWQpKSB7XHJcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuSW52YWxpZFBhdGgoaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgaGFyZGVuZWQgPSBpbmRleCA+PSBIRFByaXZhdGVLZXkuSGFyZGVuZWQgPyB0cnVlIDogaGFyZGVuZWQ7XHJcbiAgaWYgKGluZGV4IDwgSERQcml2YXRlS2V5LkhhcmRlbmVkICYmIGhhcmRlbmVkID09PSB0cnVlKSB7XHJcbiAgICBpbmRleCArPSBIRFByaXZhdGVLZXkuSGFyZGVuZWQ7XHJcbiAgfVxyXG5cclxuICB2YXIgaW5kZXhCdWZmZXIgPSBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihpbmRleCk7XHJcbiAgdmFyIGRhdGE7XHJcbiAgaWYgKGhhcmRlbmVkICYmIG5vbkNvbXBsaWFudCkge1xyXG4gICAgLy8gVGhlIHByaXZhdGUga2V5IHNlcmlhbGl6YXRpb24gaW4gdGhpcyBjYXNlIHdpbGwgbm90IGJlIGV4YWN0bHkgMzIgYnl0ZXMgYW5kIGNhbiBiZVxyXG4gICAgLy8gYW55IHZhbHVlIGxlc3MsIGFuZCB0aGUgdmFsdWUgaXMgbm90IHplcm8tcGFkZGVkLlxyXG4gICAgdmFyIG5vblplcm9QYWRkZWQgPSB0aGlzLnByaXZhdGVLZXkuYm4udG9CdWZmZXIoKTtcclxuICAgIGRhdGEgPSBCdWZmZXJVdGlsLmNvbmNhdChbQnVmZmVyLmZyb20oWzBdKSwgbm9uWmVyb1BhZGRlZCwgaW5kZXhCdWZmZXJdKTtcclxuICB9IGVsc2UgaWYgKGhhcmRlbmVkKSB7XHJcbiAgICAvLyBUaGlzIHdpbGwgdXNlIGEgMzIgYnl0ZSB6ZXJvIHBhZGRlZCBzZXJpYWxpemF0aW9uIG9mIHRoZSBwcml2YXRlIGtleVxyXG4gICAgdmFyIHByaXZhdGVLZXlCdWZmZXIgPSB0aGlzLnByaXZhdGVLZXkuYm4udG9CdWZmZXIoe3NpemU6IDMyfSk7XHJcbiAgICBhc3NlcnQocHJpdmF0ZUtleUJ1ZmZlci5sZW5ndGggPT09IDMyLCAnbGVuZ3RoIG9mIHByaXZhdGUga2V5IGJ1ZmZlciBpcyBleHBlY3RlZCB0byBiZSAzMiBieXRlcycpO1xyXG4gICAgZGF0YSA9IEJ1ZmZlclV0aWwuY29uY2F0KFtCdWZmZXIuZnJvbShbMF0pLCBwcml2YXRlS2V5QnVmZmVyLCBpbmRleEJ1ZmZlcl0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkYXRhID0gQnVmZmVyVXRpbC5jb25jYXQoW3RoaXMucHVibGljS2V5LnRvQnVmZmVyKCksIGluZGV4QnVmZmVyXSk7XHJcbiAgfVxyXG4gIHZhciBoYXNoID0gSGFzaC5zaGE1MTJobWFjKGRhdGEsIHRoaXMuX2J1ZmZlcnMuY2hhaW5Db2RlKTtcclxuICB2YXIgbGVmdFBhcnQgPSBCTi5mcm9tQnVmZmVyKGhhc2guc2xpY2UoMCwgMzIpLCB7XHJcbiAgICBzaXplOiAzMlxyXG4gIH0pO1xyXG4gIHZhciBjaGFpbkNvZGUgPSBoYXNoLnNsaWNlKDMyLCA2NCk7XHJcblxyXG4gIHZhciBwcml2YXRlS2V5ID0gbGVmdFBhcnQuYWRkKHRoaXMucHJpdmF0ZUtleS50b0JpZ051bWJlcigpKS51bW9kKFBvaW50LmdldE4oKSkudG9CdWZmZXIoe1xyXG4gICAgc2l6ZTogMzJcclxuICB9KTtcclxuXHJcbiAgaWYgKCFQcml2YXRlS2V5LmlzVmFsaWQocHJpdmF0ZUtleSkpIHtcclxuICAgIC8vIEluZGV4IGF0IHRoaXMgcG9pbnQgaXMgYWxyZWFkeSBoYXJkZW5lZCwgd2UgY2FuIHBhc3MgbnVsbCBhcyB0aGUgaGFyZGVuZWQgYXJnXHJcbiAgICByZXR1cm4gdGhpcy5fZGVyaXZlV2l0aE51bWJlcihpbmRleCArIDEsIG51bGwsIG5vbkNvbXBsaWFudCk7XHJcbiAgfVxyXG5cclxuICB2YXIgZGVyaXZlZCA9IG5ldyBIRFByaXZhdGVLZXkoe1xyXG4gICAgbmV0d29yazogdGhpcy5uZXR3b3JrLFxyXG4gICAgZGVwdGg6IHRoaXMuZGVwdGggKyAxLFxyXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IHRoaXMuZmluZ2VyUHJpbnQsXHJcbiAgICBjaGlsZEluZGV4OiBpbmRleCxcclxuICAgIGNoYWluQ29kZTogY2hhaW5Db2RlLFxyXG4gICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gZGVyaXZlZDtcclxufTtcclxuXHJcbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2Rlcml2ZUZyb21TdHJpbmcgPSBmdW5jdGlvbihwYXRoLCBub25Db21wbGlhbnQpIHtcclxuICBpZiAoIUhEUHJpdmF0ZUtleS5pc1ZhbGlkUGF0aChwYXRoKSkge1xyXG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRQYXRoKHBhdGgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGluZGV4ZXMgPSBIRFByaXZhdGVLZXkuX2dldERlcml2YXRpb25JbmRleGVzKHBhdGgpO1xyXG4gIHZhciBkZXJpdmVkID0gaW5kZXhlcy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgaW5kZXgpIHtcclxuICAgIHJldHVybiBwcmV2Ll9kZXJpdmVXaXRoTnVtYmVyKGluZGV4LCBudWxsLCBub25Db21wbGlhbnQpO1xyXG4gIH0sIHRoaXMpO1xyXG5cclxuICByZXR1cm4gZGVyaXZlZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGF0IGEgZ2l2ZW4gc2VyaWFsaXplZCBwcml2YXRlIGtleSBpbiBiYXNlNTggd2l0aCBjaGVja3N1bSBmb3JtYXRcclxuICogaXMgdmFsaWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSAtIHRoZSBzZXJpYWxpemVkIHByaXZhdGUga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfE5ldHdvcms9fSBuZXR3b3JrIC0gb3B0aW9uYWwsIGlmIHByZXNlbnQsIGNoZWNrcyB0aGF0IHRoZVxyXG4gKiAgICAgbmV0d29yayBwcm92aWRlZCBtYXRjaGVzIHRoZSBuZXR3b3JrIHNlcmlhbGl6ZWQuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5IRFByaXZhdGVLZXkuaXNWYWxpZFNlcmlhbGl6ZWQgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrKSB7XHJcbiAgcmV0dXJuICFIRFByaXZhdGVLZXkuZ2V0U2VyaWFsaXplZEVycm9yKGRhdGEsIG5ldHdvcmspO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGF0J3MgdGhlIGVycm9yIHRoYXQgY2F1c2VzIHRoZSB2YWxpZGF0aW9uIG9mIGEgc2VyaWFsaXplZCBwcml2YXRlIGtleVxyXG4gKiBpbiBiYXNlNTggd2l0aCBjaGVja3N1bSB0byBmYWlsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGEgLSB0aGUgc2VyaWFsaXplZCBwcml2YXRlIGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ3xOZXR3b3JrPX0gbmV0d29yayAtIG9wdGlvbmFsLCBpZiBwcmVzZW50LCBjaGVja3MgdGhhdCB0aGVcclxuICogICAgIG5ldHdvcmsgcHJvdmlkZWQgbWF0Y2hlcyB0aGUgbmV0d29yayBzZXJpYWxpemVkLlxyXG4gKiBAcmV0dXJuIHtlcnJvcnMuSW52YWxpZEFyZ3VtZW50fG51bGx9XHJcbiAqL1xyXG5IRFByaXZhdGVLZXkuZ2V0U2VyaWFsaXplZEVycm9yID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaykge1xyXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMCAqL1xyXG4gIGlmICghKF8uaXNTdHJpbmcoZGF0YSkgfHwgQnVmZmVyVXRpbC5pc0J1ZmZlcihkYXRhKSkpIHtcclxuICAgIHJldHVybiBuZXcgaGRFcnJvcnMuVW5yZWNvZ25pemVkQXJndW1lbnQoJ0V4cGVjdGVkIHN0cmluZyBvciBidWZmZXInKTtcclxuICB9XHJcbiAgaWYgKCFCYXNlNTgudmFsaWRDaGFyYWN0ZXJzKGRhdGEpKSB7XHJcbiAgICByZXR1cm4gbmV3IGVycm9ycy5JbnZhbGlkQjU4Q2hhcignKHVua25vd24pJywgZGF0YSk7XHJcbiAgfVxyXG4gIHRyeSB7XHJcbiAgICBkYXRhID0gQmFzZTU4Q2hlY2suZGVjb2RlKGRhdGEpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWRCNThDaGVja3N1bShkYXRhKTtcclxuICB9XHJcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBIRFByaXZhdGVLZXkuRGF0YUxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBoZEVycm9ycy5JbnZhbGlkTGVuZ3RoKGRhdGEpO1xyXG4gIH1cclxuICBpZiAoIV8uaXNVbmRlZmluZWQobmV0d29yaykpIHtcclxuICAgIHZhciBlcnJvciA9IEhEUHJpdmF0ZUtleS5fdmFsaWRhdGVOZXR3b3JrKGRhdGEsIG5ldHdvcmspO1xyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIHJldHVybiBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5IRFByaXZhdGVLZXkuX3ZhbGlkYXRlTmV0d29yayA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmtBcmcpIHtcclxuICB2YXIgbmV0d29yayA9IE5ldHdvcmsuZ2V0KG5ldHdvcmtBcmcpO1xyXG4gIGlmICghbmV0d29yaykge1xyXG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuSW52YWxpZE5ldHdvcmtBcmd1bWVudChuZXR3b3JrQXJnKTtcclxuICB9XHJcbiAgdmFyIHZlcnNpb24gPSBkYXRhLnNsaWNlKDAsIDQpO1xyXG4gIGlmIChCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHZlcnNpb24pICE9PSBuZXR3b3JrLnhwcml2a2V5KSB7XHJcbiAgICByZXR1cm4gbmV3IGVycm9ycy5JbnZhbGlkTmV0d29yayh2ZXJzaW9uKTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5IRFByaXZhdGVLZXkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKGFyZykge1xyXG4gICQuY2hlY2tBcmd1bWVudChfLmlzU3RyaW5nKGFyZyksICdObyB2YWxpZCBzdHJpbmcgd2FzIHByb3ZpZGVkJyk7XHJcbiAgcmV0dXJuIG5ldyBIRFByaXZhdGVLZXkoYXJnKTtcclxufTtcclxuXHJcbkhEUHJpdmF0ZUtleS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3QoYXJnKSwgJ05vIHZhbGlkIGFyZ3VtZW50IHdhcyBwcm92aWRlZCcpO1xyXG4gIHJldHVybiBuZXcgSERQcml2YXRlS2V5KGFyZyk7XHJcbn07XHJcblxyXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLl9idWlsZEZyb21KU09OID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbU9iamVjdChKU09OLnBhcnNlKGFyZykpO1xyXG59O1xyXG5cclxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5fYnVpbGRGcm9tT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEyICovXHJcbiAgLy8gVE9ETzogVHlwZSB2YWxpZGF0aW9uXHJcbiAgdmFyIGJ1ZmZlcnMgPSB7XHJcbiAgICB2ZXJzaW9uOiBhcmcubmV0d29yayA/IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKE5ldHdvcmsuZ2V0KGFyZy5uZXR3b3JrKS54cHJpdmtleSkgOiBhcmcudmVyc2lvbixcclxuICAgIGRlcHRoOiBfLmlzTnVtYmVyKGFyZy5kZXB0aCkgPyBCdWZmZXJVdGlsLmludGVnZXJBc1NpbmdsZUJ5dGVCdWZmZXIoYXJnLmRlcHRoKSA6IGFyZy5kZXB0aCxcclxuICAgIHBhcmVudEZpbmdlclByaW50OiBfLmlzTnVtYmVyKGFyZy5wYXJlbnRGaW5nZXJQcmludCkgPyBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihhcmcucGFyZW50RmluZ2VyUHJpbnQpIDogYXJnLnBhcmVudEZpbmdlclByaW50LFxyXG4gICAgY2hpbGRJbmRleDogXy5pc051bWJlcihhcmcuY2hpbGRJbmRleCkgPyBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihhcmcuY2hpbGRJbmRleCkgOiBhcmcuY2hpbGRJbmRleCxcclxuICAgIGNoYWluQ29kZTogXy5pc1N0cmluZyhhcmcuY2hhaW5Db2RlKSA/IEJ1ZmZlci5mcm9tKGFyZy5jaGFpbkNvZGUsJ2hleCcpIDogYXJnLmNoYWluQ29kZSxcclxuICAgIHByaXZhdGVLZXk6IChfLmlzU3RyaW5nKGFyZy5wcml2YXRlS2V5KSAmJiBKU1V0aWwuaXNIZXhhKGFyZy5wcml2YXRlS2V5KSkgPyBCdWZmZXIuZnJvbShhcmcucHJpdmF0ZUtleSwnaGV4JykgOiBhcmcucHJpdmF0ZUtleSxcclxuICAgIGNoZWNrc3VtOiBhcmcuY2hlY2tzdW0gPyAoYXJnLmNoZWNrc3VtLmxlbmd0aCA/IGFyZy5jaGVja3N1bSA6IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGFyZy5jaGVja3N1bSkpIDogdW5kZWZpbmVkXHJcbiAgfTtcclxuICByZXR1cm4gdGhpcy5fYnVpbGRGcm9tQnVmZmVycyhidWZmZXJzKTtcclxufTtcclxuXHJcbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2J1aWxkRnJvbVNlcmlhbGl6ZWQgPSBmdW5jdGlvbihhcmcpIHtcclxuICB2YXIgZGVjb2RlZCA9IEJhc2U1OENoZWNrLmRlY29kZShhcmcpO1xyXG4gIHZhciBidWZmZXJzID0ge1xyXG4gICAgdmVyc2lvbjogZGVjb2RlZC5zbGljZShIRFByaXZhdGVLZXkuVmVyc2lvblN0YXJ0LCBIRFByaXZhdGVLZXkuVmVyc2lvbkVuZCksXHJcbiAgICBkZXB0aDogZGVjb2RlZC5zbGljZShIRFByaXZhdGVLZXkuRGVwdGhTdGFydCwgSERQcml2YXRlS2V5LkRlcHRoRW5kKSxcclxuICAgIHBhcmVudEZpbmdlclByaW50OiBkZWNvZGVkLnNsaWNlKEhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0LFxyXG4gICAgICBIRFByaXZhdGVLZXkuUGFyZW50RmluZ2VyUHJpbnRFbmQpLFxyXG4gICAgY2hpbGRJbmRleDogZGVjb2RlZC5zbGljZShIRFByaXZhdGVLZXkuQ2hpbGRJbmRleFN0YXJ0LCBIRFByaXZhdGVLZXkuQ2hpbGRJbmRleEVuZCksXHJcbiAgICBjaGFpbkNvZGU6IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LkNoYWluQ29kZVN0YXJ0LCBIRFByaXZhdGVLZXkuQ2hhaW5Db2RlRW5kKSxcclxuICAgIHByaXZhdGVLZXk6IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LlByaXZhdGVLZXlTdGFydCwgSERQcml2YXRlS2V5LlByaXZhdGVLZXlFbmQpLFxyXG4gICAgY2hlY2tzdW06IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LkNoZWNrc3VtU3RhcnQsIEhEUHJpdmF0ZUtleS5DaGVja3N1bUVuZCksXHJcbiAgICB4cHJpdmtleTogYXJnXHJcbiAgfTtcclxuICByZXR1cm4gdGhpcy5fYnVpbGRGcm9tQnVmZmVycyhidWZmZXJzKTtcclxufTtcclxuXHJcbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2dlbmVyYXRlUmFuZG9tbHkgPSBmdW5jdGlvbihuZXR3b3JrKSB7XHJcbiAgcmV0dXJuIEhEUHJpdmF0ZUtleS5mcm9tU2VlZChSYW5kb20uZ2V0UmFuZG9tQnVmZmVyKDY0KSwgbmV0d29yayk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBwcml2YXRlIGtleSBmcm9tIGEgc2VlZCwgYXMgZGVzY3JpYmVkIGluIEJJUDMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gaGV4YVxyXG4gKiBAcGFyYW0geyp9IG5ldHdvcmtcclxuICogQHJldHVybiBIRFByaXZhdGVLZXlcclxuICovXHJcbkhEUHJpdmF0ZUtleS5mcm9tU2VlZCA9IGZ1bmN0aW9uKGhleGEsIG5ldHdvcmspIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogOCAqL1xyXG4gIGlmIChKU1V0aWwuaXNIZXhhU3RyaW5nKGhleGEpKSB7XHJcbiAgICBoZXhhID0gQnVmZmVyLmZyb20oaGV4YSwgJ2hleCcpO1xyXG4gIH1cclxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihoZXhhKSkge1xyXG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRFbnRyb3B5QXJndW1lbnQoaGV4YSk7XHJcbiAgfVxyXG4gIGlmIChoZXhhLmxlbmd0aCA8IE1JTklNVU1fRU5UUk9QWV9CSVRTICogQklUU19UT19CWVRFUykge1xyXG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRFbnRyb3B5QXJndW1lbnQuTm90RW5vdWdoRW50cm9weShoZXhhKTtcclxuICB9XHJcbiAgaWYgKGhleGEubGVuZ3RoID4gTUFYSU1VTV9FTlRST1BZX0JJVFMgKiBCSVRTX1RPX0JZVEVTKSB7XHJcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuSW52YWxpZEVudHJvcHlBcmd1bWVudC5Ub29NdWNoRW50cm9weShoZXhhKTtcclxuICB9XHJcbiAgdmFyIGhhc2ggPSBIYXNoLnNoYTUxMmhtYWMoaGV4YSwgQnVmZmVyLmZyb20oJ0JpdGNvaW4gc2VlZCcpKTtcclxuXHJcbiAgcmV0dXJuIG5ldyBIRFByaXZhdGVLZXkoe1xyXG4gICAgbmV0d29yazogTmV0d29yay5nZXQobmV0d29yaykgfHwgTmV0d29yay5kZWZhdWx0TmV0d29yayxcclxuICAgIGRlcHRoOiAwLFxyXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IDAsXHJcbiAgICBjaGlsZEluZGV4OiAwLFxyXG4gICAgcHJpdmF0ZUtleTogaGFzaC5zbGljZSgwLCAzMiksXHJcbiAgICBjaGFpbkNvZGU6IGhhc2guc2xpY2UoMzIsIDY0KVxyXG4gIH0pO1xyXG59O1xyXG5cclxuXHJcblxyXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLl9jYWxjSERQdWJsaWNLZXkgPSBmdW5jdGlvbigpIHtcclxuICBpZiAoIXRoaXMuX2hkUHVibGljS2V5KSB7XHJcbiAgICB2YXIgSERQdWJsaWNLZXkgPSByZXF1aXJlKCcuL2hkcHVibGlja2V5Jyk7XHJcbiAgICB0aGlzLl9oZFB1YmxpY0tleSA9IG5ldyBIRFB1YmxpY0tleSh0aGlzKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVjZWl2ZXMgYSBvYmplY3Qgd2l0aCBidWZmZXJzIGluIGFsbCB0aGUgcHJvcGVydGllcyBhbmQgcG9wdWxhdGVzIHRoZVxyXG4gKiBpbnRlcm5hbCBzdHJ1Y3R1cmVcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGFyZ1xyXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy52ZXJzaW9uXHJcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmRlcHRoXHJcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLnBhcmVudEZpbmdlclByaW50XHJcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoaWxkSW5kZXhcclxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcuY2hhaW5Db2RlXHJcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLnByaXZhdGVLZXlcclxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcuY2hlY2tzdW1cclxuICogQHBhcmFtIHtzdHJpbmc9fSBhcmcueHByaXZrZXkgLSBpZiBzZXQsIGRvbid0IHJlY2FsY3VsYXRlIHRoZSBiYXNlNThcclxuICogICAgICByZXByZXNlbnRhdGlvblxyXG4gKiBAcmV0dXJuIHtIRFByaXZhdGVLZXl9IHRoaXNcclxuICovXHJcbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2J1aWxkRnJvbUJ1ZmZlcnMgPSBmdW5jdGlvbihhcmcpIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogOCAqL1xyXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xyXG5cclxuICBIRFByaXZhdGVLZXkuX3ZhbGlkYXRlQnVmZmVyQXJndW1lbnRzKGFyZyk7XHJcblxyXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xyXG4gICAgX2J1ZmZlcnM6IGFyZ1xyXG4gIH0pO1xyXG5cclxuICB2YXIgc2VxdWVuY2UgPSBbXHJcbiAgICBhcmcudmVyc2lvbiwgYXJnLmRlcHRoLCBhcmcucGFyZW50RmluZ2VyUHJpbnQsIGFyZy5jaGlsZEluZGV4LCBhcmcuY2hhaW5Db2RlLFxyXG4gICAgQnVmZmVyVXRpbC5lbXB0eUJ1ZmZlcigxKSwgYXJnLnByaXZhdGVLZXlcclxuICBdO1xyXG4gIHZhciBjb25jYXQgPSBidWZmZXIuQnVmZmVyLmNvbmNhdChzZXF1ZW5jZSk7XHJcbiAgaWYgKCFhcmcuY2hlY2tzdW0gfHwgIWFyZy5jaGVja3N1bS5sZW5ndGgpIHtcclxuICAgIGFyZy5jaGVja3N1bSA9IEJhc2U1OENoZWNrLmNoZWNrc3VtKGNvbmNhdCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChhcmcuY2hlY2tzdW0udG9TdHJpbmcoKSAhPT0gQmFzZTU4Q2hlY2suY2hlY2tzdW0oY29uY2F0KS50b1N0cmluZygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEI1OENoZWNrc3VtKGNvbmNhdCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgbmV0d29yayA9IE5ldHdvcmsuZ2V0KEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIoYXJnLnZlcnNpb24pKTtcclxuICB2YXIgeHByaXZrZXk7XHJcbiAgeHByaXZrZXkgPSBCYXNlNThDaGVjay5lbmNvZGUoYnVmZmVyLkJ1ZmZlci5jb25jYXQoc2VxdWVuY2UpKTtcclxuICBhcmcueHByaXZrZXkgPSBCdWZmZXIuZnJvbSh4cHJpdmtleSk7XHJcblxyXG4gIHZhciBwcml2YXRlS2V5ID0gbmV3IFByaXZhdGVLZXkoQk4uZnJvbUJ1ZmZlcihhcmcucHJpdmF0ZUtleSksIG5ldHdvcmspO1xyXG4gIHZhciBwdWJsaWNLZXkgPSBwcml2YXRlS2V5LnRvUHVibGljS2V5KCk7XHJcbiAgdmFyIHNpemUgPSBIRFByaXZhdGVLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplO1xyXG4gIHZhciBmaW5nZXJQcmludCA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKHB1YmxpY0tleS50b0J1ZmZlcigpKS5zbGljZSgwLCBzaXplKTtcclxuXHJcbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XHJcbiAgICB4cHJpdmtleTogeHByaXZrZXksXHJcbiAgICBuZXR3b3JrOiBuZXR3b3JrLFxyXG4gICAgZGVwdGg6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21TaW5nbGVCeXRlQnVmZmVyKGFyZy5kZXB0aCksXHJcbiAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxyXG4gICAgcHVibGljS2V5OiBwdWJsaWNLZXksXHJcbiAgICBmaW5nZXJQcmludDogZmluZ2VyUHJpbnRcclxuICB9KTtcclxuXHJcbiAgdGhpcy5faGRQdWJsaWNLZXkgPSBudWxsO1xyXG5cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2hkUHVibGljS2V5Jywge1xyXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9jYWxjSERQdWJsaWNLZXkoKTtcclxuICAgICAgcmV0dXJuIHRoaXMuX2hkUHVibGljS2V5O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAneHB1YmtleScsIHtcclxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5fY2FsY0hEUHVibGljS2V5KCk7XHJcbiAgICAgIHJldHVybiB0aGlzLl9oZFB1YmxpY0tleS54cHVia2V5O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuSERQcml2YXRlS2V5Ll92YWxpZGF0ZUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKGFyZykge1xyXG4gIHZhciBjaGVja0J1ZmZlciA9IGZ1bmN0aW9uKG5hbWUsIHNpemUpIHtcclxuICAgIHZhciBidWZmID0gYXJnW25hbWVdO1xyXG4gICAgYXNzZXJ0KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmZiksIG5hbWUgKyAnIGFyZ3VtZW50IGlzIG5vdCBhIGJ1ZmZlcicpO1xyXG4gICAgYXNzZXJ0KFxyXG4gICAgICBidWZmLmxlbmd0aCA9PT0gc2l6ZSxcclxuICAgICAgbmFtZSArICcgaGFzIG5vdCB0aGUgZXhwZWN0ZWQgc2l6ZTogZm91bmQgJyArIGJ1ZmYubGVuZ3RoICsgJywgZXhwZWN0ZWQgJyArIHNpemVcclxuICAgICk7XHJcbiAgfTtcclxuICBjaGVja0J1ZmZlcigndmVyc2lvbicsIEhEUHJpdmF0ZUtleS5WZXJzaW9uU2l6ZSk7XHJcbiAgY2hlY2tCdWZmZXIoJ2RlcHRoJywgSERQcml2YXRlS2V5LkRlcHRoU2l6ZSk7XHJcbiAgY2hlY2tCdWZmZXIoJ3BhcmVudEZpbmdlclByaW50JywgSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50U2l6ZSk7XHJcbiAgY2hlY2tCdWZmZXIoJ2NoaWxkSW5kZXgnLCBIRFByaXZhdGVLZXkuQ2hpbGRJbmRleFNpemUpO1xyXG4gIGNoZWNrQnVmZmVyKCdjaGFpbkNvZGUnLCBIRFByaXZhdGVLZXkuQ2hhaW5Db2RlU2l6ZSk7XHJcbiAgY2hlY2tCdWZmZXIoJ3ByaXZhdGVLZXknLCBIRFByaXZhdGVLZXkuUHJpdmF0ZUtleVNpemUpO1xyXG4gIGlmIChhcmcuY2hlY2tzdW0gJiYgYXJnLmNoZWNrc3VtLmxlbmd0aCkge1xyXG4gICAgY2hlY2tCdWZmZXIoJ2NoZWNrc3VtJywgSERQcml2YXRlS2V5LkNoZWNrU3VtU2l6ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHByaXZhdGUga2V5IChhIHN0cmluZyBzdGFydGluZ1xyXG4gKiB3aXRoIFwieHBydi4uLlwiXHJcbiAqXHJcbiAqIEByZXR1cm4gc3RyaW5nXHJcbiAqL1xyXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMueHByaXZrZXk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29uc29sZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV4dGVuZGVkIHByaXZhdGUga2V5LlxyXG4gKiBAcmV0dXJuIHN0cmluZ1xyXG4gKi9cclxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICc8SERQcml2YXRlS2V5OiAnICsgdGhpcy54cHJpdmtleSArICc+JztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHdpdGggYSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHByaXZhdGUga2V5LlxyXG4gKlxyXG4gKiBGaWVsZHMgaW5jbHVkZTo8dWw+XHJcbiAqIDxsaT4gbmV0d29yazogZWl0aGVyICdsaXZlbmV0JyBvciAndGVzdG5ldCdcclxuICogPGxpPiBkZXB0aDogYSBudW1iZXIgcmFuZ2luZyBmcm9tIDAgdG8gMjU1XHJcbiAqIDxsaT4gZmluZ2VyUHJpbnQ6IGEgbnVtYmVyIHJhbmdpbmcgZnJvbSAwIHRvIDJeMzItMSwgdGFrZW4gZnJvbSB0aGUgaGFzaCBvZiB0aGVcclxuICogPGxpPiAgICAgYXNzb2NpYXRlZCBwdWJsaWMga2V5XHJcbiAqIDxsaT4gcGFyZW50RmluZ2VyUHJpbnQ6IGEgbnVtYmVyIHJhbmdpbmcgZnJvbSAwIHRvIDJeMzItMSwgdGFrZW4gZnJvbSB0aGUgaGFzaFxyXG4gKiA8bGk+ICAgICBvZiB0aGlzIHBhcmVudCdzIGFzc29jaWF0ZWQgcHVibGljIGtleSBvciB6ZXJvLlxyXG4gKiA8bGk+IGNoaWxkSW5kZXg6IHRoZSBpbmRleCBmcm9tIHdoaWNoIHRoaXMgY2hpbGQgd2FzIGRlcml2ZWQgKG9yIHplcm8pXHJcbiAqIDxsaT4gY2hhaW5Db2RlOiBhbiBoZXhhIHN0cmluZyByZXByZXNlbnRpbmcgYSBudW1iZXIgdXNlZCBpbiB0aGUgZGVyaXZhdGlvblxyXG4gKiA8bGk+IHByaXZhdGVLZXk6IHRoZSBwcml2YXRlIGtleSBhc3NvY2lhdGVkLCBpbiBoZXhhIHJlcHJlc2VudGF0aW9uXHJcbiAqIDxsaT4geHByaXZrZXk6IHRoZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV4dGVuZGVkIHByaXZhdGUga2V5IGluIGNoZWNrc3VtXHJcbiAqIDxsaT4gICAgIGJhc2U1OCBmb3JtYXRcclxuICogPGxpPiBjaGVja3N1bTogdGhlIGJhc2U1OCBjaGVja3N1bSBvZiB4cHJpdmtleVxyXG4gKiA8L3VsPlxyXG4gKiAgQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuSERQcml2YXRlS2V5LnByb3RvdHlwZS50b09iamVjdCA9IEhEUHJpdmF0ZUtleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5ldHdvcms6IE5ldHdvcmsuZ2V0KEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy52ZXJzaW9uKSwgJ3hwcml2a2V5JykubmFtZSxcclxuICAgIGRlcHRoOiBCdWZmZXJVdGlsLmludGVnZXJGcm9tU2luZ2xlQnl0ZUJ1ZmZlcih0aGlzLl9idWZmZXJzLmRlcHRoKSxcclxuICAgIGZpbmdlclByaW50OiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuZmluZ2VyUHJpbnQpLFxyXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy5wYXJlbnRGaW5nZXJQcmludCksXHJcbiAgICBjaGlsZEluZGV4OiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMuY2hpbGRJbmRleCksXHJcbiAgICBjaGFpbkNvZGU6IEJ1ZmZlclV0aWwuYnVmZmVyVG9IZXgodGhpcy5fYnVmZmVycy5jaGFpbkNvZGUpLFxyXG4gICAgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5LnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpLFxyXG4gICAgY2hlY2tzdW06IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy5jaGVja3N1bSksXHJcbiAgICB4cHJpdmtleTogdGhpcy54cHJpdmtleVxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQnVpbGQgYSBIRFByaXZhdGVLZXkgZnJvbSBhIGJ1ZmZlclxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYXJnXHJcbiAqIEByZXR1cm4ge0hEUHJpdmF0ZUtleX1cclxuICovXHJcbkhEUHJpdmF0ZUtleS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgcmV0dXJuIG5ldyBIRFByaXZhdGVLZXkoYXJnLnRvU3RyaW5nKCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIEhEUHJpdmF0ZUtleVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIEJ1ZmZlclV0aWwuY29weSh0aGlzLl9idWZmZXJzLnhwcml2a2V5KTtcclxufTtcclxuXHJcbkhEUHJpdmF0ZUtleS5EZWZhdWx0RGVwdGggPSAwO1xyXG5IRFByaXZhdGVLZXkuRGVmYXVsdEZpbmdlcnByaW50ID0gMDtcclxuSERQcml2YXRlS2V5LkRlZmF1bHRDaGlsZEluZGV4ID0gMDtcclxuSERQcml2YXRlS2V5LkhhcmRlbmVkID0gMHg4MDAwMDAwMDtcclxuSERQcml2YXRlS2V5Lk1heEluZGV4ID0gMiAqIEhEUHJpdmF0ZUtleS5IYXJkZW5lZDtcclxuXHJcbkhEUHJpdmF0ZUtleS5Sb290RWxlbWVudEFsaWFzID0gWydtJywgJ00nLCAnbVxcJycsICdNXFwnJ107XHJcblxyXG5IRFByaXZhdGVLZXkuVmVyc2lvblNpemUgPSA0O1xyXG5IRFByaXZhdGVLZXkuRGVwdGhTaXplID0gMTtcclxuSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50U2l6ZSA9IDQ7XHJcbkhEUHJpdmF0ZUtleS5DaGlsZEluZGV4U2l6ZSA9IDQ7XHJcbkhEUHJpdmF0ZUtleS5DaGFpbkNvZGVTaXplID0gMzI7XHJcbkhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5U2l6ZSA9IDMyO1xyXG5IRFByaXZhdGVLZXkuQ2hlY2tTdW1TaXplID0gNDtcclxuXHJcbkhEUHJpdmF0ZUtleS5EYXRhTGVuZ3RoID0gNzg7XHJcbkhEUHJpdmF0ZUtleS5TZXJpYWxpemVkQnl0ZVNpemUgPSA4MjtcclxuXHJcbkhEUHJpdmF0ZUtleS5WZXJzaW9uU3RhcnQgPSAwO1xyXG5IRFByaXZhdGVLZXkuVmVyc2lvbkVuZCA9IEhEUHJpdmF0ZUtleS5WZXJzaW9uU3RhcnQgKyBIRFByaXZhdGVLZXkuVmVyc2lvblNpemU7XHJcbkhEUHJpdmF0ZUtleS5EZXB0aFN0YXJ0ID0gSERQcml2YXRlS2V5LlZlcnNpb25FbmQ7XHJcbkhEUHJpdmF0ZUtleS5EZXB0aEVuZCA9IEhEUHJpdmF0ZUtleS5EZXB0aFN0YXJ0ICsgSERQcml2YXRlS2V5LkRlcHRoU2l6ZTtcclxuSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50U3RhcnQgPSBIRFByaXZhdGVLZXkuRGVwdGhFbmQ7XHJcbkhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludEVuZCA9IEhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0ICsgSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50U2l6ZTtcclxuSERQcml2YXRlS2V5LkNoaWxkSW5kZXhTdGFydCA9IEhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludEVuZDtcclxuSERQcml2YXRlS2V5LkNoaWxkSW5kZXhFbmQgPSBIRFByaXZhdGVLZXkuQ2hpbGRJbmRleFN0YXJ0ICsgSERQcml2YXRlS2V5LkNoaWxkSW5kZXhTaXplO1xyXG5IRFByaXZhdGVLZXkuQ2hhaW5Db2RlU3RhcnQgPSBIRFByaXZhdGVLZXkuQ2hpbGRJbmRleEVuZDtcclxuSERQcml2YXRlS2V5LkNoYWluQ29kZUVuZCA9IEhEUHJpdmF0ZUtleS5DaGFpbkNvZGVTdGFydCArIEhEUHJpdmF0ZUtleS5DaGFpbkNvZGVTaXplO1xyXG5IRFByaXZhdGVLZXkuUHJpdmF0ZUtleVN0YXJ0ID0gSERQcml2YXRlS2V5LkNoYWluQ29kZUVuZCArIDE7XHJcbkhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5RW5kID0gSERQcml2YXRlS2V5LlByaXZhdGVLZXlTdGFydCArIEhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5U2l6ZTtcclxuSERQcml2YXRlS2V5LkNoZWNrc3VtU3RhcnQgPSBIRFByaXZhdGVLZXkuUHJpdmF0ZUtleUVuZDtcclxuSERQcml2YXRlS2V5LkNoZWNrc3VtRW5kID0gSERQcml2YXRlS2V5LkNoZWNrc3VtU3RhcnQgKyBIRFByaXZhdGVLZXkuQ2hlY2tTdW1TaXplO1xyXG5cclxuYXNzZXJ0KEhEUHJpdmF0ZUtleS5DaGVja3N1bUVuZCA9PT0gSERQcml2YXRlS2V5LlNlcmlhbGl6ZWRCeXRlU2l6ZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhEUHJpdmF0ZUtleTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/hdprivatekey.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/hdpublickey.js":
/*!*****************************************!*\
  !*** ../bitcore-lib/lib/hdpublickey.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar Base58 = __webpack_require__(/*! ./encoding/base58 */ \"../bitcore-lib/lib/encoding/base58.js\");\r\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"../bitcore-lib/lib/encoding/base58check.js\");\r\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar HDPrivateKey = __webpack_require__(/*! ./hdprivatekey */ \"../bitcore-lib/lib/hdprivatekey.js\");\r\nvar Network = __webpack_require__(/*! ./networks */ \"../bitcore-lib/lib/networks.js\");\r\nvar Point = __webpack_require__(/*! ./crypto/point */ \"../bitcore-lib/lib/crypto/point.js\");\r\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"../bitcore-lib/lib/publickey.js\");\r\n\r\nvar bitcoreErrors = __webpack_require__(/*! ./errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar errors = bitcoreErrors;\r\nvar hdErrors = bitcoreErrors.HDPublicKey;\r\nvar assert = __webpack_require__(/*! assert */ \"assert\");\r\n\r\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\n\r\n/**\r\n * The representation of an hierarchically derived public key.\r\n *\r\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\r\n *\r\n * @constructor\r\n * @param {Object|string|Buffer} arg\r\n */\r\nfunction HDPublicKey(arg) {\r\n  /* jshint maxcomplexity: 12 */\r\n  /* jshint maxstatements: 20 */\r\n  if (arg instanceof HDPublicKey) {\r\n    return arg;\r\n  }\r\n  if (!(this instanceof HDPublicKey)) {\r\n    return new HDPublicKey(arg);\r\n  }\r\n  if (arg) {\r\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\r\n      var error = HDPublicKey.getSerializedError(arg);\r\n      if (!error) {\r\n        return this._buildFromSerialized(arg);\r\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\r\n        return this._buildFromSerialized(arg.toString());\r\n      } else {\r\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\r\n          return new HDPrivateKey(arg).hdPublicKey;\r\n        }\r\n        throw error;\r\n      }\r\n    } else {\r\n      if (_.isObject(arg)) {\r\n        if (arg instanceof HDPrivateKey) {\r\n          return this._buildFromPrivate(arg);\r\n        } else {\r\n          return this._buildFromObject(arg);\r\n        }\r\n      } else {\r\n        throw new hdErrors.UnrecognizedArgument(arg);\r\n      }\r\n    }\r\n  } else {\r\n    throw new hdErrors.MustSupplyArgument();\r\n  }\r\n}\r\n\r\n/**\r\n * Verifies that a given path is valid.\r\n *\r\n * @param {string|number} arg\r\n * @return {boolean}\r\n */\r\nHDPublicKey.isValidPath = function(arg) {\r\n  if (_.isString(arg)) {\r\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\r\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\r\n  }\r\n\r\n  if (_.isNumber(arg)) {\r\n    return arg >= 0 && arg < HDPublicKey.Hardened;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * WARNING: This method is deprecated. Use deriveChild instead.\r\n *\r\n *\r\n * Get a derivated child based on a string or number.\r\n *\r\n * If the first argument is a string, it's parsed as the full path of\r\n * derivation. Valid values for this argument include \"m\" (which returns the\r\n * same public key), \"m/0/1/40/2/1000\".\r\n *\r\n * Note that hardened keys can't be derived from a public extended key.\r\n *\r\n * If the first argument is a number, the child with that index will be\r\n * derived. See the example usage for clarification.\r\n *\r\n * @example\r\n * ```javascript\r\n * var parent = new HDPublicKey('xpub...');\r\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\r\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\r\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\r\n * ```\r\n *\r\n * @param {string|number} arg\r\n */\r\nHDPublicKey.prototype.derive = function(arg, hardened) {\r\n  return this.deriveChild(arg, hardened);\r\n};\r\n\r\n/**\r\n * WARNING: This method will not be officially supported until v1.0.0.\r\n *\r\n *\r\n * Get a derivated child based on a string or number.\r\n *\r\n * If the first argument is a string, it's parsed as the full path of\r\n * derivation. Valid values for this argument include \"m\" (which returns the\r\n * same public key), \"m/0/1/40/2/1000\".\r\n *\r\n * Note that hardened keys can't be derived from a public extended key.\r\n *\r\n * If the first argument is a number, the child with that index will be\r\n * derived. See the example usage for clarification.\r\n *\r\n * @example\r\n * ```javascript\r\n * var parent = new HDPublicKey('xpub...');\r\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\r\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\r\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\r\n * ```\r\n *\r\n * @param {string|number} arg\r\n */\r\nHDPublicKey.prototype.deriveChild = function(arg, hardened) {\r\n  if (_.isNumber(arg)) {\r\n    return this._deriveWithNumber(arg, hardened);\r\n  } else if (_.isString(arg)) {\r\n    return this._deriveFromString(arg);\r\n  } else {\r\n    throw new hdErrors.InvalidDerivationArgument(arg);\r\n  }\r\n};\r\n\r\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\r\n  if (index >= HDPublicKey.Hardened || hardened) {\r\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\r\n  }\r\n  if (index < 0) {\r\n    throw new hdErrors.InvalidPath(index);\r\n  }\r\n\r\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\r\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\r\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\r\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\r\n  var chainCode = hash.slice(32, 64);\r\n\r\n  var publicKey;\r\n  try {\r\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\r\n  } catch (e) {\r\n    return this._deriveWithNumber(index + 1);\r\n  }\r\n\r\n  var derived = new HDPublicKey({\r\n    network: this.network,\r\n    depth: this.depth + 1,\r\n    parentFingerPrint: this.fingerPrint,\r\n    childIndex: index,\r\n    chainCode: chainCode,\r\n    publicKey: publicKey\r\n  });\r\n\r\n  return derived;\r\n};\r\n\r\nHDPublicKey.prototype._deriveFromString = function(path) {\r\n  /* jshint maxcomplexity: 8 */\r\n  if (_.includes(path, \"'\")) {\r\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\r\n  } else if (!HDPublicKey.isValidPath(path)) {\r\n    throw new hdErrors.InvalidPath(path);\r\n  }\r\n\r\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\r\n  var derived = indexes.reduce(function(prev, index) {\r\n    return prev._deriveWithNumber(index);\r\n  }, this);\r\n\r\n  return derived;\r\n};\r\n\r\n/**\r\n * Verifies that a given serialized public key in base58 with checksum format\r\n * is valid.\r\n *\r\n * @param {string|Buffer} data - the serialized public key\r\n * @param {string|Network=} network - optional, if present, checks that the\r\n *     network provided matches the network serialized.\r\n * @return {boolean}\r\n */\r\nHDPublicKey.isValidSerialized = function(data, network) {\r\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\r\n};\r\n\r\n/**\r\n * Checks what's the error that causes the validation of a serialized public key\r\n * in base58 with checksum to fail.\r\n *\r\n * @param {string|Buffer} data - the serialized public key\r\n * @param {string|Network=} network - optional, if present, checks that the\r\n *     network provided matches the network serialized.\r\n * @return {errors|null}\r\n */\r\nHDPublicKey.getSerializedError = function(data, network) {\r\n  /* jshint maxcomplexity: 10 */\r\n  /* jshint maxstatements: 20 */\r\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\r\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\r\n  }\r\n  if (!Base58.validCharacters(data)) {\r\n    return new errors.InvalidB58Char('(unknown)', data);\r\n  }\r\n  try {\r\n    data = Base58Check.decode(data);\r\n  } catch (e) {\r\n    return new errors.InvalidB58Checksum(data);\r\n  }\r\n  if (data.length !== HDPublicKey.DataSize) {\r\n    return new hdErrors.InvalidLength(data);\r\n  }\r\n  if (!_.isUndefined(network)) {\r\n    var error = HDPublicKey._validateNetwork(data, network);\r\n    if (error) {\r\n      return error;\r\n    }\r\n  }\r\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\r\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\r\n    return new hdErrors.ArgumentIsPrivateExtended();\r\n  }\r\n  return null;\r\n};\r\n\r\nHDPublicKey._validateNetwork = function(data, networkArg) {\r\n  var network = Network.get(networkArg);\r\n  if (!network) {\r\n    return new errors.InvalidNetworkArgument(networkArg);\r\n  }\r\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\r\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\r\n    return new errors.InvalidNetwork(version);\r\n  }\r\n  return null;\r\n};\r\n\r\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\r\n  var args = _.clone(arg._buffers);\r\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\r\n  args.publicKey = Point.pointToCompressed(point);\r\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\r\n  args.privateKey = undefined;\r\n  args.checksum = undefined;\r\n  args.xprivkey = undefined;\r\n  return this._buildFromBuffers(args);\r\n};\r\n\r\nHDPublicKey.prototype._buildFromObject = function(arg) {\r\n  /* jshint maxcomplexity: 10 */\r\n  // TODO: Type validation\r\n  var buffers = {\r\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\r\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\r\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\r\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\r\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\r\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :\r\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\r\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\r\n  };\r\n  return this._buildFromBuffers(buffers);\r\n};\r\n\r\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\r\n  var decoded = Base58Check.decode(arg);\r\n  var buffers = {\r\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\r\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\r\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\r\n                                     HDPublicKey.ParentFingerPrintEnd),\r\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\r\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\r\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\r\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\r\n    xpubkey: arg\r\n  };\r\n  return this._buildFromBuffers(buffers);\r\n};\r\n\r\n/**\r\n * Receives a object with buffers in all the properties and populates the\r\n * internal structure\r\n *\r\n * @param {Object} arg\r\n * @param {buffer.Buffer} arg.version\r\n * @param {buffer.Buffer} arg.depth\r\n * @param {buffer.Buffer} arg.parentFingerPrint\r\n * @param {buffer.Buffer} arg.childIndex\r\n * @param {buffer.Buffer} arg.chainCode\r\n * @param {buffer.Buffer} arg.publicKey\r\n * @param {buffer.Buffer} arg.checksum\r\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\r\n *      representation\r\n * @return {HDPublicKey} this\r\n */\r\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\r\n  /* jshint maxcomplexity: 8 */\r\n  /* jshint maxstatements: 20 */\r\n\r\n  HDPublicKey._validateBufferArguments(arg);\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    _buffers: arg\r\n  });\r\n\r\n  var sequence = [\r\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\r\n    arg.publicKey\r\n  ];\r\n  var concat = BufferUtil.concat(sequence);\r\n  var checksum = Base58Check.checksum(concat);\r\n  if (!arg.checksum || !arg.checksum.length) {\r\n    arg.checksum = checksum;\r\n  } else {\r\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\r\n      throw new errors.InvalidB58Checksum(concat, checksum);\r\n    }\r\n  }\r\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\r\n\r\n  var xpubkey;\r\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\r\n  arg.xpubkey = Buffer.from(xpubkey);\r\n\r\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\r\n  var size = HDPublicKey.ParentFingerPrintSize;\r\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    xpubkey: xpubkey,\r\n    network: network,\r\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\r\n    publicKey: publicKey,\r\n    fingerPrint: fingerPrint\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\nHDPublicKey._validateBufferArguments = function(arg) {\r\n  var checkBuffer = function(name, size) {\r\n    var buff = arg[name];\r\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\r\n    assert(\r\n      buff.length === size,\r\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\r\n    );\r\n  };\r\n  checkBuffer('version', HDPublicKey.VersionSize);\r\n  checkBuffer('depth', HDPublicKey.DepthSize);\r\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\r\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\r\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\r\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\r\n  if (arg.checksum && arg.checksum.length) {\r\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\r\n  }\r\n};\r\n\r\nHDPublicKey.fromString = function(arg) {\r\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\r\n  return new HDPublicKey(arg);\r\n};\r\n\r\nHDPublicKey.fromObject = function(arg) {\r\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\r\n  return new HDPublicKey(arg);\r\n};\r\n\r\n/**\r\n * Returns the base58 checked representation of the public key\r\n * @return {string} a string starting with \"xpub...\" in livenet\r\n */\r\nHDPublicKey.prototype.toString = function() {\r\n  return this.xpubkey;\r\n};\r\n\r\n/**\r\n * Returns the console representation of this extended public key.\r\n * @return string\r\n */\r\nHDPublicKey.prototype.inspect = function() {\r\n  return '<HDPublicKey: ' + this.xpubkey + '>';\r\n};\r\n\r\n/**\r\n * Returns a plain JavaScript object with information to reconstruct a key.\r\n *\r\n * Fields are: <ul>\r\n *  <li> network: 'livenet' or 'testnet'\r\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\r\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\r\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\r\n *  <li>     parent's public key\r\n *  <li> childIndex: index with which this key was derived\r\n *  <li> chainCode: string in hexa encoding used for derivation\r\n *  <li> publicKey: string, hexa encoded, in compressed key format\r\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\r\n *  <li> xpubkey: the string with the base58 representation of this extended key\r\n *  <li> checksum: the base58 checksum of xpubkey\r\n * </ul>\r\n */\r\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\r\n  return {\r\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\r\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\r\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\r\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\r\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\r\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\r\n    publicKey: this.publicKey.toString(),\r\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\r\n    xpubkey: this.xpubkey\r\n  };\r\n};\r\n\r\n/**\r\n * Create a HDPublicKey from a buffer argument\r\n *\r\n * @param {Buffer} arg\r\n * @return {HDPublicKey}\r\n */\r\nHDPublicKey.fromBuffer = function(arg) {\r\n  return new HDPublicKey(arg);\r\n};\r\n\r\n/**\r\n * Return a buffer representation of the xpubkey\r\n *\r\n * @return {Buffer}\r\n */\r\nHDPublicKey.prototype.toBuffer = function() {\r\n  return BufferUtil.copy(this._buffers.xpubkey);\r\n};\r\n\r\nHDPublicKey.Hardened = 0x80000000;\r\nHDPublicKey.RootElementAlias = ['m', 'M'];\r\n\r\nHDPublicKey.VersionSize = 4;\r\nHDPublicKey.DepthSize = 1;\r\nHDPublicKey.ParentFingerPrintSize = 4;\r\nHDPublicKey.ChildIndexSize = 4;\r\nHDPublicKey.ChainCodeSize = 32;\r\nHDPublicKey.PublicKeySize = 33;\r\nHDPublicKey.CheckSumSize = 4;\r\n\r\nHDPublicKey.DataSize = 78;\r\nHDPublicKey.SerializedByteSize = 82;\r\n\r\nHDPublicKey.VersionStart           = 0;\r\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\r\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\r\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\r\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\r\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\r\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\r\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\r\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\r\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\r\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\r\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\r\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\r\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\r\n\r\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\r\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\r\n\r\nmodule.exports = HDPublicKey;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL2hkcHVibGlja2V5LmpzP2RhYmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyICQgPSByZXF1aXJlKCcuL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG5cclxudmFyIEJOID0gcmVxdWlyZSgnLi9jcnlwdG8vYm4nKTtcclxudmFyIEJhc2U1OCA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYmFzZTU4Jyk7XHJcbnZhciBCYXNlNThDaGVjayA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYmFzZTU4Y2hlY2snKTtcclxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2NyeXB0by9oYXNoJyk7XHJcbnZhciBIRFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL2hkcHJpdmF0ZWtleScpO1xyXG52YXIgTmV0d29yayA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9jcnlwdG8vcG9pbnQnKTtcclxudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vcHVibGlja2V5Jyk7XHJcblxyXG52YXIgYml0Y29yZUVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XHJcbnZhciBlcnJvcnMgPSBiaXRjb3JlRXJyb3JzO1xyXG52YXIgaGRFcnJvcnMgPSBiaXRjb3JlRXJyb3JzLkhEUHVibGljS2V5O1xyXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XHJcblxyXG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi91dGlsL2J1ZmZlcicpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBoaWVyYXJjaGljYWxseSBkZXJpdmVkIHB1YmxpYyBrZXkuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDMyLm1lZGlhd2lraVxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfEJ1ZmZlcn0gYXJnXHJcbiAqL1xyXG5mdW5jdGlvbiBIRFB1YmxpY0tleShhcmcpIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTIgKi9cclxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cclxuICBpZiAoYXJnIGluc3RhbmNlb2YgSERQdWJsaWNLZXkpIHtcclxuICAgIHJldHVybiBhcmc7XHJcbiAgfVxyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIRFB1YmxpY0tleSkpIHtcclxuICAgIHJldHVybiBuZXcgSERQdWJsaWNLZXkoYXJnKTtcclxuICB9XHJcbiAgaWYgKGFyZykge1xyXG4gICAgaWYgKF8uaXNTdHJpbmcoYXJnKSB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykpIHtcclxuICAgICAgdmFyIGVycm9yID0gSERQdWJsaWNLZXkuZ2V0U2VyaWFsaXplZEVycm9yKGFyZyk7XHJcbiAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRGcm9tU2VyaWFsaXplZChhcmcpO1xyXG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnKSAmJiAhSERQdWJsaWNLZXkuZ2V0U2VyaWFsaXplZEVycm9yKGFyZy50b1N0cmluZygpKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWlsZEZyb21TZXJpYWxpemVkKGFyZy50b1N0cmluZygpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBoZEVycm9ycy5Bcmd1bWVudElzUHJpdmF0ZUV4dGVuZGVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IEhEUHJpdmF0ZUtleShhcmcpLmhkUHVibGljS2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKF8uaXNPYmplY3QoYXJnKSkge1xyXG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBIRFByaXZhdGVLZXkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZEZyb21Qcml2YXRlKGFyZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZEZyb21PYmplY3QoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGhkRXJyb3JzLlVucmVjb2duaXplZEFyZ3VtZW50KGFyZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLk11c3RTdXBwbHlBcmd1bWVudCgpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWVzIHRoYXQgYSBnaXZlbiBwYXRoIGlzIHZhbGlkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGFyZ1xyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuSERQdWJsaWNLZXkuaXNWYWxpZFBhdGggPSBmdW5jdGlvbihhcmcpIHtcclxuICBpZiAoXy5pc1N0cmluZyhhcmcpKSB7XHJcbiAgICB2YXIgaW5kZXhlcyA9IEhEUHJpdmF0ZUtleS5fZ2V0RGVyaXZhdGlvbkluZGV4ZXMoYXJnKTtcclxuICAgIHJldHVybiBpbmRleGVzICE9PSBudWxsICYmIF8uZXZlcnkoaW5kZXhlcywgSERQdWJsaWNLZXkuaXNWYWxpZFBhdGgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKF8uaXNOdW1iZXIoYXJnKSkge1xyXG4gICAgcmV0dXJuIGFyZyA+PSAwICYmIGFyZyA8IEhEUHVibGljS2V5LkhhcmRlbmVkO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIFVzZSBkZXJpdmVDaGlsZCBpbnN0ZWFkLlxyXG4gKlxyXG4gKlxyXG4gKiBHZXQgYSBkZXJpdmF0ZWQgY2hpbGQgYmFzZWQgb24gYSBzdHJpbmcgb3IgbnVtYmVyLlxyXG4gKlxyXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGl0J3MgcGFyc2VkIGFzIHRoZSBmdWxsIHBhdGggb2ZcclxuICogZGVyaXZhdGlvbi4gVmFsaWQgdmFsdWVzIGZvciB0aGlzIGFyZ3VtZW50IGluY2x1ZGUgXCJtXCIgKHdoaWNoIHJldHVybnMgdGhlXHJcbiAqIHNhbWUgcHVibGljIGtleSksIFwibS8wLzEvNDAvMi8xMDAwXCIuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBoYXJkZW5lZCBrZXlzIGNhbid0IGJlIGRlcml2ZWQgZnJvbSBhIHB1YmxpYyBleHRlbmRlZCBrZXkuXHJcbiAqXHJcbiAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIG51bWJlciwgdGhlIGNoaWxkIHdpdGggdGhhdCBpbmRleCB3aWxsIGJlXHJcbiAqIGRlcml2ZWQuIFNlZSB0aGUgZXhhbXBsZSB1c2FnZSBmb3IgY2xhcmlmaWNhdGlvbi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiB2YXIgcGFyZW50ID0gbmV3IEhEUHVibGljS2V5KCd4cHViLi4uJyk7XHJcbiAqIHZhciBjaGlsZF8wXzFfMiA9IHBhcmVudC5kZXJpdmUoMCkuZGVyaXZlKDEpLmRlcml2ZSgyKTtcclxuICogdmFyIGNvcHlfb2ZfY2hpbGRfMF8xXzIgPSBwYXJlbnQuZGVyaXZlKFwibS8wLzEvMlwiKTtcclxuICogYXNzZXJ0KGNoaWxkXzBfMV8yLnhwcml2a2V5ID09PSBjb3B5X29mX2NoaWxkXzBfMV8yKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXJnXHJcbiAqL1xyXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24oYXJnLCBoYXJkZW5lZCkge1xyXG4gIHJldHVybiB0aGlzLmRlcml2ZUNoaWxkKGFyZywgaGFyZGVuZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgbm90IGJlIG9mZmljaWFsbHkgc3VwcG9ydGVkIHVudGlsIHYxLjAuMC5cclxuICpcclxuICpcclxuICogR2V0IGEgZGVyaXZhdGVkIGNoaWxkIGJhc2VkIG9uIGEgc3RyaW5nIG9yIG51bWJlci5cclxuICpcclxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLCBpdCdzIHBhcnNlZCBhcyB0aGUgZnVsbCBwYXRoIG9mXHJcbiAqIGRlcml2YXRpb24uIFZhbGlkIHZhbHVlcyBmb3IgdGhpcyBhcmd1bWVudCBpbmNsdWRlIFwibVwiICh3aGljaCByZXR1cm5zIHRoZVxyXG4gKiBzYW1lIHB1YmxpYyBrZXkpLCBcIm0vMC8xLzQwLzIvMTAwMFwiLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgaGFyZGVuZWQga2V5cyBjYW4ndCBiZSBkZXJpdmVkIGZyb20gYSBwdWJsaWMgZXh0ZW5kZWQga2V5LlxyXG4gKlxyXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBudW1iZXIsIHRoZSBjaGlsZCB3aXRoIHRoYXQgaW5kZXggd2lsbCBiZVxyXG4gKiBkZXJpdmVkLiBTZWUgdGhlIGV4YW1wbGUgdXNhZ2UgZm9yIGNsYXJpZmljYXRpb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogdmFyIHBhcmVudCA9IG5ldyBIRFB1YmxpY0tleSgneHB1Yi4uLicpO1xyXG4gKiB2YXIgY2hpbGRfMF8xXzIgPSBwYXJlbnQuZGVyaXZlQ2hpbGQoMCkuZGVyaXZlQ2hpbGQoMSkuZGVyaXZlQ2hpbGQoMik7XHJcbiAqIHZhciBjb3B5X29mX2NoaWxkXzBfMV8yID0gcGFyZW50LmRlcml2ZUNoaWxkKFwibS8wLzEvMlwiKTtcclxuICogYXNzZXJ0KGNoaWxkXzBfMV8yLnhwcml2a2V5ID09PSBjb3B5X29mX2NoaWxkXzBfMV8yKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXJnXHJcbiAqL1xyXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuZGVyaXZlQ2hpbGQgPSBmdW5jdGlvbihhcmcsIGhhcmRlbmVkKSB7XHJcbiAgaWYgKF8uaXNOdW1iZXIoYXJnKSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Rlcml2ZVdpdGhOdW1iZXIoYXJnLCBoYXJkZW5lZCk7XHJcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGFyZykpIHtcclxuICAgIHJldHVybiB0aGlzLl9kZXJpdmVGcm9tU3RyaW5nKGFyZyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkRGVyaXZhdGlvbkFyZ3VtZW50KGFyZyk7XHJcbiAgfVxyXG59O1xyXG5cclxuSERQdWJsaWNLZXkucHJvdG90eXBlLl9kZXJpdmVXaXRoTnVtYmVyID0gZnVuY3Rpb24oaW5kZXgsIGhhcmRlbmVkKSB7XHJcbiAgaWYgKGluZGV4ID49IEhEUHVibGljS2V5LkhhcmRlbmVkIHx8IGhhcmRlbmVkKSB7XHJcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuSW52YWxpZEluZGV4Q2FudERlcml2ZUhhcmRlbmVkKCk7XHJcbiAgfVxyXG4gIGlmIChpbmRleCA8IDApIHtcclxuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkUGF0aChpbmRleCk7XHJcbiAgfVxyXG5cclxuICB2YXIgaW5kZXhCdWZmZXIgPSBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihpbmRleCk7XHJcbiAgdmFyIGRhdGEgPSBCdWZmZXJVdGlsLmNvbmNhdChbdGhpcy5wdWJsaWNLZXkudG9CdWZmZXIoKSwgaW5kZXhCdWZmZXJdKTtcclxuICB2YXIgaGFzaCA9IEhhc2guc2hhNTEyaG1hYyhkYXRhLCB0aGlzLl9idWZmZXJzLmNoYWluQ29kZSk7XHJcbiAgdmFyIGxlZnRQYXJ0ID0gQk4uZnJvbUJ1ZmZlcihoYXNoLnNsaWNlKDAsIDMyKSwge3NpemU6IDMyfSk7XHJcbiAgdmFyIGNoYWluQ29kZSA9IGhhc2guc2xpY2UoMzIsIDY0KTtcclxuXHJcbiAgdmFyIHB1YmxpY0tleTtcclxuICB0cnkge1xyXG4gICAgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb21Qb2ludChQb2ludC5nZXRHKCkubXVsKGxlZnRQYXJ0KS5hZGQodGhpcy5wdWJsaWNLZXkucG9pbnQpKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVyaXZlV2l0aE51bWJlcihpbmRleCArIDEpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGRlcml2ZWQgPSBuZXcgSERQdWJsaWNLZXkoe1xyXG4gICAgbmV0d29yazogdGhpcy5uZXR3b3JrLFxyXG4gICAgZGVwdGg6IHRoaXMuZGVwdGggKyAxLFxyXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IHRoaXMuZmluZ2VyUHJpbnQsXHJcbiAgICBjaGlsZEluZGV4OiBpbmRleCxcclxuICAgIGNoYWluQ29kZTogY2hhaW5Db2RlLFxyXG4gICAgcHVibGljS2V5OiBwdWJsaWNLZXlcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGRlcml2ZWQ7XHJcbn07XHJcblxyXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuX2Rlcml2ZUZyb21TdHJpbmcgPSBmdW5jdGlvbihwYXRoKSB7XHJcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDggKi9cclxuICBpZiAoXy5pbmNsdWRlcyhwYXRoLCBcIidcIikpIHtcclxuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkSW5kZXhDYW50RGVyaXZlSGFyZGVuZWQoKTtcclxuICB9IGVsc2UgaWYgKCFIRFB1YmxpY0tleS5pc1ZhbGlkUGF0aChwYXRoKSkge1xyXG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRQYXRoKHBhdGgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGluZGV4ZXMgPSBIRFByaXZhdGVLZXkuX2dldERlcml2YXRpb25JbmRleGVzKHBhdGgpO1xyXG4gIHZhciBkZXJpdmVkID0gaW5kZXhlcy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgaW5kZXgpIHtcclxuICAgIHJldHVybiBwcmV2Ll9kZXJpdmVXaXRoTnVtYmVyKGluZGV4KTtcclxuICB9LCB0aGlzKTtcclxuXHJcbiAgcmV0dXJuIGRlcml2ZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHNlcmlhbGl6ZWQgcHVibGljIGtleSBpbiBiYXNlNTggd2l0aCBjaGVja3N1bSBmb3JtYXRcclxuICogaXMgdmFsaWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSAtIHRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBvcHRpb25hbCwgaWYgcHJlc2VudCwgY2hlY2tzIHRoYXQgdGhlXHJcbiAqICAgICBuZXR3b3JrIHByb3ZpZGVkIG1hdGNoZXMgdGhlIG5ldHdvcmsgc2VyaWFsaXplZC5cclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbkhEUHVibGljS2V5LmlzVmFsaWRTZXJpYWxpemVkID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaykge1xyXG4gIHJldHVybiBfLmlzTnVsbChIRFB1YmxpY0tleS5nZXRTZXJpYWxpemVkRXJyb3IoZGF0YSwgbmV0d29yaykpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGF0J3MgdGhlIGVycm9yIHRoYXQgY2F1c2VzIHRoZSB2YWxpZGF0aW9uIG9mIGEgc2VyaWFsaXplZCBwdWJsaWMga2V5XHJcbiAqIGluIGJhc2U1OCB3aXRoIGNoZWNrc3VtIHRvIGZhaWwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSAtIHRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBvcHRpb25hbCwgaWYgcHJlc2VudCwgY2hlY2tzIHRoYXQgdGhlXHJcbiAqICAgICBuZXR3b3JrIHByb3ZpZGVkIG1hdGNoZXMgdGhlIG5ldHdvcmsgc2VyaWFsaXplZC5cclxuICogQHJldHVybiB7ZXJyb3JzfG51bGx9XHJcbiAqL1xyXG5IRFB1YmxpY0tleS5nZXRTZXJpYWxpemVkRXJyb3IgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrKSB7XHJcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXHJcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDIwICovXHJcbiAgaWYgKCEoXy5pc1N0cmluZyhkYXRhKSB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKGRhdGEpKSkge1xyXG4gICAgcmV0dXJuIG5ldyBoZEVycm9ycy5VbnJlY29nbml6ZWRBcmd1bWVudCgnZXhwZWN0ZWQgYnVmZmVyIG9yIHN0cmluZycpO1xyXG4gIH1cclxuICBpZiAoIUJhc2U1OC52YWxpZENoYXJhY3RlcnMoZGF0YSkpIHtcclxuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWRCNThDaGFyKCcodW5rbm93biknLCBkYXRhKTtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIGRhdGEgPSBCYXNlNThDaGVjay5kZWNvZGUoZGF0YSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuSW52YWxpZEI1OENoZWNrc3VtKGRhdGEpO1xyXG4gIH1cclxuICBpZiAoZGF0YS5sZW5ndGggIT09IEhEUHVibGljS2V5LkRhdGFTaXplKSB7XHJcbiAgICByZXR1cm4gbmV3IGhkRXJyb3JzLkludmFsaWRMZW5ndGgoZGF0YSk7XHJcbiAgfVxyXG4gIGlmICghXy5pc1VuZGVmaW5lZChuZXR3b3JrKSkge1xyXG4gICAgdmFyIGVycm9yID0gSERQdWJsaWNLZXkuX3ZhbGlkYXRlTmV0d29yayhkYXRhLCBuZXR3b3JrKTtcclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciB2ZXJzaW9uID0gQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcihkYXRhLnNsaWNlKDAsIDQpKTtcclxuICBpZiAodmVyc2lvbiA9PT0gTmV0d29yay5saXZlbmV0Lnhwcml2a2V5IHx8IHZlcnNpb24gPT09IE5ldHdvcmsudGVzdG5ldC54cHJpdmtleSApIHtcclxuICAgIHJldHVybiBuZXcgaGRFcnJvcnMuQXJndW1lbnRJc1ByaXZhdGVFeHRlbmRlZCgpO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbkhEUHVibGljS2V5Ll92YWxpZGF0ZU5ldHdvcmsgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrQXJnKSB7XHJcbiAgdmFyIG5ldHdvcmsgPSBOZXR3b3JrLmdldChuZXR3b3JrQXJnKTtcclxuICBpZiAoIW5ldHdvcmspIHtcclxuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWROZXR3b3JrQXJndW1lbnQobmV0d29ya0FyZyk7XHJcbiAgfVxyXG4gIHZhciB2ZXJzaW9uID0gZGF0YS5zbGljZShIRFB1YmxpY0tleS5WZXJzaW9uU3RhcnQsIEhEUHVibGljS2V5LlZlcnNpb25FbmQpO1xyXG4gIGlmIChCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHZlcnNpb24pICE9PSBuZXR3b3JrLnhwdWJrZXkpIHtcclxuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWROZXR3b3JrKHZlcnNpb24pO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbkhEUHVibGljS2V5LnByb3RvdHlwZS5fYnVpbGRGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIChhcmcpIHtcclxuICB2YXIgYXJncyA9IF8uY2xvbmUoYXJnLl9idWZmZXJzKTtcclxuICB2YXIgcG9pbnQgPSBQb2ludC5nZXRHKCkubXVsKEJOLmZyb21CdWZmZXIoYXJncy5wcml2YXRlS2V5KSk7XHJcbiAgYXJncy5wdWJsaWNLZXkgPSBQb2ludC5wb2ludFRvQ29tcHJlc3NlZChwb2ludCk7XHJcbiAgYXJncy52ZXJzaW9uID0gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoTmV0d29yay5nZXQoQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcihhcmdzLnZlcnNpb24pKS54cHVia2V5KTtcclxuICBhcmdzLnByaXZhdGVLZXkgPSB1bmRlZmluZWQ7XHJcbiAgYXJncy5jaGVja3N1bSA9IHVuZGVmaW5lZDtcclxuICBhcmdzLnhwcml2a2V5ID0gdW5kZWZpbmVkO1xyXG4gIHJldHVybiB0aGlzLl9idWlsZEZyb21CdWZmZXJzKGFyZ3MpO1xyXG59O1xyXG5cclxuSERQdWJsaWNLZXkucHJvdG90eXBlLl9idWlsZEZyb21PYmplY3QgPSBmdW5jdGlvbihhcmcpIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cclxuICAvLyBUT0RPOiBUeXBlIHZhbGlkYXRpb25cclxuICB2YXIgYnVmZmVycyA9IHtcclxuICAgIHZlcnNpb246IGFyZy5uZXR3b3JrID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoTmV0d29yay5nZXQoYXJnLm5ldHdvcmspLnhwdWJrZXkpIDogYXJnLnZlcnNpb24sXHJcbiAgICBkZXB0aDogXy5pc051bWJlcihhcmcuZGVwdGgpID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKGFyZy5kZXB0aCkgOiBhcmcuZGVwdGgsXHJcbiAgICBwYXJlbnRGaW5nZXJQcmludDogXy5pc051bWJlcihhcmcucGFyZW50RmluZ2VyUHJpbnQpID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoYXJnLnBhcmVudEZpbmdlclByaW50KSA6IGFyZy5wYXJlbnRGaW5nZXJQcmludCxcclxuICAgIGNoaWxkSW5kZXg6IF8uaXNOdW1iZXIoYXJnLmNoaWxkSW5kZXgpID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoYXJnLmNoaWxkSW5kZXgpIDogYXJnLmNoaWxkSW5kZXgsXHJcbiAgICBjaGFpbkNvZGU6IF8uaXNTdHJpbmcoYXJnLmNoYWluQ29kZSkgPyBCdWZmZXIuZnJvbShhcmcuY2hhaW5Db2RlLCdoZXgnKSA6IGFyZy5jaGFpbkNvZGUsXHJcbiAgICBwdWJsaWNLZXk6IF8uaXNTdHJpbmcoYXJnLnB1YmxpY0tleSkgPyBCdWZmZXIuZnJvbShhcmcucHVibGljS2V5LCdoZXgnKSA6XHJcbiAgICAgIEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnLnB1YmxpY0tleSkgPyBhcmcucHVibGljS2V5IDogYXJnLnB1YmxpY0tleS50b0J1ZmZlcigpLFxyXG4gICAgY2hlY2tzdW06IF8uaXNOdW1iZXIoYXJnLmNoZWNrc3VtKSA/IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGFyZy5jaGVja3N1bSkgOiBhcmcuY2hlY2tzdW1cclxuICB9O1xyXG4gIHJldHVybiB0aGlzLl9idWlsZEZyb21CdWZmZXJzKGJ1ZmZlcnMpO1xyXG59O1xyXG5cclxuSERQdWJsaWNLZXkucHJvdG90eXBlLl9idWlsZEZyb21TZXJpYWxpemVkID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgdmFyIGRlY29kZWQgPSBCYXNlNThDaGVjay5kZWNvZGUoYXJnKTtcclxuICB2YXIgYnVmZmVycyA9IHtcclxuICAgIHZlcnNpb246IGRlY29kZWQuc2xpY2UoSERQdWJsaWNLZXkuVmVyc2lvblN0YXJ0LCBIRFB1YmxpY0tleS5WZXJzaW9uRW5kKSxcclxuICAgIGRlcHRoOiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LkRlcHRoU3RhcnQsIEhEUHVibGljS2V5LkRlcHRoRW5kKSxcclxuICAgIHBhcmVudEZpbmdlclByaW50OiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50U3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludEVuZCksXHJcbiAgICBjaGlsZEluZGV4OiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LkNoaWxkSW5kZXhTdGFydCwgSERQdWJsaWNLZXkuQ2hpbGRJbmRleEVuZCksXHJcbiAgICBjaGFpbkNvZGU6IGRlY29kZWQuc2xpY2UoSERQdWJsaWNLZXkuQ2hhaW5Db2RlU3RhcnQsIEhEUHVibGljS2V5LkNoYWluQ29kZUVuZCksXHJcbiAgICBwdWJsaWNLZXk6IGRlY29kZWQuc2xpY2UoSERQdWJsaWNLZXkuUHVibGljS2V5U3RhcnQsIEhEUHVibGljS2V5LlB1YmxpY0tleUVuZCksXHJcbiAgICBjaGVja3N1bTogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5DaGVja3N1bVN0YXJ0LCBIRFB1YmxpY0tleS5DaGVja3N1bUVuZCksXHJcbiAgICB4cHVia2V5OiBhcmdcclxuICB9O1xyXG4gIHJldHVybiB0aGlzLl9idWlsZEZyb21CdWZmZXJzKGJ1ZmZlcnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlY2VpdmVzIGEgb2JqZWN0IHdpdGggYnVmZmVycyBpbiBhbGwgdGhlIHByb3BlcnRpZXMgYW5kIHBvcHVsYXRlcyB0aGVcclxuICogaW50ZXJuYWwgc3RydWN0dXJlXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdcclxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcudmVyc2lvblxyXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5kZXB0aFxyXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5wYXJlbnRGaW5nZXJQcmludFxyXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5jaGlsZEluZGV4XHJcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoYWluQ29kZVxyXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5wdWJsaWNLZXlcclxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcuY2hlY2tzdW1cclxuICogQHBhcmFtIHtzdHJpbmc9fSBhcmcueHB1YmtleSAtIGlmIHNldCwgZG9uJ3QgcmVjYWxjdWxhdGUgdGhlIGJhc2U1OFxyXG4gKiAgICAgIHJlcHJlc2VudGF0aW9uXHJcbiAqIEByZXR1cm4ge0hEUHVibGljS2V5fSB0aGlzXHJcbiAqL1xyXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuX2J1aWxkRnJvbUJ1ZmZlcnMgPSBmdW5jdGlvbihhcmcpIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogOCAqL1xyXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xyXG5cclxuICBIRFB1YmxpY0tleS5fdmFsaWRhdGVCdWZmZXJBcmd1bWVudHMoYXJnKTtcclxuXHJcbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XHJcbiAgICBfYnVmZmVyczogYXJnXHJcbiAgfSk7XHJcblxyXG4gIHZhciBzZXF1ZW5jZSA9IFtcclxuICAgIGFyZy52ZXJzaW9uLCBhcmcuZGVwdGgsIGFyZy5wYXJlbnRGaW5nZXJQcmludCwgYXJnLmNoaWxkSW5kZXgsIGFyZy5jaGFpbkNvZGUsXHJcbiAgICBhcmcucHVibGljS2V5XHJcbiAgXTtcclxuICB2YXIgY29uY2F0ID0gQnVmZmVyVXRpbC5jb25jYXQoc2VxdWVuY2UpO1xyXG4gIHZhciBjaGVja3N1bSA9IEJhc2U1OENoZWNrLmNoZWNrc3VtKGNvbmNhdCk7XHJcbiAgaWYgKCFhcmcuY2hlY2tzdW0gfHwgIWFyZy5jaGVja3N1bS5sZW5ndGgpIHtcclxuICAgIGFyZy5jaGVja3N1bSA9IGNoZWNrc3VtO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoYXJnLmNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSAhPT0gY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpKSB7XHJcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEI1OENoZWNrc3VtKGNvbmNhdCwgY2hlY2tzdW0pO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgbmV0d29yayA9IE5ldHdvcmsuZ2V0KEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIoYXJnLnZlcnNpb24pKTtcclxuXHJcbiAgdmFyIHhwdWJrZXk7XHJcbiAgeHB1YmtleSA9IEJhc2U1OENoZWNrLmVuY29kZShCdWZmZXJVdGlsLmNvbmNhdChzZXF1ZW5jZSkpO1xyXG4gIGFyZy54cHVia2V5ID0gQnVmZmVyLmZyb20oeHB1YmtleSk7XHJcblxyXG4gIHZhciBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGFyZy5wdWJsaWNLZXksIHtuZXR3b3JrOiBuZXR3b3JrfSk7XHJcbiAgdmFyIHNpemUgPSBIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFNpemU7XHJcbiAgdmFyIGZpbmdlclByaW50ID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAocHVibGljS2V5LnRvQnVmZmVyKCkpLnNsaWNlKDAsIHNpemUpO1xyXG5cclxuICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKHRoaXMsIHtcclxuICAgIHhwdWJrZXk6IHhwdWJrZXksXHJcbiAgICBuZXR3b3JrOiBuZXR3b3JrLFxyXG4gICAgZGVwdGg6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21TaW5nbGVCeXRlQnVmZmVyKGFyZy5kZXB0aCksXHJcbiAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcclxuICAgIGZpbmdlclByaW50OiBmaW5nZXJQcmludFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkhEUHVibGljS2V5Ll92YWxpZGF0ZUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKGFyZykge1xyXG4gIHZhciBjaGVja0J1ZmZlciA9IGZ1bmN0aW9uKG5hbWUsIHNpemUpIHtcclxuICAgIHZhciBidWZmID0gYXJnW25hbWVdO1xyXG4gICAgYXNzZXJ0KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmZiksIG5hbWUgKyAnIGFyZ3VtZW50IGlzIG5vdCBhIGJ1ZmZlciwgaXRcXCdzICcgKyB0eXBlb2YgYnVmZik7XHJcbiAgICBhc3NlcnQoXHJcbiAgICAgIGJ1ZmYubGVuZ3RoID09PSBzaXplLFxyXG4gICAgICBuYW1lICsgJyBoYXMgbm90IHRoZSBleHBlY3RlZCBzaXplOiBmb3VuZCAnICsgYnVmZi5sZW5ndGggKyAnLCBleHBlY3RlZCAnICsgc2l6ZVxyXG4gICAgKTtcclxuICB9O1xyXG4gIGNoZWNrQnVmZmVyKCd2ZXJzaW9uJywgSERQdWJsaWNLZXkuVmVyc2lvblNpemUpO1xyXG4gIGNoZWNrQnVmZmVyKCdkZXB0aCcsIEhEUHVibGljS2V5LkRlcHRoU2l6ZSk7XHJcbiAgY2hlY2tCdWZmZXIoJ3BhcmVudEZpbmdlclByaW50JywgSERQdWJsaWNLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplKTtcclxuICBjaGVja0J1ZmZlcignY2hpbGRJbmRleCcsIEhEUHVibGljS2V5LkNoaWxkSW5kZXhTaXplKTtcclxuICBjaGVja0J1ZmZlcignY2hhaW5Db2RlJywgSERQdWJsaWNLZXkuQ2hhaW5Db2RlU2l6ZSk7XHJcbiAgY2hlY2tCdWZmZXIoJ3B1YmxpY0tleScsIEhEUHVibGljS2V5LlB1YmxpY0tleVNpemUpO1xyXG4gIGlmIChhcmcuY2hlY2tzdW0gJiYgYXJnLmNoZWNrc3VtLmxlbmd0aCkge1xyXG4gICAgY2hlY2tCdWZmZXIoJ2NoZWNrc3VtJywgSERQdWJsaWNLZXkuQ2hlY2tTdW1TaXplKTtcclxuICB9XHJcbn07XHJcblxyXG5IRFB1YmxpY0tleS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcoYXJnKSwgJ05vIHZhbGlkIHN0cmluZyB3YXMgcHJvdmlkZWQnKTtcclxuICByZXR1cm4gbmV3IEhEUHVibGljS2V5KGFyZyk7XHJcbn07XHJcblxyXG5IRFB1YmxpY0tleS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3QoYXJnKSwgJ05vIHZhbGlkIGFyZ3VtZW50IHdhcyBwcm92aWRlZCcpO1xyXG4gIHJldHVybiBuZXcgSERQdWJsaWNLZXkoYXJnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiYXNlNTggY2hlY2tlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgc3RyaW5nIHN0YXJ0aW5nIHdpdGggXCJ4cHViLi4uXCIgaW4gbGl2ZW5ldFxyXG4gKi9cclxuSERQdWJsaWNLZXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMueHB1YmtleTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb25zb2xlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXh0ZW5kZWQgcHVibGljIGtleS5cclxuICogQHJldHVybiBzdHJpbmdcclxuICovXHJcbkhEUHVibGljS2V5LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICc8SERQdWJsaWNLZXk6ICcgKyB0aGlzLnhwdWJrZXkgKyAnPic7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gdG8gcmVjb25zdHJ1Y3QgYSBrZXkuXHJcbiAqXHJcbiAqIEZpZWxkcyBhcmU6IDx1bD5cclxuICogIDxsaT4gbmV0d29yazogJ2xpdmVuZXQnIG9yICd0ZXN0bmV0J1xyXG4gKiAgPGxpPiBkZXB0aDogYSBudW1iZXIgZnJvbSAwIHRvIDI1NSwgdGhlIGRlcHRoIHRvIHRoZSBtYXN0ZXIgZXh0ZW5kZWQga2V5XHJcbiAqICA8bGk+IGZpbmdlclByaW50OiBhIG51bWJlciBvZiAzMiBiaXRzIHRha2VuIGZyb20gdGhlIGhhc2ggb2YgdGhlIHB1YmxpYyBrZXlcclxuICogIDxsaT4gZmluZ2VyUHJpbnQ6IGEgbnVtYmVyIG9mIDMyIGJpdHMgdGFrZW4gZnJvbSB0aGUgaGFzaCBvZiB0aGlzIGtleSdzXHJcbiAqICA8bGk+ICAgICBwYXJlbnQncyBwdWJsaWMga2V5XHJcbiAqICA8bGk+IGNoaWxkSW5kZXg6IGluZGV4IHdpdGggd2hpY2ggdGhpcyBrZXkgd2FzIGRlcml2ZWRcclxuICogIDxsaT4gY2hhaW5Db2RlOiBzdHJpbmcgaW4gaGV4YSBlbmNvZGluZyB1c2VkIGZvciBkZXJpdmF0aW9uXHJcbiAqICA8bGk+IHB1YmxpY0tleTogc3RyaW5nLCBoZXhhIGVuY29kZWQsIGluIGNvbXByZXNzZWQga2V5IGZvcm1hdFxyXG4gKiAgPGxpPiBjaGVja3N1bTogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLl9idWZmZXJzLmNoZWNrc3VtKSxcclxuICogIDxsaT4geHB1YmtleTogdGhlIHN0cmluZyB3aXRoIHRoZSBiYXNlNTggcmVwcmVzZW50YXRpb24gb2YgdGhpcyBleHRlbmRlZCBrZXlcclxuICogIDxsaT4gY2hlY2tzdW06IHRoZSBiYXNlNTggY2hlY2tzdW0gb2YgeHB1YmtleVxyXG4gKiA8L3VsPlxyXG4gKi9cclxuSERQdWJsaWNLZXkucHJvdG90eXBlLnRvT2JqZWN0ID0gSERQdWJsaWNLZXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBuZXR3b3JrOiBOZXR3b3JrLmdldChCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMudmVyc2lvbikpLm5hbWUsXHJcbiAgICBkZXB0aDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbVNpbmdsZUJ5dGVCdWZmZXIodGhpcy5fYnVmZmVycy5kZXB0aCksXHJcbiAgICBmaW5nZXJQcmludDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLmZpbmdlclByaW50KSxcclxuICAgIHBhcmVudEZpbmdlclByaW50OiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMucGFyZW50RmluZ2VyUHJpbnQpLFxyXG4gICAgY2hpbGRJbmRleDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLl9idWZmZXJzLmNoaWxkSW5kZXgpLFxyXG4gICAgY2hhaW5Db2RlOiBCdWZmZXJVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuX2J1ZmZlcnMuY2hhaW5Db2RlKSxcclxuICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkudG9TdHJpbmcoKSxcclxuICAgIGNoZWNrc3VtOiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMuY2hlY2tzdW0pLFxyXG4gICAgeHB1YmtleTogdGhpcy54cHVia2V5XHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBIRFB1YmxpY0tleSBmcm9tIGEgYnVmZmVyIGFyZ3VtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBhcmdcclxuICogQHJldHVybiB7SERQdWJsaWNLZXl9XHJcbiAqL1xyXG5IRFB1YmxpY0tleS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgcmV0dXJuIG5ldyBIRFB1YmxpY0tleShhcmcpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgeHB1YmtleVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XHJcbiAqL1xyXG5IRFB1YmxpY0tleS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gQnVmZmVyVXRpbC5jb3B5KHRoaXMuX2J1ZmZlcnMueHB1YmtleSk7XHJcbn07XHJcblxyXG5IRFB1YmxpY0tleS5IYXJkZW5lZCA9IDB4ODAwMDAwMDA7XHJcbkhEUHVibGljS2V5LlJvb3RFbGVtZW50QWxpYXMgPSBbJ20nLCAnTSddO1xyXG5cclxuSERQdWJsaWNLZXkuVmVyc2lvblNpemUgPSA0O1xyXG5IRFB1YmxpY0tleS5EZXB0aFNpemUgPSAxO1xyXG5IRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFNpemUgPSA0O1xyXG5IRFB1YmxpY0tleS5DaGlsZEluZGV4U2l6ZSA9IDQ7XHJcbkhEUHVibGljS2V5LkNoYWluQ29kZVNpemUgPSAzMjtcclxuSERQdWJsaWNLZXkuUHVibGljS2V5U2l6ZSA9IDMzO1xyXG5IRFB1YmxpY0tleS5DaGVja1N1bVNpemUgPSA0O1xyXG5cclxuSERQdWJsaWNLZXkuRGF0YVNpemUgPSA3ODtcclxuSERQdWJsaWNLZXkuU2VyaWFsaXplZEJ5dGVTaXplID0gODI7XHJcblxyXG5IRFB1YmxpY0tleS5WZXJzaW9uU3RhcnQgICAgICAgICAgID0gMDtcclxuSERQdWJsaWNLZXkuVmVyc2lvbkVuZCAgICAgICAgICAgICA9IEhEUHVibGljS2V5LlZlcnNpb25TdGFydCArIEhEUHVibGljS2V5LlZlcnNpb25TaXplO1xyXG5IRFB1YmxpY0tleS5EZXB0aFN0YXJ0ICAgICAgICAgICAgID0gSERQdWJsaWNLZXkuVmVyc2lvbkVuZDtcclxuSERQdWJsaWNLZXkuRGVwdGhFbmQgICAgICAgICAgICAgICA9IEhEUHVibGljS2V5LkRlcHRoU3RhcnQgKyBIRFB1YmxpY0tleS5EZXB0aFNpemU7XHJcbkhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50U3RhcnQgPSBIRFB1YmxpY0tleS5EZXB0aEVuZDtcclxuSERQdWJsaWNLZXkuUGFyZW50RmluZ2VyUHJpbnRFbmQgICA9IEhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50U3RhcnQgKyBIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFNpemU7XHJcbkhEUHVibGljS2V5LkNoaWxkSW5kZXhTdGFydCAgICAgICAgPSBIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludEVuZDtcclxuSERQdWJsaWNLZXkuQ2hpbGRJbmRleEVuZCAgICAgICAgICA9IEhEUHVibGljS2V5LkNoaWxkSW5kZXhTdGFydCArIEhEUHVibGljS2V5LkNoaWxkSW5kZXhTaXplO1xyXG5IRFB1YmxpY0tleS5DaGFpbkNvZGVTdGFydCAgICAgICAgID0gSERQdWJsaWNLZXkuQ2hpbGRJbmRleEVuZDtcclxuSERQdWJsaWNLZXkuQ2hhaW5Db2RlRW5kICAgICAgICAgICA9IEhEUHVibGljS2V5LkNoYWluQ29kZVN0YXJ0ICsgSERQdWJsaWNLZXkuQ2hhaW5Db2RlU2l6ZTtcclxuSERQdWJsaWNLZXkuUHVibGljS2V5U3RhcnQgICAgICAgICA9IEhEUHVibGljS2V5LkNoYWluQ29kZUVuZDtcclxuSERQdWJsaWNLZXkuUHVibGljS2V5RW5kICAgICAgICAgICA9IEhEUHVibGljS2V5LlB1YmxpY0tleVN0YXJ0ICsgSERQdWJsaWNLZXkuUHVibGljS2V5U2l6ZTtcclxuSERQdWJsaWNLZXkuQ2hlY2tzdW1TdGFydCAgICAgICAgICA9IEhEUHVibGljS2V5LlB1YmxpY0tleUVuZDtcclxuSERQdWJsaWNLZXkuQ2hlY2tzdW1FbmQgICAgICAgICAgICA9IEhEUHVibGljS2V5LkNoZWNrc3VtU3RhcnQgKyBIRFB1YmxpY0tleS5DaGVja1N1bVNpemU7XHJcblxyXG5hc3NlcnQoSERQdWJsaWNLZXkuUHVibGljS2V5RW5kID09PSBIRFB1YmxpY0tleS5EYXRhU2l6ZSk7XHJcbmFzc2VydChIRFB1YmxpY0tleS5DaGVja3N1bUVuZCA9PT0gSERQdWJsaWNLZXkuU2VyaWFsaXplZEJ5dGVTaXplKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSERQdWJsaWNLZXk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/hdpublickey.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/message.js":
/*!*************************************!*\
  !*** ../bitcore-lib/lib/message.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar PrivateKey = __webpack_require__(/*! ./privatekey */ \"../bitcore-lib/lib/privatekey.js\");\r\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"../bitcore-lib/lib/publickey.js\");\r\nvar Address = __webpack_require__(/*! ./address */ \"../bitcore-lib/lib/address.js\");\r\nvar BufferWriter = __webpack_require__(/*! ./encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar ECDSA = __webpack_require__(/*! ./crypto/ecdsa */ \"../bitcore-lib/lib/crypto/ecdsa.js\");\r\nvar Signature = __webpack_require__(/*! ./crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar sha256sha256 = (__webpack_require__(/*! ./crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\").sha256sha256);\r\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nfunction Message(message) {\r\n  if (!(this instanceof Message)) {\r\n    return new Message(message);\r\n  }\r\n  $.checkArgument(_.isString(message), 'First argument should be a string');\r\n  this.message = message;\r\n\r\n  return this;\r\n}\r\n\r\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\r\n\r\nMessage.prototype.magicHash = function magicHash() {\r\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\r\n  var messageBuffer = Buffer.from(this.message);\r\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\r\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\r\n  var hash = sha256sha256(buf);\r\n  return hash;\r\n};\r\n\r\nMessage.prototype._sign = function _sign(privateKey) {\r\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\r\n  var hash = this.magicHash();\r\n  var ecdsa = new ECDSA();\r\n  ecdsa.hashbuf = hash;\r\n  ecdsa.privkey = privateKey;\r\n  ecdsa.pubkey = privateKey.toPublicKey();\r\n  ecdsa.signRandomK();\r\n  ecdsa.calci();\r\n  return ecdsa.sig;\r\n};\r\n\r\n/**\r\n * Will sign a message with a given bitcoin private key.\r\n *\r\n * @param {PrivateKey} privateKey - An instance of PrivateKey\r\n * @returns {String} A base64 encoded compact signature\r\n */\r\nMessage.prototype.sign = function sign(privateKey) {\r\n  var signature = this._sign(privateKey);\r\n  return signature.toCompact().toString('base64');\r\n};\r\n\r\nMessage.prototype._verify = function _verify(publicKey, signature) {\r\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\r\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\r\n  var hash = this.magicHash();\r\n  var verified = ECDSA.verify(hash, signature, publicKey);\r\n  if (!verified) {\r\n    this.error = 'The signature was invalid';\r\n  }\r\n  return verified;\r\n};\r\n\r\n/**\r\n * Will return a boolean of the signature is valid for a given bitcoin address.\r\n * If it isn't the specific reason is accessible via the \"error\" member.\r\n *\r\n * @param {Address|String} bitcoinAddress - A bitcoin address\r\n * @param {String} signatureString - A base64 encoded compact signature\r\n * @returns {Boolean}\r\n */\r\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\r\n  $.checkArgument(bitcoinAddress);\r\n  $.checkArgument(signatureString && _.isString(signatureString));\r\n\r\n  if (_.isString(bitcoinAddress)) {\r\n    bitcoinAddress = Address.fromString(bitcoinAddress);\r\n  }\r\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\r\n\r\n  // recover the public key\r\n  var ecdsa = new ECDSA();\r\n  ecdsa.hashbuf = this.magicHash();\r\n  ecdsa.sig = signature;\r\n  var publicKey = ecdsa.toPublicKey();\r\n\r\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\r\n\r\n  // check that the recovered address and specified address match\r\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\r\n    this.error = 'The signature did not match the message digest';\r\n    return false;\r\n  }\r\n\r\n  return this._verify(publicKey, signature);\r\n};\r\n\r\n/**\r\n * Will return a public key string if the provided signature and the message digest is correct\r\n * If it isn't the specific reason is accessible via the \"error\" member.\r\n *\r\n * @param {Address|String} bitcoinAddress - A bitcoin address\r\n * @param {String} signatureString - A base64 encoded compact signature\r\n * @returns {String}\r\n */\r\nMessage.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {\r\n  $.checkArgument(bitcoinAddress);\r\n  $.checkArgument(signatureString && _.isString(signatureString));\r\n\r\n  if (_.isString(bitcoinAddress)) {\r\n    bitcoinAddress = Address.fromString(bitcoinAddress);\r\n  }\r\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\r\n\r\n  // recover the public key\r\n  var ecdsa = new ECDSA();\r\n  ecdsa.hashbuf = this.magicHash();\r\n  ecdsa.sig = signature;\r\n  var publicKey = ecdsa.toPublicKey();\r\n\r\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\r\n\r\n  // check that the recovered address and specified address match\r\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\r\n    this.error = 'The signature did not match the message digest';\r\n  }\r\n\r\n  return publicKey.toString();\r\n};\r\n\r\n/**\r\n * Instantiate a message from a message string\r\n *\r\n * @param {String} str - A string of the message\r\n * @returns {Message} A new instance of a Message\r\n */\r\nMessage.fromString = function(str) {\r\n  return new Message(str);\r\n};\r\n\r\n/**\r\n * Instantiate a message from JSON\r\n *\r\n * @param {String} json - An JSON string or Object with keys: message\r\n * @returns {Message} A new instance of a Message\r\n */\r\nMessage.fromJSON = function fromJSON(json) {\r\n  if (JSUtil.isValidJSON(json)) {\r\n    json = JSON.parse(json);\r\n  }\r\n  return new Message(json.message);\r\n};\r\n\r\n/**\r\n * @returns {Object} A plain object with the message information\r\n */\r\nMessage.prototype.toObject = function toObject() {\r\n  return {\r\n    message: this.message\r\n  };\r\n};\r\n\r\n/**\r\n * @returns {String} A JSON representation of the message information\r\n */\r\nMessage.prototype.toJSON = function toJSON() {\r\n  return JSON.stringify(this.toObject());\r\n};\r\n\r\n/**\r\n * Will return a the string representation of the message\r\n *\r\n * @returns {String} Message\r\n */\r\nMessage.prototype.toString = function() {\r\n  return this.message;\r\n};\r\n\r\n/**\r\n * Will return a string formatted for the console\r\n *\r\n * @returns {String} Message\r\n */\r\nMessage.prototype.inspect = function() {\r\n  return '<Message: ' + this.toString() + '>';\r\n};\r\n\r\nmodule.exports = Message;\r\n\r\nvar Script = __webpack_require__(/*! ./script */ \"../bitcore-lib/lib/script/index.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQSxRQUFRLG1CQUFPLENBQUMsNERBQVE7QUFDeEIsaUJBQWlCLG1CQUFPLENBQUMsc0RBQWM7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsb0RBQWE7QUFDckMsY0FBYyxtQkFBTyxDQUFDLGdEQUFXO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUF5QjtBQUNwRCxZQUFZLG1CQUFPLENBQUMsMERBQWdCO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFvQjtBQUM1QyxtQkFBbUIsNEZBQXFDO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxnREFBVztBQUNoQyxRQUFRLG1CQUFPLENBQUMsc0VBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0RBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9tZXNzYWdlLmpzPzVmNzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL3ByaXZhdGVrZXknKTtcclxudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vcHVibGlja2V5Jyk7XHJcbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XHJcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xyXG52YXIgRUNEU0EgPSByZXF1aXJlKCcuL2NyeXB0by9lY2RzYScpO1xyXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9jcnlwdG8vc2lnbmF0dXJlJyk7XHJcbnZhciBzaGEyNTZzaGEyNTYgPSByZXF1aXJlKCcuL2NyeXB0by9oYXNoJykuc2hhMjU2c2hhMjU2O1xyXG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxuXHJcbmZ1bmN0aW9uIE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNZXNzYWdlKSkge1xyXG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gIH1cclxuICAkLmNoZWNrQXJndW1lbnQoXy5pc1N0cmluZyhtZXNzYWdlKSwgJ0ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhIHN0cmluZycpO1xyXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5NZXNzYWdlLk1BR0lDX0JZVEVTID0gQnVmZmVyLmZyb20oJ0JpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyk7XHJcblxyXG5NZXNzYWdlLnByb3RvdHlwZS5tYWdpY0hhc2ggPSBmdW5jdGlvbiBtYWdpY0hhc2goKSB7XHJcbiAgdmFyIHByZWZpeDEgPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKE1lc3NhZ2UuTUFHSUNfQllURVMubGVuZ3RoKTtcclxuICB2YXIgbWVzc2FnZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRoaXMubWVzc2FnZSk7XHJcbiAgdmFyIHByZWZpeDIgPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKG1lc3NhZ2VCdWZmZXIubGVuZ3RoKTtcclxuICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChbcHJlZml4MSwgTWVzc2FnZS5NQUdJQ19CWVRFUywgcHJlZml4MiwgbWVzc2FnZUJ1ZmZlcl0pO1xyXG4gIHZhciBoYXNoID0gc2hhMjU2c2hhMjU2KGJ1Zik7XHJcbiAgcmV0dXJuIGhhc2g7XHJcbn07XHJcblxyXG5NZXNzYWdlLnByb3RvdHlwZS5fc2lnbiA9IGZ1bmN0aW9uIF9zaWduKHByaXZhdGVLZXkpIHtcclxuICAkLmNoZWNrQXJndW1lbnQocHJpdmF0ZUtleSBpbnN0YW5jZW9mIFByaXZhdGVLZXksICdGaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleScpO1xyXG4gIHZhciBoYXNoID0gdGhpcy5tYWdpY0hhc2goKTtcclxuICB2YXIgZWNkc2EgPSBuZXcgRUNEU0EoKTtcclxuICBlY2RzYS5oYXNoYnVmID0gaGFzaDtcclxuICBlY2RzYS5wcml2a2V5ID0gcHJpdmF0ZUtleTtcclxuICBlY2RzYS5wdWJrZXkgPSBwcml2YXRlS2V5LnRvUHVibGljS2V5KCk7XHJcbiAgZWNkc2Euc2lnblJhbmRvbUsoKTtcclxuICBlY2RzYS5jYWxjaSgpO1xyXG4gIHJldHVybiBlY2RzYS5zaWc7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCBzaWduIGEgbWVzc2FnZSB3aXRoIGEgZ2l2ZW4gYml0Y29pbiBwcml2YXRlIGtleS5cclxuICpcclxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlS2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIGJhc2U2NCBlbmNvZGVkIGNvbXBhY3Qgc2lnbmF0dXJlXHJcbiAqL1xyXG5NZXNzYWdlLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihwcml2YXRlS2V5KSB7XHJcbiAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX3NpZ24ocHJpdmF0ZUtleSk7XHJcbiAgcmV0dXJuIHNpZ25hdHVyZS50b0NvbXBhY3QoKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcbn07XHJcblxyXG5NZXNzYWdlLnByb3RvdHlwZS5fdmVyaWZ5ID0gZnVuY3Rpb24gX3ZlcmlmeShwdWJsaWNLZXksIHNpZ25hdHVyZSkge1xyXG4gICQuY2hlY2tBcmd1bWVudChwdWJsaWNLZXkgaW5zdGFuY2VvZiBQdWJsaWNLZXksICdGaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgUHVibGljS2V5Jyk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSwgJ1NlY29uZCBhcmd1bWVudCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgU2lnbmF0dXJlJyk7XHJcbiAgdmFyIGhhc2ggPSB0aGlzLm1hZ2ljSGFzaCgpO1xyXG4gIHZhciB2ZXJpZmllZCA9IEVDRFNBLnZlcmlmeShoYXNoLCBzaWduYXR1cmUsIHB1YmxpY0tleSk7XHJcbiAgaWYgKCF2ZXJpZmllZCkge1xyXG4gICAgdGhpcy5lcnJvciA9ICdUaGUgc2lnbmF0dXJlIHdhcyBpbnZhbGlkJztcclxuICB9XHJcbiAgcmV0dXJuIHZlcmlmaWVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgcmV0dXJuIGEgYm9vbGVhbiBvZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkIGZvciBhIGdpdmVuIGJpdGNvaW4gYWRkcmVzcy5cclxuICogSWYgaXQgaXNuJ3QgdGhlIHNwZWNpZmljIHJlYXNvbiBpcyBhY2Nlc3NpYmxlIHZpYSB0aGUgXCJlcnJvclwiIG1lbWJlci5cclxuICpcclxuICogQHBhcmFtIHtBZGRyZXNzfFN0cmluZ30gYml0Y29pbkFkZHJlc3MgLSBBIGJpdGNvaW4gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmF0dXJlU3RyaW5nIC0gQSBiYXNlNjQgZW5jb2RlZCBjb21wYWN0IHNpZ25hdHVyZVxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbk1lc3NhZ2UucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShiaXRjb2luQWRkcmVzcywgc2lnbmF0dXJlU3RyaW5nKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KGJpdGNvaW5BZGRyZXNzKTtcclxuICAkLmNoZWNrQXJndW1lbnQoc2lnbmF0dXJlU3RyaW5nICYmIF8uaXNTdHJpbmcoc2lnbmF0dXJlU3RyaW5nKSk7XHJcblxyXG4gIGlmIChfLmlzU3RyaW5nKGJpdGNvaW5BZGRyZXNzKSkge1xyXG4gICAgYml0Y29pbkFkZHJlc3MgPSBBZGRyZXNzLmZyb21TdHJpbmcoYml0Y29pbkFkZHJlc3MpO1xyXG4gIH1cclxuICB2YXIgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KEJ1ZmZlci5mcm9tKHNpZ25hdHVyZVN0cmluZywgJ2Jhc2U2NCcpKTtcclxuXHJcbiAgLy8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxyXG4gIHZhciBlY2RzYSA9IG5ldyBFQ0RTQSgpO1xyXG4gIGVjZHNhLmhhc2hidWYgPSB0aGlzLm1hZ2ljSGFzaCgpO1xyXG4gIGVjZHNhLnNpZyA9IHNpZ25hdHVyZTtcclxuICB2YXIgcHVibGljS2V5ID0gZWNkc2EudG9QdWJsaWNLZXkoKTtcclxuXHJcbiAgdmFyIHNpZ25hdHVyZUFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkocHVibGljS2V5LCBiaXRjb2luQWRkcmVzcy5uZXR3b3JrKTtcclxuXHJcbiAgLy8gY2hlY2sgdGhhdCB0aGUgcmVjb3ZlcmVkIGFkZHJlc3MgYW5kIHNwZWNpZmllZCBhZGRyZXNzIG1hdGNoXHJcbiAgaWYgKGJpdGNvaW5BZGRyZXNzLnRvU3RyaW5nKCkgIT09IHNpZ25hdHVyZUFkZHJlc3MudG9TdHJpbmcoKSkge1xyXG4gICAgdGhpcy5lcnJvciA9ICdUaGUgc2lnbmF0dXJlIGRpZCBub3QgbWF0Y2ggdGhlIG1lc3NhZ2UgZGlnZXN0JztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLl92ZXJpZnkocHVibGljS2V5LCBzaWduYXR1cmUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgcmV0dXJuIGEgcHVibGljIGtleSBzdHJpbmcgaWYgdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBhbmQgdGhlIG1lc3NhZ2UgZGlnZXN0IGlzIGNvcnJlY3RcclxuICogSWYgaXQgaXNuJ3QgdGhlIHNwZWNpZmljIHJlYXNvbiBpcyBhY2Nlc3NpYmxlIHZpYSB0aGUgXCJlcnJvclwiIG1lbWJlci5cclxuICpcclxuICogQHBhcmFtIHtBZGRyZXNzfFN0cmluZ30gYml0Y29pbkFkZHJlc3MgLSBBIGJpdGNvaW4gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmF0dXJlU3RyaW5nIC0gQSBiYXNlNjQgZW5jb2RlZCBjb21wYWN0IHNpZ25hdHVyZVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuTWVzc2FnZS5wcm90b3R5cGUucmVjb3ZlclB1YmxpY0tleSA9IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoYml0Y29pbkFkZHJlc3MsIHNpZ25hdHVyZVN0cmluZykge1xyXG4gICQuY2hlY2tBcmd1bWVudChiaXRjb2luQWRkcmVzcyk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ25hdHVyZVN0cmluZyAmJiBfLmlzU3RyaW5nKHNpZ25hdHVyZVN0cmluZykpO1xyXG5cclxuICBpZiAoXy5pc1N0cmluZyhiaXRjb2luQWRkcmVzcykpIHtcclxuICAgIGJpdGNvaW5BZGRyZXNzID0gQWRkcmVzcy5mcm9tU3RyaW5nKGJpdGNvaW5BZGRyZXNzKTtcclxuICB9XHJcbiAgdmFyIHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChCdWZmZXIuZnJvbShzaWduYXR1cmVTdHJpbmcsICdiYXNlNjQnKSk7XHJcblxyXG4gIC8vIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcclxuICB2YXIgZWNkc2EgPSBuZXcgRUNEU0EoKTtcclxuICBlY2RzYS5oYXNoYnVmID0gdGhpcy5tYWdpY0hhc2goKTtcclxuICBlY2RzYS5zaWcgPSBzaWduYXR1cmU7XHJcbiAgdmFyIHB1YmxpY0tleSA9IGVjZHNhLnRvUHVibGljS2V5KCk7XHJcblxyXG4gIHZhciBzaWduYXR1cmVBZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KHB1YmxpY0tleSwgYml0Y29pbkFkZHJlc3MubmV0d29yayk7XHJcblxyXG4gIC8vIGNoZWNrIHRoYXQgdGhlIHJlY292ZXJlZCBhZGRyZXNzIGFuZCBzcGVjaWZpZWQgYWRkcmVzcyBtYXRjaFxyXG4gIGlmIChiaXRjb2luQWRkcmVzcy50b1N0cmluZygpICE9PSBzaWduYXR1cmVBZGRyZXNzLnRvU3RyaW5nKCkpIHtcclxuICAgIHRoaXMuZXJyb3IgPSAnVGhlIHNpZ25hdHVyZSBkaWQgbm90IG1hdGNoIHRoZSBtZXNzYWdlIGRpZ2VzdCc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGUgYSBtZXNzYWdlIGZyb20gYSBtZXNzYWdlIHN0cmluZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gQSBzdHJpbmcgb2YgdGhlIG1lc3NhZ2VcclxuICogQHJldHVybnMge01lc3NhZ2V9IEEgbmV3IGluc3RhbmNlIG9mIGEgTWVzc2FnZVxyXG4gKi9cclxuTWVzc2FnZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgcmV0dXJuIG5ldyBNZXNzYWdlKHN0cik7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGUgYSBtZXNzYWdlIGZyb20gSlNPTlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30ganNvbiAtIEFuIEpTT04gc3RyaW5nIG9yIE9iamVjdCB3aXRoIGtleXM6IG1lc3NhZ2VcclxuICogQHJldHVybnMge01lc3NhZ2V9IEEgbmV3IGluc3RhbmNlIG9mIGEgTWVzc2FnZVxyXG4gKi9cclxuTWVzc2FnZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcclxuICBpZiAoSlNVdGlsLmlzVmFsaWRKU09OKGpzb24pKSB7XHJcbiAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBNZXNzYWdlKGpzb24ubWVzc2FnZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge09iamVjdH0gQSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgbWVzc2FnZSBpbmZvcm1hdGlvblxyXG4gKi9cclxuTWVzc2FnZS5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lc3NhZ2UgaW5mb3JtYXRpb25cclxuICovXHJcbk1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b09iamVjdCgpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaWxsIHJldHVybiBhIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lc3NhZ2VcclxuICpcclxuICogQHJldHVybnMge1N0cmluZ30gTWVzc2FnZVxyXG4gKi9cclxuTWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5tZXNzYWdlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcclxuICpcclxuICogQHJldHVybnMge1N0cmluZ30gTWVzc2FnZVxyXG4gKi9cclxuTWVzc2FnZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiAnPE1lc3NhZ2U6ICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnPic7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2U7XHJcblxyXG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/message.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/networks.js":
/*!**************************************!*\
  !*** ../bitcore-lib/lib/networks.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar networks = [];\r\nvar networkMaps = {};\r\n\r\n/**\r\n * A network is merely a map containing values that correspond to version\r\n * numbers for each bitcoin network. Currently only supporting \"livenet\"\r\n * (a.k.a. \"mainnet\") and \"testnet\".\r\n * @constructor\r\n */\r\nfunction Network() {}\r\n\r\nNetwork.prototype.toString = function toString() {\r\n  return this.name;\r\n};\r\n\r\n/**\r\n * @function\r\n * @member Networks#get\r\n * Retrieves the network associated with a magic number or string.\r\n * @param {string|number|Network} arg\r\n * @param {string|Array} keys - if set, only check if the magic number associated with this name matches\r\n * @return Network\r\n */\r\nfunction get(arg, keys) {\r\n  if (~networks.indexOf(arg)) {\r\n    return arg;\r\n  }\r\n  if (keys) {\r\n    if (!Array.isArray(keys)) {\r\n      keys = [keys];\r\n    }\r\n    for (const index in networks) {\r\n      if (keys.some(key => networks[index][key] === arg)) {\r\n        return networks[index];\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  if (networkMaps[arg] && networkMaps[arg].length >= 1) {\r\n    return networkMaps[arg][0];\r\n  } else {\r\n    return networkMaps[arg];\r\n  }\r\n}\r\n\r\n/**\r\n * @function\r\n * @member Networks#is\r\n * Returns true if the string is the network name or alias\r\n * @param {string} str - A string to check\r\n * @return boolean\r\n */\r\nfunction is(str) {\r\n  return this.name == str || this.alias == str;\r\n}\r\n\r\n/**\r\n * @function\r\n * @member Networks#add\r\n * Will add a custom Network\r\n * @param {Object} data\r\n * @param {string} data.name - The name of the network\r\n * @param {string} data.alias - The aliased name of the network\r\n * @param {Number} data.pubkeyhash - The publickey hash prefix\r\n * @param {Number} data.privatekey - The privatekey prefix\r\n * @param {Number} data.scripthash - The scripthash prefix\r\n * @param {string} data.bech32prefix - The native segwit prefix\r\n * @param {Number} data.xpubkey - The extended public key magic\r\n * @param {Number} data.xprivkey - The extended private key magic\r\n * @param {Array}  data.variants - An array of variants\r\n * @param {string} data.variants.name - The name of the variant\r\n * @param {Number} data.variants.networkMagic - The network magic number\r\n * @param {Number} data.variants.port - The network port\r\n * @param {Array}  data.variants.dnsSeeds - An array of dns seeds\r\n * @return Network\r\n */\r\nfunction addNetwork(data) {\r\n  var network = new Network();\r\n\r\n  JSUtil.defineImmutable(network, {\r\n    name: data.name,\r\n    alias: data.alias,\r\n    is: data.is,\r\n    pubkeyhash: data.pubkeyhash,\r\n    privatekey: data.privatekey,\r\n    scripthash: data.scripthash,\r\n    bech32prefix: data.bech32prefix,\r\n    xpubkey: data.xpubkey,\r\n    xprivkey: data.xprivkey\r\n  });\r\n\r\n  if (data.networkMagic) {\r\n    JSUtil.defineImmutable(network, {\r\n      networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)\r\n    });\r\n  }\r\n\r\n  if (data.port) {\r\n    JSUtil.defineImmutable(network, {\r\n      port: data.port\r\n    });\r\n  }\r\n\r\n  if (data.dnsSeeds) {\r\n    JSUtil.defineImmutable(network, {\r\n      dnsSeeds: data.dnsSeeds\r\n    });\r\n  }\r\n\r\n  for (const value of Object.values(network)) {\r\n    if (value != null && typeof value !== 'object') {\r\n      if (!networkMaps[value]) {\r\n        networkMaps[value] = [];\r\n      }\r\n      networkMaps[value].push(network);\r\n    }\r\n  };\r\n\r\n  networks.push(network);\r\n\r\n  for (const variant of data.variants || []) {\r\n    addNetwork({\r\n      ...data,\r\n      variants: undefined,\r\n      ...variant,\r\n    });\r\n  }\r\n\r\n  return network;\r\n}\r\n\r\n/**\r\n * @function\r\n * @member Networks#remove\r\n * Will remove a custom network\r\n * @param {Network} network\r\n */\r\nfunction removeNetwork(network) {\r\n  if (typeof network !== 'object') {\r\n    network = get(network);\r\n  }\r\n  for (var i = 0; i < networks.length; i++) {\r\n    if (networks[i] === network) {\r\n      networks.splice(i, 1);\r\n    }\r\n  }\r\n  for (var key in networkMaps) {\r\n    if (networkMaps[key].length) {\r\n      const index = networkMaps[key].indexOf(network);\r\n      if (index >= 0) {\r\n        networkMaps[key].splice(index, 1);\r\n      }\r\n      if (networkMaps[key].length === 0) {\r\n        delete networkMaps[key];\r\n      }\r\n    } else if (networkMaps[key] === network) {\r\n      delete networkMaps[key];\r\n    }\r\n  }\r\n}\r\n\r\naddNetwork({\r\n  name: 'livenet',\r\n  alias: 'mainnet',\r\n  is,\r\n  pubkeyhash: 0x00,\r\n  privatekey: 0x80,\r\n  scripthash: 0x05,\r\n  bech32prefix: 'bc',\r\n  xpubkey: 0x0488b21e,\r\n  xprivkey: 0x0488ade4,\r\n  networkMagic: 0xf9beb4d9,\r\n  port: 8333,\r\n  dnsSeeds: [\r\n    'seed.bitcoin.sipa.be',\r\n    'dnsseed.bluematt.me',\r\n    'dnsseed.bitcoin.dashjr.org',\r\n    'seed.bitcoinstats.com',\r\n    'seed.bitnodes.io',\r\n    'bitseed.xf2.org'\r\n  ]\r\n});\r\n\r\n/**\r\n * @instance\r\n * @member Networks#livenet\r\n */\r\nvar livenet = get('livenet');\r\n\r\naddNetwork({\r\n  name: 'testnet',\r\n  alias: 'testnet',\r\n  is,\r\n  pubkeyhash: 0x6f,\r\n  privatekey: 0xef,\r\n  scripthash: 0xc4,\r\n  bech32prefix: 'tb',\r\n  xpubkey: 0x043587cf,\r\n  xprivkey: 0x04358394,\r\n  variants: [{\r\n    name: 'testnet3',\r\n    networkMagic: 0x0b110907,\r\n    port: 18333,\r\n    dnsSeeds: [\r\n      'testnet-seed.bitcoin.petertodd.org',\r\n      'testnet-seed.bluematt.me',\r\n      'testnet-seed.alexykot.me',\r\n      'testnet-seed.bitcoin.schildbach.de'\r\n    ]\r\n  }, {\r\n    name: 'signet',\r\n    networkMagic: 0x0a03cf40,\r\n    port: 38332,\r\n    dnsSeeds: [\r\n      '178.128.221.177',\r\n      '103.16.128.63',\r\n      '153.126.143.201',\r\n      '192.241.163.142'\r\n    ]\r\n  }]\r\n});\r\n\r\n/**\r\n * @instance\r\n * @member Networks#testnet\r\n */\r\nvar testnet = get('testnet');\r\nvar testnet3 = get('testnet3');\r\nvar signet = get('signet');\r\n\r\naddNetwork({\r\n  name: 'regtest',\r\n  alias: 'dev',\r\n  is,\r\n  pubkeyhash: 0x6f,\r\n  privatekey: 0xef,\r\n  scripthash: 0xc4,\r\n  bech32prefix: 'bcrt',\r\n  xpubkey: 0x043587cf,\r\n  xprivkey: 0x04358394,\r\n  networkMagic: 0xfabfb5da,\r\n  port: 18444,\r\n  dnsSeeds: []\r\n});\r\n\r\n/**\r\n * @instance\r\n * @member Networks#regtest\r\n */\r\nvar regtest = get('regtest');\r\n\r\n/**\r\n * @function\r\n * @deprecated\r\n * @member Networks#enableRegtest\r\n * Will enable regtest features for testnet\r\n */\r\nfunction enableRegtest() {\r\n  testnet.regtestEnabled = true;\r\n}\r\n\r\n/**\r\n * @function\r\n * @deprecated\r\n * @member Networks#disableRegtest\r\n * Will disable regtest features for testnet\r\n */\r\nfunction disableRegtest() {\r\n  testnet.regtestEnabled = false;\r\n}\r\n\r\n/**\r\n * @namespace Networks\r\n */\r\nmodule.exports = {\r\n  add: addNetwork,\r\n  remove: removeNetwork,\r\n  defaultNetwork: livenet,\r\n  livenet: livenet,\r\n  mainnet: livenet,\r\n  testnet: testnet,\r\n  testnet3: testnet3,\r\n  signet: signet,\r\n  regtest: regtest,\r\n  get: get,\r\n  enableRegtest: enableRegtest,\r\n  disableRegtest: disableRegtest\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL25ldHdvcmtzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsd0RBQWU7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGdEQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvbmV0d29ya3MuanM/ODJkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi91dGlsL2J1ZmZlcicpO1xyXG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XHJcbnZhciBuZXR3b3JrcyA9IFtdO1xyXG52YXIgbmV0d29ya01hcHMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIG5ldHdvcmsgaXMgbWVyZWx5IGEgbWFwIGNvbnRhaW5pbmcgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB2ZXJzaW9uXHJcbiAqIG51bWJlcnMgZm9yIGVhY2ggYml0Y29pbiBuZXR3b3JrLiBDdXJyZW50bHkgb25seSBzdXBwb3J0aW5nIFwibGl2ZW5ldFwiXHJcbiAqIChhLmsuYS4gXCJtYWlubmV0XCIpIGFuZCBcInRlc3RuZXRcIi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBOZXR3b3JrKCkge31cclxuXHJcbk5ldHdvcmsucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcbiAgcmV0dXJuIHRoaXMubmFtZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG1lbWJlciBOZXR3b3JrcyNnZXRcclxuICogUmV0cmlldmVzIHRoZSBuZXR3b3JrIGFzc29jaWF0ZWQgd2l0aCBhIG1hZ2ljIG51bWJlciBvciBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxOZXR3b3JrfSBhcmdcclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGtleXMgLSBpZiBzZXQsIG9ubHkgY2hlY2sgaWYgdGhlIG1hZ2ljIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBuYW1lIG1hdGNoZXNcclxuICogQHJldHVybiBOZXR3b3JrXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXQoYXJnLCBrZXlzKSB7XHJcbiAgaWYgKH5uZXR3b3Jrcy5pbmRleE9mKGFyZykpIHtcclxuICAgIHJldHVybiBhcmc7XHJcbiAgfVxyXG4gIGlmIChrZXlzKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcclxuICAgICAga2V5cyA9IFtrZXlzXTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gbmV0d29ya3MpIHtcclxuICAgICAgaWYgKGtleXMuc29tZShrZXkgPT4gbmV0d29ya3NbaW5kZXhdW2tleV0gPT09IGFyZykpIHtcclxuICAgICAgICByZXR1cm4gbmV0d29ya3NbaW5kZXhdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpZiAobmV0d29ya01hcHNbYXJnXSAmJiBuZXR3b3JrTWFwc1thcmddLmxlbmd0aCA+PSAxKSB7XHJcbiAgICByZXR1cm4gbmV0d29ya01hcHNbYXJnXVswXTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5ldHdvcmtNYXBzW2FyZ107XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBtZW1iZXIgTmV0d29ya3MjaXNcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgdGhlIG5ldHdvcmsgbmFtZSBvciBhbGlhc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gQSBzdHJpbmcgdG8gY2hlY2tcclxuICogQHJldHVybiBib29sZWFuXHJcbiAqL1xyXG5mdW5jdGlvbiBpcyhzdHIpIHtcclxuICByZXR1cm4gdGhpcy5uYW1lID09IHN0ciB8fCB0aGlzLmFsaWFzID09IHN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAbWVtYmVyIE5ldHdvcmtzI2FkZFxyXG4gKiBXaWxsIGFkZCBhIGN1c3RvbSBOZXR3b3JrXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbmV0d29ya1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS5hbGlhcyAtIFRoZSBhbGlhc2VkIG5hbWUgb2YgdGhlIG5ldHdvcmtcclxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucHVia2V5aGFzaCAtIFRoZSBwdWJsaWNrZXkgaGFzaCBwcmVmaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucHJpdmF0ZWtleSAtIFRoZSBwcml2YXRla2V5IHByZWZpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JpcHRoYXNoIC0gVGhlIHNjcmlwdGhhc2ggcHJlZml4XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhLmJlY2gzMnByZWZpeCAtIFRoZSBuYXRpdmUgc2Vnd2l0IHByZWZpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YS54cHVia2V5IC0gVGhlIGV4dGVuZGVkIHB1YmxpYyBrZXkgbWFnaWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEueHByaXZrZXkgLSBUaGUgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgbWFnaWNcclxuICogQHBhcmFtIHtBcnJheX0gIGRhdGEudmFyaWFudHMgLSBBbiBhcnJheSBvZiB2YXJpYW50c1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS52YXJpYW50cy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhcmlhbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudmFyaWFudHMubmV0d29ya01hZ2ljIC0gVGhlIG5ldHdvcmsgbWFnaWMgbnVtYmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnZhcmlhbnRzLnBvcnQgLSBUaGUgbmV0d29yayBwb3J0XHJcbiAqIEBwYXJhbSB7QXJyYXl9ICBkYXRhLnZhcmlhbnRzLmRuc1NlZWRzIC0gQW4gYXJyYXkgb2YgZG5zIHNlZWRzXHJcbiAqIEByZXR1cm4gTmV0d29ya1xyXG4gKi9cclxuZnVuY3Rpb24gYWRkTmV0d29yayhkYXRhKSB7XHJcbiAgdmFyIG5ldHdvcmsgPSBuZXcgTmV0d29yaygpO1xyXG5cclxuICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKG5ldHdvcmssIHtcclxuICAgIG5hbWU6IGRhdGEubmFtZSxcclxuICAgIGFsaWFzOiBkYXRhLmFsaWFzLFxyXG4gICAgaXM6IGRhdGEuaXMsXHJcbiAgICBwdWJrZXloYXNoOiBkYXRhLnB1YmtleWhhc2gsXHJcbiAgICBwcml2YXRla2V5OiBkYXRhLnByaXZhdGVrZXksXHJcbiAgICBzY3JpcHRoYXNoOiBkYXRhLnNjcmlwdGhhc2gsXHJcbiAgICBiZWNoMzJwcmVmaXg6IGRhdGEuYmVjaDMycHJlZml4LFxyXG4gICAgeHB1YmtleTogZGF0YS54cHVia2V5LFxyXG4gICAgeHByaXZrZXk6IGRhdGEueHByaXZrZXlcclxuICB9KTtcclxuXHJcbiAgaWYgKGRhdGEubmV0d29ya01hZ2ljKSB7XHJcbiAgICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKG5ldHdvcmssIHtcclxuICAgICAgbmV0d29ya01hZ2ljOiBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihkYXRhLm5ldHdvcmtNYWdpYylcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGEucG9ydCkge1xyXG4gICAgSlNVdGlsLmRlZmluZUltbXV0YWJsZShuZXR3b3JrLCB7XHJcbiAgICAgIHBvcnQ6IGRhdGEucG9ydFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAoZGF0YS5kbnNTZWVkcykge1xyXG4gICAgSlNVdGlsLmRlZmluZUltbXV0YWJsZShuZXR3b3JrLCB7XHJcbiAgICAgIGRuc1NlZWRzOiBkYXRhLmRuc1NlZWRzXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LnZhbHVlcyhuZXR3b3JrKSkge1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICBpZiAoIW5ldHdvcmtNYXBzW3ZhbHVlXSkge1xyXG4gICAgICAgIG5ldHdvcmtNYXBzW3ZhbHVlXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIG5ldHdvcmtNYXBzW3ZhbHVlXS5wdXNoKG5ldHdvcmspO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIG5ldHdvcmtzLnB1c2gobmV0d29yayk7XHJcblxyXG4gIGZvciAoY29uc3QgdmFyaWFudCBvZiBkYXRhLnZhcmlhbnRzIHx8IFtdKSB7XHJcbiAgICBhZGROZXR3b3JrKHtcclxuICAgICAgLi4uZGF0YSxcclxuICAgICAgdmFyaWFudHM6IHVuZGVmaW5lZCxcclxuICAgICAgLi4udmFyaWFudCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldHdvcms7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG1lbWJlciBOZXR3b3JrcyNyZW1vdmVcclxuICogV2lsbCByZW1vdmUgYSBjdXN0b20gbmV0d29ya1xyXG4gKiBAcGFyYW0ge05ldHdvcmt9IG5ldHdvcmtcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZU5ldHdvcmsobmV0d29yaykge1xyXG4gIGlmICh0eXBlb2YgbmV0d29yayAhPT0gJ29iamVjdCcpIHtcclxuICAgIG5ldHdvcmsgPSBnZXQobmV0d29yayk7XHJcbiAgfVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmV0d29ya3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChuZXR3b3Jrc1tpXSA9PT0gbmV0d29yaykge1xyXG4gICAgICBuZXR3b3Jrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZvciAodmFyIGtleSBpbiBuZXR3b3JrTWFwcykge1xyXG4gICAgaWYgKG5ldHdvcmtNYXBzW2tleV0ubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gbmV0d29ya01hcHNba2V5XS5pbmRleE9mKG5ldHdvcmspO1xyXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgIG5ldHdvcmtNYXBzW2tleV0uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV0d29ya01hcHNba2V5XS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBkZWxldGUgbmV0d29ya01hcHNba2V5XTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChuZXR3b3JrTWFwc1trZXldID09PSBuZXR3b3JrKSB7XHJcbiAgICAgIGRlbGV0ZSBuZXR3b3JrTWFwc1trZXldO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuYWRkTmV0d29yayh7XHJcbiAgbmFtZTogJ2xpdmVuZXQnLFxyXG4gIGFsaWFzOiAnbWFpbm5ldCcsXHJcbiAgaXMsXHJcbiAgcHVia2V5aGFzaDogMHgwMCxcclxuICBwcml2YXRla2V5OiAweDgwLFxyXG4gIHNjcmlwdGhhc2g6IDB4MDUsXHJcbiAgYmVjaDMycHJlZml4OiAnYmMnLFxyXG4gIHhwdWJrZXk6IDB4MDQ4OGIyMWUsXHJcbiAgeHByaXZrZXk6IDB4MDQ4OGFkZTQsXHJcbiAgbmV0d29ya01hZ2ljOiAweGY5YmViNGQ5LFxyXG4gIHBvcnQ6IDgzMzMsXHJcbiAgZG5zU2VlZHM6IFtcclxuICAgICdzZWVkLmJpdGNvaW4uc2lwYS5iZScsXHJcbiAgICAnZG5zc2VlZC5ibHVlbWF0dC5tZScsXHJcbiAgICAnZG5zc2VlZC5iaXRjb2luLmRhc2hqci5vcmcnLFxyXG4gICAgJ3NlZWQuYml0Y29pbnN0YXRzLmNvbScsXHJcbiAgICAnc2VlZC5iaXRub2Rlcy5pbycsXHJcbiAgICAnYml0c2VlZC54ZjIub3JnJ1xyXG4gIF1cclxufSk7XHJcblxyXG4vKipcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXIgTmV0d29ya3MjbGl2ZW5ldFxyXG4gKi9cclxudmFyIGxpdmVuZXQgPSBnZXQoJ2xpdmVuZXQnKTtcclxuXHJcbmFkZE5ldHdvcmsoe1xyXG4gIG5hbWU6ICd0ZXN0bmV0JyxcclxuICBhbGlhczogJ3Rlc3RuZXQnLFxyXG4gIGlzLFxyXG4gIHB1YmtleWhhc2g6IDB4NmYsXHJcbiAgcHJpdmF0ZWtleTogMHhlZixcclxuICBzY3JpcHRoYXNoOiAweGM0LFxyXG4gIGJlY2gzMnByZWZpeDogJ3RiJyxcclxuICB4cHVia2V5OiAweDA0MzU4N2NmLFxyXG4gIHhwcml2a2V5OiAweDA0MzU4Mzk0LFxyXG4gIHZhcmlhbnRzOiBbe1xyXG4gICAgbmFtZTogJ3Rlc3RuZXQzJyxcclxuICAgIG5ldHdvcmtNYWdpYzogMHgwYjExMDkwNyxcclxuICAgIHBvcnQ6IDE4MzMzLFxyXG4gICAgZG5zU2VlZHM6IFtcclxuICAgICAgJ3Rlc3RuZXQtc2VlZC5iaXRjb2luLnBldGVydG9kZC5vcmcnLFxyXG4gICAgICAndGVzdG5ldC1zZWVkLmJsdWVtYXR0Lm1lJyxcclxuICAgICAgJ3Rlc3RuZXQtc2VlZC5hbGV4eWtvdC5tZScsXHJcbiAgICAgICd0ZXN0bmV0LXNlZWQuYml0Y29pbi5zY2hpbGRiYWNoLmRlJ1xyXG4gICAgXVxyXG4gIH0sIHtcclxuICAgIG5hbWU6ICdzaWduZXQnLFxyXG4gICAgbmV0d29ya01hZ2ljOiAweDBhMDNjZjQwLFxyXG4gICAgcG9ydDogMzgzMzIsXHJcbiAgICBkbnNTZWVkczogW1xyXG4gICAgICAnMTc4LjEyOC4yMjEuMTc3JyxcclxuICAgICAgJzEwMy4xNi4xMjguNjMnLFxyXG4gICAgICAnMTUzLjEyNi4xNDMuMjAxJyxcclxuICAgICAgJzE5Mi4yNDEuMTYzLjE0MidcclxuICAgIF1cclxuICB9XVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlciBOZXR3b3JrcyN0ZXN0bmV0XHJcbiAqL1xyXG52YXIgdGVzdG5ldCA9IGdldCgndGVzdG5ldCcpO1xyXG52YXIgdGVzdG5ldDMgPSBnZXQoJ3Rlc3RuZXQzJyk7XHJcbnZhciBzaWduZXQgPSBnZXQoJ3NpZ25ldCcpO1xyXG5cclxuYWRkTmV0d29yayh7XHJcbiAgbmFtZTogJ3JlZ3Rlc3QnLFxyXG4gIGFsaWFzOiAnZGV2JyxcclxuICBpcyxcclxuICBwdWJrZXloYXNoOiAweDZmLFxyXG4gIHByaXZhdGVrZXk6IDB4ZWYsXHJcbiAgc2NyaXB0aGFzaDogMHhjNCxcclxuICBiZWNoMzJwcmVmaXg6ICdiY3J0JyxcclxuICB4cHVia2V5OiAweDA0MzU4N2NmLFxyXG4gIHhwcml2a2V5OiAweDA0MzU4Mzk0LFxyXG4gIG5ldHdvcmtNYWdpYzogMHhmYWJmYjVkYSxcclxuICBwb3J0OiAxODQ0NCxcclxuICBkbnNTZWVkczogW11cclxufSk7XHJcblxyXG4vKipcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXIgTmV0d29ya3MjcmVndGVzdFxyXG4gKi9cclxudmFyIHJlZ3Rlc3QgPSBnZXQoJ3JlZ3Rlc3QnKTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQGRlcHJlY2F0ZWRcclxuICogQG1lbWJlciBOZXR3b3JrcyNlbmFibGVSZWd0ZXN0XHJcbiAqIFdpbGwgZW5hYmxlIHJlZ3Rlc3QgZmVhdHVyZXMgZm9yIHRlc3RuZXRcclxuICovXHJcbmZ1bmN0aW9uIGVuYWJsZVJlZ3Rlc3QoKSB7XHJcbiAgdGVzdG5ldC5yZWd0ZXN0RW5hYmxlZCA9IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQGRlcHJlY2F0ZWRcclxuICogQG1lbWJlciBOZXR3b3JrcyNkaXNhYmxlUmVndGVzdFxyXG4gKiBXaWxsIGRpc2FibGUgcmVndGVzdCBmZWF0dXJlcyBmb3IgdGVzdG5ldFxyXG4gKi9cclxuZnVuY3Rpb24gZGlzYWJsZVJlZ3Rlc3QoKSB7XHJcbiAgdGVzdG5ldC5yZWd0ZXN0RW5hYmxlZCA9IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBOZXR3b3Jrc1xyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgYWRkOiBhZGROZXR3b3JrLFxyXG4gIHJlbW92ZTogcmVtb3ZlTmV0d29yayxcclxuICBkZWZhdWx0TmV0d29yazogbGl2ZW5ldCxcclxuICBsaXZlbmV0OiBsaXZlbmV0LFxyXG4gIG1haW5uZXQ6IGxpdmVuZXQsXHJcbiAgdGVzdG5ldDogdGVzdG5ldCxcclxuICB0ZXN0bmV0MzogdGVzdG5ldDMsXHJcbiAgc2lnbmV0OiBzaWduZXQsXHJcbiAgcmVndGVzdDogcmVndGVzdCxcclxuICBnZXQ6IGdldCxcclxuICBlbmFibGVSZWd0ZXN0OiBlbmFibGVSZWd0ZXN0LFxyXG4gIGRpc2FibGVSZWd0ZXN0OiBkaXNhYmxlUmVndGVzdFxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/networks.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/opcode.js":
/*!************************************!*\
  !*** ../bitcore-lib/lib/opcode.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"../bitcore-lib/lib/util/js.js\");\r\n\r\nfunction Opcode(num) {\r\n  if (!(this instanceof Opcode)) {\r\n    return new Opcode(num);\r\n  }\r\n\r\n  var value;\r\n\r\n  if (_.isNumber(num)) {\r\n    value = num;\r\n  } else if (_.isString(num)) {\r\n    value = Opcode.map[num];\r\n  } else {\r\n    throw new TypeError('Unrecognized num type: \"' + typeof(num) + '\" for Opcode');\r\n  }\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    num: value\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\nOpcode.fromBuffer = function(buf) {\r\n  $.checkArgument(BufferUtil.isBuffer(buf));\r\n  return new Opcode(Number('0x' + buf.toString('hex')));\r\n};\r\n\r\nOpcode.fromNumber = function(num) {\r\n  $.checkArgument(_.isNumber(num));\r\n  return new Opcode(num);\r\n};\r\n\r\nOpcode.fromString = function(str) {\r\n  $.checkArgument(_.isString(str));\r\n  var value = Opcode.map[str];\r\n  if (typeof value === 'undefined') {\r\n    throw new TypeError('Invalid opcodestr');\r\n  }\r\n  return new Opcode(value);\r\n};\r\n\r\nOpcode.prototype.toHex = function() {\r\n  return this.num.toString(16);\r\n};\r\n\r\nOpcode.prototype.toBuffer = function() {\r\n  return Buffer.from(this.toHex(), 'hex');\r\n};\r\n\r\nOpcode.prototype.toNumber = function() {\r\n  return this.num;\r\n};\r\n\r\nOpcode.prototype.toString = function() {\r\n  var str = Opcode.reverseMap[this.num];\r\n  if (typeof str === 'undefined') {\r\n    throw new Error('Opcode does not have a string representation');\r\n  }\r\n  return str;\r\n};\r\n\r\nOpcode.smallInt = function(n) {\r\n  $.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number');\r\n  $.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');\r\n  if (n === 0) {\r\n    return Opcode('OP_0');\r\n  }\r\n  return new Opcode(Opcode.map.OP_1 + n - 1);\r\n};\r\n\r\n/**\r\n * Converts OP_0 - OP_16 to an int\r\n * @param {Number} opcode Opcode\r\n * @returns {Number}\r\n */\r\nOpcode.decodeOpN = function(opcode) {\r\n  if (opcode === Opcode.OP_0) {\r\n    return 0;\r\n  }\r\n  $.checkArgument(opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16, new Error('Invalid opcode: ' + JSON.stringify(opcode)));\r\n  return opcode - (Opcode.OP_1 - 1);\r\n};\r\n\r\n/**\r\n * Returns true if given opcode is classified as a \"success\".\r\n * This was taken from commit https://github.com/bitcoin/bitcoin/commit/72422ce396b8eba7b1a72c171c2f07dae691d1b5\r\n * @param {Number|String} opcode \r\n * @returns {Boolean}\r\n */\r\nOpcode.isOpSuccess = function(opcode) {\r\n  if (typeof opcode === 'string' && !parseInt(opcode)) {\r\n    opcode = Opcode[opcode];\r\n  }\r\n  return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\r\n        (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\r\n        (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\r\n        (opcode >= 187 && opcode <= 254);\r\n};\r\n\r\n\r\nOpcode.map = {\r\n  // push value\r\n  OP_FALSE: 0,\r\n  OP_0: 0,\r\n  OP_PUSHDATA1: 76,\r\n  OP_PUSHDATA2: 77,\r\n  OP_PUSHDATA4: 78,\r\n  OP_1NEGATE: 79,\r\n  OP_RESERVED: 80,\r\n  OP_TRUE: 81,\r\n  OP_1: 81,\r\n  OP_2: 82,\r\n  OP_3: 83,\r\n  OP_4: 84,\r\n  OP_5: 85,\r\n  OP_6: 86,\r\n  OP_7: 87,\r\n  OP_8: 88,\r\n  OP_9: 89,\r\n  OP_10: 90,\r\n  OP_11: 91,\r\n  OP_12: 92,\r\n  OP_13: 93,\r\n  OP_14: 94,\r\n  OP_15: 95,\r\n  OP_16: 96,\r\n\r\n  // control\r\n  OP_NOP: 97,\r\n  OP_VER: 98,\r\n  OP_IF: 99,\r\n  OP_NOTIF: 100,\r\n  OP_VERIF: 101,\r\n  OP_VERNOTIF: 102,\r\n  OP_ELSE: 103,\r\n  OP_ENDIF: 104,\r\n  OP_VERIFY: 105,\r\n  OP_RETURN: 106,\r\n\r\n  // stack ops\r\n  OP_TOALTSTACK: 107,\r\n  OP_FROMALTSTACK: 108,\r\n  OP_2DROP: 109,\r\n  OP_2DUP: 110,\r\n  OP_3DUP: 111,\r\n  OP_2OVER: 112,\r\n  OP_2ROT: 113,\r\n  OP_2SWAP: 114,\r\n  OP_IFDUP: 115,\r\n  OP_DEPTH: 116,\r\n  OP_DROP: 117,\r\n  OP_DUP: 118,\r\n  OP_NIP: 119,\r\n  OP_OVER: 120,\r\n  OP_PICK: 121,\r\n  OP_ROLL: 122,\r\n  OP_ROT: 123,\r\n  OP_SWAP: 124,\r\n  OP_TUCK: 125,\r\n\r\n  // splice ops\r\n  OP_CAT: 126,\r\n  OP_SUBSTR: 127,\r\n  OP_LEFT: 128,\r\n  OP_RIGHT: 129,\r\n  OP_SIZE: 130,\r\n\r\n  // bit logic\r\n  OP_INVERT: 131,\r\n  OP_AND: 132,\r\n  OP_OR: 133,\r\n  OP_XOR: 134,\r\n  OP_EQUAL: 135,\r\n  OP_EQUALVERIFY: 136,\r\n  OP_RESERVED1: 137,\r\n  OP_RESERVED2: 138,\r\n\r\n  // numeric\r\n  OP_1ADD: 139,\r\n  OP_1SUB: 140,\r\n  OP_2MUL: 141,\r\n  OP_2DIV: 142,\r\n  OP_NEGATE: 143,\r\n  OP_ABS: 144,\r\n  OP_NOT: 145,\r\n  OP_0NOTEQUAL: 146,\r\n\r\n  OP_ADD: 147,\r\n  OP_SUB: 148,\r\n  OP_MUL: 149,\r\n  OP_DIV: 150,\r\n  OP_MOD: 151,\r\n  OP_LSHIFT: 152,\r\n  OP_RSHIFT: 153,\r\n\r\n  OP_BOOLAND: 154,\r\n  OP_BOOLOR: 155,\r\n  OP_NUMEQUAL: 156,\r\n  OP_NUMEQUALVERIFY: 157,\r\n  OP_NUMNOTEQUAL: 158,\r\n  OP_LESSTHAN: 159,\r\n  OP_GREATERTHAN: 160,\r\n  OP_LESSTHANOREQUAL: 161,\r\n  OP_GREATERTHANOREQUAL: 162,\r\n  OP_MIN: 163,\r\n  OP_MAX: 164,\r\n\r\n  OP_WITHIN: 165,\r\n\r\n  // crypto\r\n  OP_RIPEMD160: 166,\r\n  OP_SHA1: 167,\r\n  OP_SHA256: 168,\r\n  OP_HASH160: 169,\r\n  OP_HASH256: 170,\r\n  OP_CODESEPARATOR: 171,\r\n  OP_CHECKSIG: 172,\r\n  OP_CHECKSIGVERIFY: 173,\r\n  OP_CHECKMULTISIG: 174,\r\n  OP_CHECKMULTISIGVERIFY: 175,\r\n\r\n  OP_CHECKLOCKTIMEVERIFY: 177,\r\n  OP_CHECKSEQUENCEVERIFY: 178,\r\n\r\n  // expansion\r\n  OP_NOP1: 176,\r\n  OP_NOP2: 177,\r\n  OP_NOP3: 178,\r\n  OP_NOP4: 179,\r\n  OP_NOP5: 180,\r\n  OP_NOP6: 181,\r\n  OP_NOP7: 182,\r\n  OP_NOP8: 183,\r\n  OP_NOP9: 184,\r\n  OP_NOP10: 185,\r\n\r\n  // Opcode added by BIP 342 (Tapscript)\r\n  OP_CHECKSIGADD: 186, // 0xba\r\n\r\n  // template matching params\r\n  OP_PUBKEYHASH: 253,\r\n  OP_PUBKEY: 254,\r\n  OP_INVALIDOPCODE: 255\r\n};\r\n\r\nOpcode.reverseMap = [];\r\n\r\nfor (var k in Opcode.map) {\r\n  Opcode.reverseMap[Opcode.map[k]] = k;\r\n}\r\n\r\n// Easier access to opcodes\r\n_.extend(Opcode, Opcode.map);\r\n\r\n/**\r\n * @returns true if opcode is one of OP_0, OP_1, ..., OP_16\r\n */\r\nOpcode.isSmallIntOp = function(opcode) {\r\n  if (opcode instanceof Opcode) {\r\n    opcode = opcode.toNumber();\r\n  }\r\n  return ((opcode === Opcode.map.OP_0) ||\r\n    ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16)));\r\n};\r\n\r\n/**\r\n * Will return a string formatted for the console\r\n *\r\n * @returns {string} Script opcode\r\n */\r\nOpcode.prototype.inspect = function() {\r\n  return '<Opcode: ' + this.toString() + ', hex: '+this.toHex()+', decimal: '+this.num+'>';\r\n};\r\n\r\nmodule.exports = Opcode;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL29wY29kZS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMsc0VBQXNCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLHdEQUFlO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxnREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL29wY29kZS5qcz9kMGJjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL3V0aWwvYnVmZmVyJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuL3V0aWwvanMnKTtcclxuXHJcbmZ1bmN0aW9uIE9wY29kZShudW0pIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3Bjb2RlKSkge1xyXG4gICAgcmV0dXJuIG5ldyBPcGNvZGUobnVtKTtcclxuICB9XHJcblxyXG4gIHZhciB2YWx1ZTtcclxuXHJcbiAgaWYgKF8uaXNOdW1iZXIobnVtKSkge1xyXG4gICAgdmFsdWUgPSBudW07XHJcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKG51bSkpIHtcclxuICAgIHZhbHVlID0gT3Bjb2RlLm1hcFtudW1dO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlY29nbml6ZWQgbnVtIHR5cGU6IFwiJyArIHR5cGVvZihudW0pICsgJ1wiIGZvciBPcGNvZGUnKTtcclxuICB9XHJcblxyXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xyXG4gICAgbnVtOiB2YWx1ZVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuT3Bjb2RlLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpKTtcclxuICByZXR1cm4gbmV3IE9wY29kZShOdW1iZXIoJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4JykpKTtcclxufTtcclxuXHJcbk9wY29kZS5mcm9tTnVtYmVyID0gZnVuY3Rpb24obnVtKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNOdW1iZXIobnVtKSk7XHJcbiAgcmV0dXJuIG5ldyBPcGNvZGUobnVtKTtcclxufTtcclxuXHJcbk9wY29kZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcoc3RyKSk7XHJcbiAgdmFyIHZhbHVlID0gT3Bjb2RlLm1hcFtzdHJdO1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wY29kZXN0cicpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IE9wY29kZSh2YWx1ZSk7XHJcbn07XHJcblxyXG5PcGNvZGUucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMubnVtLnRvU3RyaW5nKDE2KTtcclxufTtcclxuXHJcbk9wY29kZS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy50b0hleCgpLCAnaGV4Jyk7XHJcbn07XHJcblxyXG5PcGNvZGUucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMubnVtO1xyXG59O1xyXG5cclxuT3Bjb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBzdHIgPSBPcGNvZGUucmV2ZXJzZU1hcFt0aGlzLm51bV07XHJcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wY29kZSBkb2VzIG5vdCBoYXZlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uJyk7XHJcbiAgfVxyXG4gIHJldHVybiBzdHI7XHJcbn07XHJcblxyXG5PcGNvZGUuc21hbGxJbnQgPSBmdW5jdGlvbihuKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNOdW1iZXIobiksICdJbnZhbGlkIEFyZ3VtZW50OiBuIHNob3VsZCBiZSBudW1iZXInKTtcclxuICAkLmNoZWNrQXJndW1lbnQobiA+PSAwICYmIG4gPD0gMTYsICdJbnZhbGlkIEFyZ3VtZW50OiBuIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxNicpO1xyXG4gIGlmIChuID09PSAwKSB7XHJcbiAgICByZXR1cm4gT3Bjb2RlKCdPUF8wJyk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgT3Bjb2RlKE9wY29kZS5tYXAuT1BfMSArIG4gLSAxKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBPUF8wIC0gT1BfMTYgdG8gYW4gaW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcGNvZGUgT3Bjb2RlXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAqL1xyXG5PcGNvZGUuZGVjb2RlT3BOID0gZnVuY3Rpb24ob3Bjb2RlKSB7XHJcbiAgaWYgKG9wY29kZSA9PT0gT3Bjb2RlLk9QXzApIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICAkLmNoZWNrQXJndW1lbnQob3Bjb2RlID49IE9wY29kZS5PUF8xICYmIG9wY29kZSA8PSBPcGNvZGUuT1BfMTYsIG5ldyBFcnJvcignSW52YWxpZCBvcGNvZGU6ICcgKyBKU09OLnN0cmluZ2lmeShvcGNvZGUpKSk7XHJcbiAgcmV0dXJuIG9wY29kZSAtIChPcGNvZGUuT1BfMSAtIDEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBvcGNvZGUgaXMgY2xhc3NpZmllZCBhcyBhIFwic3VjY2Vzc1wiLlxyXG4gKiBUaGlzIHdhcyB0YWtlbiBmcm9tIGNvbW1pdCBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2NvbW1pdC83MjQyMmNlMzk2YjhlYmE3YjFhNzJjMTcxYzJmMDdkYWU2OTFkMWI1XHJcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gb3Bjb2RlIFxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbk9wY29kZS5pc09wU3VjY2VzcyA9IGZ1bmN0aW9uKG9wY29kZSkge1xyXG4gIGlmICh0eXBlb2Ygb3Bjb2RlID09PSAnc3RyaW5nJyAmJiAhcGFyc2VJbnQob3Bjb2RlKSkge1xyXG4gICAgb3Bjb2RlID0gT3Bjb2RlW29wY29kZV07XHJcbiAgfVxyXG4gIHJldHVybiBvcGNvZGUgPT0gODAgfHwgb3Bjb2RlID09IDk4IHx8IChvcGNvZGUgPj0gMTI2ICYmIG9wY29kZSA8PSAxMjkpIHx8XHJcbiAgICAgICAgKG9wY29kZSA+PSAxMzEgJiYgb3Bjb2RlIDw9IDEzNCkgfHwgKG9wY29kZSA+PSAxMzcgJiYgb3Bjb2RlIDw9IDEzOCkgfHxcclxuICAgICAgICAob3Bjb2RlID49IDE0MSAmJiBvcGNvZGUgPD0gMTQyKSB8fCAob3Bjb2RlID49IDE0OSAmJiBvcGNvZGUgPD0gMTUzKSB8fFxyXG4gICAgICAgIChvcGNvZGUgPj0gMTg3ICYmIG9wY29kZSA8PSAyNTQpO1xyXG59O1xyXG5cclxuXHJcbk9wY29kZS5tYXAgPSB7XHJcbiAgLy8gcHVzaCB2YWx1ZVxyXG4gIE9QX0ZBTFNFOiAwLFxyXG4gIE9QXzA6IDAsXHJcbiAgT1BfUFVTSERBVEExOiA3NixcclxuICBPUF9QVVNIREFUQTI6IDc3LFxyXG4gIE9QX1BVU0hEQVRBNDogNzgsXHJcbiAgT1BfMU5FR0FURTogNzksXHJcbiAgT1BfUkVTRVJWRUQ6IDgwLFxyXG4gIE9QX1RSVUU6IDgxLFxyXG4gIE9QXzE6IDgxLFxyXG4gIE9QXzI6IDgyLFxyXG4gIE9QXzM6IDgzLFxyXG4gIE9QXzQ6IDg0LFxyXG4gIE9QXzU6IDg1LFxyXG4gIE9QXzY6IDg2LFxyXG4gIE9QXzc6IDg3LFxyXG4gIE9QXzg6IDg4LFxyXG4gIE9QXzk6IDg5LFxyXG4gIE9QXzEwOiA5MCxcclxuICBPUF8xMTogOTEsXHJcbiAgT1BfMTI6IDkyLFxyXG4gIE9QXzEzOiA5MyxcclxuICBPUF8xNDogOTQsXHJcbiAgT1BfMTU6IDk1LFxyXG4gIE9QXzE2OiA5NixcclxuXHJcbiAgLy8gY29udHJvbFxyXG4gIE9QX05PUDogOTcsXHJcbiAgT1BfVkVSOiA5OCxcclxuICBPUF9JRjogOTksXHJcbiAgT1BfTk9USUY6IDEwMCxcclxuICBPUF9WRVJJRjogMTAxLFxyXG4gIE9QX1ZFUk5PVElGOiAxMDIsXHJcbiAgT1BfRUxTRTogMTAzLFxyXG4gIE9QX0VORElGOiAxMDQsXHJcbiAgT1BfVkVSSUZZOiAxMDUsXHJcbiAgT1BfUkVUVVJOOiAxMDYsXHJcblxyXG4gIC8vIHN0YWNrIG9wc1xyXG4gIE9QX1RPQUxUU1RBQ0s6IDEwNyxcclxuICBPUF9GUk9NQUxUU1RBQ0s6IDEwOCxcclxuICBPUF8yRFJPUDogMTA5LFxyXG4gIE9QXzJEVVA6IDExMCxcclxuICBPUF8zRFVQOiAxMTEsXHJcbiAgT1BfMk9WRVI6IDExMixcclxuICBPUF8yUk9UOiAxMTMsXHJcbiAgT1BfMlNXQVA6IDExNCxcclxuICBPUF9JRkRVUDogMTE1LFxyXG4gIE9QX0RFUFRIOiAxMTYsXHJcbiAgT1BfRFJPUDogMTE3LFxyXG4gIE9QX0RVUDogMTE4LFxyXG4gIE9QX05JUDogMTE5LFxyXG4gIE9QX09WRVI6IDEyMCxcclxuICBPUF9QSUNLOiAxMjEsXHJcbiAgT1BfUk9MTDogMTIyLFxyXG4gIE9QX1JPVDogMTIzLFxyXG4gIE9QX1NXQVA6IDEyNCxcclxuICBPUF9UVUNLOiAxMjUsXHJcblxyXG4gIC8vIHNwbGljZSBvcHNcclxuICBPUF9DQVQ6IDEyNixcclxuICBPUF9TVUJTVFI6IDEyNyxcclxuICBPUF9MRUZUOiAxMjgsXHJcbiAgT1BfUklHSFQ6IDEyOSxcclxuICBPUF9TSVpFOiAxMzAsXHJcblxyXG4gIC8vIGJpdCBsb2dpY1xyXG4gIE9QX0lOVkVSVDogMTMxLFxyXG4gIE9QX0FORDogMTMyLFxyXG4gIE9QX09SOiAxMzMsXHJcbiAgT1BfWE9SOiAxMzQsXHJcbiAgT1BfRVFVQUw6IDEzNSxcclxuICBPUF9FUVVBTFZFUklGWTogMTM2LFxyXG4gIE9QX1JFU0VSVkVEMTogMTM3LFxyXG4gIE9QX1JFU0VSVkVEMjogMTM4LFxyXG5cclxuICAvLyBudW1lcmljXHJcbiAgT1BfMUFERDogMTM5LFxyXG4gIE9QXzFTVUI6IDE0MCxcclxuICBPUF8yTVVMOiAxNDEsXHJcbiAgT1BfMkRJVjogMTQyLFxyXG4gIE9QX05FR0FURTogMTQzLFxyXG4gIE9QX0FCUzogMTQ0LFxyXG4gIE9QX05PVDogMTQ1LFxyXG4gIE9QXzBOT1RFUVVBTDogMTQ2LFxyXG5cclxuICBPUF9BREQ6IDE0NyxcclxuICBPUF9TVUI6IDE0OCxcclxuICBPUF9NVUw6IDE0OSxcclxuICBPUF9ESVY6IDE1MCxcclxuICBPUF9NT0Q6IDE1MSxcclxuICBPUF9MU0hJRlQ6IDE1MixcclxuICBPUF9SU0hJRlQ6IDE1MyxcclxuXHJcbiAgT1BfQk9PTEFORDogMTU0LFxyXG4gIE9QX0JPT0xPUjogMTU1LFxyXG4gIE9QX05VTUVRVUFMOiAxNTYsXHJcbiAgT1BfTlVNRVFVQUxWRVJJRlk6IDE1NyxcclxuICBPUF9OVU1OT1RFUVVBTDogMTU4LFxyXG4gIE9QX0xFU1NUSEFOOiAxNTksXHJcbiAgT1BfR1JFQVRFUlRIQU46IDE2MCxcclxuICBPUF9MRVNTVEhBTk9SRVFVQUw6IDE2MSxcclxuICBPUF9HUkVBVEVSVEhBTk9SRVFVQUw6IDE2MixcclxuICBPUF9NSU46IDE2MyxcclxuICBPUF9NQVg6IDE2NCxcclxuXHJcbiAgT1BfV0lUSElOOiAxNjUsXHJcblxyXG4gIC8vIGNyeXB0b1xyXG4gIE9QX1JJUEVNRDE2MDogMTY2LFxyXG4gIE9QX1NIQTE6IDE2NyxcclxuICBPUF9TSEEyNTY6IDE2OCxcclxuICBPUF9IQVNIMTYwOiAxNjksXHJcbiAgT1BfSEFTSDI1NjogMTcwLFxyXG4gIE9QX0NPREVTRVBBUkFUT1I6IDE3MSxcclxuICBPUF9DSEVDS1NJRzogMTcyLFxyXG4gIE9QX0NIRUNLU0lHVkVSSUZZOiAxNzMsXHJcbiAgT1BfQ0hFQ0tNVUxUSVNJRzogMTc0LFxyXG4gIE9QX0NIRUNLTVVMVElTSUdWRVJJRlk6IDE3NSxcclxuXHJcbiAgT1BfQ0hFQ0tMT0NLVElNRVZFUklGWTogMTc3LFxyXG4gIE9QX0NIRUNLU0VRVUVOQ0VWRVJJRlk6IDE3OCxcclxuXHJcbiAgLy8gZXhwYW5zaW9uXHJcbiAgT1BfTk9QMTogMTc2LFxyXG4gIE9QX05PUDI6IDE3NyxcclxuICBPUF9OT1AzOiAxNzgsXHJcbiAgT1BfTk9QNDogMTc5LFxyXG4gIE9QX05PUDU6IDE4MCxcclxuICBPUF9OT1A2OiAxODEsXHJcbiAgT1BfTk9QNzogMTgyLFxyXG4gIE9QX05PUDg6IDE4MyxcclxuICBPUF9OT1A5OiAxODQsXHJcbiAgT1BfTk9QMTA6IDE4NSxcclxuXHJcbiAgLy8gT3Bjb2RlIGFkZGVkIGJ5IEJJUCAzNDIgKFRhcHNjcmlwdClcclxuICBPUF9DSEVDS1NJR0FERDogMTg2LCAvLyAweGJhXHJcblxyXG4gIC8vIHRlbXBsYXRlIG1hdGNoaW5nIHBhcmFtc1xyXG4gIE9QX1BVQktFWUhBU0g6IDI1MyxcclxuICBPUF9QVUJLRVk6IDI1NCxcclxuICBPUF9JTlZBTElET1BDT0RFOiAyNTVcclxufTtcclxuXHJcbk9wY29kZS5yZXZlcnNlTWFwID0gW107XHJcblxyXG5mb3IgKHZhciBrIGluIE9wY29kZS5tYXApIHtcclxuICBPcGNvZGUucmV2ZXJzZU1hcFtPcGNvZGUubWFwW2tdXSA9IGs7XHJcbn1cclxuXHJcbi8vIEVhc2llciBhY2Nlc3MgdG8gb3Bjb2Rlc1xyXG5fLmV4dGVuZChPcGNvZGUsIE9wY29kZS5tYXApO1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgb3Bjb2RlIGlzIG9uZSBvZiBPUF8wLCBPUF8xLCAuLi4sIE9QXzE2XHJcbiAqL1xyXG5PcGNvZGUuaXNTbWFsbEludE9wID0gZnVuY3Rpb24ob3Bjb2RlKSB7XHJcbiAgaWYgKG9wY29kZSBpbnN0YW5jZW9mIE9wY29kZSkge1xyXG4gICAgb3Bjb2RlID0gb3Bjb2RlLnRvTnVtYmVyKCk7XHJcbiAgfVxyXG4gIHJldHVybiAoKG9wY29kZSA9PT0gT3Bjb2RlLm1hcC5PUF8wKSB8fFxyXG4gICAgKChvcGNvZGUgPj0gT3Bjb2RlLm1hcC5PUF8xKSAmJiAob3Bjb2RlIDw9IE9wY29kZS5tYXAuT1BfMTYpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gYSBzdHJpbmcgZm9ybWF0dGVkIGZvciB0aGUgY29uc29sZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTY3JpcHQgb3Bjb2RlXHJcbiAqL1xyXG5PcGNvZGUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gJzxPcGNvZGU6ICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnLCBoZXg6ICcrdGhpcy50b0hleCgpKycsIGRlY2ltYWw6ICcrdGhpcy5udW0rJz4nO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPcGNvZGU7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/opcode.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/privatekey.js":
/*!****************************************!*\
  !*** ../bitcore-lib/lib/privatekey.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar Address = __webpack_require__(/*! ./address */ \"../bitcore-lib/lib/address.js\");\r\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"../bitcore-lib/lib/encoding/base58check.js\");\r\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar Networks = __webpack_require__(/*! ./networks */ \"../bitcore-lib/lib/networks.js\");\r\nvar Point = __webpack_require__(/*! ./crypto/point */ \"../bitcore-lib/lib/crypto/point.js\");\r\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"../bitcore-lib/lib/publickey.js\");\r\nvar Random = __webpack_require__(/*! ./crypto/random */ \"../bitcore-lib/lib/crypto/random.js\");\r\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nconst TaggedHash = __webpack_require__(/*! ./crypto/taggedhash */ \"../bitcore-lib/lib/crypto/taggedhash.js\");\r\n\r\n/**\r\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\r\n *\r\n * @example\r\n * ```javascript\r\n * // generate a new random key\r\n * var key = PrivateKey();\r\n *\r\n * // get the associated address\r\n * var address = key.toAddress();\r\n *\r\n * // encode into wallet export format\r\n * var exported = key.toWIF();\r\n *\r\n * // instantiate from the exported (and saved) private key\r\n * var imported = PrivateKey.fromWIF(exported);\r\n * ```\r\n *\r\n * @param {string} data - The encoded data in various formats\r\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\r\n * @returns {PrivateKey} A new valid instance of an PrivateKey\r\n * @constructor\r\n */\r\nfunction PrivateKey(data, network) {\r\n  /* jshint maxstatements: 20 */\r\n  /* jshint maxcomplexity: 8 */\r\n\r\n  if (!(this instanceof PrivateKey)) {\r\n    return new PrivateKey(data, network);\r\n  }\r\n  if (data instanceof PrivateKey) {\r\n    return data;\r\n  }\r\n\r\n  var info = this._classifyArguments(data, network);\r\n\r\n  // validation\r\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0){\r\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\r\n  }\r\n  if (!info.bn.lt(Point.getN())) {\r\n    throw new TypeError('Number must be less than N');\r\n  }\r\n  if (typeof(info.network) === 'undefined') {\r\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\r\n  }\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    bn: info.bn,\r\n    compressed: info.compressed,\r\n    network: info.network\r\n  });\r\n\r\n  Object.defineProperty(this, 'publicKey', {\r\n    configurable: false,\r\n    enumerable: true,\r\n    get: this.toPublicKey.bind(this)\r\n  });\r\n\r\n  return this;\r\n\r\n};\r\n\r\n/**\r\n * Internal helper to instantiate PrivateKey internal `info` object from\r\n * different kinds of arguments passed to the constructor.\r\n *\r\n * @param {*} data\r\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\r\n * @return {Object}\r\n */\r\nPrivateKey.prototype._classifyArguments = function(data, network) {\r\n  /* jshint maxcomplexity: 10 */\r\n  var info = {\r\n    compressed: true,\r\n    network: network ? Networks.get(network) : Networks.defaultNetwork\r\n  };\r\n\r\n  // detect type of data\r\n  if (_.isUndefined(data) || _.isNull(data)){\r\n    info.bn = PrivateKey._getRandomBN();\r\n  } else if (data instanceof BN) {\r\n    info.bn = data;\r\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\r\n    info = PrivateKey._transformBuffer(data, network);\r\n  } else if (data.bn && data.network){\r\n    info = PrivateKey._transformObject(data);\r\n  } else if (!network && Networks.get(data)) {\r\n    info.bn = PrivateKey._getRandomBN();\r\n    info.network = Networks.get(data);\r\n  } else if (typeof(data) === 'string'){\r\n    if (JSUtil.isHexa(data)) {\r\n      info.bn = new BN(Buffer.from(data, 'hex'));\r\n    } else {\r\n      info = PrivateKey._transformWIF(data, network);\r\n    }\r\n  } else {\r\n    throw new TypeError('First argument is an unrecognized data type.');\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to get a random Big Number (BN)\r\n *\r\n * @returns {BN} A new randomly generated BN\r\n * @private\r\n */\r\nPrivateKey._getRandomBN = function(){\r\n  var condition;\r\n  var bn;\r\n  do {\r\n    var privbuf = Random.getRandomBuffer(32);\r\n    bn = BN.fromBuffer(privbuf);\r\n    condition = bn.lt(Point.getN());\r\n  } while (!condition);\r\n  return bn;\r\n};\r\n\r\n/**\r\n * Internal function to transform a WIF Buffer into a private key\r\n *\r\n * @param {Buffer} buf - An WIF string\r\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\r\n * @returns {Object} An object with keys: bn, network and compressed\r\n * @private\r\n */\r\nPrivateKey._transformBuffer = function(buf, network) {\r\n\r\n  var info = {};\r\n\r\n  if (buf.length === 32) {\r\n    return PrivateKey._transformBNBuffer(buf, network);\r\n  }\r\n\r\n  info.network = Networks.get(buf[0], 'privatekey');\r\n\r\n  if (!info.network) {\r\n    throw new Error('Invalid network');\r\n  }\r\n\r\n  if (network && info.network !== Networks.get(network)) {\r\n    throw new TypeError('Private key network mismatch');\r\n  }\r\n\r\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\r\n    info.compressed = true;\r\n  } else if (buf.length === 1 + 32) {\r\n    info.compressed = false;\r\n  } else {\r\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\r\n  }\r\n\r\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\r\n\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to transform a BN buffer into a private key\r\n *\r\n * @param {Buffer} buf\r\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\r\n * @returns {object} an Object with keys: bn, network, and compressed\r\n * @private\r\n */\r\nPrivateKey._transformBNBuffer = function(buf, network) {\r\n  var info = {};\r\n  info.network = Networks.get(network) || Networks.defaultNetwork;\r\n  info.bn = BN.fromBuffer(buf);\r\n  info.compressed = false;\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to transform a WIF string into a private key\r\n *\r\n * @param {string} buf - An WIF string\r\n * @returns {Object} An object with keys: bn, network and compressed\r\n * @private\r\n */\r\nPrivateKey._transformWIF = function(str, network) {\r\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\r\n};\r\n\r\n/**\r\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\r\n *\r\n * @param {Buffer} arg\r\n * @param {Network} network\r\n * @return {PrivateKey}\r\n */\r\nPrivateKey.fromBuffer = function(arg, network) {\r\n  return new PrivateKey(arg, network);\r\n};\r\n\r\n/**\r\n * Internal function to transform a JSON string on plain object into a private key\r\n * return this.\r\n *\r\n * @param {string} json - A JSON string or plain object\r\n * @returns {Object} An object with keys: bn, network and compressed\r\n * @private\r\n */\r\nPrivateKey._transformObject = function(json) {\r\n  var bn = new BN(json.bn, 'hex');\r\n  var network = Networks.get(json.network);\r\n  return {\r\n    bn: bn,\r\n    network: network,\r\n    compressed: json.compressed\r\n  };\r\n};\r\n\r\n/**\r\n * Instantiate a PrivateKey from a WIF string\r\n *\r\n * @param {string} str - The WIF encoded private key string\r\n * @returns {PrivateKey} A new valid instance of PrivateKey\r\n */\r\nPrivateKey.fromString = PrivateKey.fromWIF = function(str) {\r\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\r\n  return new PrivateKey(str);\r\n};\r\n\r\n/**\r\n * Instantiate a PrivateKey from a plain JavaScript object\r\n *\r\n * @param {Object} obj - The output from privateKey.toObject()\r\n */\r\nPrivateKey.fromObject = function(obj) {\r\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\r\n  return new PrivateKey(obj);\r\n};\r\n\r\n/**\r\n * Instantiate a PrivateKey from random bytes\r\n *\r\n * @param {string=} network - Either \"livenet\" or \"testnet\"\r\n * @returns {PrivateKey} A new valid instance of PrivateKey\r\n */\r\nPrivateKey.fromRandom = function(network) {\r\n  var bn = PrivateKey._getRandomBN();\r\n  return new PrivateKey(bn, network);\r\n};\r\n\r\n/**\r\n * Check if there would be any errors when initializing a PrivateKey\r\n *\r\n * @param {string} data - The encoded data in various formats\r\n * @param {string=} network - Either \"livenet\" or \"testnet\"\r\n * @returns {null|Error} An error if exists\r\n */\r\nPrivateKey.getValidationError = function(data, network) {\r\n  var error;\r\n  try {\r\n    /* jshint nonew: false */\r\n    new PrivateKey(data, network);\r\n  } catch (e) {\r\n    error = e;\r\n  }\r\n  return error;\r\n};\r\n\r\n/**\r\n * Check if the parameters are valid\r\n *\r\n * @param {string} data - The encoded data in various formats\r\n * @param {string=} network - Either \"livenet\" or \"testnet\"\r\n * @returns {Boolean} If the private key is would be valid\r\n */\r\nPrivateKey.isValid = function(data, network){\r\n  if (!data) {\r\n    return false;\r\n  }\r\n  return !PrivateKey.getValidationError(data, network);\r\n};\r\n\r\n/**\r\n * Will output the PrivateKey encoded as hex string\r\n *\r\n * @returns {string}\r\n */\r\nPrivateKey.prototype.toString = function() {\r\n  return this.toBuffer().toString('hex');\r\n};\r\n\r\n/**\r\n * Will output the PrivateKey to a WIF string\r\n *\r\n * @returns {string} A WIP representation of the private key\r\n */\r\nPrivateKey.prototype.toWIF = function() {\r\n  var network = this.network;\r\n  var compressed = this.compressed;\r\n\r\n  var buf;\r\n  if (compressed) {\r\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\r\n                         this.bn.toBuffer({size: 32}),\r\n                         Buffer.from([0x01])]);\r\n  } else {\r\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\r\n                         this.bn.toBuffer({size: 32})]);\r\n  }\r\n\r\n  return Base58Check.encode(buf);\r\n};\r\n\r\n/**\r\n * Will return the private key as a BN instance\r\n *\r\n * @returns {BN} A BN instance of the private key\r\n */\r\nPrivateKey.prototype.toBigNumber = function(){\r\n  return this.bn;\r\n};\r\n\r\n/**\r\n * Will return the private key as a BN buffer\r\n *\r\n * @returns {Buffer} A buffer of the private key\r\n */\r\nPrivateKey.prototype.toBuffer = function(){\r\n  return this.bn.toBuffer({size: 32});\r\n};\r\n\r\n/**\r\n * WARNING: This method will not be officially supported until v1.0.0.\r\n *\r\n *\r\n * Will return the private key as a BN buffer without leading zero padding\r\n *\r\n * @returns {Buffer} A buffer of the private key\r\n */\r\nPrivateKey.prototype.toBufferNoPadding = function() {\r\n  return this.bn.toBuffer();\r\n};\r\n\r\n/**\r\n * Will return the corresponding public key\r\n *\r\n * @returns {PublicKey} A public key generated from the private key\r\n */\r\nPrivateKey.prototype.toPublicKey = function(){\r\n  if (!this._pubkey) {\r\n    this._pubkey = PublicKey.fromPrivateKey(this);\r\n  }\r\n  return this._pubkey;\r\n};\r\n\r\n/**\r\n * Will return an address for the private key\r\n * @param {Network=} network - optional parameter specifying\r\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\r\n * the desired network for the address\r\n *\r\n * @returns {Address} An address generated from the private key\r\n */\r\nPrivateKey.prototype.toAddress = function(network, type) {\r\n  var pubkey = this.toPublicKey();\r\n  return Address.fromPublicKey(pubkey, network || this.network, type);\r\n};\r\n\r\n/**\r\n * @returns {Object} A plain object representation\r\n */\r\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\r\n  return {\r\n    bn: this.bn.toString('hex'),\r\n    compressed: this.compressed,\r\n    network: this.network.toString()\r\n  };\r\n};\r\n\r\n/**\r\n * Create a tweaked version of this private key\r\n * @param {Buffer} merkleRoot (optional)\r\n * @returns {{ tweakedPrivKey: Buffer }}\r\n */\r\nPrivateKey.prototype.createTapTweak = function(merkleRoot) {\r\n  const order = Point.getN();\r\n  const P = Point.getG().mul(this.bn);\r\n  const secKey = P.y.isEven() ? this.bn : order.sub(this.bn);\r\n  const taggedWriter = new TaggedHash('TapTweak');\r\n  taggedWriter.write(P.x.toBuffer({ size: 32 }));\r\n\r\n  if (merkleRoot) {\r\n    $.checkArgument(Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32, 'merkleRoot must be 32 byte buffer');\r\n    taggedWriter.write(merkleRoot);\r\n  }\r\n  const tweakHash = taggedWriter.finalize();\r\n\r\n  $.checkState(BN.fromBuffer(tweakHash).lt(order), 'TapTweak hash failed secp256k1 order check');\r\n  return {\r\n    tweakedPrivKey: secKey.add(new BN(tweakHash)).mod(order).toBuffer({ size: 32 })\r\n  };\r\n};\r\n\r\n/**\r\n * Will return a string formatted for the console\r\n *\r\n * @returns {string} Private key\r\n */\r\nPrivateKey.prototype.inspect = function() {\r\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\r\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\r\n};\r\n\r\nmodule.exports = PrivateKey;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL3ByaXZhdGVrZXkuanM/NzM5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xyXG52YXIgQmFzZTU4Q2hlY2sgPSByZXF1aXJlKCcuL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XHJcbnZhciBCTiA9IHJlcXVpcmUoJy4vY3J5cHRvL2JuJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuL3V0aWwvanMnKTtcclxudmFyIE5ldHdvcmtzID0gcmVxdWlyZSgnLi9uZXR3b3JrcycpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL2NyeXB0by9wb2ludCcpO1xyXG52YXIgUHVibGljS2V5ID0gcmVxdWlyZSgnLi9wdWJsaWNrZXknKTtcclxudmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4vY3J5cHRvL3JhbmRvbScpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcbmNvbnN0IFRhZ2dlZEhhc2ggPSByZXF1aXJlKCcuL2NyeXB0by90YWdnZWRoYXNoJyk7XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGUgYSBQcml2YXRlS2V5IGZyb20gYSBCTiwgQnVmZmVyIGFuZCBXSUYuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gZ2VuZXJhdGUgYSBuZXcgcmFuZG9tIGtleVxyXG4gKiB2YXIga2V5ID0gUHJpdmF0ZUtleSgpO1xyXG4gKlxyXG4gKiAvLyBnZXQgdGhlIGFzc29jaWF0ZWQgYWRkcmVzc1xyXG4gKiB2YXIgYWRkcmVzcyA9IGtleS50b0FkZHJlc3MoKTtcclxuICpcclxuICogLy8gZW5jb2RlIGludG8gd2FsbGV0IGV4cG9ydCBmb3JtYXRcclxuICogdmFyIGV4cG9ydGVkID0ga2V5LnRvV0lGKCk7XHJcbiAqXHJcbiAqIC8vIGluc3RhbnRpYXRlIGZyb20gdGhlIGV4cG9ydGVkIChhbmQgc2F2ZWQpIHByaXZhdGUga2V5XHJcbiAqIHZhciBpbXBvcnRlZCA9IFByaXZhdGVLZXkuZnJvbVdJRihleHBvcnRlZCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBlbmNvZGVkIGRhdGEgaW4gdmFyaW91cyBmb3JtYXRzXHJcbiAqIEBwYXJhbSB7TmV0d29ya3xzdHJpbmc9fSBuZXR3b3JrIC0gYSB7QGxpbmsgTmV0d29ya30gb2JqZWN0LCBvciBhIHN0cmluZyB3aXRoIHRoZSBuZXR3b3JrIG5hbWVcclxuICogQHJldHVybnMge1ByaXZhdGVLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIGFuIFByaXZhdGVLZXlcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBQcml2YXRlS2V5KGRhdGEsIG5ldHdvcmspIHtcclxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogOCAqL1xyXG5cclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJpdmF0ZUtleSkpIHtcclxuICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleShkYXRhLCBuZXR3b3JrKTtcclxuICB9XHJcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBQcml2YXRlS2V5KSB7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIHZhciBpbmZvID0gdGhpcy5fY2xhc3NpZnlBcmd1bWVudHMoZGF0YSwgbmV0d29yayk7XHJcblxyXG4gIC8vIHZhbGlkYXRpb25cclxuICBpZiAoIWluZm8uYm4gfHwgaW5mby5ibi5jbXAobmV3IEJOKDApKSA9PT0gMCl7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOdW1iZXIgY2FuIG5vdCBiZSBlcXVhbCB0byB6ZXJvLCB1bmRlZmluZWQsIG51bGwgb3IgZmFsc2UnKTtcclxuICB9XHJcbiAgaWYgKCFpbmZvLmJuLmx0KFBvaW50LmdldE4oKSkpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ051bWJlciBtdXN0IGJlIGxlc3MgdGhhbiBOJyk7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YoaW5mby5uZXR3b3JrKSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3Qgc3BlY2lmeSB0aGUgbmV0d29yayAoXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCIpJyk7XHJcbiAgfVxyXG5cclxuICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKHRoaXMsIHtcclxuICAgIGJuOiBpbmZvLmJuLFxyXG4gICAgY29tcHJlc3NlZDogaW5mby5jb21wcmVzc2VkLFxyXG4gICAgbmV0d29yazogaW5mby5uZXR3b3JrXHJcbiAgfSk7XHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHVibGljS2V5Jywge1xyXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IHRoaXMudG9QdWJsaWNLZXkuYmluZCh0aGlzKVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgaGVscGVyIHRvIGluc3RhbnRpYXRlIFByaXZhdGVLZXkgaW50ZXJuYWwgYGluZm9gIG9iamVjdCBmcm9tXHJcbiAqIGRpZmZlcmVudCBraW5kcyBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogQHBhcmFtIHsqfSBkYXRhXHJcbiAqIEBwYXJhbSB7TmV0d29ya3xzdHJpbmc9fSBuZXR3b3JrIC0gYSB7QGxpbmsgTmV0d29ya30gb2JqZWN0LCBvciBhIHN0cmluZyB3aXRoIHRoZSBuZXR3b3JrIG5hbWVcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuUHJpdmF0ZUtleS5wcm90b3R5cGUuX2NsYXNzaWZ5QXJndW1lbnRzID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaykge1xyXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMCAqL1xyXG4gIHZhciBpbmZvID0ge1xyXG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcclxuICAgIG5ldHdvcms6IG5ldHdvcmsgPyBOZXR3b3Jrcy5nZXQobmV0d29yaykgOiBOZXR3b3Jrcy5kZWZhdWx0TmV0d29ya1xyXG4gIH07XHJcblxyXG4gIC8vIGRldGVjdCB0eXBlIG9mIGRhdGFcclxuICBpZiAoXy5pc1VuZGVmaW5lZChkYXRhKSB8fCBfLmlzTnVsbChkYXRhKSl7XHJcbiAgICBpbmZvLmJuID0gUHJpdmF0ZUtleS5fZ2V0UmFuZG9tQk4oKTtcclxuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCTikge1xyXG4gICAgaW5mby5ibiA9IGRhdGE7XHJcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICBpbmZvID0gUHJpdmF0ZUtleS5fdHJhbnNmb3JtQnVmZmVyKGRhdGEsIG5ldHdvcmspO1xyXG4gIH0gZWxzZSBpZiAoZGF0YS5ibiAmJiBkYXRhLm5ldHdvcmspe1xyXG4gICAgaW5mbyA9IFByaXZhdGVLZXkuX3RyYW5zZm9ybU9iamVjdChkYXRhKTtcclxuICB9IGVsc2UgaWYgKCFuZXR3b3JrICYmIE5ldHdvcmtzLmdldChkYXRhKSkge1xyXG4gICAgaW5mby5ibiA9IFByaXZhdGVLZXkuX2dldFJhbmRvbUJOKCk7XHJcbiAgICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQoZGF0YSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YoZGF0YSkgPT09ICdzdHJpbmcnKXtcclxuICAgIGlmIChKU1V0aWwuaXNIZXhhKGRhdGEpKSB7XHJcbiAgICAgIGluZm8uYm4gPSBuZXcgQk4oQnVmZmVyLmZyb20oZGF0YSwgJ2hleCcpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluZm8gPSBQcml2YXRlS2V5Ll90cmFuc2Zvcm1XSUYoZGF0YSwgbmV0d29yayk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IGlzIGFuIHVucmVjb2duaXplZCBkYXRhIHR5cGUuJyk7XHJcbiAgfVxyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdldCBhIHJhbmRvbSBCaWcgTnVtYmVyIChCTilcclxuICpcclxuICogQHJldHVybnMge0JOfSBBIG5ldyByYW5kb21seSBnZW5lcmF0ZWQgQk5cclxuICogQHByaXZhdGVcclxuICovXHJcblByaXZhdGVLZXkuX2dldFJhbmRvbUJOID0gZnVuY3Rpb24oKXtcclxuICB2YXIgY29uZGl0aW9uO1xyXG4gIHZhciBibjtcclxuICBkbyB7XHJcbiAgICB2YXIgcHJpdmJ1ZiA9IFJhbmRvbS5nZXRSYW5kb21CdWZmZXIoMzIpO1xyXG4gICAgYm4gPSBCTi5mcm9tQnVmZmVyKHByaXZidWYpO1xyXG4gICAgY29uZGl0aW9uID0gYm4ubHQoUG9pbnQuZ2V0TigpKTtcclxuICB9IHdoaWxlICghY29uZGl0aW9uKTtcclxuICByZXR1cm4gYm47XHJcbn07XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGEgV0lGIEJ1ZmZlciBpbnRvIGEgcHJpdmF0ZSBrZXlcclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIEFuIFdJRiBzdHJpbmdcclxuICogQHBhcmFtIHtOZXR3b3JrfHN0cmluZz19IG5ldHdvcmsgLSBhIHtAbGluayBOZXR3b3JrfSBvYmplY3QsIG9yIGEgc3RyaW5nIHdpdGggdGhlIG5ldHdvcmsgbmFtZVxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBibiwgbmV0d29yayBhbmQgY29tcHJlc3NlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuUHJpdmF0ZUtleS5fdHJhbnNmb3JtQnVmZmVyID0gZnVuY3Rpb24oYnVmLCBuZXR3b3JrKSB7XHJcblxyXG4gIHZhciBpbmZvID0ge307XHJcblxyXG4gIGlmIChidWYubGVuZ3RoID09PSAzMikge1xyXG4gICAgcmV0dXJuIFByaXZhdGVLZXkuX3RyYW5zZm9ybUJOQnVmZmVyKGJ1ZiwgbmV0d29yayk7XHJcbiAgfVxyXG5cclxuICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQoYnVmWzBdLCAncHJpdmF0ZWtleScpO1xyXG5cclxuICBpZiAoIWluZm8ubmV0d29yaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5ldHdvcmsnKTtcclxuICB9XHJcblxyXG4gIGlmIChuZXR3b3JrICYmIGluZm8ubmV0d29yayAhPT0gTmV0d29ya3MuZ2V0KG5ldHdvcmspKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIGtleSBuZXR3b3JrIG1pc21hdGNoJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoYnVmLmxlbmd0aCA9PT0gMSArIDMyICsgMSAmJiBidWZbMSArIDMyICsgMSAtIDFdID09PSAxKSB7XHJcbiAgICBpbmZvLmNvbXByZXNzZWQgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA9PT0gMSArIDMyKSB7XHJcbiAgICBpbmZvLmNvbXByZXNzZWQgPSBmYWxzZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggb2YgYnVmZmVyIG11c3QgYmUgMzMgKHVuY29tcHJlc3NlZCkgb3IgMzQgKGNvbXByZXNzZWQpJyk7XHJcbiAgfVxyXG5cclxuICBpbmZvLmJuID0gQk4uZnJvbUJ1ZmZlcihidWYuc2xpY2UoMSwgMzIgKyAxKSk7XHJcblxyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIEJOIGJ1ZmZlciBpbnRvIGEgcHJpdmF0ZSBrZXlcclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxyXG4gKiBAcGFyYW0ge05ldHdvcmt8c3RyaW5nPX0gbmV0d29yayAtIGEge0BsaW5rIE5ldHdvcmt9IG9iamVjdCwgb3IgYSBzdHJpbmcgd2l0aCB0aGUgbmV0d29yayBuYW1lXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFuIE9iamVjdCB3aXRoIGtleXM6IGJuLCBuZXR3b3JrLCBhbmQgY29tcHJlc3NlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuUHJpdmF0ZUtleS5fdHJhbnNmb3JtQk5CdWZmZXIgPSBmdW5jdGlvbihidWYsIG5ldHdvcmspIHtcclxuICB2YXIgaW5mbyA9IHt9O1xyXG4gIGluZm8ubmV0d29yayA9IE5ldHdvcmtzLmdldChuZXR3b3JrKSB8fCBOZXR3b3Jrcy5kZWZhdWx0TmV0d29yaztcclxuICBpbmZvLmJuID0gQk4uZnJvbUJ1ZmZlcihidWYpO1xyXG4gIGluZm8uY29tcHJlc3NlZCA9IGZhbHNlO1xyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIFdJRiBzdHJpbmcgaW50byBhIHByaXZhdGUga2V5XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBidWYgLSBBbiBXSUYgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGJuLCBuZXR3b3JrIGFuZCBjb21wcmVzc2VkXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Qcml2YXRlS2V5Ll90cmFuc2Zvcm1XSUYgPSBmdW5jdGlvbihzdHIsIG5ldHdvcmspIHtcclxuICByZXR1cm4gUHJpdmF0ZUtleS5fdHJhbnNmb3JtQnVmZmVyKEJhc2U1OENoZWNrLmRlY29kZShzdHIpLCBuZXR3b3JrKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIFByaXZhdGVLZXkgZnJvbSBhIEJ1ZmZlciB3aXRoIHRoZSBERVIgb3IgV0lGIHJlcHJlc2VudGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBhcmdcclxuICogQHBhcmFtIHtOZXR3b3JrfSBuZXR3b3JrXHJcbiAqIEByZXR1cm4ge1ByaXZhdGVLZXl9XHJcbiAqL1xyXG5Qcml2YXRlS2V5LmZyb21CdWZmZXIgPSBmdW5jdGlvbihhcmcsIG5ldHdvcmspIHtcclxuICByZXR1cm4gbmV3IFByaXZhdGVLZXkoYXJnLCBuZXR3b3JrKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBKU09OIHN0cmluZyBvbiBwbGFpbiBvYmplY3QgaW50byBhIHByaXZhdGUga2V5XHJcbiAqIHJldHVybiB0aGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvbiAtIEEgSlNPTiBzdHJpbmcgb3IgcGxhaW4gb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGJuLCBuZXR3b3JrIGFuZCBjb21wcmVzc2VkXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Qcml2YXRlS2V5Ll90cmFuc2Zvcm1PYmplY3QgPSBmdW5jdGlvbihqc29uKSB7XHJcbiAgdmFyIGJuID0gbmV3IEJOKGpzb24uYm4sICdoZXgnKTtcclxuICB2YXIgbmV0d29yayA9IE5ldHdvcmtzLmdldChqc29uLm5ldHdvcmspO1xyXG4gIHJldHVybiB7XHJcbiAgICBibjogYm4sXHJcbiAgICBuZXR3b3JrOiBuZXR3b3JrLFxyXG4gICAgY29tcHJlc3NlZDoganNvbi5jb21wcmVzc2VkXHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIFByaXZhdGVLZXkgZnJvbSBhIFdJRiBzdHJpbmdcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBXSUYgZW5jb2RlZCBwcml2YXRlIGtleSBzdHJpbmdcclxuICogQHJldHVybnMge1ByaXZhdGVLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFByaXZhdGVLZXlcclxuICovXHJcblByaXZhdGVLZXkuZnJvbVN0cmluZyA9IFByaXZhdGVLZXkuZnJvbVdJRiA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICQuY2hlY2tBcmd1bWVudChfLmlzU3RyaW5nKHN0ciksICdGaXJzdCBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIHN0cmluZy4nKTtcclxuICByZXR1cm4gbmV3IFByaXZhdGVLZXkoc3RyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIFByaXZhdGVLZXkgZnJvbSBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb3V0cHV0IGZyb20gcHJpdmF0ZUtleS50b09iamVjdCgpXHJcbiAqL1xyXG5Qcml2YXRlS2V5LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcclxuICAkLmNoZWNrQXJndW1lbnQoXy5pc09iamVjdChvYmopLCAnRmlyc3QgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LicpO1xyXG4gIHJldHVybiBuZXcgUHJpdmF0ZUtleShvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRlIGEgUHJpdmF0ZUtleSBmcm9tIHJhbmRvbSBieXRlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5ldHdvcmsgLSBFaXRoZXIgXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCJcclxuICogQHJldHVybnMge1ByaXZhdGVLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFByaXZhdGVLZXlcclxuICovXHJcblByaXZhdGVLZXkuZnJvbVJhbmRvbSA9IGZ1bmN0aW9uKG5ldHdvcmspIHtcclxuICB2YXIgYm4gPSBQcml2YXRlS2V5Ll9nZXRSYW5kb21CTigpO1xyXG4gIHJldHVybiBuZXcgUHJpdmF0ZUtleShibiwgbmV0d29yayk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlcmUgd291bGQgYmUgYW55IGVycm9ycyB3aGVuIGluaXRpYWxpemluZyBhIFByaXZhdGVLZXlcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5ldHdvcmsgLSBFaXRoZXIgXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCJcclxuICogQHJldHVybnMge251bGx8RXJyb3J9IEFuIGVycm9yIGlmIGV4aXN0c1xyXG4gKi9cclxuUHJpdmF0ZUtleS5nZXRWYWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrKSB7XHJcbiAgdmFyIGVycm9yO1xyXG4gIHRyeSB7XHJcbiAgICAvKiBqc2hpbnQgbm9uZXc6IGZhbHNlICovXHJcbiAgICBuZXcgUHJpdmF0ZUtleShkYXRhLCBuZXR3b3JrKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBlcnJvciA9IGU7XHJcbiAgfVxyXG4gIHJldHVybiBlcnJvcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgcGFyYW1ldGVycyBhcmUgdmFsaWRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5ldHdvcmsgLSBFaXRoZXIgXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCJcclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBwcml2YXRlIGtleSBpcyB3b3VsZCBiZSB2YWxpZFxyXG4gKi9cclxuUHJpdmF0ZUtleS5pc1ZhbGlkID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yayl7XHJcbiAgaWYgKCFkYXRhKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiAhUHJpdmF0ZUtleS5nZXRWYWxpZGF0aW9uRXJyb3IoZGF0YSwgbmV0d29yayk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCBvdXRwdXQgdGhlIFByaXZhdGVLZXkgZW5jb2RlZCBhcyBoZXggc3RyaW5nXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgb3V0cHV0IHRoZSBQcml2YXRlS2V5IHRvIGEgV0lGIHN0cmluZ1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIFdJUCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXlcclxuICovXHJcblByaXZhdGVLZXkucHJvdG90eXBlLnRvV0lGID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIG5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XHJcbiAgdmFyIGNvbXByZXNzZWQgPSB0aGlzLmNvbXByZXNzZWQ7XHJcblxyXG4gIHZhciBidWY7XHJcbiAgaWYgKGNvbXByZXNzZWQpIHtcclxuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFtuZXR3b3JrLnByaXZhdGVrZXldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm4udG9CdWZmZXIoe3NpemU6IDMyfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShbMHgwMV0pXSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFtuZXR3b3JrLnByaXZhdGVrZXldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm4udG9CdWZmZXIoe3NpemU6IDMyfSldKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBCYXNlNThDaGVjay5lbmNvZGUoYnVmKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaWxsIHJldHVybiB0aGUgcHJpdmF0ZSBrZXkgYXMgYSBCTiBpbnN0YW5jZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Qk59IEEgQk4gaW5zdGFuY2Ugb2YgdGhlIHByaXZhdGUga2V5XHJcbiAqL1xyXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b0JpZ051bWJlciA9IGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIHRoaXMuYm47XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gdGhlIHByaXZhdGUga2V5IGFzIGEgQk4gYnVmZmVyXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEEgYnVmZmVyIG9mIHRoZSBwcml2YXRlIGtleVxyXG4gKi9cclxuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpe1xyXG4gIHJldHVybiB0aGlzLmJuLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgbm90IGJlIG9mZmljaWFsbHkgc3VwcG9ydGVkIHVudGlsIHYxLjAuMC5cclxuICpcclxuICpcclxuICogV2lsbCByZXR1cm4gdGhlIHByaXZhdGUga2V5IGFzIGEgQk4gYnVmZmVyIHdpdGhvdXQgbGVhZGluZyB6ZXJvIHBhZGRpbmdcclxuICpcclxuICogQHJldHVybnMge0J1ZmZlcn0gQSBidWZmZXIgb2YgdGhlIHByaXZhdGUga2V5XHJcbiAqL1xyXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b0J1ZmZlck5vUGFkZGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmJuLnRvQnVmZmVyKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcHVibGljIGtleVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fSBBIHB1YmxpYyBrZXkgZ2VuZXJhdGVkIGZyb20gdGhlIHByaXZhdGUga2V5XHJcbiAqL1xyXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b1B1YmxpY0tleSA9IGZ1bmN0aW9uKCl7XHJcbiAgaWYgKCF0aGlzLl9wdWJrZXkpIHtcclxuICAgIHRoaXMuX3B1YmtleSA9IFB1YmxpY0tleS5mcm9tUHJpdmF0ZUtleSh0aGlzKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXMuX3B1YmtleTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaWxsIHJldHVybiBhbiBhZGRyZXNzIGZvciB0aGUgcHJpdmF0ZSBrZXlcclxuICogQHBhcmFtIHtOZXR3b3JrPX0gbmV0d29yayAtIG9wdGlvbmFsIHBhcmFtZXRlciBzcGVjaWZ5aW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdwdWJrZXloYXNoJywgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3NjcmlwdGhhc2gnXHJcbiAqIHRoZSBkZXNpcmVkIG5ldHdvcmsgZm9yIHRoZSBhZGRyZXNzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBbiBhZGRyZXNzIGdlbmVyYXRlZCBmcm9tIHRoZSBwcml2YXRlIGtleVxyXG4gKi9cclxuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9BZGRyZXNzID0gZnVuY3Rpb24obmV0d29yaywgdHlwZSkge1xyXG4gIHZhciBwdWJrZXkgPSB0aGlzLnRvUHVibGljS2V5KCk7XHJcbiAgcmV0dXJuIEFkZHJlc3MuZnJvbVB1YmxpY0tleShwdWJrZXksIG5ldHdvcmsgfHwgdGhpcy5uZXR3b3JrLCB0eXBlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHBsYWluIG9iamVjdCByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9PYmplY3QgPSBQcml2YXRlS2V5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgYm46IHRoaXMuYm4udG9TdHJpbmcoJ2hleCcpLFxyXG4gICAgY29tcHJlc3NlZDogdGhpcy5jb21wcmVzc2VkLFxyXG4gICAgbmV0d29yazogdGhpcy5uZXR3b3JrLnRvU3RyaW5nKClcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIHR3ZWFrZWQgdmVyc2lvbiBvZiB0aGlzIHByaXZhdGUga2V5XHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXJrbGVSb290IChvcHRpb25hbClcclxuICogQHJldHVybnMge3sgdHdlYWtlZFByaXZLZXk6IEJ1ZmZlciB9fVxyXG4gKi9cclxuUHJpdmF0ZUtleS5wcm90b3R5cGUuY3JlYXRlVGFwVHdlYWsgPSBmdW5jdGlvbihtZXJrbGVSb290KSB7XHJcbiAgY29uc3Qgb3JkZXIgPSBQb2ludC5nZXROKCk7XHJcbiAgY29uc3QgUCA9IFBvaW50LmdldEcoKS5tdWwodGhpcy5ibik7XHJcbiAgY29uc3Qgc2VjS2V5ID0gUC55LmlzRXZlbigpID8gdGhpcy5ibiA6IG9yZGVyLnN1Yih0aGlzLmJuKTtcclxuICBjb25zdCB0YWdnZWRXcml0ZXIgPSBuZXcgVGFnZ2VkSGFzaCgnVGFwVHdlYWsnKTtcclxuICB0YWdnZWRXcml0ZXIud3JpdGUoUC54LnRvQnVmZmVyKHsgc2l6ZTogMzIgfSkpO1xyXG5cclxuICBpZiAobWVya2xlUm9vdCkge1xyXG4gICAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlci5pc0J1ZmZlcihtZXJrbGVSb290KSAmJiBtZXJrbGVSb290Lmxlbmd0aCA9PT0gMzIsICdtZXJrbGVSb290IG11c3QgYmUgMzIgYnl0ZSBidWZmZXInKTtcclxuICAgIHRhZ2dlZFdyaXRlci53cml0ZShtZXJrbGVSb290KTtcclxuICB9XHJcbiAgY29uc3QgdHdlYWtIYXNoID0gdGFnZ2VkV3JpdGVyLmZpbmFsaXplKCk7XHJcblxyXG4gICQuY2hlY2tTdGF0ZShCTi5mcm9tQnVmZmVyKHR3ZWFrSGFzaCkubHQob3JkZXIpLCAnVGFwVHdlYWsgaGFzaCBmYWlsZWQgc2VjcDI1NmsxIG9yZGVyIGNoZWNrJyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR3ZWFrZWRQcml2S2V5OiBzZWNLZXkuYWRkKG5ldyBCTih0d2Vha0hhc2gpKS5tb2Qob3JkZXIpLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSlcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcclxuICpcclxuICogQHJldHVybnMge3N0cmluZ30gUHJpdmF0ZSBrZXlcclxuICovXHJcblByaXZhdGVLZXkucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgdW5jb21wcmVzc2VkID0gIXRoaXMuY29tcHJlc3NlZCA/ICcsIHVuY29tcHJlc3NlZCcgOiAnJztcclxuICByZXR1cm4gJzxQcml2YXRlS2V5OiAnICsgdGhpcy50b1N0cmluZygpICsgJywgbmV0d29yazogJyArIHRoaXMubmV0d29yayArIHVuY29tcHJlc3NlZCArICc+JztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJpdmF0ZUtleTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/privatekey.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/publickey.js":
/*!***************************************!*\
  !*** ../bitcore-lib/lib/publickey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar Point = __webpack_require__(/*! ./crypto/point */ \"../bitcore-lib/lib/crypto/point.js\");\r\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar Network = __webpack_require__(/*! ./networks */ \"../bitcore-lib/lib/networks.js\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nconst TaggedHash = __webpack_require__(/*! ./crypto/taggedhash */ \"../bitcore-lib/lib/crypto/taggedhash.js\");\r\n\r\n/**\r\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\r\n *\r\n * There are two internal properties, `network` and `compressed`, that deal with importing\r\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\r\n *\r\n * @example\r\n * ```javascript\r\n * // instantiate from a private key\r\n * var key = PublicKey(privateKey, true);\r\n *\r\n * // export to as a DER hex encoded string\r\n * var exported = key.toString();\r\n *\r\n * // import the public key\r\n * var imported = PublicKey.fromString(exported);\r\n * ```\r\n *\r\n * @param {string} data - The encoded data in various formats\r\n * @param {Object} extra - additional options\r\n * @param {Network=} extra.network - Which network should the address for this public key be for\r\n * @param {String=} extra.compressed - If the public key is compressed\r\n * @returns {PublicKey} A new valid instance of an PublicKey\r\n * @constructor\r\n */\r\nfunction PublicKey(data, extra) {\r\n\r\n  if (!(this instanceof PublicKey)) {\r\n    return new PublicKey(data, extra);\r\n  }\r\n\r\n  $.checkArgument(data, 'First argument is required, please include public key data.');\r\n\r\n  if (data instanceof PublicKey) {\r\n    // Return copy, but as it's an immutable object, return same argument\r\n    return data;\r\n  }\r\n  extra = extra || {};\r\n\r\n  var info = this._classifyArgs(data, extra);\r\n\r\n  // validation\r\n  info.point.validate();\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    point: info.point,\r\n    compressed: info.compressed,\r\n    network: info.network || Network.defaultNetwork\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Internal function to differentiate between arguments passed to the constructor\r\n * @param {*} data\r\n * @param {Object} extra\r\n */\r\nPublicKey.prototype._classifyArgs = function(data, extra) {\r\n  /* jshint maxcomplexity: 10 */\r\n  var info = {\r\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\r\n  };\r\n\r\n  // detect type of data\r\n  if (data instanceof Point) {\r\n    info.point = data;\r\n  } else if (data.x && data.y) {\r\n    info = PublicKey._transformObject(data);\r\n  } else if (typeof(data) === 'string') {\r\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\r\n  } else if (PublicKey._isBuffer(data)) {\r\n    info = PublicKey._transformDER(data);\r\n  } else if (PublicKey._isPrivateKey(data)) {\r\n    info = PublicKey._transformPrivateKey(data);\r\n  } else {\r\n    throw new TypeError('First argument is an unrecognized data format.');\r\n  }\r\n  if (!info.network) {\r\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to detect if an object is a {@link PrivateKey}\r\n *\r\n * @param {*} param - object to test\r\n * @returns {boolean}\r\n * @private\r\n */\r\nPublicKey._isPrivateKey = function(param) {\r\n  var PrivateKey = __webpack_require__(/*! ./privatekey */ \"../bitcore-lib/lib/privatekey.js\");\r\n  return param instanceof PrivateKey;\r\n};\r\n\r\n/**\r\n * Internal function to detect if an object is a Buffer\r\n *\r\n * @param {*} param - object to test\r\n * @returns {boolean}\r\n * @private\r\n */\r\nPublicKey._isBuffer = function(param) {\r\n  return (param instanceof Buffer) || (param instanceof Uint8Array);\r\n};\r\n\r\n/**\r\n * Internal function to transform a private key into a public key point\r\n *\r\n * @param {PrivateKey} privkey - An instance of PrivateKey\r\n * @returns {Object} An object with keys: point and compressed\r\n * @private\r\n */\r\nPublicKey._transformPrivateKey = function(privkey) {\r\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\r\n  var info = {};\r\n  info.point = Point.getG().mul(privkey.bn);\r\n  info.compressed = privkey.compressed;\r\n  info.network = privkey.network;\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to transform DER into a public key point\r\n *\r\n * @param {Buffer} buf - An hex encoded buffer\r\n * @param {bool=} strict - if set to false, will loosen some conditions\r\n * @returns {Object} An object with keys: point and compressed\r\n * @private\r\n */\r\nPublicKey._transformDER = function(buf, strict) {\r\n  /* jshint maxstatements: 30 */\r\n  /* jshint maxcomplexity: 12 */\r\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\r\n  var info = {};\r\n\r\n  strict = _.isUndefined(strict) ? true : strict;\r\n\r\n  var x;\r\n  var y;\r\n  var xbuf;\r\n  var ybuf;\r\n\r\n  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {\r\n    xbuf = buf.slice(1, 33);\r\n    ybuf = buf.slice(33, 65);\r\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\r\n      throw new TypeError('Length of x and y must be 32 bytes');\r\n    }\r\n    x = new BN(xbuf);\r\n    y = new BN(ybuf);\r\n    info.point = new Point(x, y);\r\n    info.compressed = false;\r\n  } else if (buf[0] === 0x03) {\r\n    xbuf = buf.slice(1);\r\n    x = new BN(xbuf);\r\n    info = PublicKey._transformX(true, x);\r\n    info.compressed = true;\r\n  } else if (buf[0] === 0x02) {\r\n    xbuf = buf.slice(1);\r\n    x = new BN(xbuf);\r\n    info = PublicKey._transformX(false, x);\r\n    info.compressed = true;\r\n  } else {\r\n    throw new TypeError('Invalid DER format public key');\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to transform X into a public key point\r\n *\r\n * @param {Boolean} odd - If the point is above or below the x axis\r\n * @param {Point} x - The x point\r\n * @returns {Object} An object with keys: point and compressed\r\n * @private\r\n */\r\nPublicKey._transformX = function(odd, x) {\r\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\r\n  var info = {};\r\n  info.point = Point.fromX(odd, x);\r\n  return info;\r\n};\r\n\r\n/**\r\n * Internal function to transform a JSON into a public key point\r\n *\r\n * @param {String|Object} json - a JSON string or plain object\r\n * @returns {Object} An object with keys: point and compressed\r\n * @private\r\n */\r\nPublicKey._transformObject = function(json) {\r\n  var x = new BN(json.x, 'hex');\r\n  var y = new BN(json.y, 'hex');\r\n  var point = new Point(x, y);\r\n  return new PublicKey(point, {\r\n    compressed: json.compressed\r\n  });\r\n};\r\n\r\n/**\r\n * Instantiate a PublicKey from a PrivateKey\r\n *\r\n * @param {PrivateKey} privkey - An instance of PrivateKey\r\n * @returns {PublicKey} A new valid instance of PublicKey\r\n */\r\nPublicKey.fromPrivateKey = function(privkey) {\r\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\r\n  var info = PublicKey._transformPrivateKey(privkey);\r\n  return new PublicKey(info.point, {\r\n    compressed: info.compressed,\r\n    network: info.network\r\n  });\r\n};\r\n\r\n/**\r\n * Instantiate a PublicKey from a Buffer\r\n * @param {Buffer} buf A DER buffer (33+ bytes) or a 32 byte X-only coordinate (taproot only)\r\n * @param {Boolean} strict (optional; Only applies to DER format) If set to false, will loosen some conditions\r\n * @returns {PublicKey}\r\n */\r\nPublicKey.fromBuffer = function(buf, strict) {\r\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key or 32 byte X coordinate (taproot)');\r\n  if (buf.length === 32) {\r\n    return PublicKey.fromX(false, buf);\r\n  }\r\n  return PublicKey.fromDER(buf, strict);\r\n}\r\n\r\n/**\r\n * Instantiate a PublicKey from a DER buffer\r\n * @param {Buffer} buf - A DER hex buffer\r\n * @param {bool=} strict - if set to false, will loosen some conditions\r\n * @returns {PublicKey} A new valid instance of PublicKey\r\n */\r\nPublicKey.fromDER = function(buf, strict) {\r\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\r\n  var info = PublicKey._transformDER(buf, strict);\r\n  return new PublicKey(info.point, {\r\n    compressed: info.compressed\r\n  });\r\n};\r\n\r\n/**\r\n * Instantiate a PublicKey from a Point\r\n *\r\n * @param {Point} point - A Point instance\r\n * @param {boolean=} compressed - whether to store this public key as compressed format\r\n * @returns {PublicKey} A new valid instance of PublicKey\r\n */\r\nPublicKey.fromPoint = function(point, compressed) {\r\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\r\n  return new PublicKey(point, {\r\n    compressed: compressed\r\n  });\r\n};\r\n\r\n/**\r\n * Instantiate a PublicKey from a DER hex encoded string\r\n *\r\n * @param {string} str - A DER hex string\r\n * @param {String=} encoding - The type of string encoding\r\n * @returns {PublicKey} A new valid instance of PublicKey\r\n */\r\nPublicKey.fromString = function(str, encoding) {\r\n  var buf = Buffer.from(str, encoding || 'hex');\r\n  var info = PublicKey._transformDER(buf);\r\n  return new PublicKey(info.point, {\r\n    compressed: info.compressed\r\n  });\r\n};\r\n\r\n/**\r\n * Instantiate a PublicKey from an X Point\r\n *\r\n * @param {Boolean} odd - If the point is above or below the x axis\r\n * @param {Point} x - The x point\r\n * @returns {PublicKey} A new valid instance of PublicKey\r\n */\r\nPublicKey.fromX = function(odd, x) {\r\n  var info = PublicKey._transformX(odd, x);\r\n  return new PublicKey(info.point, {\r\n    compressed: info.compressed\r\n  });\r\n};\r\n\r\n/**\r\n * PublicKey instance from a Taproot (32-byte) public key\r\n * @param {String|Buffer} hexBuf \r\n * @returns {PublicKey}\r\n */\r\nPublicKey.fromTaproot = function(hexBuf) {\r\n  if (typeof hexBuf === 'string' && JSUtil.isHexaString(hexBuf)) {\r\n    hexBuf = Buffer.from(hexBuf, 'hex');\r\n  }\r\n  $.checkArgument(Buffer.isBuffer(hexBuf), 'hexBuf must be a hex string or buffer');\r\n  $.checkArgument(hexBuf.length === 32, 'Taproot public keys must be 32 bytes');\r\n  return new PublicKey.fromX(false, hexBuf);\r\n}\r\n\r\n/**\r\n * Verifies if the input is a valid Taproot public key\r\n * @param {String|Buffer} hexBuf \r\n * @returns {Boolean}\r\n */\r\nPublicKey.isValidTaproot = function(hexBuf) {\r\n  try {\r\n    return !!PublicKey.fromTaproot(hexBuf);\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Get the TapTweak tagged hash of this pub key and the merkleRoot\r\n * @param {Buffer} merkleRoot (optional)\r\n * @returns {Buffer}\r\n */\r\nPublicKey.prototype.computeTapTweakHash = function(merkleRoot) {\r\n  const taggedWriter = new TaggedHash('TapTweak');\r\n  taggedWriter.write(this.point.x.toBuffer({ size: 32 }));\r\n\r\n  //  If !merkleRoot, then we have no scripts. The actual tweak does not matter, but \r\n  //  follow BIP341 here to allow for reproducible tweaking.\r\n\r\n  if (merkleRoot) {\r\n    $.checkArgument(Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32, 'merkleRoot must be 32 byte buffer');\r\n    taggedWriter.write(merkleRoot);\r\n  }\r\n  const tweakHash = taggedWriter.finalize();\r\n  \r\n  const order = Point.getN();\r\n  $.checkState(BN.fromBuffer(tweakHash).lt(order), 'TapTweak hash failed secp256k1 order check');\r\n  return tweakHash;\r\n};\r\n\r\n\r\n/**\r\n * Verify a tweaked public key against this key\r\n * @param {PublicKey|Buffer} p Tweaked pub key\r\n * @param {Buffer} merkleRoot (optional)\r\n * @param {Buffer} control \r\n * @returns {Boolean}\r\n */\r\nPublicKey.prototype.checkTapTweak = function(p, merkleRoot, control) {\r\n  if (Buffer.isBuffer(p)) {\r\n    p = PublicKey.fromTaproot(p);\r\n  }\r\n  const tweak = p.computeTapTweakHash(merkleRoot);\r\n\r\n  const P = p.point.liftX();\r\n  const Q = P.add(this.point.curve.g.mul(BN.fromBuffer(tweak)));\r\n  \r\n  return this.point.x.eq(Q.x) && Q.y.mod(new BN(2)).eq(new BN(control[0] & 1));\r\n};\r\n\r\n\r\n/**\r\n * Create a tweaked version of this pub key\r\n * @param {Buffer} merkleRoot (optional)\r\n * @returns {{ parity: Number, tweakedPubKey: Buffer }}\r\n */\r\nPublicKey.prototype.createTapTweak = function(merkleRoot) {\r\n  $.checkArgument(merkleRoot == null || (Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32), 'merkleRoot must be a 32 byte buffer');\r\n\r\n  let t = this.computeTapTweakHash(merkleRoot);\r\n  t = new BN(t);\r\n  const Q = this.point.liftX().add(Point.getG().mul(t));\r\n  const parity = Q.y.isEven() ? 0 : 1;\r\n  return {\r\n    parity,\r\n    tweakedPubKey: Q.x.toBuffer()\r\n  };\r\n};\r\n\r\n/**\r\n * Check if there would be any errors when initializing a PublicKey\r\n *\r\n * @param {string} data - The encoded data in various formats\r\n * @returns {null|Error} An error if exists\r\n */\r\nPublicKey.getValidationError = function(data) {\r\n  var error;\r\n  try {\r\n    /* jshint nonew: false */\r\n    new PublicKey(data);\r\n  } catch (e) {\r\n    error = e;\r\n  }\r\n  return error;\r\n};\r\n\r\n/**\r\n * Check if the parameters are valid\r\n *\r\n * @param {string} data - The encoded data in various formats\r\n * @returns {Boolean} If the public key would be valid\r\n */\r\nPublicKey.isValid = function(data) {\r\n  return !PublicKey.getValidationError(data);\r\n};\r\n\r\n/**\r\n * @returns {Object} A plain object of the PublicKey\r\n */\r\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\r\n  return {\r\n    x: this.point.getX().toString('hex', 2),\r\n    y: this.point.getY().toString('hex', 2),\r\n    compressed: this.compressed\r\n  };\r\n};\r\n\r\n/**\r\n * Will output the PublicKey to a DER Buffer\r\n *\r\n * @returns {Buffer} A DER hex encoded buffer\r\n */\r\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {\r\n  var x = this.point.getX();\r\n  var y = this.point.getY();\r\n\r\n  var xbuf = x.toBuffer({\r\n    size: 32\r\n  });\r\n  var ybuf = y.toBuffer({\r\n    size: 32\r\n  });\r\n\r\n  var prefix;\r\n  if (!this.compressed) {\r\n    prefix = Buffer.from([0x04]);\r\n    return Buffer.concat([prefix, xbuf, ybuf]);\r\n  } else {\r\n    var odd = ybuf[ybuf.length - 1] % 2;\r\n    if (odd) {\r\n      prefix = Buffer.from([0x03]);\r\n    } else {\r\n      prefix = Buffer.from([0x02]);\r\n    }\r\n    return Buffer.concat([prefix, xbuf]);\r\n  }\r\n};\r\n\r\n/**\r\n * Will return a sha256 + ripemd160 hash of the serialized public key\r\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\r\n * @returns {Buffer}\r\n */\r\nPublicKey.prototype._getID = function _getID() {\r\n  return Hash.sha256ripemd160(this.toBuffer());\r\n};\r\n\r\n/**\r\n * Will return an address for the public key\r\n *\r\n * @param {String|Network=} network - Which network should the address be for\r\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\r\n * @returns {Address} An address generated from the public key\r\n */\r\nPublicKey.prototype.toAddress = function(network, type) {\r\n  var Address = __webpack_require__(/*! ./address */ \"../bitcore-lib/lib/address.js\");\r\n  return Address.fromPublicKey(this, network || this.network, type);\r\n};\r\n\r\n/**\r\n * Will output the PublicKey to a DER encoded hex string\r\n *\r\n * @returns {string} A DER hex encoded string\r\n */\r\nPublicKey.prototype.toString = function() {\r\n  return this.toDER().toString('hex');\r\n};\r\n\r\n/**\r\n * Will return a string formatted for the console\r\n *\r\n * @returns {string} Public key\r\n */\r\nPublicKey.prototype.inspect = function() {\r\n  return '<PublicKey: ' + this.toString() +\r\n    (this.compressed ? '' : ', uncompressed') + '>';\r\n};\r\n\r\n\r\nmodule.exports = PublicKey;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3B1YmxpY2tleS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxvREFBYTtBQUM5QixZQUFZLG1CQUFPLENBQUMsMERBQWdCO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyx3REFBZTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsZ0RBQVc7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLGtEQUFZO0FBQ2xDLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMsc0VBQXNCO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLG9FQUFxQjtBQUNoRDtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQixHQUFHLFlBQVk7QUFDbkU7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLG1DQUFtQyxNQUFNO0FBQ3pDLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsc0RBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUyxrQkFBa0I7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLE1BQU0sTUFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGVBQWU7QUFDZjtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLElBQUk7QUFDSjtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLE1BQU07QUFDTixlQUFlLE1BQU07QUFDckI7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnREFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvcHVibGlja2V5LmpzPzMyZmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEJOID0gcmVxdWlyZSgnLi9jcnlwdG8vYm4nKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9jcnlwdG8vcG9pbnQnKTtcclxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2NyeXB0by9oYXNoJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuL3V0aWwvanMnKTtcclxudmFyIE5ldHdvcmsgPSByZXF1aXJlKCcuL25ldHdvcmtzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4vY3J5cHRvL3RhZ2dlZGhhc2gnKTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIFB1YmxpY0tleSBmcm9tIGEge0BsaW5rIFByaXZhdGVLZXl9LCB7QGxpbmsgUG9pbnR9LCBgc3RyaW5nYCwgb3IgYEJ1ZmZlcmAuXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0d28gaW50ZXJuYWwgcHJvcGVydGllcywgYG5ldHdvcmtgIGFuZCBgY29tcHJlc3NlZGAsIHRoYXQgZGVhbCB3aXRoIGltcG9ydGluZ1xyXG4gKiBhIFB1YmxpY0tleSBmcm9tIGEgUHJpdmF0ZUtleSBpbiBXSUYgZm9ybWF0LiBNb3JlIGRldGFpbHMgZGVzY3JpYmVkIG9uIHtAbGluayBQcml2YXRlS2V5fVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIGluc3RhbnRpYXRlIGZyb20gYSBwcml2YXRlIGtleVxyXG4gKiB2YXIga2V5ID0gUHVibGljS2V5KHByaXZhdGVLZXksIHRydWUpO1xyXG4gKlxyXG4gKiAvLyBleHBvcnQgdG8gYXMgYSBERVIgaGV4IGVuY29kZWQgc3RyaW5nXHJcbiAqIHZhciBleHBvcnRlZCA9IGtleS50b1N0cmluZygpO1xyXG4gKlxyXG4gKiAvLyBpbXBvcnQgdGhlIHB1YmxpYyBrZXlcclxuICogdmFyIGltcG9ydGVkID0gUHVibGljS2V5LmZyb21TdHJpbmcoZXhwb3J0ZWQpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0cmEgLSBhZGRpdGlvbmFsIG9wdGlvbnNcclxuICogQHBhcmFtIHtOZXR3b3JrPX0gZXh0cmEubmV0d29yayAtIFdoaWNoIG5ldHdvcmsgc2hvdWxkIHRoZSBhZGRyZXNzIGZvciB0aGlzIHB1YmxpYyBrZXkgYmUgZm9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nPX0gZXh0cmEuY29tcHJlc3NlZCAtIElmIHRoZSBwdWJsaWMga2V5IGlzIGNvbXByZXNzZWRcclxuICogQHJldHVybnMge1B1YmxpY0tleX0gQSBuZXcgdmFsaWQgaW5zdGFuY2Ugb2YgYW4gUHVibGljS2V5XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gUHVibGljS2V5KGRhdGEsIGV4dHJhKSB7XHJcblxyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQdWJsaWNLZXkpKSB7XHJcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShkYXRhLCBleHRyYSk7XHJcbiAgfVxyXG5cclxuICAkLmNoZWNrQXJndW1lbnQoZGF0YSwgJ0ZpcnN0IGFyZ3VtZW50IGlzIHJlcXVpcmVkLCBwbGVhc2UgaW5jbHVkZSBwdWJsaWMga2V5IGRhdGEuJyk7XHJcblxyXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUHVibGljS2V5KSB7XHJcbiAgICAvLyBSZXR1cm4gY29weSwgYnV0IGFzIGl0J3MgYW4gaW1tdXRhYmxlIG9iamVjdCwgcmV0dXJuIHNhbWUgYXJndW1lbnRcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuICBleHRyYSA9IGV4dHJhIHx8IHt9O1xyXG5cclxuICB2YXIgaW5mbyA9IHRoaXMuX2NsYXNzaWZ5QXJncyhkYXRhLCBleHRyYSk7XHJcblxyXG4gIC8vIHZhbGlkYXRpb25cclxuICBpbmZvLnBvaW50LnZhbGlkYXRlKCk7XHJcblxyXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xyXG4gICAgcG9pbnQ6IGluZm8ucG9pbnQsXHJcbiAgICBjb21wcmVzc2VkOiBpbmZvLmNvbXByZXNzZWQsXHJcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmsgfHwgTmV0d29yay5kZWZhdWx0TmV0d29ya1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3JcclxuICogQHBhcmFtIHsqfSBkYXRhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYVxyXG4gKi9cclxuUHVibGljS2V5LnByb3RvdHlwZS5fY2xhc3NpZnlBcmdzID0gZnVuY3Rpb24oZGF0YSwgZXh0cmEpIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cclxuICB2YXIgaW5mbyA9IHtcclxuICAgIGNvbXByZXNzZWQ6IF8uaXNVbmRlZmluZWQoZXh0cmEuY29tcHJlc3NlZCkgfHwgZXh0cmEuY29tcHJlc3NlZFxyXG4gIH07XHJcblxyXG4gIC8vIGRldGVjdCB0eXBlIG9mIGRhdGFcclxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBvaW50KSB7XHJcbiAgICBpbmZvLnBvaW50ID0gZGF0YTtcclxuICB9IGVsc2UgaWYgKGRhdGEueCAmJiBkYXRhLnkpIHtcclxuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybU9iamVjdChkYXRhKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZihkYXRhKSA9PT0gJ3N0cmluZycpIHtcclxuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybURFUihCdWZmZXIuZnJvbShkYXRhLCAnaGV4JykpO1xyXG4gIH0gZWxzZSBpZiAoUHVibGljS2V5Ll9pc0J1ZmZlcihkYXRhKSkge1xyXG4gICAgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtREVSKGRhdGEpO1xyXG4gIH0gZWxzZSBpZiAoUHVibGljS2V5Ll9pc1ByaXZhdGVLZXkoZGF0YSkpIHtcclxuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybVByaXZhdGVLZXkoZGF0YSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IGlzIGFuIHVucmVjb2duaXplZCBkYXRhIGZvcm1hdC4nKTtcclxuICB9XHJcbiAgaWYgKCFpbmZvLm5ldHdvcmspIHtcclxuICAgIGluZm8ubmV0d29yayA9IF8uaXNVbmRlZmluZWQoZXh0cmEubmV0d29yaykgPyB1bmRlZmluZWQgOiBOZXR3b3JrLmdldChleHRyYS5uZXR3b3JrKTtcclxuICB9XHJcbiAgcmV0dXJuIGluZm87XHJcbn07XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIHtAbGluayBQcml2YXRlS2V5fVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHBhcmFtIC0gb2JqZWN0IHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5QdWJsaWNLZXkuX2lzUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHBhcmFtKSB7XHJcbiAgdmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL3ByaXZhdGVrZXknKTtcclxuICByZXR1cm4gcGFyYW0gaW5zdGFuY2VvZiBQcml2YXRlS2V5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcclxuICpcclxuICogQHBhcmFtIHsqfSBwYXJhbSAtIG9iamVjdCB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuUHVibGljS2V5Ll9pc0J1ZmZlciA9IGZ1bmN0aW9uKHBhcmFtKSB7XHJcbiAgcmV0dXJuIChwYXJhbSBpbnN0YW5jZW9mIEJ1ZmZlcikgfHwgKHBhcmFtIGluc3RhbmNlb2YgVWludDhBcnJheSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGEgcHJpdmF0ZSBrZXkgaW50byBhIHB1YmxpYyBrZXkgcG9pbnRcclxuICpcclxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2a2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBwb2ludCBhbmQgY29tcHJlc3NlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuUHVibGljS2V5Ll90cmFuc2Zvcm1Qcml2YXRlS2V5ID0gZnVuY3Rpb24ocHJpdmtleSkge1xyXG4gICQuY2hlY2tBcmd1bWVudChQdWJsaWNLZXkuX2lzUHJpdmF0ZUtleShwcml2a2V5KSwgJ011c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleScpO1xyXG4gIHZhciBpbmZvID0ge307XHJcbiAgaW5mby5wb2ludCA9IFBvaW50LmdldEcoKS5tdWwocHJpdmtleS5ibik7XHJcbiAgaW5mby5jb21wcmVzc2VkID0gcHJpdmtleS5jb21wcmVzc2VkO1xyXG4gIGluZm8ubmV0d29yayA9IHByaXZrZXkubmV0d29yaztcclxuICByZXR1cm4gaW5mbztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gREVSIGludG8gYSBwdWJsaWMga2V5IHBvaW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBBbiBoZXggZW5jb2RlZCBidWZmZXJcclxuICogQHBhcmFtIHtib29sPX0gc3RyaWN0IC0gaWYgc2V0IHRvIGZhbHNlLCB3aWxsIGxvb3NlbiBzb21lIGNvbmRpdGlvbnNcclxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogcG9pbnQgYW5kIGNvbXByZXNzZWRcclxuICogQHByaXZhdGVcclxuICovXHJcblB1YmxpY0tleS5fdHJhbnNmb3JtREVSID0gZnVuY3Rpb24oYnVmLCBzdHJpY3QpIHtcclxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMzAgKi9cclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTIgKi9cclxuICAkLmNoZWNrQXJndW1lbnQoUHVibGljS2V5Ll9pc0J1ZmZlcihidWYpLCAnTXVzdCBiZSBhIGhleCBidWZmZXIgb2YgREVSIGVuY29kZWQgcHVibGljIGtleScpO1xyXG4gIHZhciBpbmZvID0ge307XHJcblxyXG4gIHN0cmljdCA9IF8uaXNVbmRlZmluZWQoc3RyaWN0KSA/IHRydWUgOiBzdHJpY3Q7XHJcblxyXG4gIHZhciB4O1xyXG4gIHZhciB5O1xyXG4gIHZhciB4YnVmO1xyXG4gIHZhciB5YnVmO1xyXG5cclxuICBpZiAoYnVmWzBdID09PSAweDA0IHx8ICghc3RyaWN0ICYmIChidWZbMF0gPT09IDB4MDYgfHwgYnVmWzBdID09PSAweDA3KSkpIHtcclxuICAgIHhidWYgPSBidWYuc2xpY2UoMSwgMzMpO1xyXG4gICAgeWJ1ZiA9IGJ1Zi5zbGljZSgzMywgNjUpO1xyXG4gICAgaWYgKHhidWYubGVuZ3RoICE9PSAzMiB8fCB5YnVmLmxlbmd0aCAhPT0gMzIgfHwgYnVmLmxlbmd0aCAhPT0gNjUpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGVuZ3RoIG9mIHggYW5kIHkgbXVzdCBiZSAzMiBieXRlcycpO1xyXG4gICAgfVxyXG4gICAgeCA9IG5ldyBCTih4YnVmKTtcclxuICAgIHkgPSBuZXcgQk4oeWJ1Zik7XHJcbiAgICBpbmZvLnBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgaW5mby5jb21wcmVzc2VkID0gZmFsc2U7XHJcbiAgfSBlbHNlIGlmIChidWZbMF0gPT09IDB4MDMpIHtcclxuICAgIHhidWYgPSBidWYuc2xpY2UoMSk7XHJcbiAgICB4ID0gbmV3IEJOKHhidWYpO1xyXG4gICAgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtWCh0cnVlLCB4KTtcclxuICAgIGluZm8uY29tcHJlc3NlZCA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChidWZbMF0gPT09IDB4MDIpIHtcclxuICAgIHhidWYgPSBidWYuc2xpY2UoMSk7XHJcbiAgICB4ID0gbmV3IEJOKHhidWYpO1xyXG4gICAgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtWChmYWxzZSwgeCk7XHJcbiAgICBpbmZvLmNvbXByZXNzZWQgPSB0cnVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERFUiBmb3JtYXQgcHVibGljIGtleScpO1xyXG4gIH1cclxuICByZXR1cm4gaW5mbztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gWCBpbnRvIGEgcHVibGljIGtleSBwb2ludFxyXG4gKlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9kZCAtIElmIHRoZSBwb2ludCBpcyBhYm92ZSBvciBiZWxvdyB0aGUgeCBheGlzXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHggLSBUaGUgeCBwb2ludFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBwb2ludCBhbmQgY29tcHJlc3NlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuUHVibGljS2V5Ll90cmFuc2Zvcm1YID0gZnVuY3Rpb24ob2RkLCB4KSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHR5cGVvZiBvZGQgPT09ICdib29sZWFuJywgJ011c3Qgc3BlY2lmeSB3aGV0aGVyIHkgaXMgb2RkIG9yIG5vdCAodHJ1ZSBvciBmYWxzZSknKTtcclxuICB2YXIgaW5mbyA9IHt9O1xyXG4gIGluZm8ucG9pbnQgPSBQb2ludC5mcm9tWChvZGQsIHgpO1xyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIEpTT04gaW50byBhIHB1YmxpYyBrZXkgcG9pbnRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIC0gYSBKU09OIHN0cmluZyBvciBwbGFpbiBvYmplY3RcclxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogcG9pbnQgYW5kIGNvbXByZXNzZWRcclxuICogQHByaXZhdGVcclxuICovXHJcblB1YmxpY0tleS5fdHJhbnNmb3JtT2JqZWN0ID0gZnVuY3Rpb24oanNvbikge1xyXG4gIHZhciB4ID0gbmV3IEJOKGpzb24ueCwgJ2hleCcpO1xyXG4gIHZhciB5ID0gbmV3IEJOKGpzb24ueSwgJ2hleCcpO1xyXG4gIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICByZXR1cm4gbmV3IFB1YmxpY0tleShwb2ludCwge1xyXG4gICAgY29tcHJlc3NlZDoganNvbi5jb21wcmVzc2VkXHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGUgYSBQdWJsaWNLZXkgZnJvbSBhIFByaXZhdGVLZXlcclxuICpcclxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2a2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxyXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fSBBIG5ldyB2YWxpZCBpbnN0YW5jZSBvZiBQdWJsaWNLZXlcclxuICovXHJcblB1YmxpY0tleS5mcm9tUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHByaXZrZXkpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoUHVibGljS2V5Ll9pc1ByaXZhdGVLZXkocHJpdmtleSksICdNdXN0IGJlIGFuIGluc3RhbmNlIG9mIFByaXZhdGVLZXknKTtcclxuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtUHJpdmF0ZUtleShwcml2a2V5KTtcclxuICByZXR1cm4gbmV3IFB1YmxpY0tleShpbmZvLnBvaW50LCB7XHJcbiAgICBjb21wcmVzc2VkOiBpbmZvLmNvbXByZXNzZWQsXHJcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmtcclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIFB1YmxpY0tleSBmcm9tIGEgQnVmZmVyXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgQSBERVIgYnVmZmVyICgzMysgYnl0ZXMpIG9yIGEgMzIgYnl0ZSBYLW9ubHkgY29vcmRpbmF0ZSAodGFwcm9vdCBvbmx5KVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmljdCAob3B0aW9uYWw7IE9ubHkgYXBwbGllcyB0byBERVIgZm9ybWF0KSBJZiBzZXQgdG8gZmFsc2UsIHdpbGwgbG9vc2VuIHNvbWUgY29uZGl0aW9uc1xyXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fVxyXG4gKi9cclxuUHVibGljS2V5LmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYsIHN0cmljdCkge1xyXG4gICQuY2hlY2tBcmd1bWVudChQdWJsaWNLZXkuX2lzQnVmZmVyKGJ1ZiksICdNdXN0IGJlIGEgaGV4IGJ1ZmZlciBvZiBERVIgZW5jb2RlZCBwdWJsaWMga2V5IG9yIDMyIGJ5dGUgWCBjb29yZGluYXRlICh0YXByb290KScpO1xyXG4gIGlmIChidWYubGVuZ3RoID09PSAzMikge1xyXG4gICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tWChmYWxzZSwgYnVmKTtcclxuICB9XHJcbiAgcmV0dXJuIFB1YmxpY0tleS5mcm9tREVSKGJ1Ziwgc3RyaWN0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYSBERVIgYnVmZmVyXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBBIERFUiBoZXggYnVmZmVyXHJcbiAqIEBwYXJhbSB7Ym9vbD19IHN0cmljdCAtIGlmIHNldCB0byBmYWxzZSwgd2lsbCBsb29zZW4gc29tZSBjb25kaXRpb25zXHJcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFB1YmxpY0tleVxyXG4gKi9cclxuUHVibGljS2V5LmZyb21ERVIgPSBmdW5jdGlvbihidWYsIHN0cmljdCkge1xyXG4gICQuY2hlY2tBcmd1bWVudChQdWJsaWNLZXkuX2lzQnVmZmVyKGJ1ZiksICdNdXN0IGJlIGEgaGV4IGJ1ZmZlciBvZiBERVIgZW5jb2RlZCBwdWJsaWMga2V5Jyk7XHJcbiAgdmFyIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybURFUihidWYsIHN0cmljdCk7XHJcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoaW5mby5wb2ludCwge1xyXG4gICAgY29tcHJlc3NlZDogaW5mby5jb21wcmVzc2VkXHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zdGFudGlhdGUgYSBQdWJsaWNLZXkgZnJvbSBhIFBvaW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBQb2ludCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBjb21wcmVzc2VkIC0gd2hldGhlciB0byBzdG9yZSB0aGlzIHB1YmxpYyBrZXkgYXMgY29tcHJlc3NlZCBmb3JtYXRcclxuICogQHJldHVybnMge1B1YmxpY0tleX0gQSBuZXcgdmFsaWQgaW5zdGFuY2Ugb2YgUHVibGljS2V5XHJcbiAqL1xyXG5QdWJsaWNLZXkuZnJvbVBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIGNvbXByZXNzZWQpIHtcclxuICAkLmNoZWNrQXJndW1lbnQocG9pbnQgaW5zdGFuY2VvZiBQb2ludCwgJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUG9pbnQuJyk7XHJcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocG9pbnQsIHtcclxuICAgIGNvbXByZXNzZWQ6IGNvbXByZXNzZWRcclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIFB1YmxpY0tleSBmcm9tIGEgREVSIGhleCBlbmNvZGVkIHN0cmluZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gQSBERVIgaGV4IHN0cmluZ1xyXG4gKiBAcGFyYW0ge1N0cmluZz19IGVuY29kaW5nIC0gVGhlIHR5cGUgb2Ygc3RyaW5nIGVuY29kaW5nXHJcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFB1YmxpY0tleVxyXG4gKi9cclxuUHVibGljS2V5LmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIsIGVuY29kaW5nKSB7XHJcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgZW5jb2RpbmcgfHwgJ2hleCcpO1xyXG4gIHZhciBpbmZvID0gUHVibGljS2V5Ll90cmFuc2Zvcm1ERVIoYnVmKTtcclxuICByZXR1cm4gbmV3IFB1YmxpY0tleShpbmZvLnBvaW50LCB7XHJcbiAgICBjb21wcmVzc2VkOiBpbmZvLmNvbXByZXNzZWRcclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIFB1YmxpY0tleSBmcm9tIGFuIFggUG9pbnRcclxuICpcclxuICogQHBhcmFtIHtCb29sZWFufSBvZGQgLSBJZiB0aGUgcG9pbnQgaXMgYWJvdmUgb3IgYmVsb3cgdGhlIHggYXhpc1xyXG4gKiBAcGFyYW0ge1BvaW50fSB4IC0gVGhlIHggcG9pbnRcclxuICogQHJldHVybnMge1B1YmxpY0tleX0gQSBuZXcgdmFsaWQgaW5zdGFuY2Ugb2YgUHVibGljS2V5XHJcbiAqL1xyXG5QdWJsaWNLZXkuZnJvbVggPSBmdW5jdGlvbihvZGQsIHgpIHtcclxuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtWChvZGQsIHgpO1xyXG4gIHJldHVybiBuZXcgUHVibGljS2V5KGluZm8ucG9pbnQsIHtcclxuICAgIGNvbXByZXNzZWQ6IGluZm8uY29tcHJlc3NlZFxyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFB1YmxpY0tleSBpbnN0YW5jZSBmcm9tIGEgVGFwcm9vdCAoMzItYnl0ZSkgcHVibGljIGtleVxyXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGhleEJ1ZiBcclxuICogQHJldHVybnMge1B1YmxpY0tleX1cclxuICovXHJcblB1YmxpY0tleS5mcm9tVGFwcm9vdCA9IGZ1bmN0aW9uKGhleEJ1Zikge1xyXG4gIGlmICh0eXBlb2YgaGV4QnVmID09PSAnc3RyaW5nJyAmJiBKU1V0aWwuaXNIZXhhU3RyaW5nKGhleEJ1ZikpIHtcclxuICAgIGhleEJ1ZiA9IEJ1ZmZlci5mcm9tKGhleEJ1ZiwgJ2hleCcpO1xyXG4gIH1cclxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyLmlzQnVmZmVyKGhleEJ1ZiksICdoZXhCdWYgbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYnVmZmVyJyk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KGhleEJ1Zi5sZW5ndGggPT09IDMyLCAnVGFwcm9vdCBwdWJsaWMga2V5cyBtdXN0IGJlIDMyIGJ5dGVzJyk7XHJcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkuZnJvbVgoZmFsc2UsIGhleEJ1Zik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWZXJpZmllcyBpZiB0aGUgaW5wdXQgaXMgYSB2YWxpZCBUYXByb290IHB1YmxpYyBrZXlcclxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBoZXhCdWYgXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuUHVibGljS2V5LmlzVmFsaWRUYXByb290ID0gZnVuY3Rpb24oaGV4QnVmKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiAhIVB1YmxpY0tleS5mcm9tVGFwcm9vdChoZXhCdWYpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgVGFwVHdlYWsgdGFnZ2VkIGhhc2ggb2YgdGhpcyBwdWIga2V5IGFuZCB0aGUgbWVya2xlUm9vdFxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAob3B0aW9uYWwpXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XHJcbiAqL1xyXG5QdWJsaWNLZXkucHJvdG90eXBlLmNvbXB1dGVUYXBUd2Vha0hhc2ggPSBmdW5jdGlvbihtZXJrbGVSb290KSB7XHJcbiAgY29uc3QgdGFnZ2VkV3JpdGVyID0gbmV3IFRhZ2dlZEhhc2goJ1RhcFR3ZWFrJyk7XHJcbiAgdGFnZ2VkV3JpdGVyLndyaXRlKHRoaXMucG9pbnQueC50b0J1ZmZlcih7IHNpemU6IDMyIH0pKTtcclxuXHJcbiAgLy8gIElmICFtZXJrbGVSb290LCB0aGVuIHdlIGhhdmUgbm8gc2NyaXB0cy4gVGhlIGFjdHVhbCB0d2VhayBkb2VzIG5vdCBtYXR0ZXIsIGJ1dCBcclxuICAvLyAgZm9sbG93IEJJUDM0MSBoZXJlIHRvIGFsbG93IGZvciByZXByb2R1Y2libGUgdHdlYWtpbmcuXHJcblxyXG4gIGlmIChtZXJrbGVSb290KSB7XHJcbiAgICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyLmlzQnVmZmVyKG1lcmtsZVJvb3QpICYmIG1lcmtsZVJvb3QubGVuZ3RoID09PSAzMiwgJ21lcmtsZVJvb3QgbXVzdCBiZSAzMiBieXRlIGJ1ZmZlcicpO1xyXG4gICAgdGFnZ2VkV3JpdGVyLndyaXRlKG1lcmtsZVJvb3QpO1xyXG4gIH1cclxuICBjb25zdCB0d2Vha0hhc2ggPSB0YWdnZWRXcml0ZXIuZmluYWxpemUoKTtcclxuICBcclxuICBjb25zdCBvcmRlciA9IFBvaW50LmdldE4oKTtcclxuICAkLmNoZWNrU3RhdGUoQk4uZnJvbUJ1ZmZlcih0d2Vha0hhc2gpLmx0KG9yZGVyKSwgJ1RhcFR3ZWFrIGhhc2ggZmFpbGVkIHNlY3AyNTZrMSBvcmRlciBjaGVjaycpO1xyXG4gIHJldHVybiB0d2Vha0hhc2g7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFZlcmlmeSBhIHR3ZWFrZWQgcHVibGljIGtleSBhZ2FpbnN0IHRoaXMga2V5XHJcbiAqIEBwYXJhbSB7UHVibGljS2V5fEJ1ZmZlcn0gcCBUd2Vha2VkIHB1YiBrZXlcclxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgKG9wdGlvbmFsKVxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY29udHJvbCBcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5QdWJsaWNLZXkucHJvdG90eXBlLmNoZWNrVGFwVHdlYWsgPSBmdW5jdGlvbihwLCBtZXJrbGVSb290LCBjb250cm9sKSB7XHJcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwKSkge1xyXG4gICAgcCA9IFB1YmxpY0tleS5mcm9tVGFwcm9vdChwKTtcclxuICB9XHJcbiAgY29uc3QgdHdlYWsgPSBwLmNvbXB1dGVUYXBUd2Vha0hhc2gobWVya2xlUm9vdCk7XHJcblxyXG4gIGNvbnN0IFAgPSBwLnBvaW50LmxpZnRYKCk7XHJcbiAgY29uc3QgUSA9IFAuYWRkKHRoaXMucG9pbnQuY3VydmUuZy5tdWwoQk4uZnJvbUJ1ZmZlcih0d2VhaykpKTtcclxuICBcclxuICByZXR1cm4gdGhpcy5wb2ludC54LmVxKFEueCkgJiYgUS55Lm1vZChuZXcgQk4oMikpLmVxKG5ldyBCTihjb250cm9sWzBdICYgMSkpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSB0d2Vha2VkIHZlcnNpb24gb2YgdGhpcyBwdWIga2V5XHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXJrbGVSb290IChvcHRpb25hbClcclxuICogQHJldHVybnMge3sgcGFyaXR5OiBOdW1iZXIsIHR3ZWFrZWRQdWJLZXk6IEJ1ZmZlciB9fVxyXG4gKi9cclxuUHVibGljS2V5LnByb3RvdHlwZS5jcmVhdGVUYXBUd2VhayA9IGZ1bmN0aW9uKG1lcmtsZVJvb3QpIHtcclxuICAkLmNoZWNrQXJndW1lbnQobWVya2xlUm9vdCA9PSBudWxsIHx8IChCdWZmZXIuaXNCdWZmZXIobWVya2xlUm9vdCkgJiYgbWVya2xlUm9vdC5sZW5ndGggPT09IDMyKSwgJ21lcmtsZVJvb3QgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJyk7XHJcblxyXG4gIGxldCB0ID0gdGhpcy5jb21wdXRlVGFwVHdlYWtIYXNoKG1lcmtsZVJvb3QpO1xyXG4gIHQgPSBuZXcgQk4odCk7XHJcbiAgY29uc3QgUSA9IHRoaXMucG9pbnQubGlmdFgoKS5hZGQoUG9pbnQuZ2V0RygpLm11bCh0KSk7XHJcbiAgY29uc3QgcGFyaXR5ID0gUS55LmlzRXZlbigpID8gMCA6IDE7XHJcbiAgcmV0dXJuIHtcclxuICAgIHBhcml0eSxcclxuICAgIHR3ZWFrZWRQdWJLZXk6IFEueC50b0J1ZmZlcigpXHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGVyZSB3b3VsZCBiZSBhbnkgZXJyb3JzIHdoZW4gaW5pdGlhbGl6aW5nIGEgUHVibGljS2V5XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGVuY29kZWQgZGF0YSBpbiB2YXJpb3VzIGZvcm1hdHNcclxuICogQHJldHVybnMge251bGx8RXJyb3J9IEFuIGVycm9yIGlmIGV4aXN0c1xyXG4gKi9cclxuUHVibGljS2V5LmdldFZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICB2YXIgZXJyb3I7XHJcbiAgdHJ5IHtcclxuICAgIC8qIGpzaGludCBub25ldzogZmFsc2UgKi9cclxuICAgIG5ldyBQdWJsaWNLZXkoZGF0YSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgZXJyb3IgPSBlO1xyXG4gIH1cclxuICByZXR1cm4gZXJyb3I7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIHZhbGlkXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGVuY29kZWQgZGF0YSBpbiB2YXJpb3VzIGZvcm1hdHNcclxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBwdWJsaWMga2V5IHdvdWxkIGJlIHZhbGlkXHJcbiAqL1xyXG5QdWJsaWNLZXkuaXNWYWxpZCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICByZXR1cm4gIVB1YmxpY0tleS5nZXRWYWxpZGF0aW9uRXJyb3IoZGF0YSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge09iamVjdH0gQSBwbGFpbiBvYmplY3Qgb2YgdGhlIFB1YmxpY0tleVxyXG4gKi9cclxuUHVibGljS2V5LnByb3RvdHlwZS50b09iamVjdCA9IFB1YmxpY0tleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHRoaXMucG9pbnQuZ2V0WCgpLnRvU3RyaW5nKCdoZXgnLCAyKSxcclxuICAgIHk6IHRoaXMucG9pbnQuZ2V0WSgpLnRvU3RyaW5nKCdoZXgnLCAyKSxcclxuICAgIGNvbXByZXNzZWQ6IHRoaXMuY29tcHJlc3NlZFxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCBvdXRwdXQgdGhlIFB1YmxpY0tleSB0byBhIERFUiBCdWZmZXJcclxuICpcclxuICogQHJldHVybnMge0J1ZmZlcn0gQSBERVIgaGV4IGVuY29kZWQgYnVmZmVyXHJcbiAqL1xyXG5QdWJsaWNLZXkucHJvdG90eXBlLnRvQnVmZmVyID0gUHVibGljS2V5LnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciB4ID0gdGhpcy5wb2ludC5nZXRYKCk7XHJcbiAgdmFyIHkgPSB0aGlzLnBvaW50LmdldFkoKTtcclxuXHJcbiAgdmFyIHhidWYgPSB4LnRvQnVmZmVyKHtcclxuICAgIHNpemU6IDMyXHJcbiAgfSk7XHJcbiAgdmFyIHlidWYgPSB5LnRvQnVmZmVyKHtcclxuICAgIHNpemU6IDMyXHJcbiAgfSk7XHJcblxyXG4gIHZhciBwcmVmaXg7XHJcbiAgaWYgKCF0aGlzLmNvbXByZXNzZWQpIHtcclxuICAgIHByZWZpeCA9IEJ1ZmZlci5mcm9tKFsweDA0XSk7XHJcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcHJlZml4LCB4YnVmLCB5YnVmXSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBvZGQgPSB5YnVmW3lidWYubGVuZ3RoIC0gMV0gJSAyO1xyXG4gICAgaWYgKG9kZCkge1xyXG4gICAgICBwcmVmaXggPSBCdWZmZXIuZnJvbShbMHgwM10pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDJdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtwcmVmaXgsIHhidWZdKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gYSBzaGEyNTYgKyByaXBlbWQxNjAgaGFzaCBvZiB0aGUgc2VyaWFsaXplZCBwdWJsaWMga2V5XHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9ibG9iL21hc3Rlci9zcmMvcHVia2V5LmgjTDE0MVxyXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxyXG4gKi9cclxuUHVibGljS2V5LnByb3RvdHlwZS5fZ2V0SUQgPSBmdW5jdGlvbiBfZ2V0SUQoKSB7XHJcbiAgcmV0dXJuIEhhc2guc2hhMjU2cmlwZW1kMTYwKHRoaXMudG9CdWZmZXIoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gYW4gYWRkcmVzcyBmb3IgdGhlIHB1YmxpYyBrZXlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBXaGljaCBuZXR3b3JrIHNob3VsZCB0aGUgYWRkcmVzcyBiZSBmb3JcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBFaXRoZXIgJ3B1YmtleWhhc2gnLCAnd2l0bmVzc3B1YmtleWhhc2gnLCBvciAnc2NyaXB0aGFzaCdcclxuICogQHJldHVybnMge0FkZHJlc3N9IEFuIGFkZHJlc3MgZ2VuZXJhdGVkIGZyb20gdGhlIHB1YmxpYyBrZXlcclxuICovXHJcblB1YmxpY0tleS5wcm90b3R5cGUudG9BZGRyZXNzID0gZnVuY3Rpb24obmV0d29yaywgdHlwZSkge1xyXG4gIHZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XHJcbiAgcmV0dXJuIEFkZHJlc3MuZnJvbVB1YmxpY0tleSh0aGlzLCBuZXR3b3JrIHx8IHRoaXMubmV0d29yaywgdHlwZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCBvdXRwdXQgdGhlIFB1YmxpY0tleSB0byBhIERFUiBlbmNvZGVkIGhleCBzdHJpbmdcclxuICpcclxuICogQHJldHVybnMge3N0cmluZ30gQSBERVIgaGV4IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5QdWJsaWNLZXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudG9ERVIoKS50b1N0cmluZygnaGV4Jyk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gYSBzdHJpbmcgZm9ybWF0dGVkIGZvciB0aGUgY29uc29sZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBQdWJsaWMga2V5XHJcbiAqL1xyXG5QdWJsaWNLZXkucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gJzxQdWJsaWNLZXk6ICcgKyB0aGlzLnRvU3RyaW5nKCkgK1xyXG4gICAgKHRoaXMuY29tcHJlc3NlZCA/ICcnIDogJywgdW5jb21wcmVzc2VkJykgKyAnPic7XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQdWJsaWNLZXk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/publickey.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/script/index.js":
/*!******************************************!*\
  !*** ../bitcore-lib/lib/script/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./script */ \"../bitcore-lib/lib/script/script.js\");\r\n\r\nmodule.exports.Interpreter = __webpack_require__(/*! ./interpreter */ \"../bitcore-lib/lib/script/interpreter.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3NjcmlwdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyRkFBb0M7QUFDcEM7QUFDQSxpSEFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9zY3JpcHQvaW5kZXguanM/YTJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5JbnRlcnByZXRlciA9IHJlcXVpcmUoJy4vaW50ZXJwcmV0ZXInKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/script/index.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/script/interpreter.js":
/*!************************************************!*\
  !*** ../bitcore-lib/lib/script/interpreter.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nconst _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\nconst Script = __webpack_require__(/*! ./script */ \"../bitcore-lib/lib/script/script.js\");\r\nconst Opcode = __webpack_require__(/*! ../opcode */ \"../bitcore-lib/lib/opcode.js\");\r\nconst BN = __webpack_require__(/*! ../crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nconst Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nconst Signature = __webpack_require__(/*! ../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nconst PublicKey = __webpack_require__(/*! ../publickey */ \"../bitcore-lib/lib/publickey.js\");\r\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nconst SighashWitness = __webpack_require__(/*! ../transaction/sighashwitness */ \"../bitcore-lib/lib/transaction/sighashwitness.js\");\r\nconst SighashSchnorr = __webpack_require__(/*! ../transaction/sighashschnorr */ \"../bitcore-lib/lib/transaction/sighashschnorr.js\");\r\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"../bitcore-lib/lib/crypto/taggedhash.js\");\r\n\r\n/**\r\n * Bitcoin transactions contain scripts. Each input has a script called the\r\n * scriptSig, and each output has a script called the scriptPubkey. To validate\r\n * an input, the input's script is concatenated with the referenced output script,\r\n * and the result is executed. If at the end of execution the stack contains a\r\n * \"true\" value, then the transaction is valid.\r\n *\r\n * The primary way to use this class is via the verify function.\r\n * e.g., Interpreter().verify( ... );\r\n */\r\nvar Interpreter = function Interpreter(obj) {\r\n  if (!(this instanceof Interpreter)) {\r\n    return new Interpreter(obj);\r\n  }\r\n  if (obj) {\r\n    this.initialize();\r\n    this.set(obj);\r\n  } else {\r\n    this.initialize();\r\n  }\r\n};\r\n\r\n\r\nInterpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags, isP2SH) {\r\n\r\n  var scriptPubKey = new Script();\r\n  var stack = [];\r\n\r\n  if (version === 0) {\r\n    if (program.length === Interpreter.WITNESS_V0_SCRIPTHASH_SIZE) {\r\n      if (witness.length === 0) {\r\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\r\n        return false;\r\n      }\r\n\r\n      var scriptPubKeyBuffer = witness[witness.length - 1];\r\n      scriptPubKey = new Script(scriptPubKeyBuffer);\r\n      var hash = Hash.sha256(scriptPubKeyBuffer);\r\n      if (hash.toString('hex') !== program.toString('hex')) {\r\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\r\n        return false;\r\n      }\r\n\r\n      stack = witness.slice(0, -1);\r\n      return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.WITNESS_V0, satoshis, flags);\r\n    } else if (program.length === Interpreter.WITNESS_V0_KEYHASH_SIZE) {\r\n      if (witness.length !== 2) {\r\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\r\n        return false;\r\n      }\r\n\r\n      scriptPubKey.add(Opcode.OP_DUP);\r\n      scriptPubKey.add(Opcode.OP_HASH160);\r\n      scriptPubKey.add(program);\r\n      scriptPubKey.add(Opcode.OP_EQUALVERIFY);\r\n      scriptPubKey.add(Opcode.OP_CHECKSIG);\r\n\r\n      stack = witness;\r\n      return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.WITNESS_V0, satoshis, flags);\r\n    } else {\r\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH';\r\n      return false;\r\n    }\r\n  } else if (version === 1 && program.length == Interpreter.WITNESS_V1_TAPROOT_SIZE && !isP2SH) {\r\n    const execdata = { annexPresent: false };\r\n    // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\r\n    if (!(flags & Interpreter.SCRIPT_VERIFY_TAPROOT)) {\r\n      return true;\r\n    }\r\n    stack = Array.from(witness);\r\n    if (stack.length == 0) {\r\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\r\n      return false;\r\n    }\r\n    if (stack.length >= 2 && stack[stack.length - 1].length && stack[stack.length - 1][0] === Script.ANNEX_TAG) {\r\n      // Drop annex (this is non-standard; see IsWitnessStandard)\r\n      const annex = stack.pop();\r\n      const annexWriter = new BufferWriter();\r\n      annexWriter.writeVarintNum(annex.length);\r\n      annexWriter.write(annex);\r\n      execdata.annexHash = Hash.sha256(annexWriter.toBuffer());\r\n      execdata.annexPresent = true;\r\n    }\r\n    execdata.annexInit = true;\r\n    if (stack.length === 1) {\r\n      // Key path spending (stack size is 1 after removing optional annex)\r\n      return this.checkSchnorrSignature(stack[0], program, Signature.Version.TAPROOT, execdata);\r\n    } else {\r\n      // Script path spending (stack size is >1 after removing optional annex)\r\n      const control = stack.pop();\r\n      const scriptPubKeyBuf = stack.pop();\r\n\r\n      if (\r\n        control.length < Interpreter.TAPROOT_CONTROL_BASE_SIZE  ||\r\n        control.length > Interpreter.TAPROOT_CONTROL_MAX_SIZE   ||\r\n        ((control.length - Interpreter.TAPROOT_CONTROL_BASE_SIZE) % Interpreter.TAPROOT_CONTROL_NODE_SIZE) != 0\r\n      ) {\r\n        this.errstr = 'SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE';\r\n        return false;\r\n      }\r\n      execdata.tapleafHash = Interpreter.computeTapleafHash(control[0] & Interpreter.TAPROOT_LEAF_MASK, scriptPubKeyBuf);\r\n      if (!Interpreter.verifyTaprootCommitment(control, program, execdata.tapleafHash)) {\r\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\r\n        return false;\r\n      }\r\n      execdata.tapleafHashInit = true;\r\n      if ((control[0] & Interpreter.TAPROOT_LEAF_MASK) === Interpreter.TAPROOT_LEAF_TAPSCRIPT) {\r\n        // Tapscript (leaf version 0xc0)\r\n        let witnessSize;\r\n        {\r\n          const bw = new BufferWriter();\r\n          bw.writeVarintNum(witness.length);\r\n          for (let element of witness) {\r\n            bw.writeVarintNum(element.length);\r\n            bw.write(element);\r\n          }\r\n          witnessSize = bw.toBuffer().length;\r\n        }\r\n\r\n        try {\r\n          scriptPubKey = new Script(scriptPubKeyBuf);\r\n        } catch (err) {\r\n          // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\r\n          this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\r\n          return false;\r\n        }\r\n\r\n        execdata.validationWeightLeft = witnessSize + Script.VALIDATION_WEIGHT_OFFSET;\r\n        execdata.validationWeightLeftInit = true;\r\n        return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.TAPSCRIPT, satoshis, flags, execdata);\r\n      }\r\n      // If none of the above conditions are met then this must be an upgraded taproot version.\r\n      if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\r\n        this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION';\r\n        return false;\r\n      }\r\n      // Future softfork compatibility\r\n      return true;\r\n    }\r\n  } else if ((flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) {\r\n    this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM';\r\n    return false;\r\n  }\r\n  // Other version/size/p2sh combinations return true for future softfork compatibility\r\n  return true;\r\n};\r\n\r\n\r\nInterpreter.prototype.executeWitnessScript = function(scriptPubKey, stack, sigversion, satoshis, flags, execdata) {\r\n  if (sigversion === Signature.Version.TAPSCRIPT) {\r\n    for (let chunk of scriptPubKey.chunks) {\r\n      // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\r\n      if (Opcode.isOpSuccess(chunk.opcodenum)) {\r\n        if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\r\n          this.errstr = 'SCRIPT_ERR_DISCOURAGE_OP_SUCCESS';\r\n          return false;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Tapscript enforces initial stack size limits (altstack is empty here)\r\n    if (stack.length > Interpreter.MAX_STACK_SIZE) {\r\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\r\n  if (stack.length && stack.some(elem => elem.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE)) {\r\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\r\n    return false;\r\n  }\r\n\r\n  this.initialize();\r\n\r\n  this.set({\r\n    script: scriptPubKey,\r\n    stack: stack,\r\n    sigversion: sigversion,\r\n    satoshis: satoshis,\r\n    flags: flags,\r\n    execdata: execdata\r\n  });\r\n\r\n  if (!this.evaluate()) {\r\n    return false;\r\n  }\r\n\r\n  if (this.stack.length !== 1) {\r\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE';\r\n    return false;\r\n  }\r\n\r\n  var buf = this.stack[this.stack.length - 1];\r\n  if (!Interpreter.castToBool(buf)) {\r\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n\r\n/**\r\n * Verifies a Script by executing it and returns true if it is valid.\r\n * This function needs to be provided with the scriptSig and the scriptPubkey\r\n * separately.\r\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\r\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\r\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\r\n *    to check signature validity for some opcodes like OP_CHECKSIG)\r\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\r\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\r\n * @param {number} witness - array of witness data\r\n * @param {number} satoshis - number of satoshis created by this output\r\n *\r\n * Translated from bitcoind's VerifyScript\r\n */\r\nInterpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {\r\n\r\n  var Transaction = __webpack_require__(/*! ../transaction */ \"../bitcore-lib/lib/transaction/index.js\");\r\n  if (_.isUndefined(tx)) {\r\n    tx = new Transaction();\r\n  }\r\n  if (_.isUndefined(nin)) {\r\n    nin = 0;\r\n  }\r\n  if (_.isUndefined(flags)) {\r\n    flags = 0;\r\n  }\r\n  if (_.isUndefined(witness)) {\r\n    witness = null;\r\n  }\r\n  if (_.isUndefined(satoshis)) {\r\n    satoshis = 0;\r\n  }\r\n\r\n  this.set({\r\n    script: scriptSig,\r\n    tx: tx,\r\n    nin: nin,\r\n    sigversion: Signature.Version.BASE,\r\n    satoshis: 0,\r\n    flags: flags\r\n  });\r\n  var stackCopy;\r\n\r\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\r\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\r\n    return false;\r\n  }\r\n\r\n  // evaluate scriptSig\r\n  if (!this.evaluate()) {\r\n    return false;\r\n  }\r\n\r\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\r\n    stackCopy = this.stack.slice();\r\n  }\r\n\r\n  var stack = this.stack;\r\n  this.initialize();\r\n  this.set({\r\n    script: scriptPubkey,\r\n    stack: stack,\r\n    tx: tx,\r\n    nin: nin,\r\n    flags: flags\r\n  });\r\n\r\n  // evaluate scriptPubkey\r\n  if (!this.evaluate()) {\r\n    return false;\r\n  }\r\n\r\n  if (this.stack.length === 0) {\r\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\r\n    return false;\r\n  }\r\n\r\n  var buf = this.stack[this.stack.length - 1];\r\n  if (!Interpreter.castToBool(buf)) {\r\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\r\n    return false;\r\n  }\r\n\r\n  var hadWitness = false;\r\n  if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\r\n    var witnessValues = {};\r\n    if (scriptPubkey.isWitnessProgram(witnessValues)) {\r\n      hadWitness = true;\r\n      if (scriptSig.toBuffer().length !== 0) {\r\n        this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED';\r\n        return false;\r\n      }\r\n      if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags, /* isP2SH */ false)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Additional validation for spend-to-script-hash transactions:\r\n  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {\r\n    // scriptSig must be literals-only or validation fails\r\n    if (!scriptSig.isPushOnly()) {\r\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\r\n      return false;\r\n    }\r\n\r\n    // stackCopy cannot be empty here, because if it was the\r\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\r\n    // an empty stack and the EvalScript above would return false.\r\n    if (stackCopy.length === 0) {\r\n      throw new Error('internal error - stack copy empty');\r\n    }\r\n\r\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\r\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\r\n    stackCopy.pop();\r\n\r\n    this.initialize();\r\n    this.set({\r\n      script: redeemScript,\r\n      stack: stackCopy,\r\n      tx: tx,\r\n      nin: nin,\r\n      flags: flags\r\n    });\r\n\r\n    // evaluate redeemScript\r\n    if (!this.evaluate()) {\r\n      return false;\r\n    }\r\n\r\n    if (stackCopy.length === 0) {\r\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\r\n      return false;\r\n    }\r\n\r\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\r\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\r\n      return false;\r\n    }\r\n    if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\r\n      var p2shWitnessValues = {};\r\n      if (redeemScript.isWitnessProgram(p2shWitnessValues)) {\r\n        hadWitness = true;\r\n        var redeemScriptPush = new Script();\r\n        redeemScriptPush.add(redeemScript.toBuffer());\r\n        if (scriptSig.toHex() !== redeemScriptPush.toHex()) {\r\n          this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED_P2SH';\r\n          return false;\r\n        }\r\n\r\n        if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags, /* isP2SH */ true)) {\r\n          return false;\r\n        }\r\n        // Bypass the cleanstack check at the end. The actual stack is obviously not clean\r\n        // for witness programs.\r\n        stack = [stack[0]];\r\n      }\r\n    }\r\n  }\r\n\r\n  // The CLEANSTACK check is only performed after potential P2SH evaluation,\r\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\r\n  // a clean stack (the P2SH inputs remain). The same holds for witness\r\n  // evaluation.\r\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\r\n      // Disallow CLEANSTACK without P2SH, as otherwise a switch\r\n      // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\r\n      // softfork (and P2SH should be one).\r\n      if (\r\n        (this.flags & Interpreter.SCRIPT_VERIFY_P2SH)    == 0 ||\r\n        (this.flags & Interpreter.SCRIPT_VERIFY_WITNESS) == 0\r\n      ) {\r\n        throw 'flags & SCRIPT_VERIFY_P2SH';\r\n      }\r\n\r\n      if (stackCopy.length != 1) {\r\n        this.errstr = 'SCRIPT_ERR_CLEANSTACK';\r\n        return false;\r\n      }\r\n  }\r\n\r\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\r\n    if (!hadWitness && witness.length > 0) {\r\n      this.errstr = 'SCRIPT_ERR_WITNESS_UNEXPECTED';\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nmodule.exports = Interpreter;\r\n\r\nInterpreter.prototype.initialize = function(obj) {\r\n  this.stack = [];\r\n  this.altstack = [];\r\n  this.pc = 0;\r\n  this.satoshis = 0;\r\n  this.sigversion = Signature.Version.BASE;\r\n  this.pbegincodehash = 0;\r\n  this.nOpCount = 0;\r\n  this.vfExec = [];\r\n  this.errstr = '';\r\n  this.flags = 0;\r\n  this.execdata = {};\r\n};\r\n\r\nInterpreter.prototype.set = function(obj) {\r\n  this.script = obj.script || this.script;\r\n  this.tx = obj.tx || this.tx;\r\n  this.nin = typeof obj.nin === 'undefined' ? this.nin : parseInt(obj.nin);\r\n  this.stack = obj.stack || this.stack;\r\n  this.altstack = obj.altstack || this.altstack;\r\n  this.pc = typeof obj.pc === 'undefined' ? this.pc : obj.pc;\r\n  this.pbegincodehash = typeof obj.pbegincodehash === 'undefined' ? this.pbegincodehash : obj.pbegincodehash;\r\n  this.sigversion = typeof obj.sigversion === 'undefined' ? this.sigversion : obj.sigversion;\r\n  this.satoshis = typeof obj.satoshis === 'undefined' ? this.satoshis : obj.satoshis;\r\n  this.nOpCount = typeof obj.nOpCount === 'undefined' ? this.nOpCount : obj.nOpCount;\r\n  this.vfExec = obj.vfExec || this.vfExec;\r\n  this.errstr = obj.errstr || this.errstr;\r\n  this.flags = typeof obj.flags === 'undefined' ? this.flags : obj.flags;\r\n  this.execdata = typeof obj.execdata === 'undefined' ? this.execdata : (obj.execdata || {});\r\n};\r\n\r\nInterpreter.true = Buffer.from([1]);\r\nInterpreter.false = Buffer.from([]);\r\n\r\nInterpreter.MAX_SCRIPT_SIZE = 10000;\r\nInterpreter.MAX_STACK_SIZE = 1000;\r\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\r\n\r\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\r\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\r\n\r\n// flags taken from bitcoind\r\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\r\nInterpreter.SCRIPT_VERIFY_NONE = 0;\r\n\r\n// Evaluate P2SH subscripts (softfork safe, BIP16).\r\nInterpreter.SCRIPT_VERIFY_P2SH = (1 << 0);\r\n\r\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\r\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\r\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\r\nInterpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);\r\n\r\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\r\nInterpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);\r\n\r\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\r\n// (softfork safe, BIP62 rule 5).\r\nInterpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);\r\n\r\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\r\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);\r\n\r\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\r\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);\r\n\r\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\r\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\r\n// any other push causes the script to fail (BIP62 rule 3).\r\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\r\n// (softfork safe)\r\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);\r\n\r\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\r\n//\r\n// Provided so that nodes can avoid accepting or mining transactions\r\n// containing executed NOP's whose meaning may change after a soft-fork,\r\n// thus rendering the script invalid; with this flag set executing\r\n// discouraged NOPs fails the script. This verification flag will never be\r\n// a mandatory flag applied to scripts in a block. NOPs that are not\r\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\r\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);\r\n\r\n\r\n// Require that only a single stack element remains after evaluation. This\r\n// changes the success criterion from \"At least one stack element must\r\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\r\n// one stack element must remain, and when interpreted as a boolean, it must\r\n// be true\".\r\n// (softfork safe, BIP62 rule 6)\r\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\r\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8),\r\n\r\n// Verify CHECKLOCKTIMEVERIFY\r\n//\r\n// See BIP65 for details.\r\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);\r\n\r\n// support CHECKSEQUENCEVERIFY opcode\r\n//\r\n// See BIP112 for details\r\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);\r\n\r\n// Support segregated witness\r\n//\r\nInterpreter.SCRIPT_VERIFY_WITNESS = (1 << 11);\r\n\r\n// Making v1-v16 witness program non-standard\r\n//\r\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1 << 12);\r\n\r\n\r\n//\r\n// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\r\n// 0x01 or empty vector\r\n//\r\nInterpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);\r\n\r\n\r\n// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\r\n//\r\nInterpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);\r\n\r\n// Public keys in scripts must be compressed\r\n//\r\nInterpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1 << 15);\r\n\r\n// Do we accept signature using SIGHASH_FORKID\r\n//\r\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);\r\n\r\n// Do we accept activate replay protection using a different fork id.\r\n//\r\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);\r\n\r\n// Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\r\n//\r\nInterpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE = (1 << 16);\r\n\r\n// Verify taproot script \r\n//\r\nInterpreter.SCRIPT_VERIFY_TAPROOT = (1 << 17);\r\n\r\n// Making unknown Taproot leaf versions non-standard\r\n//\r\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1 << 18);\r\n\r\n// Making unknown OP_SUCCESS non-standard\r\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1 << 19);\r\n\r\n// Making unknown public key versions (in BIP 342 scripts) non-standard\r\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1 << 20);\r\n\r\n\r\n\r\n/* Below flags apply in the context of BIP 68*/\r\n/**\r\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\r\n * lock-time.\r\n */\r\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\r\n\r\n/**\r\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\r\n * the relative lock-time has units of 512 seconds, otherwise it specifies\r\n * blocks with a granularity of 1.\r\n */\r\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\r\n\r\n/**\r\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\r\n * extract that lock-time from the sequence field.\r\n */\r\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\r\n\r\n/** Signature hash sizes */\r\nInterpreter.WITNESS_V0_SCRIPTHASH_SIZE = 32;\r\nInterpreter.WITNESS_V0_KEYHASH_SIZE = 20;\r\nInterpreter.WITNESS_V1_TAPROOT_SIZE = 32;\r\n\r\nInterpreter.TAPROOT_LEAF_MASK = 0xfe;\r\nInterpreter.TAPROOT_LEAF_TAPSCRIPT = 0xc0;\r\nInterpreter.TAPROOT_CONTROL_BASE_SIZE = 33;\r\nInterpreter.TAPROOT_CONTROL_NODE_SIZE = 32;\r\nInterpreter.TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\r\nInterpreter.TAPROOT_CONTROL_MAX_SIZE = Interpreter.TAPROOT_CONTROL_BASE_SIZE + Interpreter.TAPROOT_CONTROL_NODE_SIZE * Interpreter.TAPROOT_CONTROL_MAX_NODE_COUNT;\r\n\r\n// Conceptually, this doesn't really belong with the Interpreter, but I haven't found a better place for it.\r\nInterpreter.PROTOCOL_VERSION = 70016;\r\n\r\nInterpreter.castToBool = function(buf) {\r\n  for (var i = 0; i < buf.length; i++) {\r\n    if (buf[i] !== 0) {\r\n      // can be negative zero\r\n      if (i === buf.length - 1 && buf[i] === 0x80) {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Translated from bitcoind's CheckSignatureEncoding\r\n */\r\nInterpreter.prototype.checkSignatureEncoding = function(buf) {\r\n  var sig;\r\n\r\n    // Empty signature. Not strictly DER encoded, but allowed to provide a\r\n    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\r\n    if (buf.length == 0) {\r\n        return true;\r\n    }\r\n\r\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\r\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\r\n    return false;\r\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\r\n    sig = Signature.fromTxFormat(buf);\r\n    if (!sig.hasLowS()) {\r\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\r\n      return false;\r\n    }\r\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\r\n    sig = Signature.fromTxFormat(buf);\r\n    if (!sig.hasDefinedHashtype()) {\r\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Translated from bitcoind's CheckPubKeyEncoding\r\n */\r\nInterpreter.prototype.checkPubkeyEncoding = function(buf) {\r\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\r\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\r\n    return false;\r\n  }\r\n\r\n  // Only compressed keys are accepted in segwit\r\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == Signature.Version.WITNESS_V0 && !PublicKey.fromBuffer(buf).compressed) {\r\n    this.errstr = 'SCRIPT_ERR_WITNESS_PUBKEYTYPE';\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Verifies ECDSA signature\r\n * @param {Signature} sig \r\n * @param {PublicKey} pubkey \r\n * @param {Number} nin \r\n * @param {Script} subscript \r\n * @param {Number} satoshis \r\n * @returns {Boolean}\r\n */\r\nInterpreter.prototype.checkEcdsaSignature = function(sig, pubkey, nin, subscript, satoshis) {\r\n  var subscriptBuffer = subscript.toBuffer();\r\n  var scriptCodeWriter = new BufferWriter();\r\n  scriptCodeWriter.writeVarintNum(subscriptBuffer.length);\r\n  scriptCodeWriter.write(subscriptBuffer);\r\n\r\n  $.checkState(JSUtil.isNaturalNumber(satoshis));\r\n  var satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();\r\n\r\n  var verified = SighashWitness.verify(\r\n    this,\r\n    sig,\r\n    pubkey,\r\n    nin,\r\n    scriptCodeWriter.toBuffer(),\r\n    satoshisBuffer\r\n  );\r\n  return verified;\r\n};\r\n\r\n\r\n/**\r\n * Verifies Schnorr signature\r\n * @param {Signature|Buffer} sig \r\n * @param {PublicKey|Buffer} pubkey \r\n * @param {Number} sigversion \r\n * @param {Object} execdata \r\n * @returns {Boolean}\r\n */\r\nInterpreter.prototype.checkSchnorrSignature = function(sig, pubkey, sigversion, execdata) {\r\n  $.checkArgument(sig && Buffer.isBuffer(sig), 'Missing sig');\r\n  $.checkArgument(pubkey && Buffer.isBuffer(pubkey), 'Missing pubkey');\r\n  $.checkArgument(sigversion, 'Missing sigversion');\r\n  $.checkArgument(execdata, 'Missing execdata');\r\n\r\n  $.checkArgument(pubkey.length === 32, 'Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.');\r\n  // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\r\n  // abort script execution). This is implemented in EvalChecksigTapscript, which won't invoke\r\n  // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\r\n  // size different from 64 or 65.\r\n  if (!(sig.length === 64 || sig.length === 65)) {\r\n    this.errstr = 'SCRIPT_ERR_SCHNORR_SIG_SIZE';\r\n    return false;\r\n  }\r\n\r\n  if (sig.length === 65 && sig[sig.length - 1] === Signature.SIGHASH_DEFAULT) {\r\n    this.errstr = 'SCRIPT_ERR_SCHNORR_SIG_HASHTYPE';\r\n    return false;\r\n  }\r\n  sig = Signature.fromSchnorr(sig);\r\n  const verified = SighashSchnorr.verify(\r\n    this.tx,\r\n    sig,\r\n    pubkey,\r\n    sigversion,\r\n    this.nin,\r\n    execdata\r\n  );\r\n  return verified;\r\n};\r\n\r\n\r\n/**\r\n * Based on bitcoind's EvalChecksigPreTapscript function\r\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\r\n */\r\nInterpreter.prototype._evalChecksigPreTapscript = function(bufSig, bufPubkey) {\r\n  $.checkArgument(\r\n    this.sigversion === Signature.Version.BASE || this.sigversion === Signature.Version.WITNESS_V0,\r\n    'sigversion must be base or witness_v0'\r\n  );\r\n\r\n  // Success signifies if the signature is valid.\r\n  // Result signifies the result of this funciton, which also takes flags into account.\r\n  const retVal = { success: false, result: false };\r\n\r\n  const subscript = new Script().set({\r\n    chunks: this.script.chunks.slice(this.pbegincodehash)\r\n  });\r\n\r\n  // Drop the signature in pre-segwit scripts but not segwit scripts\r\n  if (this.sigversion === Signature.Version.BASE) {\r\n    // Drop the signature, since there's no way for a signature to sign itself\r\n    const tmpScript = new Script().add(bufSig);\r\n    let found = subscript.chunks.length;\r\n    subscript.findAndDelete(tmpScript);\r\n\r\n    found = found == subscript.chunks.length + 1; // found if a chunk was removed\r\n    if (found && (this.flags & Interpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE)) {\r\n      this.errstr = 'SCRIPT_ERR_SIG_FINDANDDELETE';\r\n      return retVal;\r\n    }\r\n  }\r\n\r\n  if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\r\n    return retVal;\r\n  }\r\n\r\n  try {\r\n    const sig = Signature.fromTxFormat(bufSig);\r\n    const pubkey = PublicKey.fromBuffer(bufPubkey, false);\r\n    retVal.success = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);\r\n  } catch (e) {\r\n    //invalid sig or pubkey\r\n    retVal.success = false;\r\n  }\r\n\r\n  if (!retVal.success && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) && bufSig.length) {\r\n    this.errstr = 'SCRIPT_ERR_SIG_NULLFAIL';\r\n    return retVal;\r\n  }\r\n  \r\n  // If it reaches here, then true\r\n  retVal.result = true;\r\n  return retVal;\r\n};\r\n\r\n\r\n/**\r\n * Based on bitcoind's EvalChecksigTapscript function\r\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\r\n */\r\nInterpreter.prototype._evalChecksigTapscript = function(bufSig, bufPubkey) {\r\n  $.checkArgument(this.sigversion == Signature.Version.TAPSCRIPT, 'this.sigversion must by TAPSCRIPT');\r\n\r\n  /*\r\n    *  The following validation sequence is consensus critical. Please note how --\r\n    *    upgradable public key versions precede other rules;\r\n    *    the script execution fails when using empty signature with invalid public key;\r\n    *    the script execution fails when using non-empty invalid signature.\r\n    */\r\n\r\n  // Success signifies if the signature is valid.\r\n  // Result signifies the result of this funciton, which also takes flags into account.\r\n  const retVal = {\r\n    success: bufSig.length > 0,\r\n    result: false\r\n  }\r\n  if (retVal.success) {\r\n    // Implement the sigops/witnesssize ratio test.\r\n    // Passing with an upgradable public key version is also counted.\r\n    $.checkState(this.execdata.validationWeightLeftInit, 'validationWeightLeftInit is false');\r\n    this.execdata.validationWeightLeft -= Script.VALIDATION_WEIGHT_PER_SIGOP_PASSED;\r\n    if (this.execdata.validationWeightLeft < 0) {\r\n      this.errstr = 'SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT';\r\n      return retVal;\r\n    }\r\n  }\r\n  if (bufPubkey.length === 0) {\r\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\r\n    return retVal;\r\n  } else if (bufPubkey.length == 32) {\r\n    if (retVal.success && !this.tx.checkSchnorrSignature(bufSig, bufPubkey, this.nin, this.sigversion, this.execdata)) {\r\n      this.errstr = 'SCRIPT_ERR_SCHNORR_SIG';\r\n      return retVal;\r\n    }\r\n  } else {\r\n    /*\r\n      *  New public key version softforks should be defined before this `else` block.\r\n      *  Generally, the new code should not do anything but failing the script execution. To avoid\r\n      *  consensus bugs, it should not modify any existing values (including `success`).\r\n      */\r\n    if ((this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\r\n      this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE';\r\n      return retVal;\r\n    }\r\n  }\r\n\r\n  // If it reaches here, then true\r\n  retVal.result = true;\r\n  return retVal;\r\n}\r\n\r\n/**\r\n * Based on bitcoind's EvalChecksig function\r\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\r\n * @returns {{ success: Boolean, verified: Boolean }}\r\n */\r\nInterpreter.prototype._evalCheckSig = function(bufSig, bufPubkey) {\r\n  switch(this.sigversion) {\r\n    case Signature.Version.BASE:\r\n    case Signature.Version.WITNESS_V0:\r\n      // const verified = this._evalChecksigPreTapscript(bufSig, bufPubkey);\r\n      // return { success: verified, verified }; // This is to keep the same return format as _evalCheckSigTapscript\r\n      return this._evalChecksigPreTapscript(bufSig, bufPubkey);\r\n    case Signature.Version.TAPSCRIPT:\r\n      return this._evalChecksigTapscript(bufSig, bufPubkey);\r\n    case Signature.Version.TAPROOT:\r\n      // Key path spending in Taproot has no script, so this is unreachable.\r\n      throw new Error('Called evalCheckSig with a TAPROOT sigversion. Check your implementation');\r\n  }\r\n};\r\n\r\n/**\r\n * Based on bitcoind's EvalScript function, with the inner loop moved to\r\n * Interpreter.prototype.step()\r\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\r\n */\r\nInterpreter.prototype.evaluate = function() {\r\n  // sigversion cannot be TAPROOT here, as it admits no script execution.\r\n  $.checkArgument(this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0 || this.sigversion == Signature.Version.TAPSCRIPT, 'invalid sigversion');\r\n\r\n  if (\r\n    (this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0) &&\r\n    this.script.toBuffer().length > Interpreter.MAX_SCRIPT_SIZE\r\n  ) {\r\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    while (this.pc < this.script.chunks.length) {\r\n      var fSuccess = this.step();\r\n      if (!fSuccess) {\r\n        return false;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\r\n    return false;\r\n  }\r\n\r\n  if (this.vfExec.length > 0) {\r\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Checks a locktime parameter with the transaction's locktime.\r\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\r\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\r\n *\r\n * See the corresponding code on bitcoin core:\r\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\r\n *\r\n * @param {BN} nLockTime the locktime read from the script\r\n * @return {boolean} true if the transaction's locktime is less than or equal to\r\n *                   the transaction's locktime\r\n */\r\nInterpreter.prototype.checkLockTime = function(nLockTime) {\r\n\r\n  // We want to compare apples to apples, so fail the script\r\n  // unless the type of nLockTime being tested is the same as\r\n  // the nLockTime in the transaction.\r\n  if (!(\r\n    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||\r\n    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))\r\n  )) {\r\n    return false;\r\n  }\r\n\r\n  // Now that we know we're comparing apples-to-apples, the\r\n  // comparison is a simple numeric one.\r\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\r\n    return false;\r\n  }\r\n\r\n  // Finally the nLockTime feature can be disabled and thus\r\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\r\n  // finalized by setting nSequence to maxint. The\r\n  // transaction would be allowed into the blockchain, making\r\n  // the opcode ineffective.\r\n  //\r\n  // Testing if this vin is not final is sufficient to\r\n  // prevent this condition. Alternatively we could test all\r\n  // inputs, but testing just this input minimizes the data\r\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\r\n  if (!this.tx.inputs[this.nin].isFinal()) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n\r\n/**\r\n * Checks a sequence parameter with the transaction's sequence.\r\n * @param {BN} nSequence the sequence read from the script\r\n * @return {boolean} true if the transaction's sequence is less than or equal to\r\n *                   the transaction's sequence \r\n */\r\nInterpreter.prototype.checkSequence = function(nSequence) {\r\n\r\n  // Relative lock times are supported by comparing the passed in operand to\r\n  // the sequence number of the input.\r\n  var txToSequence = this.tx.inputs[this.nin].sequenceNumber;\r\n\r\n  // Fail if the transaction's version number is not set high enough to\r\n  // trigger BIP 68 rules.\r\n  if (this.tx.version < 2) {\r\n    return false;\r\n  }\r\n\r\n  // Sequence numbers with their most significant bit set are not consensus\r\n  // constrained. Testing that the transaction's sequence number do not have\r\n  // this bit set prevents using this property to get around a\r\n  // CHECKSEQUENCEVERIFY check.\r\n  if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\r\n    return false;\r\n  }\r\n\r\n  // Mask off any bits that do not have consensus-enforced meaning before\r\n  // doing the integer comparisons\r\n  var nLockTimeMask =\r\n      Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\r\n  var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\r\n  var nSequenceMasked = nSequence.and(nLockTimeMask);\r\n\r\n  // There are two kinds of nSequence: lock-by-blockheight and\r\n  // lock-by-blocktime, distinguished by whether nSequenceMasked <\r\n  // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\r\n  //\r\n  // We want to compare apples to apples, so fail the script unless the type\r\n  // of nSequenceMasked being tested is the same as the nSequenceMasked in the\r\n  // transaction.\r\n  var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\r\n  \r\n  if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)  &&\r\n          nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||\r\n        (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&\r\n          nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {\r\n    return false;\r\n  }\r\n\r\n  // Now that we know we're comparing apples-to-apples, the comparison is a\r\n  // simple numeric one.\r\n  return nSequenceMasked.lte(txToSequenceMasked)\r\n}\r\n\r\n\r\nInterpreter.computeTapleafHash = function(leafVersion, scriptBuf) {\r\n  const tagWriter = TaggedHash.TAPLEAF;\r\n  tagWriter.writeUInt8(leafVersion);\r\n  tagWriter.writeVarintNum(scriptBuf.length);\r\n  tagWriter.write(scriptBuf);\r\n  return tagWriter.finalize();\r\n};\r\n\r\n\r\nInterpreter.computeTaprootMerkleRoot = function(control, tapleafHash) {\r\n  const pathLen = (control.length - Interpreter.TAPROOT_CONTROL_BASE_SIZE) / Interpreter.TAPROOT_CONTROL_NODE_SIZE;\r\n  let k = tapleafHash;\r\n  for (let i = 0; i < pathLen; ++i) {\r\n    const tagWriter = TaggedHash.TAPBRANCH;\r\n    const start = Interpreter.TAPROOT_CONTROL_BASE_SIZE + Interpreter.TAPROOT_CONTROL_NODE_SIZE * i;\r\n    const node = control.slice(start, start + Interpreter.TAPROOT_CONTROL_NODE_SIZE);\r\n    if (Buffer.compare(k, node) === -1) {\r\n      tagWriter.write(k);\r\n      tagWriter.write(node);\r\n    } else {\r\n      tagWriter.write(node);\r\n      tagWriter.write(k);\r\n    }\r\n    k = tagWriter.finalize();\r\n  }\r\n  return k;\r\n};\r\n\r\n\r\nInterpreter.verifyTaprootCommitment = function(control, program, tapleafHash) {\r\n  $.checkArgument(control.length >= Interpreter.TAPROOT_CONTROL_BASE_SIZE, 'control too short');\r\n  $.checkArgument(program.length >= 32, 'program is too short');\r\n\r\n  try {\r\n    //! The internal pubkey (x-only, so no Y coordinate parity).\r\n    const p = PublicKey.fromX(false, control.slice(1, Interpreter.TAPROOT_CONTROL_BASE_SIZE));\r\n    //! The output pubkey (taken from the scriptPubKey).\r\n    const q = PublicKey.fromX(false, program);\r\n    // Compute the Merkle root from the leaf and the provided path.\r\n    const merkleRoot = Interpreter.computeTaprootMerkleRoot(control, tapleafHash);\r\n    // Verify that the output pubkey matches the tweaked internal pubkey, after correcting for parity.\r\n    return q.checkTapTweak(p, merkleRoot, control);\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n};\r\n\r\n\r\n/** \r\n * Based on the inner loop of bitcoind's EvalScript function\r\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\r\n */\r\nInterpreter.prototype.step = function() {\r\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\r\n\r\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\r\n  var fExec = (this.vfExec.indexOf(false) === -1);\r\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\r\n  var sig, pubkey;\r\n  var fValue, fSuccess;\r\n  this.execdata = this.execdata || {};\r\n  if (!this.execdata.codeseparatorPosInit) {\r\n    this.execdata.codeseparatorPos = new BN(0xFFFFFFFF);\r\n    this.execdata.codeseparatorPosInit = true;\r\n  }\r\n\r\n  // Read instruction\r\n  var chunk = this.script.chunks[this.pc];\r\n  this.pc++;\r\n  var opcodenum = chunk.opcodenum;\r\n  if (_.isUndefined(opcodenum)) {\r\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\r\n    return false;\r\n  }\r\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\r\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\r\n    return false;\r\n  }\r\n\r\n  if (this.sigversion === Signature.Version.BASE || this.sigversion === Signature.Version.WITNESS_V0) {\r\n    // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\r\n    if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {\r\n      this.errstr = 'SCRIPT_ERR_OP_COUNT';\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\n  if (opcodenum === Opcode.OP_CAT ||\r\n    opcodenum === Opcode.OP_SUBSTR ||\r\n    opcodenum === Opcode.OP_LEFT ||\r\n    opcodenum === Opcode.OP_RIGHT ||\r\n    opcodenum === Opcode.OP_INVERT ||\r\n    opcodenum === Opcode.OP_AND ||\r\n    opcodenum === Opcode.OP_OR ||\r\n    opcodenum === Opcode.OP_XOR ||\r\n    opcodenum === Opcode.OP_2MUL ||\r\n    opcodenum === Opcode.OP_2DIV ||\r\n    opcodenum === Opcode.OP_MUL ||\r\n    opcodenum === Opcode.OP_DIV ||\r\n    opcodenum === Opcode.OP_MOD ||\r\n    opcodenum === Opcode.OP_LSHIFT ||\r\n    opcodenum === Opcode.OP_RSHIFT) {\r\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\r\n    return false;\r\n  }\r\n\r\n  // With SCRIPT_VERIFY_CONST_SCRIPTCODE, OP_CODESEPARATOR in non-segwit script is rejected even in an unexecuted branch\r\n  if (opcodenum == Opcode.OP_CODESEPARATOR && this.sigversion === Signature.Version.BASE && (this.flags & Interpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE)) {\r\n    this.errstr = 'SCRIPT_ERR_OP_CODESEPARATOR';\r\n    return false;\r\n  }\r\n\r\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\r\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\r\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\r\n      return false;\r\n    }\r\n    if (!chunk.buf) {\r\n      this.stack.push(Interpreter.false);\r\n    } else if (chunk.len !== chunk.buf.length) {\r\n      throw new Error('Length of push value not equal to length of data');\r\n    } else {\r\n      this.stack.push(chunk.buf);\r\n    }\r\n  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {\r\n    switch (opcodenum) {\r\n      // Push value\r\n      case Opcode.OP_1NEGATE:\r\n      case Opcode.OP_1:\r\n      case Opcode.OP_2:\r\n      case Opcode.OP_3:\r\n      case Opcode.OP_4:\r\n      case Opcode.OP_5:\r\n      case Opcode.OP_6:\r\n      case Opcode.OP_7:\r\n      case Opcode.OP_8:\r\n      case Opcode.OP_9:\r\n      case Opcode.OP_10:\r\n      case Opcode.OP_11:\r\n      case Opcode.OP_12:\r\n      case Opcode.OP_13:\r\n      case Opcode.OP_14:\r\n      case Opcode.OP_15:\r\n      case Opcode.OP_16:\r\n        {\r\n          // ( -- value)\r\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\r\n          n = opcodenum - (Opcode.OP_1 - 1);\r\n          buf = new BN(n).toScriptNumBuffer();\r\n          this.stack.push(buf);\r\n          // The result of these opcodes should always be the minimal way to push the data\r\n          // they push, so no need for a CheckMinimalPush here.\r\n        }\r\n        break;\r\n\r\n\r\n        //\r\n        // Control\r\n        //\r\n      case Opcode.OP_NOP:\r\n        break;\r\n\r\n      case Opcode.OP_NOP2:\r\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\r\n\r\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\r\n          // not enabled; treat as a NOP2\r\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\r\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\r\n            return false;\r\n          }\r\n          break;\r\n        }\r\n\r\n        if (this.stack.length < 1) {\r\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n          return false;\r\n        }\r\n\r\n        // Note that elsewhere numeric opcodes are limited to\r\n        // operands in the range -2**31+1 to 2**31-1, however it is\r\n        // legal for opcodes to produce results exceeding that\r\n        // range. This limitation is implemented by CScriptNum's\r\n        // default 4-byte limit.\r\n        //\r\n        // If we kept to that limit we'd have a year 2038 problem,\r\n        // even though the nLockTime field in transactions\r\n        // themselves is uint32 which only becomes meaningless\r\n        // after the year 2106.\r\n        //\r\n        // Thus as a special case we tell CScriptNum to accept up\r\n        // to 5-byte bignums, which are good until 2**39-1, well\r\n        // beyond the 2**32-1 limit of the nLockTime field itself.\r\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\r\n\r\n        // In the rare event that the argument may be < 0 due to\r\n        // some arithmetic being done first, you can always use\r\n        // 0 MAX CHECKLOCKTIMEVERIFY.\r\n        if (nLockTime.lt(new BN(0))) {\r\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\r\n          return false;\r\n        }\r\n\r\n        // Actually compare the specified lock time with the transaction.\r\n        if (!this.checkLockTime(nLockTime)) {\r\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\r\n          return false;\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_NOP3:\r\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\r\n\r\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\r\n          // not enabled; treat as a NOP3\r\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\r\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\r\n            return false;\r\n          }\r\n          break;\r\n        }\r\n\r\n        if (this.stack.length < 1) {\r\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n          return false;\r\n        }\r\n\r\n\r\n        // nSequence, like nLockTime, is a 32-bit unsigned\r\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\r\n        // regarding 5-byte numeric operands.\r\n\r\n        var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\r\n\r\n\r\n        // In the rare event that the argument may be < 0 due to\r\n        // some arithmetic being done first, you can always use\r\n        // 0 MAX CHECKSEQUENCEVERIFY.\r\n        if (nSequence.lt(new BN(0))) {\r\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\r\n          return false;\r\n        }\r\n\r\n        // To provide for future soft-fork extensibility, if the\r\n        // operand has the disabled lock-time flag set,\r\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\r\n        if ((nSequence &\r\n          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\r\n          break;\r\n        }\r\n\r\n        // Actually compare the specified lock time with the transaction.\r\n        if (!this.checkSequence(nSequence)) {\r\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\r\n          return false;\r\n        }\r\n        break;\r\n\r\n\r\n\r\n      case Opcode.OP_NOP1:\r\n      case Opcode.OP_NOP4:\r\n      case Opcode.OP_NOP5:\r\n      case Opcode.OP_NOP6:\r\n      case Opcode.OP_NOP7:\r\n      case Opcode.OP_NOP8:\r\n      case Opcode.OP_NOP9:\r\n      case Opcode.OP_NOP10:\r\n        {\r\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\r\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\r\n            return false;\r\n          }\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_IF:\r\n      case Opcode.OP_NOTIF:\r\n        {\r\n          // <expression> if [statements] [else [statements]] endif\r\n          // bool fValue = false;\r\n          fValue = false;\r\n          if (fExec) {\r\n            if (this.stack.length < 1) {\r\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\r\n              return false;\r\n            }\r\n\r\n            buf = this.stack[this.stack.length - 1];\r\n\r\n            // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.\r\n            if (this.sigversion === Signature.Version.TAPSCRIPT) {\r\n              // The input argument to the OP_IF and OP_NOTIF opcodes must be either\r\n              // exactly 0 (the empty vector) or exactly 1 (the one-byte vector with value 1).\r\n              if (buf.length > 1 || (buf.length === 1 && buf[0] !== 1)) {\r\n                this.errstr = 'SCRIPT_ERR_TAPSCRIPT_MINIMALIF';\r\n                return false;\r\n              }\r\n            }\r\n            // Under witness v0 rules it is only a policy rule, enabled through SCRIPT_VERIFY_MINIMALIF.\r\n            if (this.sigversion === Signature.Version.WITNESS_V0 && (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF)) {\r\n              buf = this.stack[this.stack.length - 1];\r\n              if (buf.length > 1) {\r\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\r\n                return false;\r\n              }\r\n              if (buf.length == 1 && buf[0]!=1) {\r\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\r\n                return false;\r\n              }\r\n            }\r\n            fValue = Interpreter.castToBool(buf);\r\n            if (opcodenum === Opcode.OP_NOTIF) {\r\n              fValue = !fValue;\r\n            }\r\n            this.stack.pop();\r\n          }\r\n          this.vfExec.push(fValue);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_ELSE:\r\n        {\r\n          if (this.vfExec.length === 0) {\r\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\r\n            return false;\r\n          }\r\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_ENDIF:\r\n        {\r\n          if (this.vfExec.length === 0) {\r\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\r\n            return false;\r\n          }\r\n          this.vfExec.pop();\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_VERIFY:\r\n        {\r\n          // (true -- ) or\r\n          // (false -- false) and return\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf = this.stack[this.stack.length - 1];\r\n          fValue = Interpreter.castToBool(buf);\r\n          if (fValue) {\r\n            this.stack.pop();\r\n          } else {\r\n            this.errstr = 'SCRIPT_ERR_VERIFY';\r\n            return false;\r\n          }\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_RETURN:\r\n        {\r\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\r\n          return false;\r\n        }\r\n        break;\r\n\r\n\r\n        //\r\n        // Stack ops\r\n        //\r\n      case Opcode.OP_TOALTSTACK:\r\n        {\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          this.altstack.push(this.stack.pop());\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_FROMALTSTACK:\r\n        {\r\n          if (this.altstack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\r\n            return false;\r\n          }\r\n          this.stack.push(this.altstack.pop());\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_2DROP:\r\n        {\r\n          // (x1 x2 -- )\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          this.stack.pop();\r\n          this.stack.pop();\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_2DUP:\r\n        {\r\n          // (x1 x2 -- x1 x2 x1 x2)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf1 = this.stack[this.stack.length - 2];\r\n          buf2 = this.stack[this.stack.length - 1];\r\n          this.stack.push(buf1);\r\n          this.stack.push(buf2);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_3DUP:\r\n        {\r\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\r\n          if (this.stack.length < 3) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf1 = this.stack[this.stack.length - 3];\r\n          buf2 = this.stack[this.stack.length - 2];\r\n          var buf3 = this.stack[this.stack.length - 1];\r\n          this.stack.push(buf1);\r\n          this.stack.push(buf2);\r\n          this.stack.push(buf3);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_2OVER:\r\n        {\r\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\r\n          if (this.stack.length < 4) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf1 = this.stack[this.stack.length - 4];\r\n          buf2 = this.stack[this.stack.length - 3];\r\n          this.stack.push(buf1);\r\n          this.stack.push(buf2);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_2ROT:\r\n        {\r\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\r\n          if (this.stack.length < 6) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          spliced = this.stack.splice(this.stack.length - 6, 2);\r\n          this.stack.push(spliced[0]);\r\n          this.stack.push(spliced[1]);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_2SWAP:\r\n        {\r\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\r\n          if (this.stack.length < 4) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          spliced = this.stack.splice(this.stack.length - 4, 2);\r\n          this.stack.push(spliced[0]);\r\n          this.stack.push(spliced[1]);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_IFDUP:\r\n        {\r\n          // (x - 0 | x x)\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf = this.stack[this.stack.length - 1];\r\n          fValue = Interpreter.castToBool(buf);\r\n          if (fValue) {\r\n            this.stack.push(buf);\r\n          }\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_DEPTH:\r\n        {\r\n          // -- stacksize\r\n          buf = new BN(this.stack.length).toScriptNumBuffer();\r\n          this.stack.push(buf);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_DROP:\r\n        {\r\n          // (x -- )\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          this.stack.pop();\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_DUP:\r\n        {\r\n          // (x -- x x)\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          this.stack.push(this.stack[this.stack.length - 1]);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_NIP:\r\n        {\r\n          // (x1 x2 -- x2)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          this.stack.splice(this.stack.length - 2, 1);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_OVER:\r\n        {\r\n          // (x1 x2 -- x1 x2 x1)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          this.stack.push(this.stack[this.stack.length - 2]);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_PICK:\r\n      case Opcode.OP_ROLL:\r\n        {\r\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\r\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf = this.stack[this.stack.length - 1];\r\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\r\n          n = bn.toNumber();\r\n          this.stack.pop();\r\n          if (n < 0 || n >= this.stack.length) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf = this.stack[this.stack.length - n - 1];\r\n          if (opcodenum === Opcode.OP_ROLL) {\r\n            this.stack.splice(this.stack.length - n - 1, 1);\r\n          }\r\n          this.stack.push(buf);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_ROT:\r\n        {\r\n          // (x1 x2 x3 -- x2 x3 x1)\r\n          //  x2 x1 x3  after first swap\r\n          //  x2 x3 x1  after second swap\r\n          if (this.stack.length < 3) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          x1 = this.stack[this.stack.length - 3];\r\n          x2 = this.stack[this.stack.length - 2];\r\n          var x3 = this.stack[this.stack.length - 1];\r\n          this.stack[this.stack.length - 3] = x2;\r\n          this.stack[this.stack.length - 2] = x3;\r\n          this.stack[this.stack.length - 1] = x1;\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_SWAP:\r\n        {\r\n          // (x1 x2 -- x2 x1)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          x1 = this.stack[this.stack.length - 2];\r\n          x2 = this.stack[this.stack.length - 1];\r\n          this.stack[this.stack.length - 2] = x2;\r\n          this.stack[this.stack.length - 1] = x1;\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_TUCK:\r\n        {\r\n          // (x1 x2 -- x2 x1 x2)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\r\n        }\r\n        break;\r\n\r\n\r\n      case Opcode.OP_SIZE:\r\n        {\r\n          // (in -- in size)\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          bn = new BN(this.stack[this.stack.length - 1].length);\r\n          this.stack.push(bn.toScriptNumBuffer());\r\n        }\r\n        break;\r\n\r\n\r\n        //\r\n        // Bitwise logic\r\n        //\r\n      case Opcode.OP_EQUAL:\r\n      case Opcode.OP_EQUALVERIFY:\r\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\r\n        {\r\n          // (x1 x2 - bool)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf1 = this.stack[this.stack.length - 2];\r\n          buf2 = this.stack[this.stack.length - 1];\r\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\r\n          this.stack.pop();\r\n          this.stack.pop();\r\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\r\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\r\n            if (fEqual) {\r\n              this.stack.pop();\r\n            } else {\r\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n\r\n\r\n        //\r\n        // Numeric\r\n        //\r\n      case Opcode.OP_1ADD:\r\n      case Opcode.OP_1SUB:\r\n      case Opcode.OP_NEGATE:\r\n      case Opcode.OP_ABS:\r\n      case Opcode.OP_NOT:\r\n      case Opcode.OP_0NOTEQUAL:\r\n        {\r\n          // (in -- out)\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf = this.stack[this.stack.length - 1];\r\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\r\n          switch (opcodenum) {\r\n            case Opcode.OP_1ADD:\r\n              bn = bn.add(BN.One);\r\n              break;\r\n            case Opcode.OP_1SUB:\r\n              bn = bn.sub(BN.One);\r\n              break;\r\n            case Opcode.OP_NEGATE:\r\n              bn = bn.neg();\r\n              break;\r\n            case Opcode.OP_ABS:\r\n              if (bn.cmp(BN.Zero) < 0) {\r\n                bn = bn.neg();\r\n              }\r\n              break;\r\n            case Opcode.OP_NOT:\r\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\r\n              break;\r\n            case Opcode.OP_0NOTEQUAL:\r\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\r\n              break;\r\n              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\r\n          }\r\n          this.stack.pop();\r\n          this.stack.push(bn.toScriptNumBuffer());\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_ADD:\r\n      case Opcode.OP_SUB:\r\n      case Opcode.OP_BOOLAND:\r\n      case Opcode.OP_BOOLOR:\r\n      case Opcode.OP_NUMEQUAL:\r\n      case Opcode.OP_NUMEQUALVERIFY:\r\n      case Opcode.OP_NUMNOTEQUAL:\r\n      case Opcode.OP_LESSTHAN:\r\n      case Opcode.OP_GREATERTHAN:\r\n      case Opcode.OP_LESSTHANOREQUAL:\r\n      case Opcode.OP_GREATERTHANOREQUAL:\r\n      case Opcode.OP_MIN:\r\n      case Opcode.OP_MAX:\r\n        {\r\n          // (x1 x2 -- out)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\r\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\r\n          bn = new BN(0);\r\n\r\n          switch (opcodenum) {\r\n            case Opcode.OP_ADD:\r\n              bn = bn1.add(bn2);\r\n              break;\r\n\r\n            case Opcode.OP_SUB:\r\n              bn = bn1.sub(bn2);\r\n              break;\r\n\r\n              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\r\n            case Opcode.OP_BOOLAND:\r\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);\r\n              break;\r\n              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\r\n            case Opcode.OP_BOOLOR:\r\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);\r\n              break;\r\n              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\r\n            case Opcode.OP_NUMEQUAL:\r\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\r\n              break;\r\n              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\r\n            case Opcode.OP_NUMEQUALVERIFY:\r\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\r\n              break;\r\n              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\r\n            case Opcode.OP_NUMNOTEQUAL:\r\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\r\n              break;\r\n              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\r\n            case Opcode.OP_LESSTHAN:\r\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\r\n              break;\r\n              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\r\n            case Opcode.OP_GREATERTHAN:\r\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\r\n              break;\r\n              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\r\n            case Opcode.OP_LESSTHANOREQUAL:\r\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\r\n              break;\r\n              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\r\n            case Opcode.OP_GREATERTHANOREQUAL:\r\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\r\n              break;\r\n            case Opcode.OP_MIN:\r\n              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);\r\n              break;\r\n            case Opcode.OP_MAX:\r\n              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);\r\n              break;\r\n              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\r\n          }\r\n          this.stack.pop();\r\n          this.stack.pop();\r\n          this.stack.push(bn.toScriptNumBuffer());\r\n\r\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\r\n            // if (CastToBool(stacktop(-1)))\r\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\r\n              this.stack.pop();\r\n            } else {\r\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_WITHIN:\r\n        {\r\n          // (x min max -- out)\r\n          if (this.stack.length < 3) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\r\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\r\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\r\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\r\n          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);\r\n          this.stack.pop();\r\n          this.stack.pop();\r\n          this.stack.pop();\r\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\r\n        }\r\n        break;\r\n\r\n\r\n        //\r\n        // Crypto\r\n        //\r\n      case Opcode.OP_RIPEMD160:\r\n      case Opcode.OP_SHA1:\r\n      case Opcode.OP_SHA256:\r\n      case Opcode.OP_HASH160:\r\n      case Opcode.OP_HASH256:\r\n        {\r\n          // (in -- hash)\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          buf = this.stack[this.stack.length - 1];\r\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\r\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\r\n          var bufHash;\r\n          if (opcodenum === Opcode.OP_RIPEMD160) {\r\n            bufHash = Hash.ripemd160(buf);\r\n          } else if (opcodenum === Opcode.OP_SHA1) {\r\n            bufHash = Hash.sha1(buf);\r\n          } else if (opcodenum === Opcode.OP_SHA256) {\r\n            bufHash = Hash.sha256(buf);\r\n          } else if (opcodenum === Opcode.OP_HASH160) {\r\n            bufHash = Hash.sha256ripemd160(buf);\r\n          } else if (opcodenum === Opcode.OP_HASH256) {\r\n            bufHash = Hash.sha256sha256(buf);\r\n          }\r\n          this.stack.pop();\r\n          this.stack.push(bufHash);\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_CODESEPARATOR:\r\n        {\r\n          // Hash starts after the code separator\r\n          this.pbegincodehash = this.pc;\r\n          this.execdata.codeseparatorPos = this.pc - 1;\r\n        }\r\n        break;\r\n\r\n      case Opcode.OP_CHECKSIG:\r\n      case Opcode.OP_CHECKSIGVERIFY:\r\n        {\r\n          // (sig pubkey -- bool)\r\n          if (this.stack.length < 2) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n\r\n          bufSig = this.stack[this.stack.length - 2];\r\n          bufPubkey = this.stack[this.stack.length - 1];\r\n\r\n          const { success: fSuccess, result } = this._evalCheckSig(bufSig, bufPubkey);\r\n          if (!result) {\r\n            return false;\r\n          }\r\n\r\n          this.stack.pop();\r\n          this.stack.pop();\r\n\r\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\r\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\r\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\r\n            if (fSuccess) {\r\n              this.stack.pop();\r\n            } else {\r\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case Opcode.OP_CHECKSIGADD:\r\n        {\r\n          // OP_CHECKSIGADD is only available in Tapscript\r\n          if (this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0) {\r\n            this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\r\n            return false;\r\n          }\r\n\r\n          // (sig num pubkey -- num)\r\n          if (this.stack.length < 3) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n\r\n          let sig = this.stack[this.stack.length - 3];\r\n          let num = this.stack[this.stack.length - 2];\r\n          let pubkey = this.stack[this.stack.length - 1];\r\n\r\n          num = BN.fromScriptNumBuffer(num, fRequireMinimal);\r\n\r\n          const { success, result } = this._evalCheckSig(sig, pubkey);\r\n          if (!result) {\r\n            return false;\r\n          }\r\n\r\n          this.stack.pop();\r\n          this.stack.pop();\r\n          this.stack.pop();\r\n          this.stack.push(num.addn(success ? 1 : 0).toScriptNumBuffer());\r\n        }\r\n        break;\r\n      case Opcode.OP_CHECKMULTISIG:\r\n      case Opcode.OP_CHECKMULTISIGVERIFY:\r\n        {\r\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\r\n\r\n          var i = 1;\r\n          if (this.stack.length < i) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n\r\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\r\n          if (nKeysCount < 0 || nKeysCount > 20) {\r\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\r\n            return false;\r\n          }\r\n          this.nOpCount += nKeysCount;\r\n          if (this.nOpCount > 201) {\r\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\r\n            return false;\r\n          }\r\n          // int ikey = ++i;\r\n          var ikey = ++i;\r\n          i += nKeysCount;\r\n\r\n          // ikey2 is the position of last non-signature item in\r\n          // the stack. Top stack item = 1. With\r\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\r\n          // operation fails.\r\n          var ikey2 = nKeysCount + 2;\r\n\r\n          if (this.stack.length < i) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n\r\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\r\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\r\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\r\n            return false;\r\n          }\r\n          // int isig = ++i;\r\n          var isig = ++i;\r\n          i += nSigsCount;\r\n          if (this.stack.length < i) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n\r\n          // Subset of script starting at the most recent codeseparator\r\n          subscript = new Script().set({\r\n            chunks: this.script.chunks.slice(this.pbegincodehash)\r\n          });\r\n\r\n          // Drop the signatures, since there's no way for a signature to sign itself\r\n          for (var k = 0; k < nSigsCount; k++) {\r\n            bufSig = this.stack[this.stack.length - isig - k];\r\n            subscript.findAndDelete(new Script().add(bufSig));\r\n          }\r\n\r\n          fSuccess = true;\r\n          while (fSuccess && nSigsCount > 0) {\r\n            // valtype& vchSig  = stacktop(-isig);\r\n            bufSig = this.stack[this.stack.length - isig];\r\n            // valtype& vchPubKey = stacktop(-ikey);\r\n            bufPubkey = this.stack[this.stack.length - ikey];\r\n\r\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\r\n              return false;\r\n            }\r\n\r\n            var fOk;\r\n            try {\r\n              sig = Signature.fromTxFormat(bufSig);\r\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\r\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis, this.execdata);\r\n            } catch (e) {\r\n              //invalid sig or pubkey\r\n              fOk = false;\r\n            }\r\n\r\n            if (fOk) {\r\n              isig++;\r\n              nSigsCount--;\r\n            }\r\n            ikey++;\r\n            nKeysCount--;\r\n\r\n            // If there are more signatures left than keys left,\r\n            // then too many signatures have failed\r\n            if (nSigsCount > nKeysCount) {\r\n              fSuccess = false;\r\n            }\r\n          }\r\n\r\n\r\n          // Clean up stack of actual arguments\r\n          while (i-- > 1) {\r\n            if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\r\n              !ikey2 && this.stack[this.stack.length - 1].length) {\r\n\r\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\r\n              return false;\r\n            }\r\n\r\n            if (ikey2 > 0) {\r\n              ikey2--;\r\n            }\r\n\r\n            this.stack.pop();\r\n          }\r\n\r\n          // A bug causes CHECKMULTISIG to consume one extra argument\r\n          // whose contents were not checked in any way.\r\n          //\r\n          // Unfortunately this is a potential source of mutability,\r\n          // so optionally verify it is exactly equal to zero prior\r\n          // to removing it from the stack.\r\n          if (this.stack.length < 1) {\r\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\r\n            return false;\r\n          }\r\n          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {\r\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\r\n            return false;\r\n          }\r\n          this.stack.pop();\r\n\r\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\r\n\r\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\r\n            if (fSuccess) {\r\n              this.stack.pop();\r\n            } else {\r\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n\r\n      default:\r\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\r\n        return false;\r\n    }\r\n  }\r\n\r\n  // Size limits\r\n  if (this.stack.length + this.altstack.length > Interpreter.MAX_STACK_SIZE) {\r\n    this.errstr = 'SCRIPT_ERR_STACK_SIZE';\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3NjcmlwdC9pbnRlcnByZXRlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFVBQVUsbUJBQU8sQ0FBQyw0REFBUTtBQUMxQjtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxxREFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsK0NBQVc7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHFEQUFjO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyx5REFBZ0I7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsbUVBQXFCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLHFEQUFjO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMsdUZBQStCO0FBQzlELHVCQUF1QixtQkFBTyxDQUFDLHVGQUErQjtBQUM5RCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBMEI7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMscUVBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLCtEQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL3NjcmlwdC9pbnRlcnByZXRlci5qcz9lYjdlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuXHJcbmNvbnN0IFNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XHJcbmNvbnN0IE9wY29kZSA9IHJlcXVpcmUoJy4uL29wY29kZScpO1xyXG5jb25zdCBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xyXG5jb25zdCBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcclxuY29uc3QgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xyXG5jb25zdCBQdWJsaWNLZXkgPSByZXF1aXJlKCcuLi9wdWJsaWNrZXknKTtcclxuY29uc3QgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG5jb25zdCBTaWdoYXNoV2l0bmVzcyA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uL3NpZ2hhc2h3aXRuZXNzJyk7XHJcbmNvbnN0IFNpZ2hhc2hTY2hub3JyID0gcmVxdWlyZSgnLi4vdHJhbnNhY3Rpb24vc2lnaGFzaHNjaG5vcnInKTtcclxuY29uc3QgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XHJcbmNvbnN0IFRhZ2dlZEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vdGFnZ2VkaGFzaCcpO1xyXG5cclxuLyoqXHJcbiAqIEJpdGNvaW4gdHJhbnNhY3Rpb25zIGNvbnRhaW4gc2NyaXB0cy4gRWFjaCBpbnB1dCBoYXMgYSBzY3JpcHQgY2FsbGVkIHRoZVxyXG4gKiBzY3JpcHRTaWcsIGFuZCBlYWNoIG91dHB1dCBoYXMgYSBzY3JpcHQgY2FsbGVkIHRoZSBzY3JpcHRQdWJrZXkuIFRvIHZhbGlkYXRlXHJcbiAqIGFuIGlucHV0LCB0aGUgaW5wdXQncyBzY3JpcHQgaXMgY29uY2F0ZW5hdGVkIHdpdGggdGhlIHJlZmVyZW5jZWQgb3V0cHV0IHNjcmlwdCxcclxuICogYW5kIHRoZSByZXN1bHQgaXMgZXhlY3V0ZWQuIElmIGF0IHRoZSBlbmQgb2YgZXhlY3V0aW9uIHRoZSBzdGFjayBjb250YWlucyBhXHJcbiAqIFwidHJ1ZVwiIHZhbHVlLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyB2YWxpZC5cclxuICpcclxuICogVGhlIHByaW1hcnkgd2F5IHRvIHVzZSB0aGlzIGNsYXNzIGlzIHZpYSB0aGUgdmVyaWZ5IGZ1bmN0aW9uLlxyXG4gKiBlLmcuLCBJbnRlcnByZXRlcigpLnZlcmlmeSggLi4uICk7XHJcbiAqL1xyXG52YXIgSW50ZXJwcmV0ZXIgPSBmdW5jdGlvbiBJbnRlcnByZXRlcihvYmopIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW50ZXJwcmV0ZXIpKSB7XHJcbiAgICByZXR1cm4gbmV3IEludGVycHJldGVyKG9iaik7XHJcbiAgfVxyXG4gIGlmIChvYmopIHtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgdGhpcy5zZXQob2JqKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbkludGVycHJldGVyLnByb3RvdHlwZS52ZXJpZnlXaXRuZXNzUHJvZ3JhbSA9IGZ1bmN0aW9uKHZlcnNpb24sIHByb2dyYW0sIHdpdG5lc3MsIHNhdG9zaGlzLCBmbGFncywgaXNQMlNIKSB7XHJcblxyXG4gIHZhciBzY3JpcHRQdWJLZXkgPSBuZXcgU2NyaXB0KCk7XHJcbiAgdmFyIHN0YWNrID0gW107XHJcblxyXG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XHJcbiAgICBpZiAocHJvZ3JhbS5sZW5ndGggPT09IEludGVycHJldGVyLldJVE5FU1NfVjBfU0NSSVBUSEFTSF9TSVpFKSB7XHJcbiAgICAgIGlmICh3aXRuZXNzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19QUk9HUkFNX1dJVE5FU1NfRU1QVFknO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNjcmlwdFB1YktleUJ1ZmZlciA9IHdpdG5lc3Nbd2l0bmVzcy5sZW5ndGggLSAxXTtcclxuICAgICAgc2NyaXB0UHViS2V5ID0gbmV3IFNjcmlwdChzY3JpcHRQdWJLZXlCdWZmZXIpO1xyXG4gICAgICB2YXIgaGFzaCA9IEhhc2guc2hhMjU2KHNjcmlwdFB1YktleUJ1ZmZlcik7XHJcbiAgICAgIGlmIChoYXNoLnRvU3RyaW5nKCdoZXgnKSAhPT0gcHJvZ3JhbS50b1N0cmluZygnaGV4JykpIHtcclxuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfUFJPR1JBTV9NSVNNQVRDSCc7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdGFjayA9IHdpdG5lc3Muc2xpY2UoMCwgLTEpO1xyXG4gICAgICByZXR1cm4gdGhpcy5leGVjdXRlV2l0bmVzc1NjcmlwdChzY3JpcHRQdWJLZXksIHN0YWNrLCBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwLCBzYXRvc2hpcywgZmxhZ3MpO1xyXG4gICAgfSBlbHNlIGlmIChwcm9ncmFtLmxlbmd0aCA9PT0gSW50ZXJwcmV0ZXIuV0lUTkVTU19WMF9LRVlIQVNIX1NJWkUpIHtcclxuICAgICAgaWYgKHdpdG5lc3MubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX1BST0dSQU1fTUlTTUFUQ0gnO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2NyaXB0UHViS2V5LmFkZChPcGNvZGUuT1BfRFVQKTtcclxuICAgICAgc2NyaXB0UHViS2V5LmFkZChPcGNvZGUuT1BfSEFTSDE2MCk7XHJcbiAgICAgIHNjcmlwdFB1YktleS5hZGQocHJvZ3JhbSk7XHJcbiAgICAgIHNjcmlwdFB1YktleS5hZGQoT3Bjb2RlLk9QX0VRVUFMVkVSSUZZKTtcclxuICAgICAgc2NyaXB0UHViS2V5LmFkZChPcGNvZGUuT1BfQ0hFQ0tTSUcpO1xyXG5cclxuICAgICAgc3RhY2sgPSB3aXRuZXNzO1xyXG4gICAgICByZXR1cm4gdGhpcy5leGVjdXRlV2l0bmVzc1NjcmlwdChzY3JpcHRQdWJLZXksIHN0YWNrLCBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwLCBzYXRvc2hpcywgZmxhZ3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX1BST0dSQU1fV1JPTkdfTEVOR1RIJztcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMSAmJiBwcm9ncmFtLmxlbmd0aCA9PSBJbnRlcnByZXRlci5XSVRORVNTX1YxX1RBUFJPT1RfU0laRSAmJiAhaXNQMlNIKSB7XHJcbiAgICBjb25zdCBleGVjZGF0YSA9IHsgYW5uZXhQcmVzZW50OiBmYWxzZSB9O1xyXG4gICAgLy8gQklQMzQxIFRhcHJvb3Q6IDMyLWJ5dGUgbm9uLVAyU0ggd2l0bmVzcyB2MSBwcm9ncmFtICh3aGljaCBlbmNvZGVzIGEgUDJDLXR3ZWFrZWQgcHVia2V5KVxyXG4gICAgaWYgKCEoZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1RBUFJPT1QpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgc3RhY2sgPSBBcnJheS5mcm9tKHdpdG5lc3MpO1xyXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19QUk9HUkFNX1dJVE5FU1NfRU1QVFknO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhY2subGVuZ3RoID49IDIgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ubGVuZ3RoICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdWzBdID09PSBTY3JpcHQuQU5ORVhfVEFHKSB7XHJcbiAgICAgIC8vIERyb3AgYW5uZXggKHRoaXMgaXMgbm9uLXN0YW5kYXJkOyBzZWUgSXNXaXRuZXNzU3RhbmRhcmQpXHJcbiAgICAgIGNvbnN0IGFubmV4ID0gc3RhY2sucG9wKCk7XHJcbiAgICAgIGNvbnN0IGFubmV4V3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICBhbm5leFdyaXRlci53cml0ZVZhcmludE51bShhbm5leC5sZW5ndGgpO1xyXG4gICAgICBhbm5leFdyaXRlci53cml0ZShhbm5leCk7XHJcbiAgICAgIGV4ZWNkYXRhLmFubmV4SGFzaCA9IEhhc2guc2hhMjU2KGFubmV4V3JpdGVyLnRvQnVmZmVyKCkpO1xyXG4gICAgICBleGVjZGF0YS5hbm5leFByZXNlbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZXhlY2RhdGEuYW5uZXhJbml0ID0gdHJ1ZTtcclxuICAgIGlmIChzdGFjay5sZW5ndGggPT09IDEpIHtcclxuICAgICAgLy8gS2V5IHBhdGggc3BlbmRpbmcgKHN0YWNrIHNpemUgaXMgMSBhZnRlciByZW1vdmluZyBvcHRpb25hbCBhbm5leClcclxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTY2hub3JyU2lnbmF0dXJlKHN0YWNrWzBdLCBwcm9ncmFtLCBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09ULCBleGVjZGF0YSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTY3JpcHQgcGF0aCBzcGVuZGluZyAoc3RhY2sgc2l6ZSBpcyA+MSBhZnRlciByZW1vdmluZyBvcHRpb25hbCBhbm5leClcclxuICAgICAgY29uc3QgY29udHJvbCA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICBjb25zdCBzY3JpcHRQdWJLZXlCdWYgPSBzdGFjay5wb3AoKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBjb250cm9sLmxlbmd0aCA8IEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUgIHx8XHJcbiAgICAgICAgY29udHJvbC5sZW5ndGggPiBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTUFYX1NJWkUgICB8fFxyXG4gICAgICAgICgoY29udHJvbC5sZW5ndGggLSBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfQkFTRV9TSVpFKSAlIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9OT0RFX1NJWkUpICE9IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9UQVBST09UX1dST05HX0NPTlRST0xfU0laRSc7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGV4ZWNkYXRhLnRhcGxlYWZIYXNoID0gSW50ZXJwcmV0ZXIuY29tcHV0ZVRhcGxlYWZIYXNoKGNvbnRyb2xbMF0gJiBJbnRlcnByZXRlci5UQVBST09UX0xFQUZfTUFTSywgc2NyaXB0UHViS2V5QnVmKTtcclxuICAgICAgaWYgKCFJbnRlcnByZXRlci52ZXJpZnlUYXByb290Q29tbWl0bWVudChjb250cm9sLCBwcm9ncmFtLCBleGVjZGF0YS50YXBsZWFmSGFzaCkpIHtcclxuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfUFJPR1JBTV9NSVNNQVRDSCc7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGV4ZWNkYXRhLnRhcGxlYWZIYXNoSW5pdCA9IHRydWU7XHJcbiAgICAgIGlmICgoY29udHJvbFswXSAmIEludGVycHJldGVyLlRBUFJPT1RfTEVBRl9NQVNLKSA9PT0gSW50ZXJwcmV0ZXIuVEFQUk9PVF9MRUFGX1RBUFNDUklQVCkge1xyXG4gICAgICAgIC8vIFRhcHNjcmlwdCAobGVhZiB2ZXJzaW9uIDB4YzApXHJcbiAgICAgICAgbGV0IHdpdG5lc3NTaXplO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnN0IGJ3ID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgICAgYncud3JpdGVWYXJpbnROdW0od2l0bmVzcy5sZW5ndGgpO1xyXG4gICAgICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiB3aXRuZXNzKSB7XHJcbiAgICAgICAgICAgIGJ3LndyaXRlVmFyaW50TnVtKGVsZW1lbnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgYncud3JpdGUoZWxlbWVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB3aXRuZXNzU2l6ZSA9IGJ3LnRvQnVmZmVyKCkubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHNjcmlwdFB1YktleSA9IG5ldyBTY3JpcHQoc2NyaXB0UHViS2V5QnVmKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIC8vIE5vdGUgaG93IHRoaXMgY29uZGl0aW9uIHdvdWxkIG5vdCBiZSByZWFjaGVkIGlmIGFuIHVua25vd24gT1BfU1VDQ0VTU3ggd2FzIGZvdW5kXHJcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0JBRF9PUENPREUnO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhlY2RhdGEudmFsaWRhdGlvbldlaWdodExlZnQgPSB3aXRuZXNzU2l6ZSArIFNjcmlwdC5WQUxJREFUSU9OX1dFSUdIVF9PRkZTRVQ7XHJcbiAgICAgICAgZXhlY2RhdGEudmFsaWRhdGlvbldlaWdodExlZnRJbml0ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlV2l0bmVzc1NjcmlwdChzY3JpcHRQdWJLZXksIHN0YWNrLCBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQsIHNhdG9zaGlzLCBmbGFncywgZXhlY2RhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIGNvbmRpdGlvbnMgYXJlIG1ldCB0aGVuIHRoaXMgbXVzdCBiZSBhbiB1cGdyYWRlZCB0YXByb290IHZlcnNpb24uXHJcbiAgICAgIGlmIChmbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX1RBUFJPT1RfVkVSU0lPTikge1xyXG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9VUEdSQURBQkxFX1RBUFJPT1RfVkVSU0lPTic7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEZ1dHVyZSBzb2Z0Zm9yayBjb21wYXRpYmlsaXR5XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfV0lUTkVTU19QUk9HUkFNKSkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9ESVNDT1VSQUdFX1VQR1JBREFCTEVfV0lUTkVTU19QUk9HUkFNJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLy8gT3RoZXIgdmVyc2lvbi9zaXplL3Ayc2ggY29tYmluYXRpb25zIHJldHVybiB0cnVlIGZvciBmdXR1cmUgc29mdGZvcmsgY29tcGF0aWJpbGl0eVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuXHJcbkludGVycHJldGVyLnByb3RvdHlwZS5leGVjdXRlV2l0bmVzc1NjcmlwdCA9IGZ1bmN0aW9uKHNjcmlwdFB1YktleSwgc3RhY2ssIHNpZ3ZlcnNpb24sIHNhdG9zaGlzLCBmbGFncywgZXhlY2RhdGEpIHtcclxuICBpZiAoc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUKSB7XHJcbiAgICBmb3IgKGxldCBjaHVuayBvZiBzY3JpcHRQdWJLZXkuY2h1bmtzKSB7XHJcbiAgICAgIC8vIE5ldyBvcGNvZGVzIHdpbGwgYmUgbGlzdGVkIGhlcmUuIE1heSB1c2UgYSBkaWZmZXJlbnQgc2lndmVyc2lvbiB0byBtb2RpZnkgZXhpc3Rpbmcgb3Bjb2Rlcy5cclxuICAgICAgaWYgKE9wY29kZS5pc09wU3VjY2VzcyhjaHVuay5vcGNvZGVudW0pKSB7XHJcbiAgICAgICAgaWYgKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX09QX1NVQ0NFU1MpIHtcclxuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9PUF9TVUNDRVNTJztcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUYXBzY3JpcHQgZW5mb3JjZXMgaW5pdGlhbCBzdGFjayBzaXplIGxpbWl0cyAoYWx0c3RhY2sgaXMgZW1wdHkgaGVyZSlcclxuICAgIGlmIChzdGFjay5sZW5ndGggPiBJbnRlcnByZXRlci5NQVhfU1RBQ0tfU0laRSkge1xyXG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NUQUNLX1NJWkUnO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEaXNhbGxvdyBzdGFjayBpdGVtIHNpemUgPiBNQVhfU0NSSVBUX0VMRU1FTlRfU0laRSBpbiB3aXRuZXNzIHN0YWNrXHJcbiAgaWYgKHN0YWNrLmxlbmd0aCAmJiBzdGFjay5zb21lKGVsZW0gPT4gZWxlbS5sZW5ndGggPiBJbnRlcnByZXRlci5NQVhfU0NSSVBUX0VMRU1FTlRfU0laRSkpIHtcclxuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfUFVTSF9TSVpFJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICB0aGlzLnNldCh7XHJcbiAgICBzY3JpcHQ6IHNjcmlwdFB1YktleSxcclxuICAgIHN0YWNrOiBzdGFjayxcclxuICAgIHNpZ3ZlcnNpb246IHNpZ3ZlcnNpb24sXHJcbiAgICBzYXRvc2hpczogc2F0b3NoaXMsXHJcbiAgICBmbGFnczogZmxhZ3MsXHJcbiAgICBleGVjZGF0YTogZXhlY2RhdGFcclxuICB9KTtcclxuXHJcbiAgaWYgKCF0aGlzLmV2YWx1YXRlKCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9FVkFMX0ZBTFNFJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgaWYgKCFJbnRlcnByZXRlci5jYXN0VG9Cb29sKGJ1ZikpIHtcclxuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVZBTF9GQUxTRV9JTl9TVEFDSyc7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWVzIGEgU2NyaXB0IGJ5IGV4ZWN1dGluZyBpdCBhbmQgcmV0dXJucyB0cnVlIGlmIGl0IGlzIHZhbGlkLlxyXG4gKiBUaGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHByb3ZpZGVkIHdpdGggdGhlIHNjcmlwdFNpZyBhbmQgdGhlIHNjcmlwdFB1YmtleVxyXG4gKiBzZXBhcmF0ZWx5LlxyXG4gKiBAcGFyYW0ge1NjcmlwdH0gc2NyaXB0U2lnIC0gdGhlIHNjcmlwdCdzIGZpcnN0IHBhcnQgKGNvcnJlc3BvbmRpbmcgdG8gdGhlIHR4IGlucHV0KVxyXG4gKiBAcGFyYW0ge1NjcmlwdH0gc2NyaXB0UHVia2V5IC0gdGhlIHNjcmlwdCdzIGxhc3QgcGFydCAoY29ycmVzcG9uZGluZyB0byB0aGUgdHggb3V0cHV0KVxyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uPX0gdHggLSB0aGUgVHJhbnNhY3Rpb24gY29udGFpbmluZyB0aGUgc2NyaXB0U2lnIGluIG9uZSBpbnB1dCAodXNlZFxyXG4gKiAgICB0byBjaGVjayBzaWduYXR1cmUgdmFsaWRpdHkgZm9yIHNvbWUgb3Bjb2RlcyBsaWtlIE9QX0NIRUNLU0lHKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gbmluIC0gaW5kZXggb2YgdGhlIHRyYW5zYWN0aW9uIGlucHV0IGNvbnRhaW5pbmcgdGhlIHNjcmlwdFNpZyB2ZXJpZmllZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gZXZhbHVhdGlvbiBmbGFncy4gU2VlIEludGVycHJldGVyLlNDUklQVF8qIGNvbnN0YW50c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gd2l0bmVzcyAtIGFycmF5IG9mIHdpdG5lc3MgZGF0YVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2F0b3NoaXMgLSBudW1iZXIgb2Ygc2F0b3NoaXMgY3JlYXRlZCBieSB0aGlzIG91dHB1dFxyXG4gKlxyXG4gKiBUcmFuc2xhdGVkIGZyb20gYml0Y29pbmQncyBWZXJpZnlTY3JpcHRcclxuICovXHJcbkludGVycHJldGVyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbihzY3JpcHRTaWcsIHNjcmlwdFB1YmtleSwgdHgsIG5pbiwgZmxhZ3MsIHdpdG5lc3MsIHNhdG9zaGlzKSB7XHJcblxyXG4gIHZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uJyk7XHJcbiAgaWYgKF8uaXNVbmRlZmluZWQodHgpKSB7XHJcbiAgICB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xyXG4gIH1cclxuICBpZiAoXy5pc1VuZGVmaW5lZChuaW4pKSB7XHJcbiAgICBuaW4gPSAwO1xyXG4gIH1cclxuICBpZiAoXy5pc1VuZGVmaW5lZChmbGFncykpIHtcclxuICAgIGZsYWdzID0gMDtcclxuICB9XHJcbiAgaWYgKF8uaXNVbmRlZmluZWQod2l0bmVzcykpIHtcclxuICAgIHdpdG5lc3MgPSBudWxsO1xyXG4gIH1cclxuICBpZiAoXy5pc1VuZGVmaW5lZChzYXRvc2hpcykpIHtcclxuICAgIHNhdG9zaGlzID0gMDtcclxuICB9XHJcblxyXG4gIHRoaXMuc2V0KHtcclxuICAgIHNjcmlwdDogc2NyaXB0U2lnLFxyXG4gICAgdHg6IHR4LFxyXG4gICAgbmluOiBuaW4sXHJcbiAgICBzaWd2ZXJzaW9uOiBTaWduYXR1cmUuVmVyc2lvbi5CQVNFLFxyXG4gICAgc2F0b3NoaXM6IDAsXHJcbiAgICBmbGFnczogZmxhZ3NcclxuICB9KTtcclxuICB2YXIgc3RhY2tDb3B5O1xyXG5cclxuICBpZiAoKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9TSUdQVVNIT05MWSkgIT09IDAgJiYgIXNjcmlwdFNpZy5pc1B1c2hPbmx5KCkpIHtcclxuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX1BVU0hPTkxZJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIGV2YWx1YXRlIHNjcmlwdFNpZ1xyXG4gIGlmICghdGhpcy5ldmFsdWF0ZSgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1AyU0gpIHtcclxuICAgIHN0YWNrQ29weSA9IHRoaXMuc3RhY2suc2xpY2UoKTtcclxuICB9XHJcblxyXG4gIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XHJcbiAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgdGhpcy5zZXQoe1xyXG4gICAgc2NyaXB0OiBzY3JpcHRQdWJrZXksXHJcbiAgICBzdGFjazogc3RhY2ssXHJcbiAgICB0eDogdHgsXHJcbiAgICBuaW46IG5pbixcclxuICAgIGZsYWdzOiBmbGFnc1xyXG4gIH0pO1xyXG5cclxuICAvLyBldmFsdWF0ZSBzY3JpcHRQdWJrZXlcclxuICBpZiAoIXRoaXMuZXZhbHVhdGUoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0VWQUxfRkFMU0VfTk9fUkVTVUxUJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgaWYgKCFJbnRlcnByZXRlci5jYXN0VG9Cb29sKGJ1ZikpIHtcclxuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVZBTF9GQUxTRV9JTl9TVEFDSyc7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFkV2l0bmVzcyA9IGZhbHNlO1xyXG4gIGlmICgoZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1dJVE5FU1MpKSB7XHJcbiAgICB2YXIgd2l0bmVzc1ZhbHVlcyA9IHt9O1xyXG4gICAgaWYgKHNjcmlwdFB1YmtleS5pc1dpdG5lc3NQcm9ncmFtKHdpdG5lc3NWYWx1ZXMpKSB7XHJcbiAgICAgIGhhZFdpdG5lc3MgPSB0cnVlO1xyXG4gICAgICBpZiAoc2NyaXB0U2lnLnRvQnVmZmVyKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX01BTExFQVRFRCc7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy52ZXJpZnlXaXRuZXNzUHJvZ3JhbSh3aXRuZXNzVmFsdWVzLnZlcnNpb24sIHdpdG5lc3NWYWx1ZXMucHJvZ3JhbSwgd2l0bmVzcywgc2F0b3NoaXMsIHRoaXMuZmxhZ3MsIC8qIGlzUDJTSCAqLyBmYWxzZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZGl0aW9uYWwgdmFsaWRhdGlvbiBmb3Igc3BlbmQtdG8tc2NyaXB0LWhhc2ggdHJhbnNhY3Rpb25zOlxyXG4gIGlmICgoZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1AyU0gpICYmIHNjcmlwdFB1YmtleS5pc1NjcmlwdEhhc2hPdXQoKSkge1xyXG4gICAgLy8gc2NyaXB0U2lnIG11c3QgYmUgbGl0ZXJhbHMtb25seSBvciB2YWxpZGF0aW9uIGZhaWxzXHJcbiAgICBpZiAoIXNjcmlwdFNpZy5pc1B1c2hPbmx5KCkpIHtcclxuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfUFVTSE9OTFknO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RhY2tDb3B5IGNhbm5vdCBiZSBlbXB0eSBoZXJlLCBiZWNhdXNlIGlmIGl0IHdhcyB0aGVcclxuICAgIC8vIFAyU0ggIEhBU0ggPD4gRVFVQUwgIHNjcmlwdFB1YktleSB3b3VsZCBiZSBldmFsdWF0ZWQgd2l0aFxyXG4gICAgLy8gYW4gZW1wdHkgc3RhY2sgYW5kIHRoZSBFdmFsU2NyaXB0IGFib3ZlIHdvdWxkIHJldHVybiBmYWxzZS5cclxuICAgIGlmIChzdGFja0NvcHkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW50ZXJuYWwgZXJyb3IgLSBzdGFjayBjb3B5IGVtcHR5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZGVlbVNjcmlwdFNlcmlhbGl6ZWQgPSBzdGFja0NvcHlbc3RhY2tDb3B5Lmxlbmd0aCAtIDFdO1xyXG4gICAgdmFyIHJlZGVlbVNjcmlwdCA9IFNjcmlwdC5mcm9tQnVmZmVyKHJlZGVlbVNjcmlwdFNlcmlhbGl6ZWQpO1xyXG4gICAgc3RhY2tDb3B5LnBvcCgpO1xyXG5cclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgdGhpcy5zZXQoe1xyXG4gICAgICBzY3JpcHQ6IHJlZGVlbVNjcmlwdCxcclxuICAgICAgc3RhY2s6IHN0YWNrQ29weSxcclxuICAgICAgdHg6IHR4LFxyXG4gICAgICBuaW46IG5pbixcclxuICAgICAgZmxhZ3M6IGZsYWdzXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBldmFsdWF0ZSByZWRlZW1TY3JpcHRcclxuICAgIGlmICghdGhpcy5ldmFsdWF0ZSgpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhY2tDb3B5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0VWQUxfRkFMU0VfTk9fUDJTSF9TVEFDSyc7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIUludGVycHJldGVyLmNhc3RUb0Jvb2woc3RhY2tDb3B5W3N0YWNrQ29weS5sZW5ndGggLSAxXSkpIHtcclxuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9FVkFMX0ZBTFNFX0lOX1AyU0hfU1RBQ0snO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9XSVRORVNTKSkge1xyXG4gICAgICB2YXIgcDJzaFdpdG5lc3NWYWx1ZXMgPSB7fTtcclxuICAgICAgaWYgKHJlZGVlbVNjcmlwdC5pc1dpdG5lc3NQcm9ncmFtKHAyc2hXaXRuZXNzVmFsdWVzKSkge1xyXG4gICAgICAgIGhhZFdpdG5lc3MgPSB0cnVlO1xyXG4gICAgICAgIHZhciByZWRlZW1TY3JpcHRQdXNoID0gbmV3IFNjcmlwdCgpO1xyXG4gICAgICAgIHJlZGVlbVNjcmlwdFB1c2guYWRkKHJlZGVlbVNjcmlwdC50b0J1ZmZlcigpKTtcclxuICAgICAgICBpZiAoc2NyaXB0U2lnLnRvSGV4KCkgIT09IHJlZGVlbVNjcmlwdFB1c2gudG9IZXgoKSkge1xyXG4gICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX01BTExFQVRFRF9QMlNIJztcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy52ZXJpZnlXaXRuZXNzUHJvZ3JhbShwMnNoV2l0bmVzc1ZhbHVlcy52ZXJzaW9uLCBwMnNoV2l0bmVzc1ZhbHVlcy5wcm9ncmFtLCB3aXRuZXNzLCBzYXRvc2hpcywgdGhpcy5mbGFncywgLyogaXNQMlNIICovIHRydWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJ5cGFzcyB0aGUgY2xlYW5zdGFjayBjaGVjayBhdCB0aGUgZW5kLiBUaGUgYWN0dWFsIHN0YWNrIGlzIG9idmlvdXNseSBub3QgY2xlYW5cclxuICAgICAgICAvLyBmb3Igd2l0bmVzcyBwcm9ncmFtcy5cclxuICAgICAgICBzdGFjayA9IFtzdGFja1swXV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFRoZSBDTEVBTlNUQUNLIGNoZWNrIGlzIG9ubHkgcGVyZm9ybWVkIGFmdGVyIHBvdGVudGlhbCBQMlNIIGV2YWx1YXRpb24sXHJcbiAgLy8gYXMgdGhlIG5vbi1QMlNIIGV2YWx1YXRpb24gb2YgYSBQMlNIIHNjcmlwdCB3aWxsIG9idmlvdXNseSBub3QgcmVzdWx0IGluXHJcbiAgLy8gYSBjbGVhbiBzdGFjayAodGhlIFAyU0ggaW5wdXRzIHJlbWFpbikuIFRoZSBzYW1lIGhvbGRzIGZvciB3aXRuZXNzXHJcbiAgLy8gZXZhbHVhdGlvbi5cclxuICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NMRUFOU1RBQ0spICE9IDApIHtcclxuICAgICAgLy8gRGlzYWxsb3cgQ0xFQU5TVEFDSyB3aXRob3V0IFAyU0gsIGFzIG90aGVyd2lzZSBhIHN3aXRjaFxyXG4gICAgICAvLyBDTEVBTlNUQUNLLT5QMlNIK0NMRUFOU1RBQ0sgd291bGQgYmUgcG9zc2libGUsIHdoaWNoIGlzIG5vdCBhXHJcbiAgICAgIC8vIHNvZnRmb3JrIChhbmQgUDJTSCBzaG91bGQgYmUgb25lKS5cclxuICAgICAgaWYgKFxyXG4gICAgICAgICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9QMlNIKSAgICA9PSAwIHx8XHJcbiAgICAgICAgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1dJVE5FU1MpID09IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgJ2ZsYWdzICYgU0NSSVBUX1ZFUklGWV9QMlNIJztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0YWNrQ29weS5sZW5ndGggIT0gMSkge1xyXG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfQ0xFQU5TVEFDSyc7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1dJVE5FU1MpKSB7XHJcbiAgICBpZiAoIWhhZFdpdG5lc3MgJiYgd2l0bmVzcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19VTkVYUEVDVEVEJztcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVycHJldGVyO1xyXG5cclxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihvYmopIHtcclxuICB0aGlzLnN0YWNrID0gW107XHJcbiAgdGhpcy5hbHRzdGFjayA9IFtdO1xyXG4gIHRoaXMucGMgPSAwO1xyXG4gIHRoaXMuc2F0b3NoaXMgPSAwO1xyXG4gIHRoaXMuc2lndmVyc2lvbiA9IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0U7XHJcbiAgdGhpcy5wYmVnaW5jb2RlaGFzaCA9IDA7XHJcbiAgdGhpcy5uT3BDb3VudCA9IDA7XHJcbiAgdGhpcy52ZkV4ZWMgPSBbXTtcclxuICB0aGlzLmVycnN0ciA9ICcnO1xyXG4gIHRoaXMuZmxhZ3MgPSAwO1xyXG4gIHRoaXMuZXhlY2RhdGEgPSB7fTtcclxufTtcclxuXHJcbkludGVycHJldGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvYmopIHtcclxuICB0aGlzLnNjcmlwdCA9IG9iai5zY3JpcHQgfHwgdGhpcy5zY3JpcHQ7XHJcbiAgdGhpcy50eCA9IG9iai50eCB8fCB0aGlzLnR4O1xyXG4gIHRoaXMubmluID0gdHlwZW9mIG9iai5uaW4gPT09ICd1bmRlZmluZWQnID8gdGhpcy5uaW4gOiBwYXJzZUludChvYmoubmluKTtcclxuICB0aGlzLnN0YWNrID0gb2JqLnN0YWNrIHx8IHRoaXMuc3RhY2s7XHJcbiAgdGhpcy5hbHRzdGFjayA9IG9iai5hbHRzdGFjayB8fCB0aGlzLmFsdHN0YWNrO1xyXG4gIHRoaXMucGMgPSB0eXBlb2Ygb2JqLnBjID09PSAndW5kZWZpbmVkJyA/IHRoaXMucGMgOiBvYmoucGM7XHJcbiAgdGhpcy5wYmVnaW5jb2RlaGFzaCA9IHR5cGVvZiBvYmoucGJlZ2luY29kZWhhc2ggPT09ICd1bmRlZmluZWQnID8gdGhpcy5wYmVnaW5jb2RlaGFzaCA6IG9iai5wYmVnaW5jb2RlaGFzaDtcclxuICB0aGlzLnNpZ3ZlcnNpb24gPSB0eXBlb2Ygb2JqLnNpZ3ZlcnNpb24gPT09ICd1bmRlZmluZWQnID8gdGhpcy5zaWd2ZXJzaW9uIDogb2JqLnNpZ3ZlcnNpb247XHJcbiAgdGhpcy5zYXRvc2hpcyA9IHR5cGVvZiBvYmouc2F0b3NoaXMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXRvc2hpcyA6IG9iai5zYXRvc2hpcztcclxuICB0aGlzLm5PcENvdW50ID0gdHlwZW9mIG9iai5uT3BDb3VudCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm5PcENvdW50IDogb2JqLm5PcENvdW50O1xyXG4gIHRoaXMudmZFeGVjID0gb2JqLnZmRXhlYyB8fCB0aGlzLnZmRXhlYztcclxuICB0aGlzLmVycnN0ciA9IG9iai5lcnJzdHIgfHwgdGhpcy5lcnJzdHI7XHJcbiAgdGhpcy5mbGFncyA9IHR5cGVvZiBvYmouZmxhZ3MgPT09ICd1bmRlZmluZWQnID8gdGhpcy5mbGFncyA6IG9iai5mbGFncztcclxuICB0aGlzLmV4ZWNkYXRhID0gdHlwZW9mIG9iai5leGVjZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmV4ZWNkYXRhIDogKG9iai5leGVjZGF0YSB8fCB7fSk7XHJcbn07XHJcblxyXG5JbnRlcnByZXRlci50cnVlID0gQnVmZmVyLmZyb20oWzFdKTtcclxuSW50ZXJwcmV0ZXIuZmFsc2UgPSBCdWZmZXIuZnJvbShbXSk7XHJcblxyXG5JbnRlcnByZXRlci5NQVhfU0NSSVBUX1NJWkUgPSAxMDAwMDtcclxuSW50ZXJwcmV0ZXIuTUFYX1NUQUNLX1NJWkUgPSAxMDAwO1xyXG5JbnRlcnByZXRlci5NQVhfU0NSSVBUX0VMRU1FTlRfU0laRSA9IDUyMDtcclxuXHJcbkludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRCA9IDUwMDAwMDAwMDtcclxuSW50ZXJwcmV0ZXIuTE9DS1RJTUVfVEhSRVNIT0xEX0JOID0gbmV3IEJOKEludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRCk7XHJcblxyXG4vLyBmbGFncyB0YWtlbiBmcm9tIGJpdGNvaW5kXHJcbi8vIGJpdGNvaW5kIGNvbW1pdDogYjVkMWIxMDkyOTk4YmM5NTMxMzg1NmQ1MzVjNjMyZWE1YThmOTEwNFxyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX05PTkUgPSAwO1xyXG5cclxuLy8gRXZhbHVhdGUgUDJTSCBzdWJzY3JpcHRzIChzb2Z0Zm9yayBzYWZlLCBCSVAxNikuXHJcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfUDJTSCA9ICgxIDw8IDApO1xyXG5cclxuLy8gUGFzc2luZyBhIG5vbi1zdHJpY3QtREVSIHNpZ25hdHVyZSBvciBvbmUgd2l0aCB1bmRlZmluZWQgaGFzaHR5cGUgdG8gYSBjaGVja3NpZyBvcGVyYXRpb24gY2F1c2VzIHNjcmlwdCBmYWlsdXJlLlxyXG4vLyBQYXNzaW5nIGEgcHVia2V5IHRoYXQgaXMgbm90ICgweDA0ICsgNjQgYnl0ZXMpIG9yICgweDAyIG9yIDB4MDMgKyAzMiBieXRlcykgdG8gY2hlY2tzaWcgY2F1c2VzIHRoYXQgcHVia2V5IHRvIGJlXHJcbi8vIHNraXBwZWQgKG5vdCBzb2Z0Zm9yayBzYWZlOiB0aGlzIGZsYWcgY2FuIHdpZGVuIHRoZSB2YWxpZGl0eSBvZiBPUF9DSEVDS1NJRyBPUF9OT1QpLlxyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1NUUklDVEVOQyA9ICgxIDw8IDEpO1xyXG5cclxuLy8gUGFzc2luZyBhIG5vbi1zdHJpY3QtREVSIHNpZ25hdHVyZSB0byBhIGNoZWNrc2lnIG9wZXJhdGlvbiBjYXVzZXMgc2NyaXB0IGZhaWx1cmUgKHNvZnRmb3JrIHNhZmUsIEJJUDYyIHJ1bGUgMSlcclxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ERVJTSUcgPSAoMSA8PCAyKTtcclxuXHJcbi8vIFBhc3NpbmcgYSBub24tc3RyaWN0LURFUiBzaWduYXR1cmUgb3Igb25lIHdpdGggUyA+IG9yZGVyLzIgdG8gYSBjaGVja3NpZyBvcGVyYXRpb24gY2F1c2VzIHNjcmlwdCBmYWlsdXJlXHJcbi8vIChzb2Z0Zm9yayBzYWZlLCBCSVA2MiBydWxlIDUpLlxyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0xPV19TID0gKDEgPDwgMyk7XHJcblxyXG4vLyB2ZXJpZnkgZHVtbXkgc3RhY2sgaXRlbSBjb25zdW1lZCBieSBDSEVDS01VTFRJU0lHIGlzIG9mIHplcm8tbGVuZ3RoIChzb2Z0Zm9yayBzYWZlLCBCSVA2MiBydWxlIDcpLlxyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX05VTExEVU1NWSA9ICgxIDw8IDQpO1xyXG5cclxuLy8gVXNpbmcgYSBub24tcHVzaCBvcGVyYXRvciBpbiB0aGUgc2NyaXB0U2lnIGNhdXNlcyBzY3JpcHQgZmFpbHVyZSAoc29mdGZvcmsgc2FmZSwgQklQNjIgcnVsZSAyKS5cclxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9TSUdQVVNIT05MWSA9ICgxIDw8IDUpO1xyXG5cclxuLy8gUmVxdWlyZSBtaW5pbWFsIGVuY29kaW5ncyBmb3IgYWxsIHB1c2ggb3BlcmF0aW9ucyAoT1BfMC4uLiBPUF8xNiwgT1BfMU5FR0FURSB3aGVyZSBwb3NzaWJsZSwgZGlyZWN0XHJcbi8vIHB1c2hlcyB1cCB0byA3NSBieXRlcywgT1BfUFVTSERBVEEgdXAgdG8gMjU1IGJ5dGVzLCBPUF9QVVNIREFUQTIgZm9yIGFueXRoaW5nIGxhcmdlcikuIEV2YWx1YXRpbmdcclxuLy8gYW55IG90aGVyIHB1c2ggY2F1c2VzIHRoZSBzY3JpcHQgdG8gZmFpbCAoQklQNjIgcnVsZSAzKS5cclxuLy8gSW4gYWRkaXRpb24sIHdoZW5ldmVyIGEgc3RhY2sgZWxlbWVudCBpcyBpbnRlcnByZXRlZCBhcyBhIG51bWJlciwgaXQgbXVzdCBiZSBvZiBtaW5pbWFsIGxlbmd0aCAoQklQNjIgcnVsZSA0KS5cclxuLy8gKHNvZnRmb3JrIHNhZmUpXHJcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfTUlOSU1BTERBVEEgPSAoMSA8PCA2KTtcclxuXHJcbi8vIERpc2NvdXJhZ2UgdXNlIG9mIE5PUHMgcmVzZXJ2ZWQgZm9yIHVwZ3JhZGVzIChOT1AxLTEwKVxyXG4vL1xyXG4vLyBQcm92aWRlZCBzbyB0aGF0IG5vZGVzIGNhbiBhdm9pZCBhY2NlcHRpbmcgb3IgbWluaW5nIHRyYW5zYWN0aW9uc1xyXG4vLyBjb250YWluaW5nIGV4ZWN1dGVkIE5PUCdzIHdob3NlIG1lYW5pbmcgbWF5IGNoYW5nZSBhZnRlciBhIHNvZnQtZm9yayxcclxuLy8gdGh1cyByZW5kZXJpbmcgdGhlIHNjcmlwdCBpbnZhbGlkOyB3aXRoIHRoaXMgZmxhZyBzZXQgZXhlY3V0aW5nXHJcbi8vIGRpc2NvdXJhZ2VkIE5PUHMgZmFpbHMgdGhlIHNjcmlwdC4gVGhpcyB2ZXJpZmljYXRpb24gZmxhZyB3aWxsIG5ldmVyIGJlXHJcbi8vIGEgbWFuZGF0b3J5IGZsYWcgYXBwbGllZCB0byBzY3JpcHRzIGluIGEgYmxvY2suIE5PUHMgdGhhdCBhcmUgbm90XHJcbi8vIGV4ZWN1dGVkLCBlLmcuICB3aXRoaW4gYW4gdW5leGVjdXRlZCBJRiBFTkRJRiBibG9jaywgYXJlICpub3QqIHJlamVjdGVkLlxyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9OT1BTID0gKDEgPDwgNyk7XHJcblxyXG5cclxuLy8gUmVxdWlyZSB0aGF0IG9ubHkgYSBzaW5nbGUgc3RhY2sgZWxlbWVudCByZW1haW5zIGFmdGVyIGV2YWx1YXRpb24uIFRoaXNcclxuLy8gY2hhbmdlcyB0aGUgc3VjY2VzcyBjcml0ZXJpb24gZnJvbSBcIkF0IGxlYXN0IG9uZSBzdGFjayBlbGVtZW50IG11c3RcclxuLy8gcmVtYWluLCBhbmQgd2hlbiBpbnRlcnByZXRlZCBhcyBhIGJvb2xlYW4sIGl0IG11c3QgYmUgdHJ1ZVwiIHRvIFwiRXhhY3RseVxyXG4vLyBvbmUgc3RhY2sgZWxlbWVudCBtdXN0IHJlbWFpbiwgYW5kIHdoZW4gaW50ZXJwcmV0ZWQgYXMgYSBib29sZWFuLCBpdCBtdXN0XHJcbi8vIGJlIHRydWVcIi5cclxuLy8gKHNvZnRmb3JrIHNhZmUsIEJJUDYyIHJ1bGUgNilcclxuLy8gTm90ZTogQ0xFQU5TVEFDSyBzaG91bGQgbmV2ZXIgYmUgdXNlZCB3aXRob3V0IFAyU0ggb3IgV0lUTkVTUy5cclxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9DTEVBTlNUQUNLID0gKDEgPDwgOCksXHJcblxyXG4vLyBWZXJpZnkgQ0hFQ0tMT0NLVElNRVZFUklGWVxyXG4vL1xyXG4vLyBTZWUgQklQNjUgZm9yIGRldGFpbHMuXHJcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ0hFQ0tMT0NLVElNRVZFUklGWSA9ICgxIDw8IDkpO1xyXG5cclxuLy8gc3VwcG9ydCBDSEVDS1NFUVVFTkNFVkVSSUZZIG9wY29kZVxyXG4vL1xyXG4vLyBTZWUgQklQMTEyIGZvciBkZXRhaWxzXHJcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ0hFQ0tTRVFVRU5DRVZFUklGWSA9ICgxIDw8IDEwKTtcclxuXHJcbi8vIFN1cHBvcnQgc2VncmVnYXRlZCB3aXRuZXNzXHJcbi8vXHJcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfV0lUTkVTUyA9ICgxIDw8IDExKTtcclxuXHJcbi8vIE1ha2luZyB2MS12MTYgd2l0bmVzcyBwcm9ncmFtIG5vbi1zdGFuZGFyZFxyXG4vL1xyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9XSVRORVNTX1BST0dSQU0gPSAoMSA8PCAxMik7XHJcblxyXG5cclxuLy9cclxuLy8gU2Vnd2l0IHNjcmlwdCBvbmx5OiBSZXF1aXJlIHRoZSBhcmd1bWVudCBvZiBPUF9JRi9OT1RJRiB0byBiZSBleGFjdGx5XHJcbi8vIDB4MDEgb3IgZW1wdHkgdmVjdG9yXHJcbi8vXHJcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfTUlOSU1BTElGID0gKDEgPDwgMTMpO1xyXG5cclxuXHJcbi8vIFNpZ25hdHVyZShzKSBtdXN0IGJlIGVtcHR5IHZlY3RvciBpZiBhbiBDSEVDSyhNVUxUSSlTSUcgb3BlcmF0aW9uIGZhaWxlZFxyXG4vL1xyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX05VTExGQUlMID0gKDEgPDwgMTQpO1xyXG5cclxuLy8gUHVibGljIGtleXMgaW4gc2NyaXB0cyBtdXN0IGJlIGNvbXByZXNzZWRcclxuLy9cclxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9XSVRORVNTX1BVQktFWVRZUEUgPSAoMSA8PCAxNSk7XHJcblxyXG4vLyBEbyB3ZSBhY2NlcHQgc2lnbmF0dXJlIHVzaW5nIFNJR0hBU0hfRk9SS0lEXHJcbi8vXHJcbkludGVycHJldGVyLlNDUklQVF9FTkFCTEVfU0lHSEFTSF9GT1JLSUQgPSAoMSA8PCAxNik7XHJcblxyXG4vLyBEbyB3ZSBhY2NlcHQgYWN0aXZhdGUgcmVwbGF5IHByb3RlY3Rpb24gdXNpbmcgYSBkaWZmZXJlbnQgZm9yayBpZC5cclxuLy9cclxuSW50ZXJwcmV0ZXIuU0NSSVBUX0VOQUJMRV9SRVBMQVlfUFJPVEVDVElPTiA9ICgxIDw8IDE3KTtcclxuXHJcbi8vIE1ha2luZyBPUF9DT0RFU0VQQVJBVE9SIGFuZCBGaW5kQW5kRGVsZXRlIGZhaWwgYW55IG5vbi1zZWd3aXQgc2NyaXB0c1xyXG4vL1xyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NPTlNUX1NDUklQVENPREUgPSAoMSA8PCAxNik7XHJcblxyXG4vLyBWZXJpZnkgdGFwcm9vdCBzY3JpcHQgXHJcbi8vXHJcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfVEFQUk9PVCA9ICgxIDw8IDE3KTtcclxuXHJcbi8vIE1ha2luZyB1bmtub3duIFRhcHJvb3QgbGVhZiB2ZXJzaW9ucyBub24tc3RhbmRhcmRcclxuLy9cclxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfVEFQUk9PVF9WRVJTSU9OID0gKDEgPDwgMTgpO1xyXG5cclxuLy8gTWFraW5nIHVua25vd24gT1BfU1VDQ0VTUyBub24tc3RhbmRhcmRcclxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX09QX1NVQ0NFU1MgPSAoMSA8PCAxOSk7XHJcblxyXG4vLyBNYWtpbmcgdW5rbm93biBwdWJsaWMga2V5IHZlcnNpb25zIChpbiBCSVAgMzQyIHNjcmlwdHMpIG5vbi1zdGFuZGFyZFxyXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9QVUJLRVlUWVBFID0gKDEgPDwgMjApO1xyXG5cclxuXHJcblxyXG4vKiBCZWxvdyBmbGFncyBhcHBseSBpbiB0aGUgY29udGV4dCBvZiBCSVAgNjgqL1xyXG4vKipcclxuICogSWYgdGhpcyBmbGFnIHNldCwgQ1R4SW46Om5TZXF1ZW5jZSBpcyBOT1QgaW50ZXJwcmV0ZWQgYXMgYSByZWxhdGl2ZVxyXG4gKiBsb2NrLXRpbWUuXHJcbiAqL1xyXG5JbnRlcnByZXRlci5TRVFVRU5DRV9MT0NLVElNRV9ESVNBQkxFX0ZMQUcgPSAoMSA8PCAzMSk7XHJcblxyXG4vKipcclxuICogSWYgQ1R4SW46Om5TZXF1ZW5jZSBlbmNvZGVzIGEgcmVsYXRpdmUgbG9jay10aW1lIGFuZCB0aGlzIGZsYWcgaXMgc2V0LFxyXG4gKiB0aGUgcmVsYXRpdmUgbG9jay10aW1lIGhhcyB1bml0cyBvZiA1MTIgc2Vjb25kcywgb3RoZXJ3aXNlIGl0IHNwZWNpZmllc1xyXG4gKiBibG9ja3Mgd2l0aCBhIGdyYW51bGFyaXR5IG9mIDEuXHJcbiAqL1xyXG5JbnRlcnByZXRlci5TRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcgPSAoMSA8PCAyMik7XHJcblxyXG4vKipcclxuICogSWYgQ1R4SW46Om5TZXF1ZW5jZSBlbmNvZGVzIGEgcmVsYXRpdmUgbG9jay10aW1lLCB0aGlzIG1hc2sgaXMgYXBwbGllZCB0b1xyXG4gKiBleHRyYWN0IHRoYXQgbG9jay10aW1lIGZyb20gdGhlIHNlcXVlbmNlIGZpZWxkLlxyXG4gKi9cclxuSW50ZXJwcmV0ZXIuU0VRVUVOQ0VfTE9DS1RJTUVfTUFTSyA9IDB4MDAwMGZmZmY7XHJcblxyXG4vKiogU2lnbmF0dXJlIGhhc2ggc2l6ZXMgKi9cclxuSW50ZXJwcmV0ZXIuV0lUTkVTU19WMF9TQ1JJUFRIQVNIX1NJWkUgPSAzMjtcclxuSW50ZXJwcmV0ZXIuV0lUTkVTU19WMF9LRVlIQVNIX1NJWkUgPSAyMDtcclxuSW50ZXJwcmV0ZXIuV0lUTkVTU19WMV9UQVBST09UX1NJWkUgPSAzMjtcclxuXHJcbkludGVycHJldGVyLlRBUFJPT1RfTEVBRl9NQVNLID0gMHhmZTtcclxuSW50ZXJwcmV0ZXIuVEFQUk9PVF9MRUFGX1RBUFNDUklQVCA9IDB4YzA7XHJcbkludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUgPSAzMztcclxuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX05PREVfU0laRSA9IDMyO1xyXG5JbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTUFYX05PREVfQ09VTlQgPSAxMjg7XHJcbkludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9NQVhfU0laRSA9IEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUgKyBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTk9ERV9TSVpFICogSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX01BWF9OT0RFX0NPVU5UO1xyXG5cclxuLy8gQ29uY2VwdHVhbGx5LCB0aGlzIGRvZXNuJ3QgcmVhbGx5IGJlbG9uZyB3aXRoIHRoZSBJbnRlcnByZXRlciwgYnV0IEkgaGF2ZW4ndCBmb3VuZCBhIGJldHRlciBwbGFjZSBmb3IgaXQuXHJcbkludGVycHJldGVyLlBST1RPQ09MX1ZFUlNJT04gPSA3MDAxNjtcclxuXHJcbkludGVycHJldGVyLmNhc3RUb0Jvb2wgPSBmdW5jdGlvbihidWYpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGJ1ZltpXSAhPT0gMCkge1xyXG4gICAgICAvLyBjYW4gYmUgbmVnYXRpdmUgemVyb1xyXG4gICAgICBpZiAoaSA9PT0gYnVmLmxlbmd0aCAtIDEgJiYgYnVmW2ldID09PSAweDgwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgQ2hlY2tTaWduYXR1cmVFbmNvZGluZ1xyXG4gKi9cclxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrU2lnbmF0dXJlRW5jb2RpbmcgPSBmdW5jdGlvbihidWYpIHtcclxuICB2YXIgc2lnO1xyXG5cclxuICAgIC8vIEVtcHR5IHNpZ25hdHVyZS4gTm90IHN0cmljdGx5IERFUiBlbmNvZGVkLCBidXQgYWxsb3dlZCB0byBwcm92aWRlIGFcclxuICAgIC8vIGNvbXBhY3Qgd2F5IHRvIHByb3ZpZGUgYW4gaW52YWxpZCBzaWduYXR1cmUgZm9yIHVzZSB3aXRoIENIRUNLKE1VTFRJKVNJR1xyXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICBpZiAoKHRoaXMuZmxhZ3MgJiAoSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ERVJTSUcgfCBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0xPV19TIHwgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9TVFJJQ1RFTkMpKSAhPT0gMCAmJiAhU2lnbmF0dXJlLmlzVHhERVIoYnVmKSkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfREVSX0lOVkFMSURfRk9STUFUJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9IGVsc2UgaWYgKCh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9MT1dfUykgIT09IDApIHtcclxuICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoYnVmKTtcclxuICAgIGlmICghc2lnLmhhc0xvd1MoKSkge1xyXG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NJR19ERVJfSElHSF9TJztcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1NUUklDVEVOQykgIT09IDApIHtcclxuICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoYnVmKTtcclxuICAgIGlmICghc2lnLmhhc0RlZmluZWRIYXNodHlwZSgpKSB7XHJcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX0hBU0hUWVBFJztcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgQ2hlY2tQdWJLZXlFbmNvZGluZ1xyXG4gKi9cclxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrUHVia2V5RW5jb2RpbmcgPSBmdW5jdGlvbihidWYpIHtcclxuICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1NUUklDVEVOQykgIT09IDAgJiYgIVB1YmxpY0tleS5pc1ZhbGlkKGJ1ZikpIHtcclxuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfUFVCS0VZVFlQRSc7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBPbmx5IGNvbXByZXNzZWQga2V5cyBhcmUgYWNjZXB0ZWQgaW4gc2Vnd2l0XHJcbiAgaWYgKCh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9XSVRORVNTX1BVQktFWVRZUEUpICE9IDAgJiYgdGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjAgJiYgIVB1YmxpY0tleS5mcm9tQnVmZmVyKGJ1ZikuY29tcHJlc3NlZCkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX1BVQktFWVRZUEUnO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWVzIEVDRFNBIHNpZ25hdHVyZVxyXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnIFxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVia2V5IFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbmluIFxyXG4gKiBAcGFyYW0ge1NjcmlwdH0gc3Vic2NyaXB0IFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2F0b3NoaXMgXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrRWNkc2FTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcsIHB1YmtleSwgbmluLCBzdWJzY3JpcHQsIHNhdG9zaGlzKSB7XHJcbiAgdmFyIHN1YnNjcmlwdEJ1ZmZlciA9IHN1YnNjcmlwdC50b0J1ZmZlcigpO1xyXG4gIHZhciBzY3JpcHRDb2RlV3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gIHNjcmlwdENvZGVXcml0ZXIud3JpdGVWYXJpbnROdW0oc3Vic2NyaXB0QnVmZmVyLmxlbmd0aCk7XHJcbiAgc2NyaXB0Q29kZVdyaXRlci53cml0ZShzdWJzY3JpcHRCdWZmZXIpO1xyXG5cclxuICAkLmNoZWNrU3RhdGUoSlNVdGlsLmlzTmF0dXJhbE51bWJlcihzYXRvc2hpcykpO1xyXG4gIHZhciBzYXRvc2hpc0J1ZmZlciA9IG5ldyBCdWZmZXJXcml0ZXIoKS53cml0ZVVJbnQ2NExFQk4obmV3IEJOKHNhdG9zaGlzKSkudG9CdWZmZXIoKTtcclxuXHJcbiAgdmFyIHZlcmlmaWVkID0gU2lnaGFzaFdpdG5lc3MudmVyaWZ5KFxyXG4gICAgdGhpcyxcclxuICAgIHNpZyxcclxuICAgIHB1YmtleSxcclxuICAgIG5pbixcclxuICAgIHNjcmlwdENvZGVXcml0ZXIudG9CdWZmZXIoKSxcclxuICAgIHNhdG9zaGlzQnVmZmVyXHJcbiAgKTtcclxuICByZXR1cm4gdmVyaWZpZWQ7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7U2lnbmF0dXJlfEJ1ZmZlcn0gc2lnIFxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleXxCdWZmZXJ9IHB1YmtleSBcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ3ZlcnNpb24gXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBleGVjZGF0YSBcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5JbnRlcnByZXRlci5wcm90b3R5cGUuY2hlY2tTY2hub3JyU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnLCBwdWJrZXksIHNpZ3ZlcnNpb24sIGV4ZWNkYXRhKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNpZyAmJiBCdWZmZXIuaXNCdWZmZXIoc2lnKSwgJ01pc3Npbmcgc2lnJyk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHB1YmtleSAmJiBCdWZmZXIuaXNCdWZmZXIocHVia2V5KSwgJ01pc3NpbmcgcHVia2V5Jyk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ3ZlcnNpb24sICdNaXNzaW5nIHNpZ3ZlcnNpb24nKTtcclxuICAkLmNoZWNrQXJndW1lbnQoZXhlY2RhdGEsICdNaXNzaW5nIGV4ZWNkYXRhJyk7XHJcblxyXG4gICQuY2hlY2tBcmd1bWVudChwdWJrZXkubGVuZ3RoID09PSAzMiwgJ1NjaG5vcnIgc2lnbmF0dXJlcyBoYXZlIDMyLWJ5dGUgcHVibGljIGtleXMuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGVuZm9yY2luZyB0aGlzLicpO1xyXG4gIC8vIE5vdGUgdGhhdCBpbiBUYXBzY3JpcHQgZXZhbHVhdGlvbiwgZW1wdHkgc2lnbmF0dXJlcyBhcmUgdHJlYXRlZCBzcGVjaWFsbHkgKGludmFsaWQgc2lnbmF0dXJlIHRoYXQgZG9lcyBub3RcclxuICAvLyBhYm9ydCBzY3JpcHQgZXhlY3V0aW9uKS4gVGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBFdmFsQ2hlY2tzaWdUYXBzY3JpcHQsIHdoaWNoIHdvbid0IGludm9rZVxyXG4gIC8vIENoZWNrU2Nobm9yclNpZ25hdHVyZSBpbiB0aGF0IGNhc2UuIEluIG90aGVyIGNvbnRleHRzLCB0aGV5IGFyZSBpbnZhbGlkIGxpa2UgZXZlcnkgb3RoZXIgc2lnbmF0dXJlIHdpdGhcclxuICAvLyBzaXplIGRpZmZlcmVudCBmcm9tIDY0IG9yIDY1LlxyXG4gIGlmICghKHNpZy5sZW5ndGggPT09IDY0IHx8IHNpZy5sZW5ndGggPT09IDY1KSkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TQ0hOT1JSX1NJR19TSVpFJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChzaWcubGVuZ3RoID09PSA2NSAmJiBzaWdbc2lnLmxlbmd0aCAtIDFdID09PSBTaWduYXR1cmUuU0lHSEFTSF9ERUZBVUxUKSB7XHJcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NDSE5PUlJfU0lHX0hBU0hUWVBFJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgc2lnID0gU2lnbmF0dXJlLmZyb21TY2hub3JyKHNpZyk7XHJcbiAgY29uc3QgdmVyaWZpZWQgPSBTaWdoYXNoU2Nobm9yci52ZXJpZnkoXHJcbiAgICB0aGlzLnR4LFxyXG4gICAgc2lnLFxyXG4gICAgcHVia2V5LFxyXG4gICAgc2lndmVyc2lvbixcclxuICAgIHRoaXMubmluLFxyXG4gICAgZXhlY2RhdGFcclxuICApO1xyXG4gIHJldHVybiB2ZXJpZmllZDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQmFzZWQgb24gYml0Y29pbmQncyBFdmFsQ2hlY2tzaWdQcmVUYXBzY3JpcHQgZnVuY3Rpb25cclxuICogYml0Y29pbmQgY29tbWl0OiBhMDk4ODE0MGI3MTQ4NWFkMTJjM2MzYTRhOTU3M2Y3YzIxYjFlZmY4XHJcbiAqL1xyXG5JbnRlcnByZXRlci5wcm90b3R5cGUuX2V2YWxDaGVja3NpZ1ByZVRhcHNjcmlwdCA9IGZ1bmN0aW9uKGJ1ZlNpZywgYnVmUHVia2V5KSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KFxyXG4gICAgdGhpcy5zaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5CQVNFIHx8IHRoaXMuc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMCxcclxuICAgICdzaWd2ZXJzaW9uIG11c3QgYmUgYmFzZSBvciB3aXRuZXNzX3YwJ1xyXG4gICk7XHJcblxyXG4gIC8vIFN1Y2Nlc3Mgc2lnbmlmaWVzIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQuXHJcbiAgLy8gUmVzdWx0IHNpZ25pZmllcyB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY2l0b24sIHdoaWNoIGFsc28gdGFrZXMgZmxhZ3MgaW50byBhY2NvdW50LlxyXG4gIGNvbnN0IHJldFZhbCA9IHsgc3VjY2VzczogZmFsc2UsIHJlc3VsdDogZmFsc2UgfTtcclxuXHJcbiAgY29uc3Qgc3Vic2NyaXB0ID0gbmV3IFNjcmlwdCgpLnNldCh7XHJcbiAgICBjaHVua3M6IHRoaXMuc2NyaXB0LmNodW5rcy5zbGljZSh0aGlzLnBiZWdpbmNvZGVoYXNoKVxyXG4gIH0pO1xyXG5cclxuICAvLyBEcm9wIHRoZSBzaWduYXR1cmUgaW4gcHJlLXNlZ3dpdCBzY3JpcHRzIGJ1dCBub3Qgc2Vnd2l0IHNjcmlwdHNcclxuICBpZiAodGhpcy5zaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5CQVNFKSB7XHJcbiAgICAvLyBEcm9wIHRoZSBzaWduYXR1cmUsIHNpbmNlIHRoZXJlJ3Mgbm8gd2F5IGZvciBhIHNpZ25hdHVyZSB0byBzaWduIGl0c2VsZlxyXG4gICAgY29uc3QgdG1wU2NyaXB0ID0gbmV3IFNjcmlwdCgpLmFkZChidWZTaWcpO1xyXG4gICAgbGV0IGZvdW5kID0gc3Vic2NyaXB0LmNodW5rcy5sZW5ndGg7XHJcbiAgICBzdWJzY3JpcHQuZmluZEFuZERlbGV0ZSh0bXBTY3JpcHQpO1xyXG5cclxuICAgIGZvdW5kID0gZm91bmQgPT0gc3Vic2NyaXB0LmNodW5rcy5sZW5ndGggKyAxOyAvLyBmb3VuZCBpZiBhIGNodW5rIHdhcyByZW1vdmVkXHJcbiAgICBpZiAoZm91bmQgJiYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NPTlNUX1NDUklQVENPREUpKSB7XHJcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX0ZJTkRBTkRERUxFVEUnO1xyXG4gICAgICByZXR1cm4gcmV0VmFsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCF0aGlzLmNoZWNrU2lnbmF0dXJlRW5jb2RpbmcoYnVmU2lnKSB8fCAhdGhpcy5jaGVja1B1YmtleUVuY29kaW5nKGJ1ZlB1YmtleSkpIHtcclxuICAgIHJldHVybiByZXRWYWw7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnID0gU2lnbmF0dXJlLmZyb21UeEZvcm1hdChidWZTaWcpO1xyXG4gICAgY29uc3QgcHVia2V5ID0gUHVibGljS2V5LmZyb21CdWZmZXIoYnVmUHVia2V5LCBmYWxzZSk7XHJcbiAgICByZXRWYWwuc3VjY2VzcyA9IHRoaXMudHgudmVyaWZ5U2lnbmF0dXJlKHNpZywgcHVia2V5LCB0aGlzLm5pbiwgc3Vic2NyaXB0LCB0aGlzLnNpZ3ZlcnNpb24sIHRoaXMuc2F0b3NoaXMpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIC8vaW52YWxpZCBzaWcgb3IgcHVia2V5XHJcbiAgICByZXRWYWwuc3VjY2VzcyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFyZXRWYWwuc3VjY2VzcyAmJiAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfTlVMTEZBSUwpICYmIGJ1ZlNpZy5sZW5ndGgpIHtcclxuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX05VTExGQUlMJztcclxuICAgIHJldHVybiByZXRWYWw7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIElmIGl0IHJlYWNoZXMgaGVyZSwgdGhlbiB0cnVlXHJcbiAgcmV0VmFsLnJlc3VsdCA9IHRydWU7XHJcbiAgcmV0dXJuIHJldFZhbDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQmFzZWQgb24gYml0Y29pbmQncyBFdmFsQ2hlY2tzaWdUYXBzY3JpcHQgZnVuY3Rpb25cclxuICogYml0Y29pbmQgY29tbWl0OiBhMDk4ODE0MGI3MTQ4NWFkMTJjM2MzYTRhOTU3M2Y3YzIxYjFlZmY4XHJcbiAqL1xyXG5JbnRlcnByZXRlci5wcm90b3R5cGUuX2V2YWxDaGVja3NpZ1RhcHNjcmlwdCA9IGZ1bmN0aW9uKGJ1ZlNpZywgYnVmUHVia2V5KSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQsICd0aGlzLnNpZ3ZlcnNpb24gbXVzdCBieSBUQVBTQ1JJUFQnKTtcclxuXHJcbiAgLypcclxuICAgICogIFRoZSBmb2xsb3dpbmcgdmFsaWRhdGlvbiBzZXF1ZW5jZSBpcyBjb25zZW5zdXMgY3JpdGljYWwuIFBsZWFzZSBub3RlIGhvdyAtLVxyXG4gICAgKiAgICB1cGdyYWRhYmxlIHB1YmxpYyBrZXkgdmVyc2lvbnMgcHJlY2VkZSBvdGhlciBydWxlcztcclxuICAgICogICAgdGhlIHNjcmlwdCBleGVjdXRpb24gZmFpbHMgd2hlbiB1c2luZyBlbXB0eSBzaWduYXR1cmUgd2l0aCBpbnZhbGlkIHB1YmxpYyBrZXk7XHJcbiAgICAqICAgIHRoZSBzY3JpcHQgZXhlY3V0aW9uIGZhaWxzIHdoZW4gdXNpbmcgbm9uLWVtcHR5IGludmFsaWQgc2lnbmF0dXJlLlxyXG4gICAgKi9cclxuXHJcbiAgLy8gU3VjY2VzcyBzaWduaWZpZXMgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZC5cclxuICAvLyBSZXN1bHQgc2lnbmlmaWVzIHRoZSByZXN1bHQgb2YgdGhpcyBmdW5jaXRvbiwgd2hpY2ggYWxzbyB0YWtlcyBmbGFncyBpbnRvIGFjY291bnQuXHJcbiAgY29uc3QgcmV0VmFsID0ge1xyXG4gICAgc3VjY2VzczogYnVmU2lnLmxlbmd0aCA+IDAsXHJcbiAgICByZXN1bHQ6IGZhbHNlXHJcbiAgfVxyXG4gIGlmIChyZXRWYWwuc3VjY2Vzcykge1xyXG4gICAgLy8gSW1wbGVtZW50IHRoZSBzaWdvcHMvd2l0bmVzc3NpemUgcmF0aW8gdGVzdC5cclxuICAgIC8vIFBhc3Npbmcgd2l0aCBhbiB1cGdyYWRhYmxlIHB1YmxpYyBrZXkgdmVyc2lvbiBpcyBhbHNvIGNvdW50ZWQuXHJcbiAgICAkLmNoZWNrU3RhdGUodGhpcy5leGVjZGF0YS52YWxpZGF0aW9uV2VpZ2h0TGVmdEluaXQsICd2YWxpZGF0aW9uV2VpZ2h0TGVmdEluaXQgaXMgZmFsc2UnKTtcclxuICAgIHRoaXMuZXhlY2RhdGEudmFsaWRhdGlvbldlaWdodExlZnQgLT0gU2NyaXB0LlZBTElEQVRJT05fV0VJR0hUX1BFUl9TSUdPUF9QQVNTRUQ7XHJcbiAgICBpZiAodGhpcy5leGVjZGF0YS52YWxpZGF0aW9uV2VpZ2h0TGVmdCA8IDApIHtcclxuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9UQVBTQ1JJUFRfVkFMSURBVElPTl9XRUlHSFQnO1xyXG4gICAgICByZXR1cm4gcmV0VmFsO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoYnVmUHVia2V5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9QVUJLRVlUWVBFJztcclxuICAgIHJldHVybiByZXRWYWw7XHJcbiAgfSBlbHNlIGlmIChidWZQdWJrZXkubGVuZ3RoID09IDMyKSB7XHJcbiAgICBpZiAocmV0VmFsLnN1Y2Nlc3MgJiYgIXRoaXMudHguY2hlY2tTY2hub3JyU2lnbmF0dXJlKGJ1ZlNpZywgYnVmUHVia2V5LCB0aGlzLm5pbiwgdGhpcy5zaWd2ZXJzaW9uLCB0aGlzLmV4ZWNkYXRhKSkge1xyXG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NDSE5PUlJfU0lHJztcclxuICAgICAgcmV0dXJuIHJldFZhbDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLypcclxuICAgICAgKiAgTmV3IHB1YmxpYyBrZXkgdmVyc2lvbiBzb2Z0Zm9ya3Mgc2hvdWxkIGJlIGRlZmluZWQgYmVmb3JlIHRoaXMgYGVsc2VgIGJsb2NrLlxyXG4gICAgICAqICBHZW5lcmFsbHksIHRoZSBuZXcgY29kZSBzaG91bGQgbm90IGRvIGFueXRoaW5nIGJ1dCBmYWlsaW5nIHRoZSBzY3JpcHQgZXhlY3V0aW9uLiBUbyBhdm9pZFxyXG4gICAgICAqICBjb25zZW5zdXMgYnVncywgaXQgc2hvdWxkIG5vdCBtb2RpZnkgYW55IGV4aXN0aW5nIHZhbHVlcyAoaW5jbHVkaW5nIGBzdWNjZXNzYCkuXHJcbiAgICAgICovXHJcbiAgICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9QVUJLRVlUWVBFKSAhPSAwKSB7XHJcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9VUEdSQURBQkxFX1BVQktFWVRZUEUnO1xyXG4gICAgICByZXR1cm4gcmV0VmFsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSWYgaXQgcmVhY2hlcyBoZXJlLCB0aGVuIHRydWVcclxuICByZXRWYWwucmVzdWx0ID0gdHJ1ZTtcclxuICByZXR1cm4gcmV0VmFsO1xyXG59XHJcblxyXG4vKipcclxuICogQmFzZWQgb24gYml0Y29pbmQncyBFdmFsQ2hlY2tzaWcgZnVuY3Rpb25cclxuICogYml0Y29pbmQgY29tbWl0OiBhMDk4ODE0MGI3MTQ4NWFkMTJjM2MzYTRhOTU3M2Y3YzIxYjFlZmY4XHJcbiAqIEByZXR1cm5zIHt7IHN1Y2Nlc3M6IEJvb2xlYW4sIHZlcmlmaWVkOiBCb29sZWFuIH19XHJcbiAqL1xyXG5JbnRlcnByZXRlci5wcm90b3R5cGUuX2V2YWxDaGVja1NpZyA9IGZ1bmN0aW9uKGJ1ZlNpZywgYnVmUHVia2V5KSB7XHJcbiAgc3dpdGNoKHRoaXMuc2lndmVyc2lvbikge1xyXG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5CQVNFOlxyXG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwOlxyXG4gICAgICAvLyBjb25zdCB2ZXJpZmllZCA9IHRoaXMuX2V2YWxDaGVja3NpZ1ByZVRhcHNjcmlwdChidWZTaWcsIGJ1ZlB1YmtleSk7XHJcbiAgICAgIC8vIHJldHVybiB7IHN1Y2Nlc3M6IHZlcmlmaWVkLCB2ZXJpZmllZCB9OyAvLyBUaGlzIGlzIHRvIGtlZXAgdGhlIHNhbWUgcmV0dXJuIGZvcm1hdCBhcyBfZXZhbENoZWNrU2lnVGFwc2NyaXB0XHJcbiAgICAgIHJldHVybiB0aGlzLl9ldmFsQ2hlY2tzaWdQcmVUYXBzY3JpcHQoYnVmU2lnLCBidWZQdWJrZXkpO1xyXG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQ6XHJcbiAgICAgIHJldHVybiB0aGlzLl9ldmFsQ2hlY2tzaWdUYXBzY3JpcHQoYnVmU2lnLCBidWZQdWJrZXkpO1xyXG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09UOlxyXG4gICAgICAvLyBLZXkgcGF0aCBzcGVuZGluZyBpbiBUYXByb290IGhhcyBubyBzY3JpcHQsIHNvIHRoaXMgaXMgdW5yZWFjaGFibGUuXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGVkIGV2YWxDaGVja1NpZyB3aXRoIGEgVEFQUk9PVCBzaWd2ZXJzaW9uLiBDaGVjayB5b3VyIGltcGxlbWVudGF0aW9uJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJhc2VkIG9uIGJpdGNvaW5kJ3MgRXZhbFNjcmlwdCBmdW5jdGlvbiwgd2l0aCB0aGUgaW5uZXIgbG9vcCBtb3ZlZCB0b1xyXG4gKiBJbnRlcnByZXRlci5wcm90b3R5cGUuc3RlcCgpXHJcbiAqIGJpdGNvaW5kIGNvbW1pdDogYjVkMWIxMDkyOTk4YmM5NTMxMzg1NmQ1MzVjNjMyZWE1YThmOTEwNFxyXG4gKi9cclxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgLy8gc2lndmVyc2lvbiBjYW5ub3QgYmUgVEFQUk9PVCBoZXJlLCBhcyBpdCBhZG1pdHMgbm8gc2NyaXB0IGV4ZWN1dGlvbi5cclxuICAkLmNoZWNrQXJndW1lbnQodGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UgfHwgdGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjAgfHwgdGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVCwgJ2ludmFsaWQgc2lndmVyc2lvbicpO1xyXG5cclxuICBpZiAoXHJcbiAgICAodGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UgfHwgdGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjApICYmXHJcbiAgICB0aGlzLnNjcmlwdC50b0J1ZmZlcigpLmxlbmd0aCA+IEludGVycHJldGVyLk1BWF9TQ1JJUFRfU0laRVxyXG4gICkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TQ1JJUFRfU0laRSc7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgd2hpbGUgKHRoaXMucGMgPCB0aGlzLnNjcmlwdC5jaHVua3MubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBmU3VjY2VzcyA9IHRoaXMuc3RlcCgpO1xyXG4gICAgICBpZiAoIWZTdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9VTktOT1dOX0VSUk9SOiAnICsgZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICh0aGlzLnZmRXhlYy5sZW5ndGggPiAwKSB7XHJcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOQkFMQU5DRURfQ09ORElUSU9OQUwnO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGEgbG9ja3RpbWUgcGFyYW1ldGVyIHdpdGggdGhlIHRyYW5zYWN0aW9uJ3MgbG9ja3RpbWUuXHJcbiAqIFRoZXJlIGFyZSB0d28gdGltZXMgb2YgbkxvY2tUaW1lOiBsb2NrLWJ5LWJsb2NraGVpZ2h0IGFuZCBsb2NrLWJ5LWJsb2NrdGltZSxcclxuICogZGlzdGluZ3Vpc2hlZCBieSB3aGV0aGVyIG5Mb2NrVGltZSA8IExPQ0tUSU1FX1RIUkVTSE9MRCA9IDUwMDAwMDAwMFxyXG4gKlxyXG4gKiBTZWUgdGhlIGNvcnJlc3BvbmRpbmcgY29kZSBvbiBiaXRjb2luIGNvcmU6XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpdGNvaW4vYmxvYi9mZmQ3NWFkY2UwMWE3OGIzNDYxYjNmZjA1YmNjMmI1MzBhOWNlOTk0L3NyYy9zY3JpcHQvaW50ZXJwcmV0ZXIuY3BwI0wxMTI5XHJcbiAqXHJcbiAqIEBwYXJhbSB7Qk59IG5Mb2NrVGltZSB0aGUgbG9ja3RpbWUgcmVhZCBmcm9tIHRoZSBzY3JpcHRcclxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24ncyBsb2NrdGltZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cclxuICogICAgICAgICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uJ3MgbG9ja3RpbWVcclxuICovXHJcbkludGVycHJldGVyLnByb3RvdHlwZS5jaGVja0xvY2tUaW1lID0gZnVuY3Rpb24obkxvY2tUaW1lKSB7XHJcblxyXG4gIC8vIFdlIHdhbnQgdG8gY29tcGFyZSBhcHBsZXMgdG8gYXBwbGVzLCBzbyBmYWlsIHRoZSBzY3JpcHRcclxuICAvLyB1bmxlc3MgdGhlIHR5cGUgb2YgbkxvY2tUaW1lIGJlaW5nIHRlc3RlZCBpcyB0aGUgc2FtZSBhc1xyXG4gIC8vIHRoZSBuTG9ja1RpbWUgaW4gdGhlIHRyYW5zYWN0aW9uLlxyXG4gIGlmICghKFxyXG4gICAgKHRoaXMudHgubkxvY2tUaW1lIDwgIEludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRCAmJiBuTG9ja1RpbWUubHQoSW50ZXJwcmV0ZXIuTE9DS1RJTUVfVEhSRVNIT0xEX0JOKSkgfHxcclxuICAgICh0aGlzLnR4Lm5Mb2NrVGltZSA+PSBJbnRlcnByZXRlci5MT0NLVElNRV9USFJFU0hPTEQgJiYgbkxvY2tUaW1lLmd0ZShJbnRlcnByZXRlci5MT0NLVElNRV9USFJFU0hPTERfQk4pKVxyXG4gICkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIE5vdyB0aGF0IHdlIGtub3cgd2UncmUgY29tcGFyaW5nIGFwcGxlcy10by1hcHBsZXMsIHRoZVxyXG4gIC8vIGNvbXBhcmlzb24gaXMgYSBzaW1wbGUgbnVtZXJpYyBvbmUuXHJcbiAgaWYgKG5Mb2NrVGltZS5ndChuZXcgQk4odGhpcy50eC5uTG9ja1RpbWUpKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gRmluYWxseSB0aGUgbkxvY2tUaW1lIGZlYXR1cmUgY2FuIGJlIGRpc2FibGVkIGFuZCB0aHVzXHJcbiAgLy8gQ0hFQ0tMT0NLVElNRVZFUklGWSBieXBhc3NlZCBpZiBldmVyeSB0eGluIGhhcyBiZWVuXHJcbiAgLy8gZmluYWxpemVkIGJ5IHNldHRpbmcgblNlcXVlbmNlIHRvIG1heGludC4gVGhlXHJcbiAgLy8gdHJhbnNhY3Rpb24gd291bGQgYmUgYWxsb3dlZCBpbnRvIHRoZSBibG9ja2NoYWluLCBtYWtpbmdcclxuICAvLyB0aGUgb3Bjb2RlIGluZWZmZWN0aXZlLlxyXG4gIC8vXHJcbiAgLy8gVGVzdGluZyBpZiB0aGlzIHZpbiBpcyBub3QgZmluYWwgaXMgc3VmZmljaWVudCB0b1xyXG4gIC8vIHByZXZlbnQgdGhpcyBjb25kaXRpb24uIEFsdGVybmF0aXZlbHkgd2UgY291bGQgdGVzdCBhbGxcclxuICAvLyBpbnB1dHMsIGJ1dCB0ZXN0aW5nIGp1c3QgdGhpcyBpbnB1dCBtaW5pbWl6ZXMgdGhlIGRhdGFcclxuICAvLyByZXF1aXJlZCB0byBwcm92ZSBjb3JyZWN0IENIRUNLTE9DS1RJTUVWRVJJRlkgZXhlY3V0aW9uLlxyXG4gIGlmICghdGhpcy50eC5pbnB1dHNbdGhpcy5uaW5dLmlzRmluYWwoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ2hlY2tzIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHdpdGggdGhlIHRyYW5zYWN0aW9uJ3Mgc2VxdWVuY2UuXHJcbiAqIEBwYXJhbSB7Qk59IG5TZXF1ZW5jZSB0aGUgc2VxdWVuY2UgcmVhZCBmcm9tIHRoZSBzY3JpcHRcclxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24ncyBzZXF1ZW5jZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cclxuICogICAgICAgICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uJ3Mgc2VxdWVuY2UgXHJcbiAqL1xyXG5JbnRlcnByZXRlci5wcm90b3R5cGUuY2hlY2tTZXF1ZW5jZSA9IGZ1bmN0aW9uKG5TZXF1ZW5jZSkge1xyXG5cclxuICAvLyBSZWxhdGl2ZSBsb2NrIHRpbWVzIGFyZSBzdXBwb3J0ZWQgYnkgY29tcGFyaW5nIHRoZSBwYXNzZWQgaW4gb3BlcmFuZCB0b1xyXG4gIC8vIHRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIGlucHV0LlxyXG4gIHZhciB0eFRvU2VxdWVuY2UgPSB0aGlzLnR4LmlucHV0c1t0aGlzLm5pbl0uc2VxdWVuY2VOdW1iZXI7XHJcblxyXG4gIC8vIEZhaWwgaWYgdGhlIHRyYW5zYWN0aW9uJ3MgdmVyc2lvbiBudW1iZXIgaXMgbm90IHNldCBoaWdoIGVub3VnaCB0b1xyXG4gIC8vIHRyaWdnZXIgQklQIDY4IHJ1bGVzLlxyXG4gIGlmICh0aGlzLnR4LnZlcnNpb24gPCAyKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBTZXF1ZW5jZSBudW1iZXJzIHdpdGggdGhlaXIgbW9zdCBzaWduaWZpY2FudCBiaXQgc2V0IGFyZSBub3QgY29uc2Vuc3VzXHJcbiAgLy8gY29uc3RyYWluZWQuIFRlc3RpbmcgdGhhdCB0aGUgdHJhbnNhY3Rpb24ncyBzZXF1ZW5jZSBudW1iZXIgZG8gbm90IGhhdmVcclxuICAvLyB0aGlzIGJpdCBzZXQgcHJldmVudHMgdXNpbmcgdGhpcyBwcm9wZXJ0eSB0byBnZXQgYXJvdW5kIGFcclxuICAvLyBDSEVDS1NFUVVFTkNFVkVSSUZZIGNoZWNrLlxyXG4gIGlmICh0eFRvU2VxdWVuY2UgJiBTRVFVRU5DRV9MT0NLVElNRV9ESVNBQkxFX0ZMQUcpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIE1hc2sgb2ZmIGFueSBiaXRzIHRoYXQgZG8gbm90IGhhdmUgY29uc2Vuc3VzLWVuZm9yY2VkIG1lYW5pbmcgYmVmb3JlXHJcbiAgLy8gZG9pbmcgdGhlIGludGVnZXIgY29tcGFyaXNvbnNcclxuICB2YXIgbkxvY2tUaW1lTWFzayA9XHJcbiAgICAgIEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBRyB8IEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX01BU0s7XHJcbiAgdmFyIHR4VG9TZXF1ZW5jZU1hc2tlZCA9IG5ldyBCTih0eFRvU2VxdWVuY2UgJiBuTG9ja1RpbWVNYXNrKTtcclxuICB2YXIgblNlcXVlbmNlTWFza2VkID0gblNlcXVlbmNlLmFuZChuTG9ja1RpbWVNYXNrKTtcclxuXHJcbiAgLy8gVGhlcmUgYXJlIHR3byBraW5kcyBvZiBuU2VxdWVuY2U6IGxvY2stYnktYmxvY2toZWlnaHQgYW5kXHJcbiAgLy8gbG9jay1ieS1ibG9ja3RpbWUsIGRpc3Rpbmd1aXNoZWQgYnkgd2hldGhlciBuU2VxdWVuY2VNYXNrZWQgPFxyXG4gIC8vIENUeEluOjpTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcuXHJcbiAgLy9cclxuICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgYXBwbGVzIHRvIGFwcGxlcywgc28gZmFpbCB0aGUgc2NyaXB0IHVubGVzcyB0aGUgdHlwZVxyXG4gIC8vIG9mIG5TZXF1ZW5jZU1hc2tlZCBiZWluZyB0ZXN0ZWQgaXMgdGhlIHNhbWUgYXMgdGhlIG5TZXF1ZW5jZU1hc2tlZCBpbiB0aGVcclxuICAvLyB0cmFuc2FjdGlvbi5cclxuICB2YXIgU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOID0gbmV3IEJOKEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBRyk7XHJcbiAgXHJcbiAgaWYgKCEoKHR4VG9TZXF1ZW5jZU1hc2tlZC5sdChTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUdfQk4pICAmJlxyXG4gICAgICAgICAgblNlcXVlbmNlTWFza2VkLmx0KFNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBR19CTikpIHx8XHJcbiAgICAgICAgKHR4VG9TZXF1ZW5jZU1hc2tlZC5ndGUoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSAmJlxyXG4gICAgICAgICAgblNlcXVlbmNlTWFza2VkLmd0ZShTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUdfQk4pKSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIE5vdyB0aGF0IHdlIGtub3cgd2UncmUgY29tcGFyaW5nIGFwcGxlcy10by1hcHBsZXMsIHRoZSBjb21wYXJpc29uIGlzIGFcclxuICAvLyBzaW1wbGUgbnVtZXJpYyBvbmUuXHJcbiAgcmV0dXJuIG5TZXF1ZW5jZU1hc2tlZC5sdGUodHhUb1NlcXVlbmNlTWFza2VkKVxyXG59XHJcblxyXG5cclxuSW50ZXJwcmV0ZXIuY29tcHV0ZVRhcGxlYWZIYXNoID0gZnVuY3Rpb24obGVhZlZlcnNpb24sIHNjcmlwdEJ1Zikge1xyXG4gIGNvbnN0IHRhZ1dyaXRlciA9IFRhZ2dlZEhhc2guVEFQTEVBRjtcclxuICB0YWdXcml0ZXIud3JpdGVVSW50OChsZWFmVmVyc2lvbik7XHJcbiAgdGFnV3JpdGVyLndyaXRlVmFyaW50TnVtKHNjcmlwdEJ1Zi5sZW5ndGgpO1xyXG4gIHRhZ1dyaXRlci53cml0ZShzY3JpcHRCdWYpO1xyXG4gIHJldHVybiB0YWdXcml0ZXIuZmluYWxpemUoKTtcclxufTtcclxuXHJcblxyXG5JbnRlcnByZXRlci5jb21wdXRlVGFwcm9vdE1lcmtsZVJvb3QgPSBmdW5jdGlvbihjb250cm9sLCB0YXBsZWFmSGFzaCkge1xyXG4gIGNvbnN0IHBhdGhMZW4gPSAoY29udHJvbC5sZW5ndGggLSBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfQkFTRV9TSVpFKSAvIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9OT0RFX1NJWkU7XHJcbiAgbGV0IGsgPSB0YXBsZWFmSGFzaDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhMZW47ICsraSkge1xyXG4gICAgY29uc3QgdGFnV3JpdGVyID0gVGFnZ2VkSGFzaC5UQVBCUkFOQ0g7XHJcbiAgICBjb25zdCBzdGFydCA9IEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUgKyBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTk9ERV9TSVpFICogaTtcclxuICAgIGNvbnN0IG5vZGUgPSBjb250cm9sLnNsaWNlKHN0YXJ0LCBzdGFydCArIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9OT0RFX1NJWkUpO1xyXG4gICAgaWYgKEJ1ZmZlci5jb21wYXJlKGssIG5vZGUpID09PSAtMSkge1xyXG4gICAgICB0YWdXcml0ZXIud3JpdGUoayk7XHJcbiAgICAgIHRhZ1dyaXRlci53cml0ZShub2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRhZ1dyaXRlci53cml0ZShub2RlKTtcclxuICAgICAgdGFnV3JpdGVyLndyaXRlKGspO1xyXG4gICAgfVxyXG4gICAgayA9IHRhZ1dyaXRlci5maW5hbGl6ZSgpO1xyXG4gIH1cclxuICByZXR1cm4gaztcclxufTtcclxuXHJcblxyXG5JbnRlcnByZXRlci52ZXJpZnlUYXByb290Q29tbWl0bWVudCA9IGZ1bmN0aW9uKGNvbnRyb2wsIHByb2dyYW0sIHRhcGxlYWZIYXNoKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KGNvbnRyb2wubGVuZ3RoID49IEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUsICdjb250cm9sIHRvbyBzaG9ydCcpO1xyXG4gICQuY2hlY2tBcmd1bWVudChwcm9ncmFtLmxlbmd0aCA+PSAzMiwgJ3Byb2dyYW0gaXMgdG9vIHNob3J0Jyk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyEgVGhlIGludGVybmFsIHB1YmtleSAoeC1vbmx5LCBzbyBubyBZIGNvb3JkaW5hdGUgcGFyaXR5KS5cclxuICAgIGNvbnN0IHAgPSBQdWJsaWNLZXkuZnJvbVgoZmFsc2UsIGNvbnRyb2wuc2xpY2UoMSwgSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSkpO1xyXG4gICAgLy8hIFRoZSBvdXRwdXQgcHVia2V5ICh0YWtlbiBmcm9tIHRoZSBzY3JpcHRQdWJLZXkpLlxyXG4gICAgY29uc3QgcSA9IFB1YmxpY0tleS5mcm9tWChmYWxzZSwgcHJvZ3JhbSk7XHJcbiAgICAvLyBDb21wdXRlIHRoZSBNZXJrbGUgcm9vdCBmcm9tIHRoZSBsZWFmIGFuZCB0aGUgcHJvdmlkZWQgcGF0aC5cclxuICAgIGNvbnN0IG1lcmtsZVJvb3QgPSBJbnRlcnByZXRlci5jb21wdXRlVGFwcm9vdE1lcmtsZVJvb3QoY29udHJvbCwgdGFwbGVhZkhhc2gpO1xyXG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIG91dHB1dCBwdWJrZXkgbWF0Y2hlcyB0aGUgdHdlYWtlZCBpbnRlcm5hbCBwdWJrZXksIGFmdGVyIGNvcnJlY3RpbmcgZm9yIHBhcml0eS5cclxuICAgIHJldHVybiBxLmNoZWNrVGFwVHdlYWsocCwgbWVya2xlUm9vdCwgY29udHJvbCk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKiBcclxuICogQmFzZWQgb24gdGhlIGlubmVyIGxvb3Agb2YgYml0Y29pbmQncyBFdmFsU2NyaXB0IGZ1bmN0aW9uXHJcbiAqIGJpdGNvaW5kIGNvbW1pdDogYjVkMWIxMDkyOTk4YmM5NTMxMzg1NmQ1MzVjNjMyZWE1YThmOTEwNFxyXG4gKi9cclxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZlJlcXVpcmVNaW5pbWFsID0gKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX01JTklNQUxEQVRBKSAhPT0gMDtcclxuXHJcbiAgLy9ib29sIGZFeGVjID0gIWNvdW50KHZmRXhlYy5iZWdpbigpLCB2ZkV4ZWMuZW5kKCksIGZhbHNlKTtcclxuICB2YXIgZkV4ZWMgPSAodGhpcy52ZkV4ZWMuaW5kZXhPZihmYWxzZSkgPT09IC0xKTtcclxuICB2YXIgYnVmLCBidWYxLCBidWYyLCBzcGxpY2VkLCBuLCB4MSwgeDIsIGJuLCBibjEsIGJuMiwgYnVmU2lnLCBidWZQdWJrZXksIHN1YnNjcmlwdDtcclxuICB2YXIgc2lnLCBwdWJrZXk7XHJcbiAgdmFyIGZWYWx1ZSwgZlN1Y2Nlc3M7XHJcbiAgdGhpcy5leGVjZGF0YSA9IHRoaXMuZXhlY2RhdGEgfHwge307XHJcbiAgaWYgKCF0aGlzLmV4ZWNkYXRhLmNvZGVzZXBhcmF0b3JQb3NJbml0KSB7XHJcbiAgICB0aGlzLmV4ZWNkYXRhLmNvZGVzZXBhcmF0b3JQb3MgPSBuZXcgQk4oMHhGRkZGRkZGRik7XHJcbiAgICB0aGlzLmV4ZWNkYXRhLmNvZGVzZXBhcmF0b3JQb3NJbml0ID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFJlYWQgaW5zdHJ1Y3Rpb25cclxuICB2YXIgY2h1bmsgPSB0aGlzLnNjcmlwdC5jaHVua3NbdGhpcy5wY107XHJcbiAgdGhpcy5wYysrO1xyXG4gIHZhciBvcGNvZGVudW0gPSBjaHVuay5vcGNvZGVudW07XHJcbiAgaWYgKF8uaXNVbmRlZmluZWQob3Bjb2RlbnVtKSkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9VTkRFRklORURfT1BDT0RFJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKGNodW5rLmJ1ZiAmJiBjaHVuay5idWYubGVuZ3RoID4gSW50ZXJwcmV0ZXIuTUFYX1NDUklQVF9FTEVNRU5UX1NJWkUpIHtcclxuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfUFVTSF9TSVpFJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICh0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UgfHwgdGhpcy5zaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwKSB7XHJcbiAgICAvLyBOb3RlIGhvdyBPcGNvZGUuT1BfUkVTRVJWRUQgZG9lcyBub3QgY291bnQgdG93YXJkcyB0aGUgb3Bjb2RlIGxpbWl0LlxyXG4gICAgaWYgKG9wY29kZW51bSA+IE9wY29kZS5PUF8xNiAmJiArKyh0aGlzLm5PcENvdW50KSA+IDIwMSkge1xyXG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX09QX0NPVU5UJztcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9DQVQgfHxcclxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1NVQlNUUiB8fFxyXG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfTEVGVCB8fFxyXG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUklHSFQgfHxcclxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0lOVkVSVCB8fFxyXG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfQU5EIHx8XHJcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9PUiB8fFxyXG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfWE9SIHx8XHJcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF8yTVVMIHx8XHJcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF8yRElWIHx8XHJcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9NVUwgfHxcclxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0RJViB8fFxyXG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfTU9EIHx8XHJcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9MU0hJRlQgfHxcclxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1JTSElGVCkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9ESVNBQkxFRF9PUENPREUnO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gV2l0aCBTQ1JJUFRfVkVSSUZZX0NPTlNUX1NDUklQVENPREUsIE9QX0NPREVTRVBBUkFUT1IgaW4gbm9uLXNlZ3dpdCBzY3JpcHQgaXMgcmVqZWN0ZWQgZXZlbiBpbiBhbiB1bmV4ZWN1dGVkIGJyYW5jaFxyXG4gIGlmIChvcGNvZGVudW0gPT0gT3Bjb2RlLk9QX0NPREVTRVBBUkFUT1IgJiYgdGhpcy5zaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5CQVNFICYmICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9DT05TVF9TQ1JJUFRDT0RFKSkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9PUF9DT0RFU0VQQVJBVE9SJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChmRXhlYyAmJiAwIDw9IG9wY29kZW51bSAmJiBvcGNvZGVudW0gPD0gT3Bjb2RlLk9QX1BVU0hEQVRBNCkge1xyXG4gICAgaWYgKGZSZXF1aXJlTWluaW1hbCAmJiAhdGhpcy5zY3JpcHQuY2hlY2tNaW5pbWFsUHVzaCh0aGlzLnBjIC0gMSkpIHtcclxuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9NSU5JTUFMREFUQSc7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghY2h1bmsuYnVmKSB7XHJcbiAgICAgIHRoaXMuc3RhY2sucHVzaChJbnRlcnByZXRlci5mYWxzZSk7XHJcbiAgICB9IGVsc2UgaWYgKGNodW5rLmxlbiAhPT0gY2h1bmsuYnVmLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBvZiBwdXNoIHZhbHVlIG5vdCBlcXVhbCB0byBsZW5ndGggb2YgZGF0YScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdGFjay5wdXNoKGNodW5rLmJ1Zik7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChmRXhlYyB8fCAoT3Bjb2RlLk9QX0lGIDw9IG9wY29kZW51bSAmJiBvcGNvZGVudW0gPD0gT3Bjb2RlLk9QX0VORElGKSkge1xyXG4gICAgc3dpdGNoIChvcGNvZGVudW0pIHtcclxuICAgICAgLy8gUHVzaCB2YWx1ZVxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8xTkVHQVRFOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8xOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8yOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8zOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF80OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF81OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF82OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF83OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF84OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF85OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8xMDpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfMTE6XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzEyOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8xMzpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfMTQ6XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzE1OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8xNjpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAoIC0tIHZhbHVlKVxyXG4gICAgICAgICAgLy8gU2NyaXB0TnVtIGJuKChpbnQpb3Bjb2RlIC0gKGludCkoT3Bjb2RlLk9QXzEgLSAxKSk7XHJcbiAgICAgICAgICBuID0gb3Bjb2RlbnVtIC0gKE9wY29kZS5PUF8xIC0gMSk7XHJcbiAgICAgICAgICBidWYgPSBuZXcgQk4obikudG9TY3JpcHROdW1CdWZmZXIoKTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYpO1xyXG4gICAgICAgICAgLy8gVGhlIHJlc3VsdCBvZiB0aGVzZSBvcGNvZGVzIHNob3VsZCBhbHdheXMgYmUgdGhlIG1pbmltYWwgd2F5IHRvIHB1c2ggdGhlIGRhdGFcclxuICAgICAgICAgIC8vIHRoZXkgcHVzaCwgc28gbm8gbmVlZCBmb3IgYSBDaGVja01pbmltYWxQdXNoIGhlcmUuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBDb250cm9sXHJcbiAgICAgICAgLy9cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QOlxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QMjpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tMT0NLVElNRVZFUklGWTpcclxuXHJcbiAgICAgICAgaWYgKCEodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ0hFQ0tMT0NLVElNRVZFUklGWSkpIHtcclxuICAgICAgICAgIC8vIG5vdCBlbmFibGVkOyB0cmVhdCBhcyBhIE5PUDJcclxuICAgICAgICAgIGlmICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfTk9QUykge1xyXG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9OT1BTJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdGUgdGhhdCBlbHNld2hlcmUgbnVtZXJpYyBvcGNvZGVzIGFyZSBsaW1pdGVkIHRvXHJcbiAgICAgICAgLy8gb3BlcmFuZHMgaW4gdGhlIHJhbmdlIC0yKiozMSsxIHRvIDIqKjMxLTEsIGhvd2V2ZXIgaXQgaXNcclxuICAgICAgICAvLyBsZWdhbCBmb3Igb3Bjb2RlcyB0byBwcm9kdWNlIHJlc3VsdHMgZXhjZWVkaW5nIHRoYXRcclxuICAgICAgICAvLyByYW5nZS4gVGhpcyBsaW1pdGF0aW9uIGlzIGltcGxlbWVudGVkIGJ5IENTY3JpcHROdW0nc1xyXG4gICAgICAgIC8vIGRlZmF1bHQgNC1ieXRlIGxpbWl0LlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gSWYgd2Uga2VwdCB0byB0aGF0IGxpbWl0IHdlJ2QgaGF2ZSBhIHllYXIgMjAzOCBwcm9ibGVtLFxyXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZSBuTG9ja1RpbWUgZmllbGQgaW4gdHJhbnNhY3Rpb25zXHJcbiAgICAgICAgLy8gdGhlbXNlbHZlcyBpcyB1aW50MzIgd2hpY2ggb25seSBiZWNvbWVzIG1lYW5pbmdsZXNzXHJcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHllYXIgMjEwNi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRodXMgYXMgYSBzcGVjaWFsIGNhc2Ugd2UgdGVsbCBDU2NyaXB0TnVtIHRvIGFjY2VwdCB1cFxyXG4gICAgICAgIC8vIHRvIDUtYnl0ZSBiaWdudW1zLCB3aGljaCBhcmUgZ29vZCB1bnRpbCAyKiozOS0xLCB3ZWxsXHJcbiAgICAgICAgLy8gYmV5b25kIHRoZSAyKiozMi0xIGxpbWl0IG9mIHRoZSBuTG9ja1RpbWUgZmllbGQgaXRzZWxmLlxyXG4gICAgICAgIHZhciBuTG9ja1RpbWUgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSwgZlJlcXVpcmVNaW5pbWFsLCA1KTtcclxuXHJcbiAgICAgICAgLy8gSW4gdGhlIHJhcmUgZXZlbnQgdGhhdCB0aGUgYXJndW1lbnQgbWF5IGJlIDwgMCBkdWUgdG9cclxuICAgICAgICAvLyBzb21lIGFyaXRobWV0aWMgYmVpbmcgZG9uZSBmaXJzdCwgeW91IGNhbiBhbHdheXMgdXNlXHJcbiAgICAgICAgLy8gMCBNQVggQ0hFQ0tMT0NLVElNRVZFUklGWS5cclxuICAgICAgICBpZiAobkxvY2tUaW1lLmx0KG5ldyBCTigwKSkpIHtcclxuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfTkVHQVRJVkVfTE9DS1RJTUUnO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWN0dWFsbHkgY29tcGFyZSB0aGUgc3BlY2lmaWVkIGxvY2sgdGltZSB3aXRoIHRoZSB0cmFuc2FjdGlvbi5cclxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tMb2NrVGltZShuTG9ja1RpbWUpKSB7XHJcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOU0FUSVNGSUVEX0xPQ0tUSU1FJztcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1AzOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9DSEVDS1NFUVVFTkNFVkVSSUZZOlxyXG5cclxuICAgICAgICBpZiAoISh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9DSEVDS1NFUVVFTkNFVkVSSUZZKSkge1xyXG4gICAgICAgICAgLy8gbm90IGVuYWJsZWQ7IHRyZWF0IGFzIGEgTk9QM1xyXG4gICAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9OT1BTKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9VUEdSQURBQkxFX05PUFMnO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIG5TZXF1ZW5jZSwgbGlrZSBuTG9ja1RpbWUsIGlzIGEgMzItYml0IHVuc2lnbmVkXHJcbiAgICAgICAgLy8gaW50ZWdlciBmaWVsZC4gU2VlIHRoZSBjb21tZW50IGluIENIRUNLTE9DS1RJTUVWRVJJRllcclxuICAgICAgICAvLyByZWdhcmRpbmcgNS1ieXRlIG51bWVyaWMgb3BlcmFuZHMuXHJcblxyXG4gICAgICAgIHZhciBuU2VxdWVuY2UgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSwgZlJlcXVpcmVNaW5pbWFsLCA1KTtcclxuXHJcblxyXG4gICAgICAgIC8vIEluIHRoZSByYXJlIGV2ZW50IHRoYXQgdGhlIGFyZ3VtZW50IG1heSBiZSA8IDAgZHVlIHRvXHJcbiAgICAgICAgLy8gc29tZSBhcml0aG1ldGljIGJlaW5nIGRvbmUgZmlyc3QsIHlvdSBjYW4gYWx3YXlzIHVzZVxyXG4gICAgICAgIC8vIDAgTUFYIENIRUNLU0VRVUVOQ0VWRVJJRlkuXHJcbiAgICAgICAgaWYgKG5TZXF1ZW5jZS5sdChuZXcgQk4oMCkpKSB7XHJcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX05FR0FUSVZFX0xPQ0tUSU1FJztcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRvIHByb3ZpZGUgZm9yIGZ1dHVyZSBzb2Z0LWZvcmsgZXh0ZW5zaWJpbGl0eSwgaWYgdGhlXHJcbiAgICAgICAgLy8gb3BlcmFuZCBoYXMgdGhlIGRpc2FibGVkIGxvY2stdGltZSBmbGFnIHNldCxcclxuICAgICAgICAvLyBDSEVDS1NFUVVFTkNFVkVSSUZZIGJlaGF2ZXMgYXMgYSBOT1AuXHJcbiAgICAgICAgaWYgKChuU2VxdWVuY2UgJlxyXG4gICAgICAgICAgSW50ZXJwcmV0ZXIuU0VRVUVOQ0VfTE9DS1RJTUVfRElTQUJMRV9GTEFHKSAhPSAwKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFjdHVhbGx5IGNvbXBhcmUgdGhlIHNwZWNpZmllZCBsb2NrIHRpbWUgd2l0aCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrU2VxdWVuY2UoblNlcXVlbmNlKSkge1xyXG4gICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9VTlNBVElTRklFRF9MT0NLVElNRSc7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuXHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1AxOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A0OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A1OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A2OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A3OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A4OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A5OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1AxMDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX05PUFMpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9ESVNDT1VSQUdFX1VQR1JBREFCTEVfTk9QUyc7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9JRjpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9USUY6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gPGV4cHJlc3Npb24+IGlmIFtzdGF0ZW1lbnRzXSBbZWxzZSBbc3RhdGVtZW50c11dIGVuZGlmXHJcbiAgICAgICAgICAvLyBib29sIGZWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgZlZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAoZkV4ZWMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVU5CQUxBTkNFRF9DT05ESVRJT05BTCc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgICAgICAvLyBUYXBzY3JpcHQgcmVxdWlyZXMgbWluaW1hbCBJRi9OT1RJRiBpbnB1dHMgYXMgYSBjb25zZW5zdXMgcnVsZS5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUKSB7XHJcbiAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IGFyZ3VtZW50IHRvIHRoZSBPUF9JRiBhbmQgT1BfTk9USUYgb3Bjb2RlcyBtdXN0IGJlIGVpdGhlclxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0bHkgMCAodGhlIGVtcHR5IHZlY3Rvcikgb3IgZXhhY3RseSAxICh0aGUgb25lLWJ5dGUgdmVjdG9yIHdpdGggdmFsdWUgMSkuXHJcbiAgICAgICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPiAxIHx8IChidWYubGVuZ3RoID09PSAxICYmIGJ1ZlswXSAhPT0gMSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVEFQU0NSSVBUX01JTklNQUxJRic7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVuZGVyIHdpdG5lc3MgdjAgcnVsZXMgaXQgaXMgb25seSBhIHBvbGljeSBydWxlLCBlbmFibGVkIHRocm91Z2ggU0NSSVBUX1ZFUklGWV9NSU5JTUFMSUYuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjAgJiYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX01JTklNQUxJRikpIHtcclxuICAgICAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX01JTklNQUxJRic7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChidWYubGVuZ3RoID09IDEgJiYgYnVmWzBdIT0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX01JTklNQUxJRic7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZWYWx1ZSA9IEludGVycHJldGVyLmNhc3RUb0Jvb2woYnVmKTtcclxuICAgICAgICAgICAgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX05PVElGKSB7XHJcbiAgICAgICAgICAgICAgZlZhbHVlID0gIWZWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy52ZkV4ZWMucHVzaChmVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0VMU0U6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWYgKHRoaXMudmZFeGVjLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOQkFMQU5DRURfQ09ORElUSU9OQUwnO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnZmRXhlY1t0aGlzLnZmRXhlYy5sZW5ndGggLSAxXSA9ICF0aGlzLnZmRXhlY1t0aGlzLnZmRXhlYy5sZW5ndGggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9FTkRJRjpcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAodGhpcy52ZkV4ZWMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVU5CQUxBTkNFRF9DT05ESVRJT05BTCc7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMudmZFeGVjLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1ZFUklGWTpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAodHJ1ZSAtLSApIG9yXHJcbiAgICAgICAgICAvLyAoZmFsc2UgLS0gZmFsc2UpIGFuZCByZXR1cm5cclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgIGZWYWx1ZSA9IEludGVycHJldGVyLmNhc3RUb0Jvb2woYnVmKTtcclxuICAgICAgICAgIGlmIChmVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVkVSSUZZJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1JFVFVSTjpcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX09QX1JFVFVSTic7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBTdGFjayBvcHNcclxuICAgICAgICAvL1xyXG4gICAgICBjYXNlIE9wY29kZS5PUF9UT0FMVFNUQUNLOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuYWx0c3RhY2sucHVzaCh0aGlzLnN0YWNrLnBvcCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9GUk9NQUxUU1RBQ0s6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWYgKHRoaXMuYWx0c3RhY2subGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfQUxUU1RBQ0tfT1BFUkFUSU9OJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuYWx0c3RhY2sucG9wKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzJEUk9QOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4MSB4MiAtLSApXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8yRFVQOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4MSB4MiAtLSB4MSB4MiB4MSB4MilcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJ1ZjEgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICBidWYyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1ZjEpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1ZjIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzNEVVA6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gKHgxIHgyIHgzIC0tIHgxIHgyIHgzIHgxIHgyIHgzKVxyXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnVmMSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAzXTtcclxuICAgICAgICAgIGJ1ZjIgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICB2YXIgYnVmMyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYxKTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYyKTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8yT1ZFUjpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAoeDEgeDIgeDMgeDQgLS0geDEgeDIgeDMgeDQgeDEgeDIpXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCA0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBidWYxID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDRdO1xyXG4gICAgICAgICAgYnVmMiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAzXTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYxKTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF8yUk9UOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4MSB4MiB4MyB4NCB4NSB4NiAtLSB4MyB4NCB4NSB4NiB4MSB4MilcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDYpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNwbGljZWQgPSB0aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aCAtIDYsIDIpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHNwbGljZWRbMF0pO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHNwbGljZWRbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzJTV0FQOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4MSB4MiB4MyB4NCAtLSB4MyB4NCB4MSB4MilcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDQpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNwbGljZWQgPSB0aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aCAtIDQsIDIpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHNwbGljZWRbMF0pO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHNwbGljZWRbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0lGRFVQOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4IC0gMCB8IHggeClcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgIGZWYWx1ZSA9IEludGVycHJldGVyLmNhc3RUb0Jvb2woYnVmKTtcclxuICAgICAgICAgIGlmIChmVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1Zik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfREVQVEg6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gLS0gc3RhY2tzaXplXHJcbiAgICAgICAgICBidWYgPSBuZXcgQk4odGhpcy5zdGFjay5sZW5ndGgpLnRvU2NyaXB0TnVtQnVmZmVyKCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9EUk9QOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4IC0tIClcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfRFVQOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4IC0tIHggeClcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05JUDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAoeDEgeDIgLS0geDIpXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aCAtIDIsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX09WRVI6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gKHgxIHgyIC0tIHgxIHgyIHgxKVxyXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfUElDSzpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfUk9MTDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAoeG4gLi4uIHgyIHgxIHgwIG4gLSB4biAuLi4geDIgeDEgeDAgeG4pXHJcbiAgICAgICAgICAvLyAoeG4gLi4uIHgyIHgxIHgwIG4gLSAuLi4geDIgeDEgeDAgeG4pXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICBibiA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIoYnVmLCBmUmVxdWlyZU1pbmltYWwpO1xyXG4gICAgICAgICAgbiA9IGJuLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSBuIC0gMV07XHJcbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUk9MTCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aCAtIG4gLSAxLCAxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1JPVDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAoeDEgeDIgeDMgLS0geDIgeDMgeDEpXHJcbiAgICAgICAgICAvLyAgeDIgeDEgeDMgIGFmdGVyIGZpcnN0IHN3YXBcclxuICAgICAgICAgIC8vICB4MiB4MyB4MSAgYWZ0ZXIgc2Vjb25kIHN3YXBcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHgxID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDNdO1xyXG4gICAgICAgICAgeDIgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICB2YXIgeDMgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gM10gPSB4MjtcclxuICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXSA9IHgzO1xyXG4gICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0geDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfU1dBUDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAoeDEgeDIgLS0geDIgeDEpXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB4MSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTtcclxuICAgICAgICAgIHgyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdID0geDI7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPSB4MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9UVUNLOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4MSB4MiAtLSB4MiB4MSB4MilcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhY2suc3BsaWNlKHRoaXMuc3RhY2subGVuZ3RoIC0gMiwgMCwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfU0laRTpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAoaW4gLS0gaW4gc2l6ZSlcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJuID0gbmV3IEJOKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXS5sZW5ndGgpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJuLnRvU2NyaXB0TnVtQnVmZmVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gQml0d2lzZSBsb2dpY1xyXG4gICAgICAgIC8vXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0VRVUFMOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9FUVVBTFZFUklGWTpcclxuICAgICAgICAvL2Nhc2UgT3Bjb2RlLk9QX05PVEVRVUFMOiAvLyB1c2UgT3Bjb2RlLk9QX05VTU5PVEVRVUFMXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gKHgxIHgyIC0gYm9vbClcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJ1ZjEgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICBidWYyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgdmFyIGZFcXVhbCA9IGJ1ZjEudG9TdHJpbmcoJ2hleCcpID09PSBidWYyLnRvU3RyaW5nKCdoZXgnKTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZFcXVhbCA/IEludGVycHJldGVyLnRydWUgOiBJbnRlcnByZXRlci5mYWxzZSk7XHJcbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfRVFVQUxWRVJJRlkpIHtcclxuICAgICAgICAgICAgaWYgKGZFcXVhbCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9FUVVBTFZFUklGWSc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBOdW1lcmljXHJcbiAgICAgICAgLy9cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfMUFERDpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfMVNVQjpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfTkVHQVRFOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9BQlM6XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PVDpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfME5PVEVRVUFMOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vIChpbiAtLSBvdXQpXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICBibiA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIoYnVmLCBmUmVxdWlyZU1pbmltYWwpO1xyXG4gICAgICAgICAgc3dpdGNoIChvcGNvZGVudW0pIHtcclxuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfMUFERDpcclxuICAgICAgICAgICAgICBibiA9IGJuLmFkZChCTi5PbmUpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF8xU1VCOlxyXG4gICAgICAgICAgICAgIGJuID0gYm4uc3ViKEJOLk9uZSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX05FR0FURTpcclxuICAgICAgICAgICAgICBibiA9IGJuLm5lZygpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9BQlM6XHJcbiAgICAgICAgICAgICAgaWYgKGJuLmNtcChCTi5aZXJvKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGJuID0gYm4ubmVnKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9OT1Q6XHJcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKGJuLmNtcChCTi5aZXJvKSA9PT0gMCkgKyAwKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfME5PVEVRVUFMOlxyXG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibi5jbXAoQk4uWmVybykgIT09IDApICsgMCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgLy9kZWZhdWx0OiAgICAgIGFzc2VydCghJ2ludmFsaWQgb3Bjb2RlJyk7IGJyZWFrOyAvLyBUT0RPOiBkb2VzIHRoaXMgZXZlciBvY2N1cj9cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYm4udG9TY3JpcHROdW1CdWZmZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfQUREOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9TVUI6XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0JPT0xBTkQ6XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0JPT0xPUjpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfTlVNRVFVQUw6XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMVkVSSUZZOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9OVU1OT1RFUVVBTDpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfTEVTU1RIQU46XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9MRVNTVEhBTk9SRVFVQUw6XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOT1JFUVVBTDpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfTUlOOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9NQVg6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gKHgxIHgyIC0tIG91dClcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJuMSA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdLCBmUmVxdWlyZU1pbmltYWwpO1xyXG4gICAgICAgICAgYm4yID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0sIGZSZXF1aXJlTWluaW1hbCk7XHJcbiAgICAgICAgICBibiA9IG5ldyBCTigwKTtcclxuXHJcbiAgICAgICAgICBzd2l0Y2ggKG9wY29kZW51bSkge1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9BREQ6XHJcbiAgICAgICAgICAgICAgYm4gPSBibjEuYWRkKGJuMik7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9TVUI6XHJcbiAgICAgICAgICAgICAgYm4gPSBibjEuc3ViKGJuMik7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0JPT0xBTkQ6ICAgICAgIGJuID0gKGJuMSAhPSBiblplcm8gJiYgYm4yICE9IGJuWmVybyk7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9CT09MQU5EOlxyXG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKCgoYm4xLmNtcChCTi5aZXJvKSAhPT0gMCkgJiYgKGJuMi5jbXAoQk4uWmVybykgIT09IDApKSArIDApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0JPT0xPUjogICAgICAgIGJuID0gKGJuMSAhPSBiblplcm8gfHwgYm4yICE9IGJuWmVybyk7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9CT09MT1I6XHJcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKChibjEuY21wKEJOLlplcm8pICE9PSAwKSB8fCAoYm4yLmNtcChCTi5aZXJvKSAhPT0gMCkpICsgMCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgLy8gY2FzZSBPcGNvZGUuT1BfTlVNRVFVQUw6ICAgICAgYm4gPSAoYm4xID09IGJuMik7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9OVU1FUVVBTDpcclxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoYm4xLmNtcChibjIpID09PSAwKSArIDApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMVkVSSUZZOiAgICBibiA9IChibjEgPT0gYm4yKTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMVkVSSUZZOlxyXG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibjEuY21wKGJuMikgPT09IDApICsgMCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgLy8gY2FzZSBPcGNvZGUuT1BfTlVNTk9URVFVQUw6ICAgICBibiA9IChibjEgIT0gYm4yKTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX05VTU5PVEVRVUFMOlxyXG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibjEuY21wKGJuMikgIT09IDApICsgMCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgLy8gY2FzZSBPcGNvZGUuT1BfTEVTU1RIQU46ICAgICAgYm4gPSAoYm4xIDwgYm4yKTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX0xFU1NUSEFOOlxyXG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibjEuY21wKGJuMikgPCAwKSArIDApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOOiAgICAgYm4gPSAoYm4xID4gYm4yKTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOOlxyXG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibjEuY21wKGJuMikgPiAwKSArIDApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0xFU1NUSEFOT1JFUVVBTDogICBibiA9IChibjEgPD0gYm4yKTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX0xFU1NUSEFOT1JFUVVBTDpcclxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoYm4xLmNtcChibjIpIDw9IDApICsgMCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgLy8gY2FzZSBPcGNvZGUuT1BfR1JFQVRFUlRIQU5PUkVRVUFMOiAgYm4gPSAoYm4xID49IGJuMik7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9HUkVBVEVSVEhBTk9SRVFVQUw6XHJcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKGJuMS5jbXAoYm4yKSA+PSAwKSArIDApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9NSU46XHJcbiAgICAgICAgICAgICAgYm4gPSAoYm4xLmNtcChibjIpIDwgMCA/IGJuMSA6IGJuMik7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX01BWDpcclxuICAgICAgICAgICAgICBibiA9IChibjEuY21wKGJuMikgPiAwID8gYm4xIDogYm4yKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAvLyBkZWZhdWx0OiAgICAgICAgICAgYXNzZXJ0KCEnaW52YWxpZCBvcGNvZGUnKTsgYnJlYWs7IC8vVE9ETzogZG9lcyB0aGlzIGV2ZXIgb2NjdXI/XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChibi50b1NjcmlwdE51bUJ1ZmZlcigpKTtcclxuXHJcbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfTlVNRVFVQUxWRVJJRlkpIHtcclxuICAgICAgICAgICAgLy8gaWYgKENhc3RUb0Jvb2woc3RhY2t0b3AoLTEpKSlcclxuICAgICAgICAgICAgaWYgKEludGVycHJldGVyLmNhc3RUb0Jvb2wodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdKSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9OVU1FUVVBTFZFUklGWSc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfV0lUSElOOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vICh4IG1pbiBtYXggLS0gb3V0KVxyXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYm4xID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gM10sIGZSZXF1aXJlTWluaW1hbCk7XHJcbiAgICAgICAgICBibjIgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXSwgZlJlcXVpcmVNaW5pbWFsKTtcclxuICAgICAgICAgIHZhciBibjMgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSwgZlJlcXVpcmVNaW5pbWFsKTtcclxuICAgICAgICAgIC8vYm9vbCBmVmFsdWUgPSAoYm4yIDw9IGJuMSAmJiBibjEgPCBibjMpO1xyXG4gICAgICAgICAgZlZhbHVlID0gKGJuMi5jbXAoYm4xKSA8PSAwKSAmJiAoYm4xLmNtcChibjMpIDwgMCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZlZhbHVlID8gSW50ZXJwcmV0ZXIudHJ1ZSA6IEludGVycHJldGVyLmZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIENyeXB0b1xyXG4gICAgICAgIC8vXHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1JJUEVNRDE2MDpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfU0hBMTpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfU0hBMjU2OlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9IQVNIMTYwOlxyXG4gICAgICBjYXNlIE9wY29kZS5PUF9IQVNIMjU2OlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vIChpbiAtLSBoYXNoKVxyXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnVmID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgLy92YWx0eXBlIHZjaEhhc2goKG9wY29kZSA9PSBPcGNvZGUuT1BfUklQRU1EMTYwIHx8XHJcbiAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgb3Bjb2RlID09IE9wY29kZS5PUF9TSEExIHx8IG9wY29kZSA9PSBPcGNvZGUuT1BfSEFTSDE2MCkgPyAyMCA6IDMyKTtcclxuICAgICAgICAgIHZhciBidWZIYXNoO1xyXG4gICAgICAgICAgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1JJUEVNRDE2MCkge1xyXG4gICAgICAgICAgICBidWZIYXNoID0gSGFzaC5yaXBlbWQxNjAoYnVmKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfU0hBMSkge1xyXG4gICAgICAgICAgICBidWZIYXNoID0gSGFzaC5zaGExKGJ1Zik7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1NIQTI1Nikge1xyXG4gICAgICAgICAgICBidWZIYXNoID0gSGFzaC5zaGEyNTYoYnVmKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfSEFTSDE2MCkge1xyXG4gICAgICAgICAgICBidWZIYXNoID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAoYnVmKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfSEFTSDI1Nikge1xyXG4gICAgICAgICAgICBidWZIYXNoID0gSGFzaC5zaGEyNTZzaGEyNTYoYnVmKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ09ERVNFUEFSQVRPUjpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyBIYXNoIHN0YXJ0cyBhZnRlciB0aGUgY29kZSBzZXBhcmF0b3JcclxuICAgICAgICAgIHRoaXMucGJlZ2luY29kZWhhc2ggPSB0aGlzLnBjO1xyXG4gICAgICAgICAgdGhpcy5leGVjZGF0YS5jb2Rlc2VwYXJhdG9yUG9zID0gdGhpcy5wYyAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tTSUc6XHJcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0NIRUNLU0lHVkVSSUZZOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vIChzaWcgcHVia2V5IC0tIGJvb2wpXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnVmU2lnID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgICAgYnVmUHVia2V5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHsgc3VjY2VzczogZlN1Y2Nlc3MsIHJlc3VsdCB9ID0gdGhpcy5fZXZhbENoZWNrU2lnKGJ1ZlNpZywgYnVmUHVia2V5KTtcclxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuXHJcbiAgICAgICAgICAvLyBzdGFjay5wdXNoX2JhY2soZlN1Y2Nlc3MgPyB2Y2hUcnVlIDogdmNoRmFsc2UpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZTdWNjZXNzID8gSW50ZXJwcmV0ZXIudHJ1ZSA6IEludGVycHJldGVyLmZhbHNlKTtcclxuICAgICAgICAgIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9DSEVDS1NJR1ZFUklGWSkge1xyXG4gICAgICAgICAgICBpZiAoZlN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfQ0hFQ0tTSUdWRVJJRlknO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tTSUdBREQ6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gT1BfQ0hFQ0tTSUdBREQgaXMgb25seSBhdmFpbGFibGUgaW4gVGFwc2NyaXB0XHJcbiAgICAgICAgICBpZiAodGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UgfHwgdGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9CQURfT1BDT0RFJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIChzaWcgbnVtIHB1YmtleSAtLSBudW0pXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbGV0IHNpZyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAzXTtcclxuICAgICAgICAgIGxldCBudW0gPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICBsZXQgcHVia2V5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICAgIG51bSA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIobnVtLCBmUmVxdWlyZU1pbmltYWwpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHsgc3VjY2VzcywgcmVzdWx0IH0gPSB0aGlzLl9ldmFsQ2hlY2tTaWcoc2lnLCBwdWJrZXkpO1xyXG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChudW0uYWRkbihzdWNjZXNzID8gMSA6IDApLnRvU2NyaXB0TnVtQnVmZmVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJRzpcclxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWTpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyAoW3NpZyAuLi5dIG51bV9vZl9zaWduYXR1cmVzIFtwdWJrZXkgLi4uXSBudW1fb2ZfcHVia2V5cyAtLSBib29sKVxyXG5cclxuICAgICAgICAgIHZhciBpID0gMTtcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IGkpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgbktleXNDb3VudCA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIGldLCBmUmVxdWlyZU1pbmltYWwpLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICBpZiAobktleXNDb3VudCA8IDAgfHwgbktleXNDb3VudCA+IDIwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfUFVCS0VZX0NPVU5UJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5uT3BDb3VudCArPSBuS2V5c0NvdW50O1xyXG4gICAgICAgICAgaWYgKHRoaXMubk9wQ291bnQgPiAyMDEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9PUF9DT1VOVCc7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGludCBpa2V5ID0gKytpO1xyXG4gICAgICAgICAgdmFyIGlrZXkgPSArK2k7XHJcbiAgICAgICAgICBpICs9IG5LZXlzQ291bnQ7XHJcblxyXG4gICAgICAgICAgLy8gaWtleTIgaXMgdGhlIHBvc2l0aW9uIG9mIGxhc3Qgbm9uLXNpZ25hdHVyZSBpdGVtIGluXHJcbiAgICAgICAgICAvLyB0aGUgc3RhY2suIFRvcCBzdGFjayBpdGVtID0gMS4gV2l0aFxyXG4gICAgICAgICAgLy8gU0NSSVBUX1ZFUklGWV9OVUxMRkFJTCwgdGhpcyBpcyB1c2VkIGZvciBjbGVhbnVwIGlmXHJcbiAgICAgICAgICAvLyBvcGVyYXRpb24gZmFpbHMuXHJcbiAgICAgICAgICB2YXIgaWtleTIgPSBuS2V5c0NvdW50ICsgMjtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCBpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIG5TaWdzQ291bnQgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSBpXSwgZlJlcXVpcmVNaW5pbWFsKS50b051bWJlcigpO1xyXG4gICAgICAgICAgaWYgKG5TaWdzQ291bnQgPCAwIHx8IG5TaWdzQ291bnQgPiBuS2V5c0NvdW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX0NPVU5UJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gaW50IGlzaWcgPSArK2k7XHJcbiAgICAgICAgICB2YXIgaXNpZyA9ICsraTtcclxuICAgICAgICAgIGkgKz0gblNpZ3NDb3VudDtcclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IGkpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTdWJzZXQgb2Ygc2NyaXB0IHN0YXJ0aW5nIGF0IHRoZSBtb3N0IHJlY2VudCBjb2Rlc2VwYXJhdG9yXHJcbiAgICAgICAgICBzdWJzY3JpcHQgPSBuZXcgU2NyaXB0KCkuc2V0KHtcclxuICAgICAgICAgICAgY2h1bmtzOiB0aGlzLnNjcmlwdC5jaHVua3Muc2xpY2UodGhpcy5wYmVnaW5jb2RlaGFzaClcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIERyb3AgdGhlIHNpZ25hdHVyZXMsIHNpbmNlIHRoZXJlJ3Mgbm8gd2F5IGZvciBhIHNpZ25hdHVyZSB0byBzaWduIGl0c2VsZlxyXG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuU2lnc0NvdW50OyBrKyspIHtcclxuICAgICAgICAgICAgYnVmU2lnID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIGlzaWcgLSBrXTtcclxuICAgICAgICAgICAgc3Vic2NyaXB0LmZpbmRBbmREZWxldGUobmV3IFNjcmlwdCgpLmFkZChidWZTaWcpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmU3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgICB3aGlsZSAoZlN1Y2Nlc3MgJiYgblNpZ3NDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgLy8gdmFsdHlwZSYgdmNoU2lnICA9IHN0YWNrdG9wKC1pc2lnKTtcclxuICAgICAgICAgICAgYnVmU2lnID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIGlzaWddO1xyXG4gICAgICAgICAgICAvLyB2YWx0eXBlJiB2Y2hQdWJLZXkgPSBzdGFja3RvcCgtaWtleSk7XHJcbiAgICAgICAgICAgIGJ1ZlB1YmtleSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSBpa2V5XTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NpZ25hdHVyZUVuY29kaW5nKGJ1ZlNpZykgfHwgIXRoaXMuY2hlY2tQdWJrZXlFbmNvZGluZyhidWZQdWJrZXkpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZk9rO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoYnVmU2lnKTtcclxuICAgICAgICAgICAgICBwdWJrZXkgPSBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihidWZQdWJrZXksIGZhbHNlKTtcclxuICAgICAgICAgICAgICBmT2sgPSB0aGlzLnR4LnZlcmlmeVNpZ25hdHVyZShzaWcsIHB1YmtleSwgdGhpcy5uaW4sIHN1YnNjcmlwdCwgdGhpcy5zaWd2ZXJzaW9uLCB0aGlzLnNhdG9zaGlzLCB0aGlzLmV4ZWNkYXRhKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIC8vaW52YWxpZCBzaWcgb3IgcHVia2V5XHJcbiAgICAgICAgICAgICAgZk9rID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmT2spIHtcclxuICAgICAgICAgICAgICBpc2lnKys7XHJcbiAgICAgICAgICAgICAgblNpZ3NDb3VudC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlrZXkrKztcclxuICAgICAgICAgICAgbktleXNDb3VudC0tO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgc2lnbmF0dXJlcyBsZWZ0IHRoYW4ga2V5cyBsZWZ0LFxyXG4gICAgICAgICAgICAvLyB0aGVuIHRvbyBtYW55IHNpZ25hdHVyZXMgaGF2ZSBmYWlsZWRcclxuICAgICAgICAgICAgaWYgKG5TaWdzQ291bnQgPiBuS2V5c0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgZlN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAvLyBDbGVhbiB1cCBzdGFjayBvZiBhY3R1YWwgYXJndW1lbnRzXHJcbiAgICAgICAgICB3aGlsZSAoaS0tID4gMSkge1xyXG4gICAgICAgICAgICBpZiAoIWZTdWNjZXNzICYmICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9OVUxMRkFJTCkgJiZcclxuICAgICAgICAgICAgICAhaWtleTIgJiYgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX05VTExGQUlMJztcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpa2V5MiA+IDApIHtcclxuICAgICAgICAgICAgICBpa2V5Mi0tO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEEgYnVnIGNhdXNlcyBDSEVDS01VTFRJU0lHIHRvIGNvbnN1bWUgb25lIGV4dHJhIGFyZ3VtZW50XHJcbiAgICAgICAgICAvLyB3aG9zZSBjb250ZW50cyB3ZXJlIG5vdCBjaGVja2VkIGluIGFueSB3YXkuXHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSB0aGlzIGlzIGEgcG90ZW50aWFsIHNvdXJjZSBvZiBtdXRhYmlsaXR5LFxyXG4gICAgICAgICAgLy8gc28gb3B0aW9uYWxseSB2ZXJpZnkgaXQgaXMgZXhhY3RseSBlcXVhbCB0byB6ZXJvIHByaW9yXHJcbiAgICAgICAgICAvLyB0byByZW1vdmluZyBpdCBmcm9tIHRoZSBzdGFjay5cclxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfTlVMTERVTU1ZKSAmJiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX05VTExEVU1NWSc7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcblxyXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZTdWNjZXNzID8gSW50ZXJwcmV0ZXIudHJ1ZSA6IEludGVycHJldGVyLmZhbHNlKTtcclxuXHJcbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWSkge1xyXG4gICAgICAgICAgICBpZiAoZlN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfQ0hFQ0tNVUxUSVNJR1ZFUklGWSc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0JBRF9PUENPREUnO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNpemUgbGltaXRzXHJcbiAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICsgdGhpcy5hbHRzdGFjay5sZW5ndGggPiBJbnRlcnByZXRlci5NQVhfU1RBQ0tfU0laRSkge1xyXG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TVEFDS19TSVpFJztcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/script/interpreter.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/script/script.js":
/*!*******************************************!*\
  !*** ../bitcore-lib/lib/script/script.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar Address = __webpack_require__(/*! ../address */ \"../bitcore-lib/lib/address.js\");\r\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar Opcode = __webpack_require__(/*! ../opcode */ \"../bitcore-lib/lib/opcode.js\");\r\nvar PublicKey = __webpack_require__(/*! ../publickey */ \"../bitcore-lib/lib/publickey.js\");\r\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar Networks = __webpack_require__(/*! ../networks */ \"../bitcore-lib/lib/networks.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"../bitcore-lib/lib/crypto/taggedhash.js\");\r\n\r\n/**\r\n * A bitcoin transaction script. Each transaction's inputs and outputs\r\n * has a script that is evaluated to validate it's spending.\r\n *\r\n * See https://en.bitcoin.it/wiki/Script\r\n *\r\n * @constructor\r\n * @param {Object|string|Buffer=} from optional data to populate script\r\n */\r\nvar Script = function Script(from) {\r\n  if (!(this instanceof Script)) {\r\n    return new Script(from);\r\n  }\r\n  this.chunks = [];\r\n\r\n  if (BufferUtil.isBuffer(from)) {\r\n    return Script.fromBuffer(from);\r\n  } else if (from instanceof Address) {\r\n    return Script.fromAddress(from);\r\n  } else if (from instanceof Script) {\r\n    return Script.fromBuffer(from.toBuffer());\r\n  } else if (typeof from === 'string') {\r\n    return Script.fromString(from);\r\n  } else if (_.isObject(from) && Array.isArray(from.chunks)) {\r\n    this.set(from);\r\n  }\r\n};\r\n\r\n\r\nScript.prototype.set = function(obj) {\r\n  $.checkArgument(_.isObject(obj));\r\n  $.checkArgument(Array.isArray(obj.chunks));\r\n  this.chunks = obj.chunks;\r\n  return this;\r\n};\r\n\r\nScript.fromBuffer = function(buffer) {\r\n  var script = new Script();\r\n  script.chunks = [];\r\n\r\n  var br = new BufferReader(buffer);\r\n  while (!br.finished()) {\r\n    try {\r\n      var opcodenum = br.readUInt8();\r\n\r\n      var len, buf;\r\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\r\n        len = opcodenum;\r\n        script.chunks.push({\r\n          buf: br.read(len),\r\n          len: len,\r\n          opcodenum: opcodenum\r\n        });\r\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\r\n        len = br.readUInt8();\r\n        buf = br.read(len);\r\n        script.chunks.push({\r\n          buf: buf,\r\n          len: len,\r\n          opcodenum: opcodenum\r\n        });\r\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\r\n        len = br.readUInt16LE();\r\n        buf = br.read(len);\r\n        script.chunks.push({\r\n          buf: buf,\r\n          len: len,\r\n          opcodenum: opcodenum\r\n        });\r\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\r\n        len = br.readUInt32LE();\r\n        buf = br.read(len);\r\n        script.chunks.push({\r\n          buf: buf,\r\n          len: len,\r\n          opcodenum: opcodenum\r\n        });\r\n      } else if (Opcode.isOpSuccess(opcodenum)) {\r\n        // OP_SUCCESSx processing overrides everything, including stack element size limits\r\n        buf = br.readAll();\r\n        len = buf.length;\r\n        script.chunks.push({\r\n          buf: buf,\r\n          len: len,\r\n          opcodenum: opcodenum\r\n        });\r\n      } else {\r\n        script.chunks.push({\r\n          opcodenum: opcodenum\r\n        });\r\n      }\r\n    } catch (e) {\r\n      if (e instanceof RangeError) {\r\n        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));\r\n      }\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  return script;\r\n};\r\n\r\nScript.prototype.toBuffer = function() {\r\n  var bw = new BufferWriter();\r\n\r\n  for (var i = 0; i < this.chunks.length; i++) {\r\n    var chunk = this.chunks[i];\r\n    var opcodenum = chunk.opcodenum;\r\n    bw.writeUInt8(chunk.opcodenum);\r\n    if (chunk.buf) {\r\n      if (opcodenum < Opcode.OP_PUSHDATA1) {\r\n        bw.write(chunk.buf);\r\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\r\n        bw.writeUInt8(chunk.len);\r\n        bw.write(chunk.buf);\r\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\r\n        bw.writeUInt16LE(chunk.len);\r\n        bw.write(chunk.buf);\r\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\r\n        bw.writeUInt32LE(chunk.len);\r\n        bw.write(chunk.buf);\r\n      } else {\r\n        // Could reach here if opcodenum is OP_SUCCESSx (see comment in .fromBuffer)\r\n        bw.write(chunk.buf);\r\n      }\r\n    }\r\n  }\r\n\r\n  return bw.concat();\r\n};\r\n\r\nScript.fromASM = function(str) {\r\n  var script = new Script();\r\n  script.chunks = [];\r\n\r\n  var tokens = str.split(' ');\r\n  var i = 0;\r\n  while (i < tokens.length) {\r\n    var token = tokens[i];\r\n    var opcode = Opcode(token);\r\n    var opcodenum = opcode.toNumber();\r\n\r\n    if (opcodenum == null) {\r\n      var buf = Buffer.from(tokens[i], 'hex');\r\n      script.chunks.push({\r\n        buf: buf,\r\n        len: buf.length,\r\n        opcodenum: buf.length\r\n      });\r\n      i = i + 1;\r\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\r\n      opcodenum === Opcode.OP_PUSHDATA2 ||\r\n      opcodenum === Opcode.OP_PUSHDATA4) {\r\n      script.chunks.push({\r\n        buf: Buffer.from(tokens[i + 2], 'hex'),\r\n        len: parseInt(tokens[i + 1]),\r\n        opcodenum: opcodenum\r\n      });\r\n      i = i + 3;\r\n    } else {\r\n      script.chunks.push({\r\n        opcodenum: opcodenum\r\n      });\r\n      i = i + 1;\r\n    }\r\n  }\r\n  return script;\r\n};\r\n\r\nScript.fromHex = function(str) {\r\n  return new Script(Buffer.from(str, 'hex'));\r\n};\r\n\r\nScript.fromString = function(str) {\r\n  if (JSUtil.isHexa(str) || str.length === 0) {\r\n    return new Script(Buffer.from(str, 'hex'));\r\n  }\r\n  var script = new Script();\r\n  script.chunks = [];\r\n\r\n  var tokens = str.split(' ');\r\n  var i = 0;\r\n  while (i < tokens.length) {\r\n    var token = tokens[i];\r\n    var opcode = Opcode(token);\r\n    var opcodenum = opcode.toNumber();\r\n\r\n    if (opcodenum == null) {\r\n      opcodenum = parseInt(token);\r\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\r\n        script.chunks.push({\r\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\r\n          len: opcodenum,\r\n          opcodenum: opcodenum\r\n        });\r\n        i = i + 2;\r\n      } else {\r\n        throw new Error('Invalid script: ' + JSON.stringify(str));\r\n      }\r\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\r\n      opcodenum === Opcode.OP_PUSHDATA2 ||\r\n      opcodenum === Opcode.OP_PUSHDATA4) {\r\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\r\n        throw new Error('Pushdata data must start with 0x');\r\n      }\r\n      script.chunks.push({\r\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\r\n        len: parseInt(tokens[i + 1]),\r\n        opcodenum: opcodenum\r\n      });\r\n      i = i + 3;\r\n    } else {\r\n      script.chunks.push({\r\n        opcodenum: opcodenum\r\n      });\r\n      i = i + 1;\r\n    }\r\n  }\r\n  return script;\r\n};\r\n\r\nScript.prototype._chunkToString = function(chunk, type) {\r\n  var opcodenum = chunk.opcodenum;\r\n  var asm = (type === 'asm');\r\n  var str = '';\r\n  if (!chunk.buf) {\r\n    // no data chunk\r\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\r\n      if (asm) {\r\n        // A few cases where the opcode name differs from reverseMap\r\n        // aside from 1 to 16 data pushes.\r\n        if (opcodenum === 0) {\r\n          // OP_0 -> 0\r\n          str = str + ' 0';\r\n        } else if(opcodenum === 79) {\r\n          // OP_1NEGATE -> 1\r\n          str = str + ' -1';\r\n        } else {\r\n          str = str + ' ' + Opcode(opcodenum).toString();\r\n        }\r\n      } else {\r\n        str = str + ' ' + Opcode(opcodenum).toString();\r\n      }\r\n    } else {\r\n      var numstr = opcodenum.toString(16);\r\n      if (numstr.length % 2 !== 0) {\r\n        numstr = '0' + numstr;\r\n      }\r\n      if (asm) {\r\n        str = str + ' ' + numstr;\r\n      } else {\r\n        str = str + ' ' + '0x' + numstr;\r\n      }\r\n    }\r\n  } else {\r\n    // data chunk\r\n    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 ||\r\n      opcodenum === Opcode.OP_PUSHDATA2 ||\r\n      opcodenum === Opcode.OP_PUSHDATA4) {\r\n      str = str + ' ' + Opcode(opcodenum).toString();\r\n    }\r\n    if (chunk.len > 0) {\r\n      if (asm) {\r\n        str = str + ' ' + chunk.buf.toString('hex');\r\n      } else {\r\n        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n};\r\n\r\nScript.prototype.toASM = function() {\r\n  var str = '';\r\n  for (var i = 0; i < this.chunks.length; i++) {\r\n    var chunk = this.chunks[i];\r\n    str += this._chunkToString(chunk, 'asm');\r\n  }\r\n\r\n  return str.substr(1);\r\n};\r\n\r\nScript.prototype.toString = function() {\r\n  var str = '';\r\n  for (var i = 0; i < this.chunks.length; i++) {\r\n    var chunk = this.chunks[i];\r\n    str += this._chunkToString(chunk);\r\n  }\r\n\r\n  return str.substr(1);\r\n};\r\n\r\nScript.prototype.toHex = function() {\r\n  return this.toBuffer().toString('hex');\r\n};\r\n\r\nScript.prototype.inspect = function() {\r\n  return '<Script: ' + this.toString() + '>';\r\n};\r\n\r\n// script classification methods\r\n\r\n/**\r\n * @returns {boolean} if this is a pay to pubkey hash output script\r\n */\r\nScript.prototype.isPublicKeyHashOut = function() {\r\n  return !!(this.chunks.length === 5 &&\r\n    this.chunks[0].opcodenum === Opcode.OP_DUP &&\r\n    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&\r\n    this.chunks[2].buf &&\r\n    this.chunks[2].buf.length === 20 &&\r\n    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&\r\n    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a pay to public key hash input script\r\n */\r\nScript.prototype.isPublicKeyHashIn = function() {\r\n  if (this.chunks.length === 2) {\r\n    var signatureBuf = this.chunks[0].buf;\r\n    var pubkeyBuf = this.chunks[1].buf;\r\n    if (signatureBuf &&\r\n        signatureBuf.length &&\r\n        signatureBuf[0] === 0x30 &&\r\n        pubkeyBuf &&\r\n        pubkeyBuf.length\r\n       ) {\r\n      var version = pubkeyBuf[0];\r\n      if ((version === 0x04 ||\r\n           version === 0x06 ||\r\n           version === 0x07) && pubkeyBuf.length === 65) {\r\n        return true;\r\n      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nScript.prototype.getPublicKey = function() {\r\n  $.checkState(this.isPublicKeyOut(), 'Can\\'t retrieve PublicKey from a non-PK output');\r\n  return this.chunks[0].buf;\r\n};\r\n\r\nScript.prototype.getPublicKeyHash = function() {\r\n  if (this.isPublicKeyHashOut()) {\r\n    return this.chunks[2].buf;\r\n  } else if (this.isWitnessPublicKeyHashOut()) {\r\n    return this.chunks[1].buf;\r\n  } else if (this.isTaproot()) {\r\n    return this.chunks[1].buf;\r\n  } else {\r\n    throw new Error('Can\\'t retrieve PublicKeyHash from a non-PKH output');\r\n  }\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a public key output script\r\n */\r\nScript.prototype.isPublicKeyOut = function() {\r\n  if (this.chunks.length === 2 &&\r\n      this.chunks[0].buf &&\r\n      this.chunks[0].buf.length &&\r\n      this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\r\n    var pubkeyBuf = this.chunks[0].buf;\r\n    var version = pubkeyBuf[0];\r\n    var isVersion = false;\r\n    if ((version === 0x04 ||\r\n         version === 0x06 ||\r\n         version === 0x07) && pubkeyBuf.length === 65) {\r\n      isVersion = true;\r\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\r\n      isVersion = true;\r\n    }\r\n    if (isVersion) {\r\n      return PublicKey.isValid(pubkeyBuf);\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a pay to public key input script\r\n */\r\nScript.prototype.isPublicKeyIn = function() {\r\n  if (this.chunks.length === 1) {\r\n    var signatureBuf = this.chunks[0].buf;\r\n    if (signatureBuf &&\r\n        signatureBuf.length &&\r\n        signatureBuf[0] === 0x30) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a p2sh output script\r\n */\r\nScript.prototype.isScriptHashOut = function() {\r\n  var buf = this.toBuffer();\r\n  return (buf.length === 23 &&\r\n    buf[0] === Opcode.OP_HASH160 &&\r\n    buf[1] === 0x14 &&\r\n    buf[buf.length - 1] === Opcode.OP_EQUAL);\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a p2wsh output script\r\n */\r\nScript.prototype.isWitnessScriptHashOut = function() {\r\n  var buf = this.toBuffer();\r\n  return (buf.length === 34 && buf[0] === Opcode.OP_0 && buf[1] === 32);\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a p2wpkh output script\r\n */\r\nScript.prototype.isWitnessPublicKeyHashOut = function() {\r\n  var buf = this.toBuffer();\r\n  return (buf.length === 22 && buf[0] === Opcode.OP_0 && buf[1] === 20);\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a p2tr output script\r\n */\r\nScript.prototype.isTaproot = function() {\r\n  var buf = this.toBuffer();\r\n  return (buf.length === 34 && buf[0] === Opcode.OP_1 && buf[1] === 32);\r\n}\r\n\r\n/**\r\n * @param {Object=} values - The return values\r\n * @param {Number} values.version - Set with the witness version\r\n * @param {Buffer} values.program - Set with the witness program\r\n * @returns {boolean} if this is a p2wpkh output script\r\n */\r\nScript.prototype.isWitnessProgram = function(values) {\r\n  if (!values) {\r\n    values = {};\r\n  }\r\n  var buf = this.toBuffer();\r\n  if (buf.length < 4 || buf.length > 42) {\r\n    return false;\r\n  }\r\n  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {\r\n    return false;\r\n  }\r\n\r\n  if (buf.length === buf[1] + 2) {\r\n    values.version = Opcode.decodeOpN(buf[0]);\r\n    values.program = buf.slice(2, buf.length);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a p2sh input script\r\n * Note that these are frequently indistinguishable from pubkeyhashin\r\n */\r\nScript.prototype.isScriptHashIn = function() {\r\n  if (this.chunks.length <= 1) {\r\n    return false;\r\n  }\r\n  var redeemChunk = this.chunks[this.chunks.length - 1];\r\n  var redeemBuf = redeemChunk.buf;\r\n  if (!redeemBuf) {\r\n    return false;\r\n  }\r\n\r\n  var redeemScript;\r\n  try {\r\n    redeemScript = Script.fromBuffer(redeemBuf);\r\n  } catch (e) {\r\n    if (e instanceof errors.Script.InvalidBuffer) {\r\n      return false;\r\n    }\r\n    throw e;\r\n  }\r\n  var type = redeemScript.classify();\r\n  return type !== Script.types.UNKNOWN;\r\n};\r\n\r\n/**\r\n * @returns {boolean} if this is a mutlsig output script\r\n */\r\nScript.prototype.isMultisigOut = function() {\r\n  return (this.chunks.length > 3 &&\r\n    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&\r\n    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {\r\n      return obj.buf && BufferUtil.isBuffer(obj.buf);\r\n    }) &&\r\n    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&\r\n    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);\r\n};\r\n\r\n\r\n/**\r\n * @returns {boolean} if this is a multisig input script\r\n */\r\nScript.prototype.isMultisigIn = function() {\r\n  return this.chunks.length >= 2 &&\r\n    this.chunks[0].opcodenum === 0 &&\r\n    this.chunks.slice(1, this.chunks.length).every(function(obj) {\r\n      return obj.buf &&\r\n        BufferUtil.isBuffer(obj.buf) &&\r\n        Signature.isTxDER(obj.buf);\r\n    });\r\n};\r\n\r\n/**\r\n * @returns {boolean} true if this is a valid standard OP_RETURN output\r\n */\r\nScript.prototype.isDataOut = function() {\r\n  return this.chunks.length >= 1 &&\r\n    this.chunks[0].opcodenum === Opcode.OP_RETURN &&\r\n    (this.chunks.length === 1 ||\r\n      (this.chunks.length === 2 &&\r\n        this.chunks[1].buf &&\r\n        this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE &&\r\n        this.chunks[1].length === this.chunks.len));\r\n};\r\n\r\n/**\r\n * Retrieve the associated data for this script.\r\n * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.\r\n * In the case of a standard OP_RETURN, return the data\r\n * @returns {Buffer}\r\n */\r\nScript.prototype.getData = function() {\r\n  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut() || this.isTaproot()) {\r\n    if (this.chunks[1] == null) {\r\n      return Buffer.alloc(0);\r\n    } else {\r\n      return Buffer.from(this.chunks[1].buf);\r\n    }\r\n  }\r\n  if (this.isPublicKeyHashOut()) {\r\n    return Buffer.from(this.chunks[2].buf);\r\n  }\r\n  throw new Error('Unrecognized script type to get data from');\r\n};\r\n\r\n/**\r\n * @returns {boolean} if the script is only composed of data pushing\r\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\r\n */\r\nScript.prototype.isPushOnly = function() {\r\n  return this.chunks.every(function(chunk) {\r\n    return chunk.opcodenum <= Opcode.OP_16;\r\n  });\r\n};\r\n\r\n\r\nScript.types = {};\r\nScript.types.UNKNOWN = 'Unknown';\r\nScript.types.PUBKEY_OUT = 'Pay to public key';\r\nScript.types.PUBKEY_IN = 'Spend from public key';\r\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\r\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\r\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\r\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\r\nScript.types.MULTISIG_OUT = 'Pay to multisig';\r\nScript.types.MULTISIG_IN = 'Spend from multisig';\r\nScript.types.DATA_OUT = 'Data push';\r\n\r\nScript.OP_RETURN_STANDARD_SIZE = 80;\r\n\r\n// Tag for input annex. If there are at least two witness elements for a transaction input,\r\n// and the first byte of the last element is 0x50, this last element is called annex, and\r\n// has meanings independent of the script\r\nScript.ANNEX_TAG = 0x50;\r\n\r\n// Validation weight per passing signature (Tapscript only, see BIP 342).\r\nScript.VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;\r\n\r\n// How much weight budget is added to the witness size (Tapscript only, see BIP 342).\r\nScript.VALIDATION_WEIGHT_OFFSET = 50;\r\n\r\n\r\n/**\r\n * @returns {object} The Script type if it is a known form,\r\n * or Script.UNKNOWN if it isn't\r\n */\r\nScript.prototype.classify = function() {\r\n  if (this._isInput) {\r\n    return this.classifyInput();\r\n  } else if (this._isOutput) {\r\n    return this.classifyOutput();\r\n  } else {\r\n    var outputType = this.classifyOutput();\r\n    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();\r\n  }\r\n};\r\n\r\nScript.outputIdentifiers = {};\r\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\r\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\r\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\r\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\r\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\r\n\r\n/**\r\n * @returns {object} The Script type if it is a known form,\r\n * or Script.UNKNOWN if it isn't\r\n */\r\nScript.prototype.classifyOutput = function() {\r\n  for (var type in Script.outputIdentifiers) {\r\n    if (Script.outputIdentifiers[type].bind(this)()) {\r\n      return Script.types[type];\r\n    }\r\n  }\r\n  return Script.types.UNKNOWN;\r\n};\r\n\r\nScript.inputIdentifiers = {};\r\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\r\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\r\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\r\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\r\n\r\n/**\r\n * @returns {object} The Script type if it is a known form,\r\n * or Script.UNKNOWN if it isn't\r\n */\r\nScript.prototype.classifyInput = function() {\r\n  for (var type in Script.inputIdentifiers) {\r\n    if (Script.inputIdentifiers[type].bind(this)()) {\r\n      return Script.types[type];\r\n    }\r\n  }\r\n  return Script.types.UNKNOWN;\r\n};\r\n\r\n\r\n/**\r\n * @returns {boolean} if script is one of the known types\r\n */\r\nScript.prototype.isStandard = function() {\r\n  // TODO: Add BIP62 compliance\r\n  return this.classify() !== Script.types.UNKNOWN;\r\n};\r\n\r\n\r\n// Script construction methods\r\n\r\n/**\r\n * Adds a script element at the start of the script.\r\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\r\n * @returns {Script} this script instance\r\n */\r\nScript.prototype.prepend = function(obj) {\r\n  this._addByType(obj, true);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Compares a script with another script\r\n */\r\nScript.prototype.equals = function(script) {\r\n  $.checkState(script instanceof Script, 'Must provide another script');\r\n  if (this.chunks.length !== script.chunks.length) {\r\n    return false;\r\n  }\r\n  var i;\r\n  for (i = 0; i < this.chunks.length; i++) {\r\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\r\n      return false;\r\n    }\r\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\r\n      return false;\r\n    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Adds a script element to the end of the script.\r\n *\r\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\r\n * @returns {Script} this script instance\r\n *\r\n */\r\nScript.prototype.add = function(obj) {\r\n  this._addByType(obj, false);\r\n  return this;\r\n};\r\n\r\nScript.prototype._addByType = function(obj, prepend) {\r\n  if (typeof obj === 'string') {\r\n    this._addOpcode(obj, prepend);\r\n  } else if (typeof obj === 'number') {\r\n    this._addOpcode(obj, prepend);\r\n  } else if (obj instanceof Opcode) {\r\n    this._addOpcode(obj, prepend);\r\n  } else if (BufferUtil.isBuffer(obj)) {\r\n    this._addBuffer(obj, prepend);\r\n  } else if (obj instanceof Script) {\r\n    this.chunks = this.chunks.concat(obj.chunks);\r\n  } else if (typeof obj === 'object') {\r\n    this._insertAtPosition(obj, prepend);\r\n  } else {\r\n    throw new Error('Invalid script chunk');\r\n  }\r\n};\r\n\r\nScript.prototype._insertAtPosition = function(op, prepend) {\r\n  if (prepend) {\r\n    this.chunks.unshift(op);\r\n  } else {\r\n    this.chunks.push(op);\r\n  }\r\n};\r\n\r\nScript.prototype._addOpcode = function(opcode, prepend) {\r\n  var op;\r\n  if (typeof opcode === 'number') {\r\n    op = opcode;\r\n  } else if (opcode instanceof Opcode) {\r\n    op = opcode.toNumber();\r\n  } else {\r\n    op = Opcode(opcode).toNumber();\r\n  }\r\n  this._insertAtPosition({\r\n    opcodenum: op\r\n  }, prepend);\r\n  return this;\r\n};\r\n\r\nScript.prototype._addBuffer = function(buf, prepend) {\r\n  var opcodenum;\r\n  var len = buf.length;\r\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\r\n    opcodenum = len;\r\n  } else if (len < Math.pow(2, 8)) {\r\n    opcodenum = Opcode.OP_PUSHDATA1;\r\n  } else if (len < Math.pow(2, 16)) {\r\n    opcodenum = Opcode.OP_PUSHDATA2;\r\n  } else if (len < Math.pow(2, 32)) {\r\n    opcodenum = Opcode.OP_PUSHDATA4;\r\n  } else {\r\n    throw new Error('You can\\'t push that much data');\r\n  }\r\n  this._insertAtPosition({\r\n    buf: buf,\r\n    len: len,\r\n    opcodenum: opcodenum\r\n  }, prepend);\r\n  return this;\r\n};\r\n\r\nScript.prototype.hasCodeseparators = function() {\r\n  for (var i = 0; i < this.chunks.length; i++) {\r\n    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nScript.prototype.removeCodeseparators = function() {\r\n  var chunks = [];\r\n  for (var i = 0; i < this.chunks.length; i++) {\r\n    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {\r\n      chunks.push(this.chunks[i]);\r\n    }\r\n  }\r\n  this.chunks = chunks;\r\n  return this;\r\n};\r\n\r\n// high level script builder methods\r\n\r\n/**\r\n * @returns {Script} a new Multisig output script for given public keys,\r\n * requiring m of those public keys to spend\r\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\r\n * @param {number} threshold - amount of required signatures to spend the output\r\n * @param {Object=} opts - Several options:\r\n *        - noSorting: defaults to false, if true, don't sort the given\r\n *                      public keys before creating the script\r\n */\r\nScript.buildMultisigOut = function(publicKeys, threshold, opts) {\r\n  $.checkArgument(threshold <= publicKeys.length,\r\n    'Number of required signatures must be less than or equal to the number of public keys');\r\n  opts = opts || {};\r\n  var script = new Script();\r\n  script.add(Opcode.smallInt(threshold));\r\n  publicKeys = publicKeys.map(PublicKey);\r\n  var sorted = publicKeys;\r\n  if (!opts.noSorting) {\r\n    sorted = _.sortBy(publicKeys, function(publicKey) {\r\n      return publicKey.toString('hex');\r\n    });\r\n  }\r\n  for (var i = 0; i < sorted.length; i++) {\r\n    var publicKey = sorted[i];\r\n    script.add(publicKey.toBuffer());\r\n  }\r\n  script.add(Opcode.smallInt(publicKeys.length));\r\n  script.add(Opcode.OP_CHECKMULTISIG);\r\n  return script;\r\n};\r\n\r\nScript.buildWitnessMultisigOutFromScript = function(script) {\r\n  if (script instanceof Script) {\r\n    var s = new Script();\r\n    s.add(Opcode.OP_0);\r\n    s.add(Hash.sha256(script.toBuffer()));\r\n    return s;\r\n  } else {\r\n    throw new TypeError('First argument is expected to be a p2sh script');\r\n  }\r\n};\r\n\r\n/**\r\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\r\n *\r\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\r\n * @param {number} threshold amount of required signatures to spend the output\r\n * @param {Array} signatures and array of signature buffers to append to the script\r\n * @param {Object=} opts\r\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\r\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\r\n *\r\n * @returns {Script}\r\n */\r\nScript.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {\r\n  $.checkArgument(Array.isArray(pubkeys));\r\n  $.checkArgument(!isNaN(threshold));\r\n  $.checkArgument(Array.isArray(signatures));\r\n  opts = opts || {};\r\n  var s = new Script();\r\n  s.add(Opcode.OP_0);\r\n  for (const signature of signatures) {\r\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\r\n    // TODO: allow signatures to be an array of Signature objects\r\n    s.add(signature);\r\n  }\r\n  return s;\r\n};\r\n\r\n/**\r\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\r\n *\r\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\r\n * @param {number} threshold amount of required signatures to spend the output\r\n * @param {Array} signatures and array of signature buffers to append to the script\r\n * @param {Object=} opts\r\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\r\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\r\n *\r\n * @returns {Script}\r\n */\r\nScript.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {\r\n  $.checkArgument(Array.isArray(pubkeys));\r\n  $.checkArgument(!isNaN(threshold));\r\n  $.checkArgument(Array.isArray(signatures));\r\n  opts = opts || {};\r\n  var s = new Script();\r\n  s.add(Opcode.OP_0);\r\n  for (const signature of signatures) {\r\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\r\n    // TODO: allow signatures to be an array of Signature objects\r\n    s.add(signature);\r\n  }\r\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\r\n  return s;\r\n};\r\n\r\n/**\r\n * @returns {Script} a new pay to public key hash output for the given\r\n * address or public key\r\n * @param {(Address|PublicKey)} to - destination address or public key\r\n */\r\nScript.buildPublicKeyHashOut = function(to) {\r\n  $.checkArgument(to != null);\r\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\r\n  if (to instanceof PublicKey) {\r\n    to = to.toAddress();\r\n  } else if (typeof to === 'string') {\r\n    to = new Address(to);\r\n  }\r\n  var s = new Script();\r\n  s.add(Opcode.OP_DUP)\r\n    .add(Opcode.OP_HASH160)\r\n    .add(to.hashBuffer)\r\n    .add(Opcode.OP_EQUALVERIFY)\r\n    .add(Opcode.OP_CHECKSIG);\r\n  s._network = to.network;\r\n  return s;\r\n};\r\n\r\n/**\r\n * @returns {Script} a new pay to witness v0 output for the given\r\n * address\r\n * @param {(Address|PublicKey)} to - destination address\r\n */\r\nScript.buildWitnessV0Out = function(to) {\r\n  $.checkArgument(to != null);\r\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\r\n  if (to instanceof PublicKey) {\r\n    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);\r\n  } else if (typeof to === 'string') {\r\n    to = new Address(to);\r\n  }\r\n  var s = new Script();\r\n  s.add(Opcode.OP_0)\r\n    .add(to.hashBuffer);\r\n  s._network = to.network;\r\n  return s;\r\n};\r\n\r\n\r\n/**\r\n * Build Taproot script output\r\n * @param {PublicKey|Address} to recipient's pubKey or address\r\n * @param {Array|Object} scriptTree single leaf object OR array of leaves. leaf: { script: String, leafVersion: Integer }\r\n * @returns {Script}\r\n */\r\nScript.buildWitnessV1Out = function(to, scriptTree) {\r\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\r\n  $.checkArgument(!scriptTree || Array.isArray(scriptTree) || !!scriptTree.script);\r\n\r\n  if (typeof to === 'string') {\r\n    to = PublicKey.fromTaproot(to);\r\n  }\r\n  \r\n  function buildTree(tree) {\r\n    if (Array.isArray(tree)) {\r\n      const [left, leftH] = buildTree(tree[0]);\r\n      const [right, rightH] = buildTree(tree[1]);\r\n      const ret = [[[left[0], left[1]], rightH], [[right[0], right[1]], leftH]];\r\n      const hWriter = TaggedHash.TAPBRANCH;\r\n      if (leftH.compare(rightH) === 1) {\r\n        hWriter.write(rightH);\r\n        hWriter.write(leftH);\r\n      } else {\r\n        hWriter.write(leftH);\r\n        hWriter.write(rightH);\r\n      }\r\n      return [ret, hWriter.finalize()];\r\n    } else {\r\n      const { leafVersion, script } = tree;\r\n      const scriptBuf = new Script(script).toBuffer();\r\n      const leafWriter = TaggedHash.TAPLEAF;\r\n      leafWriter.writeUInt8(leafVersion);\r\n      leafWriter.writeUInt8(scriptBuf.length);\r\n      leafWriter.write(scriptBuf);\r\n      const h = leafWriter.finalize();\r\n      return [[Buffer.from([leafVersion]), scriptBuf], h];\r\n    }\r\n  }\r\n\r\n  let taggedHash = null;\r\n  if (scriptTree) { \r\n    const [_, h] = buildTree(scriptTree);\r\n    taggedHash = h;\r\n  }\r\n  \r\n  let tweakedPubKey;\r\n  if (to instanceof PublicKey) {\r\n    tweakedPubKey = to.createTapTweak(taggedHash).tweakedPubKey;\r\n  } else { // Address\r\n    tweakedPubKey = to.hashBuffer;\r\n  }\r\n  const s = new Script();\r\n  s.add(Opcode.OP_1);\r\n  s.add(tweakedPubKey);\r\n  return s;\r\n};\r\n\r\n\r\n/**\r\n * @returns {Script} a new pay to public key output for the given\r\n *  public key\r\n */\r\nScript.buildPublicKeyOut = function(pubkey) {\r\n  $.checkArgument(pubkey instanceof PublicKey);\r\n  var s = new Script();\r\n  s.add(pubkey.toBuffer())\r\n    .add(Opcode.OP_CHECKSIG);\r\n  return s;\r\n};\r\n\r\n/**\r\n * @returns {Script} a new OP_RETURN script with data\r\n * @param {(string|Buffer)} data - the data to embed in the output\r\n * @param {(string)} encoding - the type of encoding of the string\r\n */\r\nScript.buildDataOut = function(data, encoding) {\r\n  $.checkArgument(data == null || typeof data === 'string' || BufferUtil.isBuffer(data));\r\n  if (typeof data === 'string') {\r\n    data = Buffer.from(data, encoding);\r\n  }\r\n  var s = new Script();\r\n  s.add(Opcode.OP_RETURN);\r\n  if (data != null) {\r\n    s.add(data);\r\n  }\r\n  return s;\r\n};\r\n\r\n/**\r\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\r\n *    It can also be a p2sh address\r\n * @returns {Script} new pay to script hash script for given script\r\n */\r\nScript.buildScriptHashOut = function(script) {\r\n  $.checkArgument(script instanceof Script ||\r\n    (script instanceof Address && script.isPayToScriptHash()));\r\n  var s = new Script();\r\n  s.add(Opcode.OP_HASH160)\r\n    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))\r\n    .add(Opcode.OP_EQUAL);\r\n\r\n  s._network = script._network || script.network;\r\n  return s;\r\n};\r\n\r\n/**\r\n * Builds a scriptSig (a script for an input) that signs a public key output script.\r\n *\r\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\r\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\r\n */\r\nScript.buildPublicKeyIn = function(signature, sigtype) {\r\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\r\n  $.checkArgument(sigtype == null || !isNaN(sigtype));\r\n  if (signature instanceof Signature) {\r\n    signature = signature.toBuffer();\r\n  }\r\n  var script = new Script();\r\n  script.add(BufferUtil.concat([\r\n    signature,\r\n    BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\r\n  ]));\r\n  return script;\r\n};\r\n\r\n/**\r\n * Builds a scriptSig (a script for an input) that signs a public key hash\r\n * output script.\r\n *\r\n * @param {Buffer|string|PublicKey} publicKey\r\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\r\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\r\n */\r\nScript.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {\r\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\r\n  $.checkArgument(sigtype == null || !isNaN(sigtype));\r\n  if (signature instanceof Signature) {\r\n    signature = signature.toBuffer();\r\n  }\r\n  var script = new Script()\r\n    .add(BufferUtil.concat([\r\n      signature,\r\n      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\r\n    ]))\r\n    .add(new PublicKey(publicKey).toBuffer());\r\n  return script;\r\n};\r\n\r\n/**\r\n * @returns {Script} an empty script\r\n */\r\nScript.empty = function() {\r\n  return new Script();\r\n};\r\n\r\n/**\r\n * @returns {Script} a new pay to script hash script that pays to this script\r\n */\r\nScript.prototype.toScriptHashOut = function() {\r\n  return Script.buildScriptHashOut(this);\r\n};\r\n\r\n/**\r\n * @return {Script} an output script built from the address\r\n */\r\nScript.fromAddress = function(address) {\r\n  address = Address(address);\r\n  if (address.isPayToScriptHash()) {\r\n    return Script.buildScriptHashOut(address);\r\n  } else if (address.isPayToPublicKeyHash()) {\r\n    return Script.buildPublicKeyHashOut(address);\r\n  } else if (address.isPayToWitnessPublicKeyHash()) {\r\n    return Script.buildWitnessV0Out(address);\r\n  } else if (address.isPayToWitnessScriptHash()) {\r\n    return Script.buildWitnessV0Out(address);\r\n  } else if (address.isPayToTaproot()) {\r\n    return Script.buildWitnessV1Out(address);\r\n  }\r\n  throw new errors.Script.UnrecognizedAddress(address);\r\n};\r\n\r\n/**\r\n * Will return the associated address information object\r\n * @return {Address|boolean}\r\n */\r\nScript.prototype.getAddressInfo = function(opts) {\r\n  if (this._isInput) {\r\n    return this._getInputAddressInfo();\r\n  } else if (this._isOutput) {\r\n    return this._getOutputAddressInfo();\r\n  } else {\r\n    var info = this._getOutputAddressInfo();\r\n    if (!info) {\r\n      return this._getInputAddressInfo();\r\n    }\r\n    return info;\r\n  }\r\n};\r\n\r\n/**\r\n * Will return the associated output scriptPubKey address information object\r\n * @return {Address|boolean}\r\n * @private\r\n */\r\nScript.prototype._getOutputAddressInfo = function() {\r\n  var info = {};\r\n  if (this.isScriptHashOut()) {\r\n    info.hashBuffer = this.getData();\r\n    info.type = Address.PayToScriptHash;\r\n  } else if (this.isPublicKeyHashOut()) {\r\n    info.hashBuffer = this.getData();\r\n    info.type = Address.PayToPublicKeyHash;\r\n  } else if (this.isWitnessScriptHashOut()) {\r\n    info.hashBuffer = this.getData();\r\n    info.type = Address.PayToWitnessScriptHash;\r\n  } else if (this.isWitnessPublicKeyHashOut()) {\r\n    info.hashBuffer = this.getData();\r\n    info.type = Address.PayToWitnessPublicKeyHash;\r\n  } else if (this.isTaproot()) {\r\n    info.hashBuffer = this.getData();\r\n    info.type = Address.PayToTaproot;\r\n  } else {\r\n    return false;\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * Will return the associated input scriptSig address information object\r\n * @return {Address|boolean}\r\n * @private\r\n */\r\nScript.prototype._getInputAddressInfo = function() {\r\n  var info = {};\r\n  if (this.isPublicKeyHashIn()) {\r\n    // hash the publickey found in the scriptSig\r\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\r\n    info.type = Address.PayToPublicKeyHash;\r\n  } else if (this.isScriptHashIn()) {\r\n    // hash the redeemscript found at the end of the scriptSig\r\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\r\n    info.type = Address.PayToScriptHash;\r\n  } else {\r\n    return false;\r\n  }\r\n  return info;\r\n};\r\n\r\n/**\r\n * @param {Network=} network\r\n * @return {Address|boolean} the associated address for this script if possible, or false\r\n */\r\nScript.prototype.toAddress = function(network) {\r\n  var info = this.getAddressInfo();\r\n  if (!info) {\r\n    return false;\r\n  }\r\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\r\n  return new Address(info);\r\n};\r\n\r\n/**\r\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\r\n * typically used with push data chunks.  Note that this will find and delete\r\n * not just the same data, but the same data with the same push data op as\r\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\r\n * pushdata op, then when you try to remove the data it is pushing, it will not\r\n * be removed, because they do not use the same pushdata op.\r\n */\r\nScript.prototype.findAndDelete = function(script) {\r\n  var buf = script.toBuffer();\r\n  var hex = buf.toString('hex');\r\n  for (var i = 0; i < this.chunks.length; i++) {\r\n    var script2 = Script({\r\n      chunks: [this.chunks[i]]\r\n    });\r\n    var buf2 = script2.toBuffer();\r\n    var hex2 = buf2.toString('hex');\r\n    if (hex === hex2) {\r\n      this.chunks.splice(i, 1);\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Comes from bitcoind's script interpreter CheckMinimalPush function\r\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\r\n */\r\nScript.prototype.checkMinimalPush = function(i) {\r\n  var chunk = this.chunks[i];\r\n  var buf = chunk.buf;\r\n  var opcodenum = chunk.opcodenum;\r\n  if (!buf) {\r\n    return true;\r\n  }\r\n  if (buf.length === 0) {\r\n    // Could have used OP_0.\r\n    return opcodenum === Opcode.OP_0;\r\n  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\r\n    // Could have used OP_1 .. OP_16.\r\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\r\n  } else if (buf.length === 1 && buf[0] === 0x81) {\r\n    // Could have used OP_1NEGATE\r\n    return opcodenum === Opcode.OP_1NEGATE;\r\n  } else if (buf.length <= 75) {\r\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\r\n    return opcodenum === buf.length;\r\n  } else if (buf.length <= 255) {\r\n    // Could have used OP_PUSHDATA.\r\n    return opcodenum === Opcode.OP_PUSHDATA1;\r\n  } else if (buf.length <= 65535) {\r\n    // Could have used OP_PUSHDATA2.\r\n    return opcodenum === Opcode.OP_PUSHDATA2;\r\n  }\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Comes from bitcoind's script GetSigOpCount(boolean) function\r\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\r\n * @returns {number} number of signature operations required by this script\r\n */\r\nScript.prototype.getSignatureOperationsCount = function(accurate) {\r\n  accurate = (accurate == null ? true : accurate);\r\n  var n = 0;\r\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\r\n  for (const chunk of this.chunks) {\r\n    var opcode = chunk.opcodenum;\r\n    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {\r\n      n++;\r\n    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {\r\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\r\n        n += Opcode.decodeOpN(lastOpcode);\r\n      } else {\r\n        n += 20;\r\n      }\r\n    }\r\n    lastOpcode = opcode;\r\n  }\r\n  return n;\r\n};\r\n\r\nmodule.exports = Script;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLE1BQU07QUFDTixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi9zY3JpcHQvc2NyaXB0LmpzP2I4NmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi9hZGRyZXNzJyk7XHJcbnZhciBCdWZmZXJSZWFkZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJyZWFkZXInKTtcclxudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xyXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by9oYXNoJyk7XHJcbnZhciBPcGNvZGUgPSByZXF1aXJlKCcuLi9vcGNvZGUnKTtcclxudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4uL3B1YmxpY2tleScpO1xyXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xyXG52YXIgTmV0d29ya3MgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcclxudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvanMnKTtcclxuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by90YWdnZWRoYXNoJyk7XHJcblxyXG4vKipcclxuICogQSBiaXRjb2luIHRyYW5zYWN0aW9uIHNjcmlwdC4gRWFjaCB0cmFuc2FjdGlvbidzIGlucHV0cyBhbmQgb3V0cHV0c1xyXG4gKiBoYXMgYSBzY3JpcHQgdGhhdCBpcyBldmFsdWF0ZWQgdG8gdmFsaWRhdGUgaXQncyBzcGVuZGluZy5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL1NjcmlwdFxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfEJ1ZmZlcj19IGZyb20gb3B0aW9uYWwgZGF0YSB0byBwb3B1bGF0ZSBzY3JpcHRcclxuICovXHJcbnZhciBTY3JpcHQgPSBmdW5jdGlvbiBTY3JpcHQoZnJvbSkge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSB7XHJcbiAgICByZXR1cm4gbmV3IFNjcmlwdChmcm9tKTtcclxuICB9XHJcbiAgdGhpcy5jaHVua3MgPSBbXTtcclxuXHJcbiAgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIoZnJvbSkpIHtcclxuICAgIHJldHVybiBTY3JpcHQuZnJvbUJ1ZmZlcihmcm9tKTtcclxuICB9IGVsc2UgaWYgKGZyb20gaW5zdGFuY2VvZiBBZGRyZXNzKSB7XHJcbiAgICByZXR1cm4gU2NyaXB0LmZyb21BZGRyZXNzKGZyb20pO1xyXG4gIH0gZWxzZSBpZiAoZnJvbSBpbnN0YW5jZW9mIFNjcmlwdCkge1xyXG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tQnVmZmVyKGZyb20udG9CdWZmZXIoKSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZnJvbSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBTY3JpcHQuZnJvbVN0cmluZyhmcm9tKTtcclxuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZnJvbSkgJiYgQXJyYXkuaXNBcnJheShmcm9tLmNodW5rcykpIHtcclxuICAgIHRoaXMuc2V0KGZyb20pO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5TY3JpcHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICQuY2hlY2tBcmd1bWVudChfLmlzT2JqZWN0KG9iaikpO1xyXG4gICQuY2hlY2tBcmd1bWVudChBcnJheS5pc0FycmF5KG9iai5jaHVua3MpKTtcclxuICB0aGlzLmNodW5rcyA9IG9iai5jaHVua3M7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TY3JpcHQuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gIHZhciBzY3JpcHQgPSBuZXcgU2NyaXB0KCk7XHJcbiAgc2NyaXB0LmNodW5rcyA9IFtdO1xyXG5cclxuICB2YXIgYnIgPSBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcik7XHJcbiAgd2hpbGUgKCFici5maW5pc2hlZCgpKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgb3Bjb2RlbnVtID0gYnIucmVhZFVJbnQ4KCk7XHJcblxyXG4gICAgICB2YXIgbGVuLCBidWY7XHJcbiAgICAgIGlmIChvcGNvZGVudW0gPiAwICYmIG9wY29kZW51bSA8IE9wY29kZS5PUF9QVVNIREFUQTEpIHtcclxuICAgICAgICBsZW4gPSBvcGNvZGVudW07XHJcbiAgICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcclxuICAgICAgICAgIGJ1ZjogYnIucmVhZChsZW4pLFxyXG4gICAgICAgICAgbGVuOiBsZW4sXHJcbiAgICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSkge1xyXG4gICAgICAgIGxlbiA9IGJyLnJlYWRVSW50OCgpO1xyXG4gICAgICAgIGJ1ZiA9IGJyLnJlYWQobGVuKTtcclxuICAgICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xyXG4gICAgICAgICAgYnVmOiBidWYsXHJcbiAgICAgICAgICBsZW46IGxlbixcclxuICAgICAgICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyKSB7XHJcbiAgICAgICAgbGVuID0gYnIucmVhZFVJbnQxNkxFKCk7XHJcbiAgICAgICAgYnVmID0gYnIucmVhZChsZW4pO1xyXG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XHJcbiAgICAgICAgICBidWY6IGJ1ZixcclxuICAgICAgICAgIGxlbjogbGVuLFxyXG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTQpIHtcclxuICAgICAgICBsZW4gPSBici5yZWFkVUludDMyTEUoKTtcclxuICAgICAgICBidWYgPSBici5yZWFkKGxlbik7XHJcbiAgICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcclxuICAgICAgICAgIGJ1ZjogYnVmLFxyXG4gICAgICAgICAgbGVuOiBsZW4sXHJcbiAgICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKE9wY29kZS5pc09wU3VjY2VzcyhvcGNvZGVudW0pKSB7XHJcbiAgICAgICAgLy8gT1BfU1VDQ0VTU3ggcHJvY2Vzc2luZyBvdmVycmlkZXMgZXZlcnl0aGluZywgaW5jbHVkaW5nIHN0YWNrIGVsZW1lbnQgc2l6ZSBsaW1pdHNcclxuICAgICAgICBidWYgPSBici5yZWFkQWxsKCk7XHJcbiAgICAgICAgbGVuID0gYnVmLmxlbmd0aDtcclxuICAgICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xyXG4gICAgICAgICAgYnVmOiBidWYsXHJcbiAgICAgICAgICBsZW46IGxlbixcclxuICAgICAgICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcclxuICAgICAgICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5TY3JpcHQuSW52YWxpZEJ1ZmZlcihidWZmZXIudG9TdHJpbmcoJ2hleCcpKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNjcmlwdDtcclxufTtcclxuXHJcblNjcmlwdC5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBjaHVuayA9IHRoaXMuY2h1bmtzW2ldO1xyXG4gICAgdmFyIG9wY29kZW51bSA9IGNodW5rLm9wY29kZW51bTtcclxuICAgIGJ3LndyaXRlVUludDgoY2h1bmsub3Bjb2RlbnVtKTtcclxuICAgIGlmIChjaHVuay5idWYpIHtcclxuICAgICAgaWYgKG9wY29kZW51bSA8IE9wY29kZS5PUF9QVVNIREFUQTEpIHtcclxuICAgICAgICBidy53cml0ZShjaHVuay5idWYpO1xyXG4gICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSkge1xyXG4gICAgICAgIGJ3LndyaXRlVUludDgoY2h1bmsubGVuKTtcclxuICAgICAgICBidy53cml0ZShjaHVuay5idWYpO1xyXG4gICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMikge1xyXG4gICAgICAgIGJ3LndyaXRlVUludDE2TEUoY2h1bmsubGVuKTtcclxuICAgICAgICBidy53cml0ZShjaHVuay5idWYpO1xyXG4gICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBNCkge1xyXG4gICAgICAgIGJ3LndyaXRlVUludDMyTEUoY2h1bmsubGVuKTtcclxuICAgICAgICBidy53cml0ZShjaHVuay5idWYpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENvdWxkIHJlYWNoIGhlcmUgaWYgb3Bjb2RlbnVtIGlzIE9QX1NVQ0NFU1N4IChzZWUgY29tbWVudCBpbiAuZnJvbUJ1ZmZlcilcclxuICAgICAgICBidy53cml0ZShjaHVuay5idWYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYncuY29uY2F0KCk7XHJcbn07XHJcblxyXG5TY3JpcHQuZnJvbUFTTSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gIHZhciBzY3JpcHQgPSBuZXcgU2NyaXB0KCk7XHJcbiAgc2NyaXB0LmNodW5rcyA9IFtdO1xyXG5cclxuICB2YXIgdG9rZW5zID0gc3RyLnNwbGl0KCcgJyk7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xyXG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgdmFyIG9wY29kZSA9IE9wY29kZSh0b2tlbik7XHJcbiAgICB2YXIgb3Bjb2RlbnVtID0gb3Bjb2RlLnRvTnVtYmVyKCk7XHJcblxyXG4gICAgaWYgKG9wY29kZW51bSA9PSBudWxsKSB7XHJcbiAgICAgIHZhciBidWYgPSBCdWZmZXIuZnJvbSh0b2tlbnNbaV0sICdoZXgnKTtcclxuICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcclxuICAgICAgICBidWY6IGJ1ZixcclxuICAgICAgICBsZW46IGJ1Zi5sZW5ndGgsXHJcbiAgICAgICAgb3Bjb2RlbnVtOiBidWYubGVuZ3RoXHJcbiAgICAgIH0pO1xyXG4gICAgICBpID0gaSArIDE7XHJcbiAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSB8fFxyXG4gICAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTIgfHxcclxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEE0KSB7XHJcbiAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XHJcbiAgICAgICAgYnVmOiBCdWZmZXIuZnJvbSh0b2tlbnNbaSArIDJdLCAnaGV4JyksXHJcbiAgICAgICAgbGVuOiBwYXJzZUludCh0b2tlbnNbaSArIDFdKSxcclxuICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxyXG4gICAgICB9KTtcclxuICAgICAgaSA9IGkgKyAzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcclxuICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxyXG4gICAgICB9KTtcclxuICAgICAgaSA9IGkgKyAxO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2NyaXB0O1xyXG59O1xyXG5cclxuU2NyaXB0LmZyb21IZXggPSBmdW5jdGlvbihzdHIpIHtcclxuICByZXR1cm4gbmV3IFNjcmlwdChCdWZmZXIuZnJvbShzdHIsICdoZXgnKSk7XHJcbn07XHJcblxyXG5TY3JpcHQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gIGlmIChKU1V0aWwuaXNIZXhhKHN0cikgfHwgc3RyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIG5ldyBTY3JpcHQoQnVmZmVyLmZyb20oc3RyLCAnaGV4JykpO1xyXG4gIH1cclxuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpO1xyXG4gIHNjcmlwdC5jaHVua3MgPSBbXTtcclxuXHJcbiAgdmFyIHRva2VucyA9IHN0ci5zcGxpdCgnICcpO1xyXG4gIHZhciBpID0gMDtcclxuICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcclxuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgIHZhciBvcGNvZGUgPSBPcGNvZGUodG9rZW4pO1xyXG4gICAgdmFyIG9wY29kZW51bSA9IG9wY29kZS50b051bWJlcigpO1xyXG5cclxuICAgIGlmIChvcGNvZGVudW0gPT0gbnVsbCkge1xyXG4gICAgICBvcGNvZGVudW0gPSBwYXJzZUludCh0b2tlbik7XHJcbiAgICAgIGlmIChvcGNvZGVudW0gPiAwICYmIG9wY29kZW51bSA8IE9wY29kZS5PUF9QVVNIREFUQTEpIHtcclxuICAgICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xyXG4gICAgICAgICAgYnVmOiBCdWZmZXIuZnJvbSh0b2tlbnNbaSArIDFdLnNsaWNlKDIpLCAnaGV4JyksXHJcbiAgICAgICAgICBsZW46IG9wY29kZW51bSxcclxuICAgICAgICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaSA9IGkgKyAyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY3JpcHQ6ICcgKyBKU09OLnN0cmluZ2lmeShzdHIpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTEgfHxcclxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyIHx8XHJcbiAgICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBNCkge1xyXG4gICAgICBpZiAodG9rZW5zW2kgKyAyXS5zbGljZSgwLCAyKSAhPT0gJzB4Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHVzaGRhdGEgZGF0YSBtdXN0IHN0YXJ0IHdpdGggMHgnKTtcclxuICAgICAgfVxyXG4gICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xyXG4gICAgICAgIGJ1ZjogQnVmZmVyLmZyb20odG9rZW5zW2kgKyAyXS5zbGljZSgyKSwgJ2hleCcpLFxyXG4gICAgICAgIGxlbjogcGFyc2VJbnQodG9rZW5zW2kgKyAxXSksXHJcbiAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cclxuICAgICAgfSk7XHJcbiAgICAgIGkgPSBpICsgMztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XHJcbiAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cclxuICAgICAgfSk7XHJcbiAgICAgIGkgPSBpICsgMTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHNjcmlwdDtcclxufTtcclxuXHJcblNjcmlwdC5wcm90b3R5cGUuX2NodW5rVG9TdHJpbmcgPSBmdW5jdGlvbihjaHVuaywgdHlwZSkge1xyXG4gIHZhciBvcGNvZGVudW0gPSBjaHVuay5vcGNvZGVudW07XHJcbiAgdmFyIGFzbSA9ICh0eXBlID09PSAnYXNtJyk7XHJcbiAgdmFyIHN0ciA9ICcnO1xyXG4gIGlmICghY2h1bmsuYnVmKSB7XHJcbiAgICAvLyBubyBkYXRhIGNodW5rXHJcbiAgICBpZiAodHlwZW9mIE9wY29kZS5yZXZlcnNlTWFwW29wY29kZW51bV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGlmIChhc20pIHtcclxuICAgICAgICAvLyBBIGZldyBjYXNlcyB3aGVyZSB0aGUgb3Bjb2RlIG5hbWUgZGlmZmVycyBmcm9tIHJldmVyc2VNYXBcclxuICAgICAgICAvLyBhc2lkZSBmcm9tIDEgdG8gMTYgZGF0YSBwdXNoZXMuXHJcbiAgICAgICAgaWYgKG9wY29kZW51bSA9PT0gMCkge1xyXG4gICAgICAgICAgLy8gT1BfMCAtPiAwXHJcbiAgICAgICAgICBzdHIgPSBzdHIgKyAnIDAnO1xyXG4gICAgICAgIH0gZWxzZSBpZihvcGNvZGVudW0gPT09IDc5KSB7XHJcbiAgICAgICAgICAvLyBPUF8xTkVHQVRFIC0+IDFcclxuICAgICAgICAgIHN0ciA9IHN0ciArICcgLTEnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyBPcGNvZGUob3Bjb2RlbnVtKS50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyBPcGNvZGUob3Bjb2RlbnVtKS50b1N0cmluZygpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgbnVtc3RyID0gb3Bjb2RlbnVtLnRvU3RyaW5nKDE2KTtcclxuICAgICAgaWYgKG51bXN0ci5sZW5ndGggJSAyICE9PSAwKSB7XHJcbiAgICAgICAgbnVtc3RyID0gJzAnICsgbnVtc3RyO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhc20pIHtcclxuICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyBudW1zdHI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RyID0gc3RyICsgJyAnICsgJzB4JyArIG51bXN0cjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBkYXRhIGNodW5rXHJcbiAgICBpZiAoIWFzbSAmJiBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTEgfHxcclxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyIHx8XHJcbiAgICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBNCkge1xyXG4gICAgICBzdHIgPSBzdHIgKyAnICcgKyBPcGNvZGUob3Bjb2RlbnVtKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNodW5rLmxlbiA+IDApIHtcclxuICAgICAgaWYgKGFzbSkge1xyXG4gICAgICAgIHN0ciA9IHN0ciArICcgJyArIGNodW5rLmJ1Zi50b1N0cmluZygnaGV4Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RyID0gc3RyICsgJyAnICsgY2h1bmsubGVuICsgJyAnICsgJzB4JyArIGNodW5rLmJ1Zi50b1N0cmluZygnaGV4Jyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcblNjcmlwdC5wcm90b3R5cGUudG9BU00gPSBmdW5jdGlvbigpIHtcclxuICB2YXIgc3RyID0gJyc7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGNodW5rID0gdGhpcy5jaHVua3NbaV07XHJcbiAgICBzdHIgKz0gdGhpcy5fY2h1bmtUb1N0cmluZyhjaHVuaywgJ2FzbScpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMSk7XHJcbn07XHJcblxyXG5TY3JpcHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHN0ciA9ICcnO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBjaHVuayA9IHRoaXMuY2h1bmtzW2ldO1xyXG4gICAgc3RyICs9IHRoaXMuX2NodW5rVG9TdHJpbmcoY2h1bmspO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMSk7XHJcbn07XHJcblxyXG5TY3JpcHQucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XHJcbn07XHJcblxyXG5TY3JpcHQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gJzxTY3JpcHQ6ICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnPic7XHJcbn07XHJcblxyXG4vLyBzY3JpcHQgY2xhc3NpZmljYXRpb24gbWV0aG9kc1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiB0aGlzIGlzIGEgcGF5IHRvIHB1YmtleSBoYXNoIG91dHB1dCBzY3JpcHRcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlIYXNoT3V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICEhKHRoaXMuY2h1bmtzLmxlbmd0aCA9PT0gNSAmJlxyXG4gICAgdGhpcy5jaHVua3NbMF0ub3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfRFVQICYmXHJcbiAgICB0aGlzLmNodW5rc1sxXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9IQVNIMTYwICYmXHJcbiAgICB0aGlzLmNodW5rc1syXS5idWYgJiZcclxuICAgIHRoaXMuY2h1bmtzWzJdLmJ1Zi5sZW5ndGggPT09IDIwICYmXHJcbiAgICB0aGlzLmNodW5rc1szXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9FUVVBTFZFUklGWSAmJlxyXG4gICAgdGhpcy5jaHVua3NbNF0ub3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfQ0hFQ0tTSUcpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiB0aGlzIGlzIGEgcGF5IHRvIHB1YmxpYyBrZXkgaGFzaCBpbnB1dCBzY3JpcHRcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlIYXNoSW4gPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAyKSB7XHJcbiAgICB2YXIgc2lnbmF0dXJlQnVmID0gdGhpcy5jaHVua3NbMF0uYnVmO1xyXG4gICAgdmFyIHB1YmtleUJ1ZiA9IHRoaXMuY2h1bmtzWzFdLmJ1ZjtcclxuICAgIGlmIChzaWduYXR1cmVCdWYgJiZcclxuICAgICAgICBzaWduYXR1cmVCdWYubGVuZ3RoICYmXHJcbiAgICAgICAgc2lnbmF0dXJlQnVmWzBdID09PSAweDMwICYmXHJcbiAgICAgICAgcHVia2V5QnVmICYmXHJcbiAgICAgICAgcHVia2V5QnVmLmxlbmd0aFxyXG4gICAgICAgKSB7XHJcbiAgICAgIHZhciB2ZXJzaW9uID0gcHVia2V5QnVmWzBdO1xyXG4gICAgICBpZiAoKHZlcnNpb24gPT09IDB4MDQgfHxcclxuICAgICAgICAgICB2ZXJzaW9uID09PSAweDA2IHx8XHJcbiAgICAgICAgICAgdmVyc2lvbiA9PT0gMHgwNykgJiYgcHVia2V5QnVmLmxlbmd0aCA9PT0gNjUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSBlbHNlIGlmICgodmVyc2lvbiA9PT0gMHgwMyB8fCB2ZXJzaW9uID09PSAweDAyKSAmJiBwdWJrZXlCdWYubGVuZ3RoID09PSAzMykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcblNjcmlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24oKSB7XHJcbiAgJC5jaGVja1N0YXRlKHRoaXMuaXNQdWJsaWNLZXlPdXQoKSwgJ0NhblxcJ3QgcmV0cmlldmUgUHVibGljS2V5IGZyb20gYSBub24tUEsgb3V0cHV0Jyk7XHJcbiAgcmV0dXJuIHRoaXMuY2h1bmtzWzBdLmJ1ZjtcclxufTtcclxuXHJcblNjcmlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5SGFzaCA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICh0aGlzLmlzUHVibGljS2V5SGFzaE91dCgpKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jaHVua3NbMl0uYnVmO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkpIHtcclxuICAgIHJldHVybiB0aGlzLmNodW5rc1sxXS5idWY7XHJcbiAgfSBlbHNlIGlmICh0aGlzLmlzVGFwcm9vdCgpKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jaHVua3NbMV0uYnVmO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcmV0cmlldmUgUHVibGljS2V5SGFzaCBmcm9tIGEgbm9uLVBLSCBvdXRwdXQnKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwdWJsaWMga2V5IG91dHB1dCBzY3JpcHRcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlPdXQgPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAyICYmXHJcbiAgICAgIHRoaXMuY2h1bmtzWzBdLmJ1ZiAmJlxyXG4gICAgICB0aGlzLmNodW5rc1swXS5idWYubGVuZ3RoICYmXHJcbiAgICAgIHRoaXMuY2h1bmtzWzFdLm9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0NIRUNLU0lHKSB7XHJcbiAgICB2YXIgcHVia2V5QnVmID0gdGhpcy5jaHVua3NbMF0uYnVmO1xyXG4gICAgdmFyIHZlcnNpb24gPSBwdWJrZXlCdWZbMF07XHJcbiAgICB2YXIgaXNWZXJzaW9uID0gZmFsc2U7XHJcbiAgICBpZiAoKHZlcnNpb24gPT09IDB4MDQgfHxcclxuICAgICAgICAgdmVyc2lvbiA9PT0gMHgwNiB8fFxyXG4gICAgICAgICB2ZXJzaW9uID09PSAweDA3KSAmJiBwdWJrZXlCdWYubGVuZ3RoID09PSA2NSkge1xyXG4gICAgICBpc1ZlcnNpb24gPSB0cnVlO1xyXG4gICAgfSBlbHNlIGlmICgodmVyc2lvbiA9PT0gMHgwMyB8fCB2ZXJzaW9uID09PSAweDAyKSAmJiBwdWJrZXlCdWYubGVuZ3RoID09PSAzMykge1xyXG4gICAgICBpc1ZlcnNpb24gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVmVyc2lvbikge1xyXG4gICAgICByZXR1cm4gUHVibGljS2V5LmlzVmFsaWQocHVia2V5QnVmKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiB0aGlzIGlzIGEgcGF5IHRvIHB1YmxpYyBrZXkgaW5wdXQgc2NyaXB0XHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLmlzUHVibGljS2V5SW4gPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICB2YXIgc2lnbmF0dXJlQnVmID0gdGhpcy5jaHVua3NbMF0uYnVmO1xyXG4gICAgaWYgKHNpZ25hdHVyZUJ1ZiAmJlxyXG4gICAgICAgIHNpZ25hdHVyZUJ1Zi5sZW5ndGggJiZcclxuICAgICAgICBzaWduYXR1cmVCdWZbMF0gPT09IDB4MzApIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHAyc2ggb3V0cHV0IHNjcmlwdFxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5pc1NjcmlwdEhhc2hPdXQgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xyXG4gIHJldHVybiAoYnVmLmxlbmd0aCA9PT0gMjMgJiZcclxuICAgIGJ1ZlswXSA9PT0gT3Bjb2RlLk9QX0hBU0gxNjAgJiZcclxuICAgIGJ1ZlsxXSA9PT0gMHgxNCAmJlxyXG4gICAgYnVmW2J1Zi5sZW5ndGggLSAxXSA9PT0gT3Bjb2RlLk9QX0VRVUFMKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHAyd3NoIG91dHB1dCBzY3JpcHRcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuaXNXaXRuZXNzU2NyaXB0SGFzaE91dCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XHJcbiAgcmV0dXJuIChidWYubGVuZ3RoID09PSAzNCAmJiBidWZbMF0gPT09IE9wY29kZS5PUF8wICYmIGJ1ZlsxXSA9PT0gMzIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiB0aGlzIGlzIGEgcDJ3cGtoIG91dHB1dCBzY3JpcHRcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XHJcbiAgcmV0dXJuIChidWYubGVuZ3RoID09PSAyMiAmJiBidWZbMF0gPT09IE9wY29kZS5PUF8wICYmIGJ1ZlsxXSA9PT0gMjApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiB0aGlzIGlzIGEgcDJ0ciBvdXRwdXQgc2NyaXB0XHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLmlzVGFwcm9vdCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XHJcbiAgcmV0dXJuIChidWYubGVuZ3RoID09PSAzNCAmJiBidWZbMF0gPT09IE9wY29kZS5PUF8xICYmIGJ1ZlsxXSA9PT0gMzIpO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtPYmplY3Q9fSB2YWx1ZXMgLSBUaGUgcmV0dXJuIHZhbHVlc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVzLnZlcnNpb24gLSBTZXQgd2l0aCB0aGUgd2l0bmVzcyB2ZXJzaW9uXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZXMucHJvZ3JhbSAtIFNldCB3aXRoIHRoZSB3aXRuZXNzIHByb2dyYW1cclxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMndwa2ggb3V0cHV0IHNjcmlwdFxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5pc1dpdG5lc3NQcm9ncmFtID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgaWYgKCF2YWx1ZXMpIHtcclxuICAgIHZhbHVlcyA9IHt9O1xyXG4gIH1cclxuICB2YXIgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xyXG4gIGlmIChidWYubGVuZ3RoIDwgNCB8fCBidWYubGVuZ3RoID4gNDIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKGJ1ZlswXSAhPT0gT3Bjb2RlLk9QXzAgJiYgIShidWZbMF0gPj0gT3Bjb2RlLk9QXzEgJiYgYnVmWzBdIDw9IE9wY29kZS5PUF8xNikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChidWYubGVuZ3RoID09PSBidWZbMV0gKyAyKSB7XHJcbiAgICB2YWx1ZXMudmVyc2lvbiA9IE9wY29kZS5kZWNvZGVPcE4oYnVmWzBdKTtcclxuICAgIHZhbHVlcy5wcm9ncmFtID0gYnVmLnNsaWNlKDIsIGJ1Zi5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMnNoIGlucHV0IHNjcmlwdFxyXG4gKiBOb3RlIHRoYXQgdGhlc2UgYXJlIGZyZXF1ZW50bHkgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBwdWJrZXloYXNoaW5cclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuaXNTY3JpcHRIYXNoSW4gPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5jaHVua3MubGVuZ3RoIDw9IDEpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIHJlZGVlbUNodW5rID0gdGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV07XHJcbiAgdmFyIHJlZGVlbUJ1ZiA9IHJlZGVlbUNodW5rLmJ1ZjtcclxuICBpZiAoIXJlZGVlbUJ1Zikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlZGVlbVNjcmlwdDtcclxuICB0cnkge1xyXG4gICAgcmVkZWVtU2NyaXB0ID0gU2NyaXB0LmZyb21CdWZmZXIocmVkZWVtQnVmKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAoZSBpbnN0YW5jZW9mIGVycm9ycy5TY3JpcHQuSW52YWxpZEJ1ZmZlcikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBlO1xyXG4gIH1cclxuICB2YXIgdHlwZSA9IHJlZGVlbVNjcmlwdC5jbGFzc2lmeSgpO1xyXG4gIHJldHVybiB0eXBlICE9PSBTY3JpcHQudHlwZXMuVU5LTk9XTjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIG11dGxzaWcgb3V0cHV0IHNjcmlwdFxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5pc011bHRpc2lnT3V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICh0aGlzLmNodW5rcy5sZW5ndGggPiAzICYmXHJcbiAgICBPcGNvZGUuaXNTbWFsbEludE9wKHRoaXMuY2h1bmtzWzBdLm9wY29kZW51bSkgJiZcclxuICAgIHRoaXMuY2h1bmtzLnNsaWNlKDEsIHRoaXMuY2h1bmtzLmxlbmd0aCAtIDIpLmV2ZXJ5KGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqLmJ1ZiAmJiBCdWZmZXJVdGlsLmlzQnVmZmVyKG9iai5idWYpO1xyXG4gICAgfSkgJiZcclxuICAgIE9wY29kZS5pc1NtYWxsSW50T3AodGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMl0ub3Bjb2RlbnVtKSAmJlxyXG4gICAgdGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV0ub3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJRyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiB0aGlzIGlzIGEgbXVsdGlzaWcgaW5wdXQgc2NyaXB0XHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLmlzTXVsdGlzaWdJbiA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmNodW5rcy5sZW5ndGggPj0gMiAmJlxyXG4gICAgdGhpcy5jaHVua3NbMF0ub3Bjb2RlbnVtID09PSAwICYmXHJcbiAgICB0aGlzLmNodW5rcy5zbGljZSgxLCB0aGlzLmNodW5rcy5sZW5ndGgpLmV2ZXJ5KGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqLmJ1ZiAmJlxyXG4gICAgICAgIEJ1ZmZlclV0aWwuaXNCdWZmZXIob2JqLmJ1ZikgJiZcclxuICAgICAgICBTaWduYXR1cmUuaXNUeERFUihvYmouYnVmKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBzdGFuZGFyZCBPUF9SRVRVUk4gb3V0cHV0XHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLmlzRGF0YU91dCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmNodW5rcy5sZW5ndGggPj0gMSAmJlxyXG4gICAgdGhpcy5jaHVua3NbMF0ub3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUkVUVVJOICYmXHJcbiAgICAodGhpcy5jaHVua3MubGVuZ3RoID09PSAxIHx8XHJcbiAgICAgICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDIgJiZcclxuICAgICAgICB0aGlzLmNodW5rc1sxXS5idWYgJiZcclxuICAgICAgICB0aGlzLmNodW5rc1sxXS5idWYubGVuZ3RoIDw9IFNjcmlwdC5PUF9SRVRVUk5fU1RBTkRBUkRfU0laRSAmJlxyXG4gICAgICAgIHRoaXMuY2h1bmtzWzFdLmxlbmd0aCA9PT0gdGhpcy5jaHVua3MubGVuKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgdGhlIGFzc29jaWF0ZWQgZGF0YSBmb3IgdGhpcyBzY3JpcHQuXHJcbiAqIEluIHRoZSBjYXNlIG9mIGEgcGF5IHRvIHB1YmxpYyBrZXkgaGFzaCwgUDJTSCwgUDJXU0gsIG9yIFAyV1BLSCwgcmV0dXJuIHRoZSBoYXNoLlxyXG4gKiBJbiB0aGUgY2FzZSBvZiBhIHN0YW5kYXJkIE9QX1JFVFVSTiwgcmV0dXJuIHRoZSBkYXRhXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5pc0RhdGFPdXQoKSB8fCB0aGlzLmlzU2NyaXB0SGFzaE91dCgpIHx8IHRoaXMuaXNXaXRuZXNzU2NyaXB0SGFzaE91dCgpIHx8IHRoaXMuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCgpIHx8IHRoaXMuaXNUYXByb290KCkpIHtcclxuICAgIGlmICh0aGlzLmNodW5rc1sxXSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5jaHVua3NbMV0uYnVmKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHRoaXMuaXNQdWJsaWNLZXlIYXNoT3V0KCkpIHtcclxuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmNodW5rc1syXS5idWYpO1xyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBzY3JpcHQgdHlwZSB0byBnZXQgZGF0YSBmcm9tJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoZSBzY3JpcHQgaXMgb25seSBjb21wb3NlZCBvZiBkYXRhIHB1c2hpbmdcclxuICogb3Bjb2RlcyBvciBzbWFsbCBpbnQgb3Bjb2RlcyAoT1BfMCwgT1BfMSwgLi4uLCBPUF8xNilcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuaXNQdXNoT25seSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmNodW5rcy5ldmVyeShmdW5jdGlvbihjaHVuaykge1xyXG4gICAgcmV0dXJuIGNodW5rLm9wY29kZW51bSA8PSBPcGNvZGUuT1BfMTY7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5cclxuU2NyaXB0LnR5cGVzID0ge307XHJcblNjcmlwdC50eXBlcy5VTktOT1dOID0gJ1Vua25vd24nO1xyXG5TY3JpcHQudHlwZXMuUFVCS0VZX09VVCA9ICdQYXkgdG8gcHVibGljIGtleSc7XHJcblNjcmlwdC50eXBlcy5QVUJLRVlfSU4gPSAnU3BlbmQgZnJvbSBwdWJsaWMga2V5JztcclxuU2NyaXB0LnR5cGVzLlBVQktFWUhBU0hfT1VUID0gJ1BheSB0byBwdWJsaWMga2V5IGhhc2gnO1xyXG5TY3JpcHQudHlwZXMuUFVCS0VZSEFTSF9JTiA9ICdTcGVuZCBmcm9tIHB1YmxpYyBrZXkgaGFzaCc7XHJcblNjcmlwdC50eXBlcy5TQ1JJUFRIQVNIX09VVCA9ICdQYXkgdG8gc2NyaXB0IGhhc2gnO1xyXG5TY3JpcHQudHlwZXMuU0NSSVBUSEFTSF9JTiA9ICdTcGVuZCBmcm9tIHNjcmlwdCBoYXNoJztcclxuU2NyaXB0LnR5cGVzLk1VTFRJU0lHX09VVCA9ICdQYXkgdG8gbXVsdGlzaWcnO1xyXG5TY3JpcHQudHlwZXMuTVVMVElTSUdfSU4gPSAnU3BlbmQgZnJvbSBtdWx0aXNpZyc7XHJcblNjcmlwdC50eXBlcy5EQVRBX09VVCA9ICdEYXRhIHB1c2gnO1xyXG5cclxuU2NyaXB0Lk9QX1JFVFVSTl9TVEFOREFSRF9TSVpFID0gODA7XHJcblxyXG4vLyBUYWcgZm9yIGlucHV0IGFubmV4LiBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIHdpdG5lc3MgZWxlbWVudHMgZm9yIGEgdHJhbnNhY3Rpb24gaW5wdXQsXHJcbi8vIGFuZCB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgbGFzdCBlbGVtZW50IGlzIDB4NTAsIHRoaXMgbGFzdCBlbGVtZW50IGlzIGNhbGxlZCBhbm5leCwgYW5kXHJcbi8vIGhhcyBtZWFuaW5ncyBpbmRlcGVuZGVudCBvZiB0aGUgc2NyaXB0XHJcblNjcmlwdC5BTk5FWF9UQUcgPSAweDUwO1xyXG5cclxuLy8gVmFsaWRhdGlvbiB3ZWlnaHQgcGVyIHBhc3Npbmcgc2lnbmF0dXJlIChUYXBzY3JpcHQgb25seSwgc2VlIEJJUCAzNDIpLlxyXG5TY3JpcHQuVkFMSURBVElPTl9XRUlHSFRfUEVSX1NJR09QX1BBU1NFRCA9IDUwO1xyXG5cclxuLy8gSG93IG11Y2ggd2VpZ2h0IGJ1ZGdldCBpcyBhZGRlZCB0byB0aGUgd2l0bmVzcyBzaXplIChUYXBzY3JpcHQgb25seSwgc2VlIEJJUCAzNDIpLlxyXG5TY3JpcHQuVkFMSURBVElPTl9XRUlHSFRfT0ZGU0VUID0gNTA7XHJcblxyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBTY3JpcHQgdHlwZSBpZiBpdCBpcyBhIGtub3duIGZvcm0sXHJcbiAqIG9yIFNjcmlwdC5VTktOT1dOIGlmIGl0IGlzbid0XHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLmNsYXNzaWZ5ID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKHRoaXMuX2lzSW5wdXQpIHtcclxuICAgIHJldHVybiB0aGlzLmNsYXNzaWZ5SW5wdXQoKTtcclxuICB9IGVsc2UgaWYgKHRoaXMuX2lzT3V0cHV0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbGFzc2lmeU91dHB1dCgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgb3V0cHV0VHlwZSA9IHRoaXMuY2xhc3NpZnlPdXRwdXQoKTtcclxuICAgIHJldHVybiBvdXRwdXRUeXBlICE9IFNjcmlwdC50eXBlcy5VTktOT1dOID8gb3V0cHV0VHlwZSA6IHRoaXMuY2xhc3NpZnlJbnB1dCgpO1xyXG4gIH1cclxufTtcclxuXHJcblNjcmlwdC5vdXRwdXRJZGVudGlmaWVycyA9IHt9O1xyXG5TY3JpcHQub3V0cHV0SWRlbnRpZmllcnMuUFVCS0VZX09VVCA9IFNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlPdXQ7XHJcblNjcmlwdC5vdXRwdXRJZGVudGlmaWVycy5QVUJLRVlIQVNIX09VVCA9IFNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlIYXNoT3V0O1xyXG5TY3JpcHQub3V0cHV0SWRlbnRpZmllcnMuTVVMVElTSUdfT1VUID0gU2NyaXB0LnByb3RvdHlwZS5pc011bHRpc2lnT3V0O1xyXG5TY3JpcHQub3V0cHV0SWRlbnRpZmllcnMuU0NSSVBUSEFTSF9PVVQgPSBTY3JpcHQucHJvdG90eXBlLmlzU2NyaXB0SGFzaE91dDtcclxuU2NyaXB0Lm91dHB1dElkZW50aWZpZXJzLkRBVEFfT1VUID0gU2NyaXB0LnByb3RvdHlwZS5pc0RhdGFPdXQ7XHJcblxyXG4vKipcclxuICogQHJldHVybnMge29iamVjdH0gVGhlIFNjcmlwdCB0eXBlIGlmIGl0IGlzIGEga25vd24gZm9ybSxcclxuICogb3IgU2NyaXB0LlVOS05PV04gaWYgaXQgaXNuJ3RcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuY2xhc3NpZnlPdXRwdXQgPSBmdW5jdGlvbigpIHtcclxuICBmb3IgKHZhciB0eXBlIGluIFNjcmlwdC5vdXRwdXRJZGVudGlmaWVycykge1xyXG4gICAgaWYgKFNjcmlwdC5vdXRwdXRJZGVudGlmaWVyc1t0eXBlXS5iaW5kKHRoaXMpKCkpIHtcclxuICAgICAgcmV0dXJuIFNjcmlwdC50eXBlc1t0eXBlXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFNjcmlwdC50eXBlcy5VTktOT1dOO1xyXG59O1xyXG5cclxuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMgPSB7fTtcclxuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuUFVCS0VZX0lOID0gU2NyaXB0LnByb3RvdHlwZS5pc1B1YmxpY0tleUluO1xyXG5TY3JpcHQuaW5wdXRJZGVudGlmaWVycy5QVUJLRVlIQVNIX0lOID0gU2NyaXB0LnByb3RvdHlwZS5pc1B1YmxpY0tleUhhc2hJbjtcclxuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuTVVMVElTSUdfSU4gPSBTY3JpcHQucHJvdG90eXBlLmlzTXVsdGlzaWdJbjtcclxuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuU0NSSVBUSEFTSF9JTiA9IFNjcmlwdC5wcm90b3R5cGUuaXNTY3JpcHRIYXNoSW47XHJcblxyXG4vKipcclxuICogQHJldHVybnMge29iamVjdH0gVGhlIFNjcmlwdCB0eXBlIGlmIGl0IGlzIGEga25vd24gZm9ybSxcclxuICogb3IgU2NyaXB0LlVOS05PV04gaWYgaXQgaXNuJ3RcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuY2xhc3NpZnlJbnB1dCA9IGZ1bmN0aW9uKCkge1xyXG4gIGZvciAodmFyIHR5cGUgaW4gU2NyaXB0LmlucHV0SWRlbnRpZmllcnMpIHtcclxuICAgIGlmIChTY3JpcHQuaW5wdXRJZGVudGlmaWVyc1t0eXBlXS5iaW5kKHRoaXMpKCkpIHtcclxuICAgICAgcmV0dXJuIFNjcmlwdC50eXBlc1t0eXBlXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFNjcmlwdC50eXBlcy5VTktOT1dOO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgc2NyaXB0IGlzIG9uZSBvZiB0aGUga25vd24gdHlwZXNcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUuaXNTdGFuZGFyZCA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIFRPRE86IEFkZCBCSVA2MiBjb21wbGlhbmNlXHJcbiAgcmV0dXJuIHRoaXMuY2xhc3NpZnkoKSAhPT0gU2NyaXB0LnR5cGVzLlVOS05PV047XHJcbn07XHJcblxyXG5cclxuLy8gU2NyaXB0IGNvbnN0cnVjdGlvbiBtZXRob2RzXHJcblxyXG4vKipcclxuICogQWRkcyBhIHNjcmlwdCBlbGVtZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgc2NyaXB0LlxyXG4gKiBAcGFyYW0geyp9IG9iaiBhIHN0cmluZywgbnVtYmVyLCBPcGNvZGUsIEJ1ZmZlciwgb3Igb2JqZWN0IHRvIGFkZFxyXG4gKiBAcmV0dXJucyB7U2NyaXB0fSB0aGlzIHNjcmlwdCBpbnN0YW5jZVxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgdGhpcy5fYWRkQnlUeXBlKG9iaiwgdHJ1ZSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgYSBzY3JpcHQgd2l0aCBhbm90aGVyIHNjcmlwdFxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihzY3JpcHQpIHtcclxuICAkLmNoZWNrU3RhdGUoc2NyaXB0IGluc3RhbmNlb2YgU2NyaXB0LCAnTXVzdCBwcm92aWRlIGFub3RoZXIgc2NyaXB0Jyk7XHJcbiAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCAhPT0gc2NyaXB0LmNodW5rcy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIGk7XHJcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcih0aGlzLmNodW5rc1tpXS5idWYpICYmICFCdWZmZXJVdGlsLmlzQnVmZmVyKHNjcmlwdC5jaHVua3NbaV0uYnVmKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcih0aGlzLmNodW5rc1tpXS5idWYpICYmICFCdWZmZXJVdGlsLmVxdWFscyh0aGlzLmNodW5rc1tpXS5idWYsIHNjcmlwdC5jaHVua3NbaV0uYnVmKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2h1bmtzW2ldLm9wY29kZW51bSAhPT0gc2NyaXB0LmNodW5rc1tpXS5vcGNvZGVudW0pIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgc2NyaXB0IGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgc2NyaXB0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG9iaiBhIHN0cmluZywgbnVtYmVyLCBPcGNvZGUsIEJ1ZmZlciwgb3Igb2JqZWN0IHRvIGFkZFxyXG4gKiBAcmV0dXJucyB7U2NyaXB0fSB0aGlzIHNjcmlwdCBpbnN0YW5jZVxyXG4gKlxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcclxuICB0aGlzLl9hZGRCeVR5cGUob2JqLCBmYWxzZSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TY3JpcHQucHJvdG90eXBlLl9hZGRCeVR5cGUgPSBmdW5jdGlvbihvYmosIHByZXBlbmQpIHtcclxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcclxuICAgIHRoaXMuX2FkZE9wY29kZShvYmosIHByZXBlbmQpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcclxuICAgIHRoaXMuX2FkZE9wY29kZShvYmosIHByZXBlbmQpO1xyXG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgT3Bjb2RlKSB7XHJcbiAgICB0aGlzLl9hZGRPcGNvZGUob2JqLCBwcmVwZW5kKTtcclxuICB9IGVsc2UgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIob2JqKSkge1xyXG4gICAgdGhpcy5fYWRkQnVmZmVyKG9iaiwgcHJlcGVuZCk7XHJcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBTY3JpcHQpIHtcclxuICAgIHRoaXMuY2h1bmtzID0gdGhpcy5jaHVua3MuY29uY2F0KG9iai5jaHVua3MpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcclxuICAgIHRoaXMuX2luc2VydEF0UG9zaXRpb24ob2JqLCBwcmVwZW5kKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNjcmlwdCBjaHVuaycpO1xyXG4gIH1cclxufTtcclxuXHJcblNjcmlwdC5wcm90b3R5cGUuX2luc2VydEF0UG9zaXRpb24gPSBmdW5jdGlvbihvcCwgcHJlcGVuZCkge1xyXG4gIGlmIChwcmVwZW5kKSB7XHJcbiAgICB0aGlzLmNodW5rcy51bnNoaWZ0KG9wKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5jaHVua3MucHVzaChvcCk7XHJcbiAgfVxyXG59O1xyXG5cclxuU2NyaXB0LnByb3RvdHlwZS5fYWRkT3Bjb2RlID0gZnVuY3Rpb24ob3Bjb2RlLCBwcmVwZW5kKSB7XHJcbiAgdmFyIG9wO1xyXG4gIGlmICh0eXBlb2Ygb3Bjb2RlID09PSAnbnVtYmVyJykge1xyXG4gICAgb3AgPSBvcGNvZGU7XHJcbiAgfSBlbHNlIGlmIChvcGNvZGUgaW5zdGFuY2VvZiBPcGNvZGUpIHtcclxuICAgIG9wID0gb3Bjb2RlLnRvTnVtYmVyKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9wID0gT3Bjb2RlKG9wY29kZSkudG9OdW1iZXIoKTtcclxuICB9XHJcbiAgdGhpcy5faW5zZXJ0QXRQb3NpdGlvbih7XHJcbiAgICBvcGNvZGVudW06IG9wXHJcbiAgfSwgcHJlcGVuZCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TY3JpcHQucHJvdG90eXBlLl9hZGRCdWZmZXIgPSBmdW5jdGlvbihidWYsIHByZXBlbmQpIHtcclxuICB2YXIgb3Bjb2RlbnVtO1xyXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xyXG4gIGlmIChsZW4gPj0gMCAmJiBsZW4gPCBPcGNvZGUuT1BfUFVTSERBVEExKSB7XHJcbiAgICBvcGNvZGVudW0gPSBsZW47XHJcbiAgfSBlbHNlIGlmIChsZW4gPCBNYXRoLnBvdygyLCA4KSkge1xyXG4gICAgb3Bjb2RlbnVtID0gT3Bjb2RlLk9QX1BVU0hEQVRBMTtcclxuICB9IGVsc2UgaWYgKGxlbiA8IE1hdGgucG93KDIsIDE2KSkge1xyXG4gICAgb3Bjb2RlbnVtID0gT3Bjb2RlLk9QX1BVU0hEQVRBMjtcclxuICB9IGVsc2UgaWYgKGxlbiA8IE1hdGgucG93KDIsIDMyKSkge1xyXG4gICAgb3Bjb2RlbnVtID0gT3Bjb2RlLk9QX1BVU0hEQVRBNDtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuXFwndCBwdXNoIHRoYXQgbXVjaCBkYXRhJyk7XHJcbiAgfVxyXG4gIHRoaXMuX2luc2VydEF0UG9zaXRpb24oe1xyXG4gICAgYnVmOiBidWYsXHJcbiAgICBsZW46IGxlbixcclxuICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXHJcbiAgfSwgcHJlcGVuZCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TY3JpcHQucHJvdG90eXBlLmhhc0NvZGVzZXBhcmF0b3JzID0gZnVuY3Rpb24oKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHRoaXMuY2h1bmtzW2ldLm9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0NPREVTRVBBUkFUT1IpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcblNjcmlwdC5wcm90b3R5cGUucmVtb3ZlQ29kZXNlcGFyYXRvcnMgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgY2h1bmtzID0gW107XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHRoaXMuY2h1bmtzW2ldLm9wY29kZW51bSAhPT0gT3Bjb2RlLk9QX0NPREVTRVBBUkFUT1IpIHtcclxuICAgICAgY2h1bmtzLnB1c2godGhpcy5jaHVua3NbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLmNodW5rcyA9IGNodW5rcztcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIGhpZ2ggbGV2ZWwgc2NyaXB0IGJ1aWxkZXIgbWV0aG9kc1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtTY3JpcHR9IGEgbmV3IE11bHRpc2lnIG91dHB1dCBzY3JpcHQgZm9yIGdpdmVuIHB1YmxpYyBrZXlzLFxyXG4gKiByZXF1aXJpbmcgbSBvZiB0aG9zZSBwdWJsaWMga2V5cyB0byBzcGVuZFxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleVtdfSBwdWJsaWNLZXlzIC0gbGlzdCBvZiBhbGwgcHVibGljIGtleXMgY29udHJvbGxpbmcgdGhlIG91dHB1dFxyXG4gKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIC0gYW1vdW50IG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMgdG8gc3BlbmQgdGhlIG91dHB1dFxyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdHMgLSBTZXZlcmFsIG9wdGlvbnM6XHJcbiAqICAgICAgICAtIG5vU29ydGluZzogZGVmYXVsdHMgdG8gZmFsc2UsIGlmIHRydWUsIGRvbid0IHNvcnQgdGhlIGdpdmVuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgIHB1YmxpYyBrZXlzIGJlZm9yZSBjcmVhdGluZyB0aGUgc2NyaXB0XHJcbiAqL1xyXG5TY3JpcHQuYnVpbGRNdWx0aXNpZ091dCA9IGZ1bmN0aW9uKHB1YmxpY0tleXMsIHRocmVzaG9sZCwgb3B0cykge1xyXG4gICQuY2hlY2tBcmd1bWVudCh0aHJlc2hvbGQgPD0gcHVibGljS2V5cy5sZW5ndGgsXHJcbiAgICAnTnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBwdWJsaWMga2V5cycpO1xyXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gIHZhciBzY3JpcHQgPSBuZXcgU2NyaXB0KCk7XHJcbiAgc2NyaXB0LmFkZChPcGNvZGUuc21hbGxJbnQodGhyZXNob2xkKSk7XHJcbiAgcHVibGljS2V5cyA9IHB1YmxpY0tleXMubWFwKFB1YmxpY0tleSk7XHJcbiAgdmFyIHNvcnRlZCA9IHB1YmxpY0tleXM7XHJcbiAgaWYgKCFvcHRzLm5vU29ydGluZykge1xyXG4gICAgc29ydGVkID0gXy5zb3J0QnkocHVibGljS2V5cywgZnVuY3Rpb24ocHVibGljS2V5KSB7XHJcbiAgICAgIHJldHVybiBwdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydGVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgcHVibGljS2V5ID0gc29ydGVkW2ldO1xyXG4gICAgc2NyaXB0LmFkZChwdWJsaWNLZXkudG9CdWZmZXIoKSk7XHJcbiAgfVxyXG4gIHNjcmlwdC5hZGQoT3Bjb2RlLnNtYWxsSW50KHB1YmxpY0tleXMubGVuZ3RoKSk7XHJcbiAgc2NyaXB0LmFkZChPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJRyk7XHJcbiAgcmV0dXJuIHNjcmlwdDtcclxufTtcclxuXHJcblNjcmlwdC5idWlsZFdpdG5lc3NNdWx0aXNpZ091dEZyb21TY3JpcHQgPSBmdW5jdGlvbihzY3JpcHQpIHtcclxuICBpZiAoc2NyaXB0IGluc3RhbmNlb2YgU2NyaXB0KSB7XHJcbiAgICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcclxuICAgIHMuYWRkKE9wY29kZS5PUF8wKTtcclxuICAgIHMuYWRkKEhhc2guc2hhMjU2KHNjcmlwdC50b0J1ZmZlcigpKSk7XHJcbiAgICByZXR1cm4gcztcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwMnNoIHNjcmlwdCcpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIG5ldyBNdWx0aXNpZyBpbnB1dCBzY3JpcHQgZm9yIHRoZSBnaXZlbiBwdWJsaWMga2V5cywgcmVxdWlyaW5nIG0gb2YgdGhvc2UgcHVibGljIGtleXMgdG8gc3BlbmRcclxuICpcclxuICogQHBhcmFtIHtQdWJsaWNLZXlbXX0gcHVia2V5cyBsaXN0IG9mIGFsbCBwdWJsaWMga2V5cyBjb250cm9sbGluZyB0aGUgb3V0cHV0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGQgYW1vdW50IG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMgdG8gc3BlbmQgdGhlIG91dHB1dFxyXG4gKiBAcGFyYW0ge0FycmF5fSBzaWduYXR1cmVzIGFuZCBhcnJheSBvZiBzaWduYXR1cmUgYnVmZmVycyB0byBhcHBlbmQgdG8gdGhlIHNjcmlwdFxyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdHNcclxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0cy5ub1NvcnRpbmcgZG9uJ3Qgc29ydCB0aGUgZ2l2ZW4gcHVibGljIGtleXMgYmVmb3JlIGNyZWF0aW5nIHRoZSBzY3JpcHQgKGZhbHNlIGJ5IGRlZmF1bHQpXHJcbiAqIEBwYXJhbSB7U2NyaXB0PX0gb3B0cy5jYWNoZWRNdWx0aXNpZyBkb24ndCByZWNhbGN1bGF0ZSB0aGUgcmVkZWVtU2NyaXB0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtTY3JpcHR9XHJcbiAqL1xyXG5TY3JpcHQuYnVpbGRNdWx0aXNpZ0luID0gZnVuY3Rpb24ocHVia2V5cywgdGhyZXNob2xkLCBzaWduYXR1cmVzLCBvcHRzKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KEFycmF5LmlzQXJyYXkocHVia2V5cykpO1xyXG4gICQuY2hlY2tBcmd1bWVudCghaXNOYU4odGhyZXNob2xkKSk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlcykpO1xyXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gIHZhciBzID0gbmV3IFNjcmlwdCgpO1xyXG4gIHMuYWRkKE9wY29kZS5PUF8wKTtcclxuICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiBzaWduYXR1cmVzKSB7XHJcbiAgICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihzaWduYXR1cmUpLCAnU2lnbmF0dXJlcyBtdXN0IGJlIGFuIGFycmF5IG9mIEJ1ZmZlcnMnKTtcclxuICAgIC8vIFRPRE86IGFsbG93IHNpZ25hdHVyZXMgdG8gYmUgYW4gYXJyYXkgb2YgU2lnbmF0dXJlIG9iamVjdHNcclxuICAgIHMuYWRkKHNpZ25hdHVyZSk7XHJcbiAgfVxyXG4gIHJldHVybiBzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgbmV3IFAyU0ggTXVsdGlzaWcgaW5wdXQgc2NyaXB0IGZvciB0aGUgZ2l2ZW4gcHVibGljIGtleXMsIHJlcXVpcmluZyBtIG9mIHRob3NlIHB1YmxpYyBrZXlzIHRvIHNwZW5kXHJcbiAqXHJcbiAqIEBwYXJhbSB7UHVibGljS2V5W119IHB1YmtleXMgbGlzdCBvZiBhbGwgcHVibGljIGtleXMgY29udHJvbGxpbmcgdGhlIG91dHB1dFxyXG4gKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIGFtb3VudCBvZiByZXF1aXJlZCBzaWduYXR1cmVzIHRvIHNwZW5kIHRoZSBvdXRwdXRcclxuICogQHBhcmFtIHtBcnJheX0gc2lnbmF0dXJlcyBhbmQgYXJyYXkgb2Ygc2lnbmF0dXJlIGJ1ZmZlcnMgdG8gYXBwZW5kIHRvIHRoZSBzY3JpcHRcclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdHMubm9Tb3J0aW5nIGRvbid0IHNvcnQgdGhlIGdpdmVuIHB1YmxpYyBrZXlzIGJlZm9yZSBjcmVhdGluZyB0aGUgc2NyaXB0IChmYWxzZSBieSBkZWZhdWx0KVxyXG4gKiBAcGFyYW0ge1NjcmlwdD19IG9wdHMuY2FjaGVkTXVsdGlzaWcgZG9uJ3QgcmVjYWxjdWxhdGUgdGhlIHJlZGVlbVNjcmlwdFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7U2NyaXB0fVxyXG4gKi9cclxuU2NyaXB0LmJ1aWxkUDJTSE11bHRpc2lnSW4gPSBmdW5jdGlvbihwdWJrZXlzLCB0aHJlc2hvbGQsIHNpZ25hdHVyZXMsIG9wdHMpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoQXJyYXkuaXNBcnJheShwdWJrZXlzKSk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KCFpc05hTih0aHJlc2hvbGQpKTtcclxuICAkLmNoZWNrQXJndW1lbnQoQXJyYXkuaXNBcnJheShzaWduYXR1cmVzKSk7XHJcbiAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgdmFyIHMgPSBuZXcgU2NyaXB0KCk7XHJcbiAgcy5hZGQoT3Bjb2RlLk9QXzApO1xyXG4gIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHNpZ25hdHVyZXMpIHtcclxuICAgICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKHNpZ25hdHVyZSksICdTaWduYXR1cmVzIG11c3QgYmUgYW4gYXJyYXkgb2YgQnVmZmVycycpO1xyXG4gICAgLy8gVE9ETzogYWxsb3cgc2lnbmF0dXJlcyB0byBiZSBhbiBhcnJheSBvZiBTaWduYXR1cmUgb2JqZWN0c1xyXG4gICAgcy5hZGQoc2lnbmF0dXJlKTtcclxuICB9XHJcbiAgcy5hZGQoKG9wdHMuY2FjaGVkTXVsdGlzaWcgfHwgU2NyaXB0LmJ1aWxkTXVsdGlzaWdPdXQocHVia2V5cywgdGhyZXNob2xkLCBvcHRzKSkudG9CdWZmZXIoKSk7XHJcbiAgcmV0dXJuIHM7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge1NjcmlwdH0gYSBuZXcgcGF5IHRvIHB1YmxpYyBrZXkgaGFzaCBvdXRwdXQgZm9yIHRoZSBnaXZlblxyXG4gKiBhZGRyZXNzIG9yIHB1YmxpYyBrZXlcclxuICogQHBhcmFtIHsoQWRkcmVzc3xQdWJsaWNLZXkpfSB0byAtIGRlc3RpbmF0aW9uIGFkZHJlc3Mgb3IgcHVibGljIGtleVxyXG4gKi9cclxuU2NyaXB0LmJ1aWxkUHVibGljS2V5SGFzaE91dCA9IGZ1bmN0aW9uKHRvKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHRvICE9IG51bGwpO1xyXG4gICQuY2hlY2tBcmd1bWVudCh0byBpbnN0YW5jZW9mIFB1YmxpY0tleSB8fCB0byBpbnN0YW5jZW9mIEFkZHJlc3MgfHwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyk7XHJcbiAgaWYgKHRvIGluc3RhbmNlb2YgUHVibGljS2V5KSB7XHJcbiAgICB0byA9IHRvLnRvQWRkcmVzcygpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHRvID09PSAnc3RyaW5nJykge1xyXG4gICAgdG8gPSBuZXcgQWRkcmVzcyh0byk7XHJcbiAgfVxyXG4gIHZhciBzID0gbmV3IFNjcmlwdCgpO1xyXG4gIHMuYWRkKE9wY29kZS5PUF9EVVApXHJcbiAgICAuYWRkKE9wY29kZS5PUF9IQVNIMTYwKVxyXG4gICAgLmFkZCh0by5oYXNoQnVmZmVyKVxyXG4gICAgLmFkZChPcGNvZGUuT1BfRVFVQUxWRVJJRlkpXHJcbiAgICAuYWRkKE9wY29kZS5PUF9DSEVDS1NJRyk7XHJcbiAgcy5fbmV0d29yayA9IHRvLm5ldHdvcms7XHJcbiAgcmV0dXJuIHM7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge1NjcmlwdH0gYSBuZXcgcGF5IHRvIHdpdG5lc3MgdjAgb3V0cHV0IGZvciB0aGUgZ2l2ZW5cclxuICogYWRkcmVzc1xyXG4gKiBAcGFyYW0geyhBZGRyZXNzfFB1YmxpY0tleSl9IHRvIC0gZGVzdGluYXRpb24gYWRkcmVzc1xyXG4gKi9cclxuU2NyaXB0LmJ1aWxkV2l0bmVzc1YwT3V0ID0gZnVuY3Rpb24odG8pIHtcclxuICAkLmNoZWNrQXJndW1lbnQodG8gIT0gbnVsbCk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHRvIGluc3RhbmNlb2YgUHVibGljS2V5IHx8IHRvIGluc3RhbmNlb2YgQWRkcmVzcyB8fCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnKTtcclxuICBpZiAodG8gaW5zdGFuY2VvZiBQdWJsaWNLZXkpIHtcclxuICAgIHRvID0gdG8udG9BZGRyZXNzKG51bGwsIEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaCk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XHJcbiAgICB0byA9IG5ldyBBZGRyZXNzKHRvKTtcclxuICB9XHJcbiAgdmFyIHMgPSBuZXcgU2NyaXB0KCk7XHJcbiAgcy5hZGQoT3Bjb2RlLk9QXzApXHJcbiAgICAuYWRkKHRvLmhhc2hCdWZmZXIpO1xyXG4gIHMuX25ldHdvcmsgPSB0by5uZXR3b3JrO1xyXG4gIHJldHVybiBzO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBUYXByb290IHNjcmlwdCBvdXRwdXRcclxuICogQHBhcmFtIHtQdWJsaWNLZXl8QWRkcmVzc30gdG8gcmVjaXBpZW50J3MgcHViS2V5IG9yIGFkZHJlc3NcclxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHNjcmlwdFRyZWUgc2luZ2xlIGxlYWYgb2JqZWN0IE9SIGFycmF5IG9mIGxlYXZlcy4gbGVhZjogeyBzY3JpcHQ6IFN0cmluZywgbGVhZlZlcnNpb246IEludGVnZXIgfVxyXG4gKiBAcmV0dXJucyB7U2NyaXB0fVxyXG4gKi9cclxuU2NyaXB0LmJ1aWxkV2l0bmVzc1YxT3V0ID0gZnVuY3Rpb24odG8sIHNjcmlwdFRyZWUpIHtcclxuICAkLmNoZWNrQXJndW1lbnQodG8gaW5zdGFuY2VvZiBQdWJsaWNLZXkgfHwgdG8gaW5zdGFuY2VvZiBBZGRyZXNzIHx8IHR5cGVvZiB0byA9PT0gJ3N0cmluZycpO1xyXG4gICQuY2hlY2tBcmd1bWVudCghc2NyaXB0VHJlZSB8fCBBcnJheS5pc0FycmF5KHNjcmlwdFRyZWUpIHx8ICEhc2NyaXB0VHJlZS5zY3JpcHQpO1xyXG5cclxuICBpZiAodHlwZW9mIHRvID09PSAnc3RyaW5nJykge1xyXG4gICAgdG8gPSBQdWJsaWNLZXkuZnJvbVRhcHJvb3QodG8pO1xyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiBidWlsZFRyZWUodHJlZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcclxuICAgICAgY29uc3QgW2xlZnQsIGxlZnRIXSA9IGJ1aWxkVHJlZSh0cmVlWzBdKTtcclxuICAgICAgY29uc3QgW3JpZ2h0LCByaWdodEhdID0gYnVpbGRUcmVlKHRyZWVbMV0pO1xyXG4gICAgICBjb25zdCByZXQgPSBbW1tsZWZ0WzBdLCBsZWZ0WzFdXSwgcmlnaHRIXSwgW1tyaWdodFswXSwgcmlnaHRbMV1dLCBsZWZ0SF1dO1xyXG4gICAgICBjb25zdCBoV3JpdGVyID0gVGFnZ2VkSGFzaC5UQVBCUkFOQ0g7XHJcbiAgICAgIGlmIChsZWZ0SC5jb21wYXJlKHJpZ2h0SCkgPT09IDEpIHtcclxuICAgICAgICBoV3JpdGVyLndyaXRlKHJpZ2h0SCk7XHJcbiAgICAgICAgaFdyaXRlci53cml0ZShsZWZ0SCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaFdyaXRlci53cml0ZShsZWZ0SCk7XHJcbiAgICAgICAgaFdyaXRlci53cml0ZShyaWdodEgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbcmV0LCBoV3JpdGVyLmZpbmFsaXplKCldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgeyBsZWFmVmVyc2lvbiwgc2NyaXB0IH0gPSB0cmVlO1xyXG4gICAgICBjb25zdCBzY3JpcHRCdWYgPSBuZXcgU2NyaXB0KHNjcmlwdCkudG9CdWZmZXIoKTtcclxuICAgICAgY29uc3QgbGVhZldyaXRlciA9IFRhZ2dlZEhhc2guVEFQTEVBRjtcclxuICAgICAgbGVhZldyaXRlci53cml0ZVVJbnQ4KGxlYWZWZXJzaW9uKTtcclxuICAgICAgbGVhZldyaXRlci53cml0ZVVJbnQ4KHNjcmlwdEJ1Zi5sZW5ndGgpO1xyXG4gICAgICBsZWFmV3JpdGVyLndyaXRlKHNjcmlwdEJ1Zik7XHJcbiAgICAgIGNvbnN0IGggPSBsZWFmV3JpdGVyLmZpbmFsaXplKCk7XHJcbiAgICAgIHJldHVybiBbW0J1ZmZlci5mcm9tKFtsZWFmVmVyc2lvbl0pLCBzY3JpcHRCdWZdLCBoXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCB0YWdnZWRIYXNoID0gbnVsbDtcclxuICBpZiAoc2NyaXB0VHJlZSkgeyBcclxuICAgIGNvbnN0IFtfLCBoXSA9IGJ1aWxkVHJlZShzY3JpcHRUcmVlKTtcclxuICAgIHRhZ2dlZEhhc2ggPSBoO1xyXG4gIH1cclxuICBcclxuICBsZXQgdHdlYWtlZFB1YktleTtcclxuICBpZiAodG8gaW5zdGFuY2VvZiBQdWJsaWNLZXkpIHtcclxuICAgIHR3ZWFrZWRQdWJLZXkgPSB0by5jcmVhdGVUYXBUd2Vhayh0YWdnZWRIYXNoKS50d2Vha2VkUHViS2V5O1xyXG4gIH0gZWxzZSB7IC8vIEFkZHJlc3NcclxuICAgIHR3ZWFrZWRQdWJLZXkgPSB0by5oYXNoQnVmZmVyO1xyXG4gIH1cclxuICBjb25zdCBzID0gbmV3IFNjcmlwdCgpO1xyXG4gIHMuYWRkKE9wY29kZS5PUF8xKTtcclxuICBzLmFkZCh0d2Vha2VkUHViS2V5KTtcclxuICByZXR1cm4gcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQHJldHVybnMge1NjcmlwdH0gYSBuZXcgcGF5IHRvIHB1YmxpYyBrZXkgb3V0cHV0IGZvciB0aGUgZ2l2ZW5cclxuICogIHB1YmxpYyBrZXlcclxuICovXHJcblNjcmlwdC5idWlsZFB1YmxpY0tleU91dCA9IGZ1bmN0aW9uKHB1YmtleSkge1xyXG4gICQuY2hlY2tBcmd1bWVudChwdWJrZXkgaW5zdGFuY2VvZiBQdWJsaWNLZXkpO1xyXG4gIHZhciBzID0gbmV3IFNjcmlwdCgpO1xyXG4gIHMuYWRkKHB1YmtleS50b0J1ZmZlcigpKVxyXG4gICAgLmFkZChPcGNvZGUuT1BfQ0hFQ0tTSUcpO1xyXG4gIHJldHVybiBzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtTY3JpcHR9IGEgbmV3IE9QX1JFVFVSTiBzY3JpcHQgd2l0aCBkYXRhXHJcbiAqIEBwYXJhbSB7KHN0cmluZ3xCdWZmZXIpfSBkYXRhIC0gdGhlIGRhdGEgdG8gZW1iZWQgaW4gdGhlIG91dHB1dFxyXG4gKiBAcGFyYW0geyhzdHJpbmcpfSBlbmNvZGluZyAtIHRoZSB0eXBlIG9mIGVuY29kaW5nIG9mIHRoZSBzdHJpbmdcclxuICovXHJcblNjcmlwdC5idWlsZERhdGFPdXQgPSBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xyXG4gICQuY2hlY2tBcmd1bWVudChkYXRhID09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlclV0aWwuaXNCdWZmZXIoZGF0YSkpO1xyXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZyk7XHJcbiAgfVxyXG4gIHZhciBzID0gbmV3IFNjcmlwdCgpO1xyXG4gIHMuYWRkKE9wY29kZS5PUF9SRVRVUk4pO1xyXG4gIGlmIChkYXRhICE9IG51bGwpIHtcclxuICAgIHMuYWRkKGRhdGEpO1xyXG4gIH1cclxuICByZXR1cm4gcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1NjcmlwdHxBZGRyZXNzfSBzY3JpcHQgLSB0aGUgcmVkZWVtU2NyaXB0IGZvciB0aGUgbmV3IHAyc2ggb3V0cHV0LlxyXG4gKiAgICBJdCBjYW4gYWxzbyBiZSBhIHAyc2ggYWRkcmVzc1xyXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBuZXcgcGF5IHRvIHNjcmlwdCBoYXNoIHNjcmlwdCBmb3IgZ2l2ZW4gc2NyaXB0XHJcbiAqL1xyXG5TY3JpcHQuYnVpbGRTY3JpcHRIYXNoT3V0ID0gZnVuY3Rpb24oc2NyaXB0KSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCB8fFxyXG4gICAgKHNjcmlwdCBpbnN0YW5jZW9mIEFkZHJlc3MgJiYgc2NyaXB0LmlzUGF5VG9TY3JpcHRIYXNoKCkpKTtcclxuICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcclxuICBzLmFkZChPcGNvZGUuT1BfSEFTSDE2MClcclxuICAgIC5hZGQoc2NyaXB0IGluc3RhbmNlb2YgQWRkcmVzcyA/IHNjcmlwdC5oYXNoQnVmZmVyIDogSGFzaC5zaGEyNTZyaXBlbWQxNjAoc2NyaXB0LnRvQnVmZmVyKCkpKVxyXG4gICAgLmFkZChPcGNvZGUuT1BfRVFVQUwpO1xyXG5cclxuICBzLl9uZXR3b3JrID0gc2NyaXB0Ll9uZXR3b3JrIHx8IHNjcmlwdC5uZXR3b3JrO1xyXG4gIHJldHVybiBzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHNjcmlwdFNpZyAoYSBzY3JpcHQgZm9yIGFuIGlucHV0KSB0aGF0IHNpZ25zIGEgcHVibGljIGtleSBvdXRwdXQgc2NyaXB0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZ25hdHVyZSAtIGEgU2lnbmF0dXJlIG9iamVjdCwgb3IgdGhlIHNpZ25hdHVyZSBpbiBERVIgY2Fub25pY2FsIGVuY29kaW5nXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHRoZSBzaWduYXR1cmUgKGRlZmF1bHRzIHRvIFNJR0hBU0hfQUxMKVxyXG4gKi9cclxuU2NyaXB0LmJ1aWxkUHVibGljS2V5SW4gPSBmdW5jdGlvbihzaWduYXR1cmUsIHNpZ3R5cGUpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlIHx8IEJ1ZmZlclV0aWwuaXNCdWZmZXIoc2lnbmF0dXJlKSk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ3R5cGUgPT0gbnVsbCB8fCAhaXNOYU4oc2lndHlwZSkpO1xyXG4gIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcclxuICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS50b0J1ZmZlcigpO1xyXG4gIH1cclxuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpO1xyXG4gIHNjcmlwdC5hZGQoQnVmZmVyVXRpbC5jb25jYXQoW1xyXG4gICAgc2lnbmF0dXJlLFxyXG4gICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ3R5cGUgfHwgU2lnbmF0dXJlLlNJR0hBU0hfQUxMKVxyXG4gIF0pKTtcclxuICByZXR1cm4gc2NyaXB0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHNjcmlwdFNpZyAoYSBzY3JpcHQgZm9yIGFuIGlucHV0KSB0aGF0IHNpZ25zIGEgcHVibGljIGtleSBoYXNoXHJcbiAqIG91dHB1dCBzY3JpcHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ3xQdWJsaWNLZXl9IHB1YmxpY0tleVxyXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZ25hdHVyZSAtIGEgU2lnbmF0dXJlIG9iamVjdCwgb3IgdGhlIHNpZ25hdHVyZSBpbiBERVIgY2Fub25pY2FsIGVuY29kaW5nXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHRoZSBzaWduYXR1cmUgKGRlZmF1bHRzIHRvIFNJR0hBU0hfQUxMKVxyXG4gKi9cclxuU2NyaXB0LmJ1aWxkUHVibGljS2V5SGFzaEluID0gZnVuY3Rpb24ocHVibGljS2V5LCBzaWduYXR1cmUsIHNpZ3R5cGUpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlIHx8IEJ1ZmZlclV0aWwuaXNCdWZmZXIoc2lnbmF0dXJlKSk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ3R5cGUgPT0gbnVsbCB8fCAhaXNOYU4oc2lndHlwZSkpO1xyXG4gIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcclxuICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS50b0J1ZmZlcigpO1xyXG4gIH1cclxuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpXHJcbiAgICAuYWRkKEJ1ZmZlclV0aWwuY29uY2F0KFtcclxuICAgICAgc2lnbmF0dXJlLFxyXG4gICAgICBCdWZmZXJVdGlsLmludGVnZXJBc1NpbmdsZUJ5dGVCdWZmZXIoc2lndHlwZSB8fCBTaWduYXR1cmUuU0lHSEFTSF9BTEwpXHJcbiAgICBdKSlcclxuICAgIC5hZGQobmV3IFB1YmxpY0tleShwdWJsaWNLZXkpLnRvQnVmZmVyKCkpO1xyXG4gIHJldHVybiBzY3JpcHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge1NjcmlwdH0gYW4gZW1wdHkgc2NyaXB0XHJcbiAqL1xyXG5TY3JpcHQuZW1wdHkgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gbmV3IFNjcmlwdCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtTY3JpcHR9IGEgbmV3IHBheSB0byBzY3JpcHQgaGFzaCBzY3JpcHQgdGhhdCBwYXlzIHRvIHRoaXMgc2NyaXB0XHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLnRvU2NyaXB0SGFzaE91dCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBTY3JpcHQuYnVpbGRTY3JpcHRIYXNoT3V0KHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm4ge1NjcmlwdH0gYW4gb3V0cHV0IHNjcmlwdCBidWlsdCBmcm9tIHRoZSBhZGRyZXNzXHJcbiAqL1xyXG5TY3JpcHQuZnJvbUFkZHJlc3MgPSBmdW5jdGlvbihhZGRyZXNzKSB7XHJcbiAgYWRkcmVzcyA9IEFkZHJlc3MoYWRkcmVzcyk7XHJcbiAgaWYgKGFkZHJlc3MuaXNQYXlUb1NjcmlwdEhhc2goKSkge1xyXG4gICAgcmV0dXJuIFNjcmlwdC5idWlsZFNjcmlwdEhhc2hPdXQoYWRkcmVzcyk7XHJcbiAgfSBlbHNlIGlmIChhZGRyZXNzLmlzUGF5VG9QdWJsaWNLZXlIYXNoKCkpIHtcclxuICAgIHJldHVybiBTY3JpcHQuYnVpbGRQdWJsaWNLZXlIYXNoT3V0KGFkZHJlc3MpO1xyXG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvV2l0bmVzc1B1YmxpY0tleUhhc2goKSkge1xyXG4gICAgcmV0dXJuIFNjcmlwdC5idWlsZFdpdG5lc3NWME91dChhZGRyZXNzKTtcclxuICB9IGVsc2UgaWYgKGFkZHJlc3MuaXNQYXlUb1dpdG5lc3NTY3JpcHRIYXNoKCkpIHtcclxuICAgIHJldHVybiBTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQoYWRkcmVzcyk7XHJcbiAgfSBlbHNlIGlmIChhZGRyZXNzLmlzUGF5VG9UYXByb290KCkpIHtcclxuICAgIHJldHVybiBTY3JpcHQuYnVpbGRXaXRuZXNzVjFPdXQoYWRkcmVzcyk7XHJcbiAgfVxyXG4gIHRocm93IG5ldyBlcnJvcnMuU2NyaXB0LlVucmVjb2duaXplZEFkZHJlc3MoYWRkcmVzcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgYWRkcmVzcyBpbmZvcm1hdGlvbiBvYmplY3RcclxuICogQHJldHVybiB7QWRkcmVzc3xib29sZWFufVxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5nZXRBZGRyZXNzSW5mbyA9IGZ1bmN0aW9uKG9wdHMpIHtcclxuICBpZiAodGhpcy5faXNJbnB1dCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldElucHV0QWRkcmVzc0luZm8oKTtcclxuICB9IGVsc2UgaWYgKHRoaXMuX2lzT3V0cHV0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0T3V0cHV0QWRkcmVzc0luZm8oKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGluZm8gPSB0aGlzLl9nZXRPdXRwdXRBZGRyZXNzSW5mbygpO1xyXG4gICAgaWYgKCFpbmZvKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9nZXRJbnB1dEFkZHJlc3NJbmZvKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5mbztcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgb3V0cHV0IHNjcmlwdFB1YktleSBhZGRyZXNzIGluZm9ybWF0aW9uIG9iamVjdFxyXG4gKiBAcmV0dXJuIHtBZGRyZXNzfGJvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLl9nZXRPdXRwdXRBZGRyZXNzSW5mbyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBpbmZvID0ge307XHJcbiAgaWYgKHRoaXMuaXNTY3JpcHRIYXNoT3V0KCkpIHtcclxuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xyXG4gICAgaW5mby50eXBlID0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XHJcbiAgfSBlbHNlIGlmICh0aGlzLmlzUHVibGljS2V5SGFzaE91dCgpKSB7XHJcbiAgICBpbmZvLmhhc2hCdWZmZXIgPSB0aGlzLmdldERhdGEoKTtcclxuICAgIGluZm8udHlwZSA9IEFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5pc1dpdG5lc3NTY3JpcHRIYXNoT3V0KCkpIHtcclxuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xyXG4gICAgaW5mby50eXBlID0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkpIHtcclxuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xyXG4gICAgaW5mby50eXBlID0gQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5pc1RhcHJvb3QoKSkge1xyXG4gICAgaW5mby5oYXNoQnVmZmVyID0gdGhpcy5nZXREYXRhKCk7XHJcbiAgICBpbmZvLnR5cGUgPSBBZGRyZXNzLlBheVRvVGFwcm9vdDtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gaW5mbztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaWxsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBzY3JpcHRTaWcgYWRkcmVzcyBpbmZvcm1hdGlvbiBvYmplY3RcclxuICogQHJldHVybiB7QWRkcmVzc3xib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5fZ2V0SW5wdXRBZGRyZXNzSW5mbyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBpbmZvID0ge307XHJcbiAgaWYgKHRoaXMuaXNQdWJsaWNLZXlIYXNoSW4oKSkge1xyXG4gICAgLy8gaGFzaCB0aGUgcHVibGlja2V5IGZvdW5kIGluIHRoZSBzY3JpcHRTaWdcclxuICAgIGluZm8uaGFzaEJ1ZmZlciA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKHRoaXMuY2h1bmtzWzFdLmJ1Zik7XHJcbiAgICBpbmZvLnR5cGUgPSBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcclxuICB9IGVsc2UgaWYgKHRoaXMuaXNTY3JpcHRIYXNoSW4oKSkge1xyXG4gICAgLy8gaGFzaCB0aGUgcmVkZWVtc2NyaXB0IGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIHNjcmlwdFNpZ1xyXG4gICAgaW5mby5oYXNoQnVmZmVyID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAodGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV0uYnVmKTtcclxuICAgIGluZm8udHlwZSA9IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBpbmZvO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7TmV0d29yaz19IG5ldHdvcmtcclxuICogQHJldHVybiB7QWRkcmVzc3xib29sZWFufSB0aGUgYXNzb2NpYXRlZCBhZGRyZXNzIGZvciB0aGlzIHNjcmlwdCBpZiBwb3NzaWJsZSwgb3IgZmFsc2VcclxuICovXHJcblNjcmlwdC5wcm90b3R5cGUudG9BZGRyZXNzID0gZnVuY3Rpb24obmV0d29yaykge1xyXG4gIHZhciBpbmZvID0gdGhpcy5nZXRBZGRyZXNzSW5mbygpO1xyXG4gIGlmICghaW5mbykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQobmV0d29yaykgfHwgdGhpcy5fbmV0d29yayB8fCBOZXR3b3Jrcy5kZWZhdWx0TmV0d29yaztcclxuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mbyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQW5hbG9nb3VzIHRvIGJpdGNvaW5kJ3MgRmluZEFuZERlbGV0ZS4gRmluZCBhbmQgZGVsZXRlIGVxdWl2YWxlbnQgY2h1bmtzLFxyXG4gKiB0eXBpY2FsbHkgdXNlZCB3aXRoIHB1c2ggZGF0YSBjaHVua3MuICBOb3RlIHRoYXQgdGhpcyB3aWxsIGZpbmQgYW5kIGRlbGV0ZVxyXG4gKiBub3QganVzdCB0aGUgc2FtZSBkYXRhLCBidXQgdGhlIHNhbWUgZGF0YSB3aXRoIHRoZSBzYW1lIHB1c2ggZGF0YSBvcCBhc1xyXG4gKiBwcm9kdWNlZCBieSBkZWZhdWx0LiBpLmUuLCBpZiBhIHB1c2hkYXRhIGluIGEgdHggZG9lcyBub3QgdXNlIHRoZSBtaW5pbWFsXHJcbiAqIHB1c2hkYXRhIG9wLCB0aGVuIHdoZW4geW91IHRyeSB0byByZW1vdmUgdGhlIGRhdGEgaXQgaXMgcHVzaGluZywgaXQgd2lsbCBub3RcclxuICogYmUgcmVtb3ZlZCwgYmVjYXVzZSB0aGV5IGRvIG5vdCB1c2UgdGhlIHNhbWUgcHVzaGRhdGEgb3AuXHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLmZpbmRBbmREZWxldGUgPSBmdW5jdGlvbihzY3JpcHQpIHtcclxuICB2YXIgYnVmID0gc2NyaXB0LnRvQnVmZmVyKCk7XHJcbiAgdmFyIGhleCA9IGJ1Zi50b1N0cmluZygnaGV4Jyk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHNjcmlwdDIgPSBTY3JpcHQoe1xyXG4gICAgICBjaHVua3M6IFt0aGlzLmNodW5rc1tpXV1cclxuICAgIH0pO1xyXG4gICAgdmFyIGJ1ZjIgPSBzY3JpcHQyLnRvQnVmZmVyKCk7XHJcbiAgICB2YXIgaGV4MiA9IGJ1ZjIudG9TdHJpbmcoJ2hleCcpO1xyXG4gICAgaWYgKGhleCA9PT0gaGV4Mikge1xyXG4gICAgICB0aGlzLmNodW5rcy5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbWVzIGZyb20gYml0Y29pbmQncyBzY3JpcHQgaW50ZXJwcmV0ZXIgQ2hlY2tNaW5pbWFsUHVzaCBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhlIGNodW5rIHtpfSBpcyB0aGUgc21hbGxlc3Qgd2F5IHRvIHB1c2ggdGhhdCBwYXJ0aWN1bGFyIGRhdGEuXHJcbiAqL1xyXG5TY3JpcHQucHJvdG90eXBlLmNoZWNrTWluaW1hbFB1c2ggPSBmdW5jdGlvbihpKSB7XHJcbiAgdmFyIGNodW5rID0gdGhpcy5jaHVua3NbaV07XHJcbiAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZjtcclxuICB2YXIgb3Bjb2RlbnVtID0gY2h1bmsub3Bjb2RlbnVtO1xyXG4gIGlmICghYnVmKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcclxuICAgIC8vIENvdWxkIGhhdmUgdXNlZCBPUF8wLlxyXG4gICAgcmV0dXJuIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QXzA7XHJcbiAgfSBlbHNlIGlmIChidWYubGVuZ3RoID09PSAxICYmIGJ1ZlswXSA+PSAxICYmIGJ1ZlswXSA8PSAxNikge1xyXG4gICAgLy8gQ291bGQgaGF2ZSB1c2VkIE9QXzEgLi4gT1BfMTYuXHJcbiAgICByZXR1cm4gb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfMSArIChidWZbMF0gLSAxKTtcclxuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPT09IDEgJiYgYnVmWzBdID09PSAweDgxKSB7XHJcbiAgICAvLyBDb3VsZCBoYXZlIHVzZWQgT1BfMU5FR0FURVxyXG4gICAgcmV0dXJuIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QXzFORUdBVEU7XHJcbiAgfSBlbHNlIGlmIChidWYubGVuZ3RoIDw9IDc1KSB7XHJcbiAgICAvLyBDb3VsZCBoYXZlIHVzZWQgYSBkaXJlY3QgcHVzaCAob3Bjb2RlIGluZGljYXRpbmcgbnVtYmVyIG9mIGJ5dGVzIHB1c2hlZCArIHRob3NlIGJ5dGVzKS5cclxuICAgIHJldHVybiBvcGNvZGVudW0gPT09IGJ1Zi5sZW5ndGg7XHJcbiAgfSBlbHNlIGlmIChidWYubGVuZ3RoIDw9IDI1NSkge1xyXG4gICAgLy8gQ291bGQgaGF2ZSB1c2VkIE9QX1BVU0hEQVRBLlxyXG4gICAgcmV0dXJuIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMTtcclxuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPD0gNjU1MzUpIHtcclxuICAgIC8vIENvdWxkIGhhdmUgdXNlZCBPUF9QVVNIREFUQTIuXHJcbiAgICByZXR1cm4gb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29tZXMgZnJvbSBiaXRjb2luZCdzIHNjcmlwdCBHZXRTaWdPcENvdW50KGJvb2xlYW4pIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlIGN1cnJlbnQgKHRydWUpIG9yIHByZS12ZXJzaW9uLTAuNiAoZmFsc2UpIGxvZ2ljXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG51bWJlciBvZiBzaWduYXR1cmUgb3BlcmF0aW9ucyByZXF1aXJlZCBieSB0aGlzIHNjcmlwdFxyXG4gKi9cclxuU2NyaXB0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVPcGVyYXRpb25zQ291bnQgPSBmdW5jdGlvbihhY2N1cmF0ZSkge1xyXG4gIGFjY3VyYXRlID0gKGFjY3VyYXRlID09IG51bGwgPyB0cnVlIDogYWNjdXJhdGUpO1xyXG4gIHZhciBuID0gMDtcclxuICB2YXIgbGFzdE9wY29kZSA9IE9wY29kZS5PUF9JTlZBTElET1BDT0RFO1xyXG4gIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5jaHVua3MpIHtcclxuICAgIHZhciBvcGNvZGUgPSBjaHVuay5vcGNvZGVudW07XHJcbiAgICBpZiAob3Bjb2RlID09IE9wY29kZS5PUF9DSEVDS1NJRyB8fCBvcGNvZGUgPT0gT3Bjb2RlLk9QX0NIRUNLU0lHVkVSSUZZKSB7XHJcbiAgICAgIG4rKztcclxuICAgIH0gZWxzZSBpZiAob3Bjb2RlID09IE9wY29kZS5PUF9DSEVDS01VTFRJU0lHIHx8IG9wY29kZSA9PSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWSkge1xyXG4gICAgICBpZiAoYWNjdXJhdGUgJiYgbGFzdE9wY29kZSA+PSBPcGNvZGUuT1BfMSAmJiBsYXN0T3Bjb2RlIDw9IE9wY29kZS5PUF8xNikge1xyXG4gICAgICAgIG4gKz0gT3Bjb2RlLmRlY29kZU9wTihsYXN0T3Bjb2RlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuICs9IDIwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsYXN0T3Bjb2RlID0gb3Bjb2RlO1xyXG4gIH1cclxuICByZXR1cm4gbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NyaXB0O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/script/script.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/index.js":
/*!***********************************************!*\
  !*** ../bitcore-lib/lib/transaction/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./transaction */ \"../bitcore-lib/lib/transaction/transaction.js\");\r\n\r\nmodule.exports.Input = __webpack_require__(/*! ./input */ \"../bitcore-lib/lib/transaction/input/index.js\");\r\nmodule.exports.Output = __webpack_require__(/*! ./output */ \"../bitcore-lib/lib/transaction/output.js\");\r\nmodule.exports.UnspentOutput = __webpack_require__(/*! ./unspentoutput */ \"../bitcore-lib/lib/transaction/unspentoutput.js\");\r\nmodule.exports.Signature = __webpack_require__(/*! ./signature */ \"../bitcore-lib/lib/transaction/signature.js\");\r\nmodule.exports.Sighash = __webpack_require__(/*! ./sighash */ \"../bitcore-lib/lib/transaction/sighash.js\");\r\nmodule.exports.SighashWitness = __webpack_require__(/*! ./sighashwitness */ \"../bitcore-lib/lib/transaction/sighashwitness.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDBHQUF5QztBQUN6QztBQUNBLDBHQUF5QztBQUN6Qyx1R0FBMkM7QUFDM0MsNEhBQXlEO0FBQ3pELGdIQUFpRDtBQUNqRCwwR0FBNkM7QUFDN0MsK0hBQTJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5kZXguanM/NTA0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLklucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xyXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSByZXF1aXJlKCcuL291dHB1dCcpO1xyXG5tb2R1bGUuZXhwb3J0cy5VbnNwZW50T3V0cHV0ID0gcmVxdWlyZSgnLi91bnNwZW50b3V0cHV0Jyk7XHJcbm1vZHVsZS5leHBvcnRzLlNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XHJcbm1vZHVsZS5leHBvcnRzLlNpZ2hhc2ggPSByZXF1aXJlKCcuL3NpZ2hhc2gnKTtcclxubW9kdWxlLmV4cG9ydHMuU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuL3NpZ2hhc2h3aXRuZXNzJyk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/index.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/input/index.js":
/*!*****************************************************!*\
  !*** ../bitcore-lib/lib/transaction/input/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./input */ \"../bitcore-lib/lib/transaction/input/input.js\");\r\n\r\nmodule.exports.PublicKey = __webpack_require__(/*! ./publickey */ \"../bitcore-lib/lib/transaction/input/publickey.js\");\r\nmodule.exports.PublicKeyHash = __webpack_require__(/*! ./publickeyhash */ \"../bitcore-lib/lib/transaction/input/publickeyhash.js\");\r\nmodule.exports.MultiSig = __webpack_require__(/*! ./multisig */ \"../bitcore-lib/lib/transaction/input/multisig.js\");\r\nmodule.exports.MultiSigScriptHash = __webpack_require__(/*! ./multisigscripthash */ \"../bitcore-lib/lib/transaction/input/multisigscripthash.js\");\r\nmodule.exports.Taproot = __webpack_require__(/*! ./taproot */ \"../bitcore-lib/lib/transaction/input/taproot.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLG9HQUFtQztBQUNuQztBQUNBLHNIQUFpRDtBQUNqRCxrSUFBeUQ7QUFDekQsbUhBQStDO0FBQy9DLGlKQUFtRTtBQUNuRSxnSEFBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi90cmFuc2FjdGlvbi9pbnB1dC9pbmRleC5qcz9iOWI2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuUHVibGljS2V5ID0gcmVxdWlyZSgnLi9wdWJsaWNrZXknKTtcclxubW9kdWxlLmV4cG9ydHMuUHVibGljS2V5SGFzaCA9IHJlcXVpcmUoJy4vcHVibGlja2V5aGFzaCcpO1xyXG5tb2R1bGUuZXhwb3J0cy5NdWx0aVNpZyA9IHJlcXVpcmUoJy4vbXVsdGlzaWcnKTtcclxubW9kdWxlLmV4cG9ydHMuTXVsdGlTaWdTY3JpcHRIYXNoID0gcmVxdWlyZSgnLi9tdWx0aXNpZ3NjcmlwdGhhc2gnKTtcclxubW9kdWxlLmV4cG9ydHMuVGFwcm9vdCA9IHJlcXVpcmUoJy4vdGFwcm9vdCcpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/input/index.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/input/input.js":
/*!*****************************************************!*\
  !*** ../bitcore-lib/lib/transaction/input/input.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nconst errors = __webpack_require__(/*! ../../errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\r\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ../../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar Script = __webpack_require__(/*! ../../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar Sighash = __webpack_require__(/*! ../sighash */ \"../bitcore-lib/lib/transaction/sighash.js\");\r\nvar Output = __webpack_require__(/*! ../output */ \"../bitcore-lib/lib/transaction/output.js\");\r\n\r\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\r\nvar DEFAULT_SEQNUMBER = MAXINT;\r\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\r\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\r\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG =  Math.pow(2,31); // (1 << 31);\r\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2,22); // (1 << 22);\r\nconst SEQUENCE_LOCKTIME_MASK = 0xffff;\r\nconst SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\r\nconst SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2,16)-1; // 16 bits \r\n\r\n\r\nfunction Input(params) {\r\n  if (!(this instanceof Input)) {\r\n    return new Input(params);\r\n  }\r\n  if (params) {\r\n    return this._fromObject(params);\r\n  }\r\n}\r\n\r\nInput.MAXINT = MAXINT;\r\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\r\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\r\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\r\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\r\n\r\nObject.defineProperty(Input.prototype, 'script', {\r\n  configurable: false,\r\n  enumerable: true,\r\n  get: function() {\r\n    if (this.isNull()) {\r\n      return null;\r\n    }\r\n    if (!this._script) {\r\n      this._script = new Script(this._scriptBuffer);\r\n      this._script._isInput = true;\r\n    }\r\n    return this._script;\r\n  }\r\n});\r\n\r\nInput.fromObject = function(obj) {\r\n  $.checkArgument(_.isObject(obj));\r\n  var input = new Input();\r\n  return input._fromObject(obj);\r\n};\r\n\r\nInput.prototype._fromObject = function(params) {\r\n  var prevTxId;\r\n  if (typeof params.prevTxId === 'string' && JSUtil.isHexa(params.prevTxId)) {\r\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\r\n  } else {\r\n    prevTxId = params.prevTxId;\r\n  }\r\n  this.witnesses = [];\r\n  this.output = params.output ?\r\n    (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;\r\n  this.prevTxId = prevTxId || params.txidbuf;\r\n  this.outputIndex = params.outputIndex == null ? params.txoutnum : params.outputIndex;\r\n  this.sequenceNumber = params.sequenceNumber == null ?\r\n    (params.seqnum == null ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;\r\n  // null script is allowed in setScript()\r\n  if (params.script === undefined && params.scriptBuffer === undefined) {\r\n    throw new errors.Transaction.Input.MissingScript();\r\n  }\r\n  this.setScript(params.scriptBuffer || params.script);\r\n  return this;\r\n};\r\n\r\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\r\n  var obj = {\r\n    prevTxId: this.prevTxId.toString('hex'),\r\n    outputIndex: this.outputIndex,\r\n    sequenceNumber: this.sequenceNumber,\r\n    script: this._scriptBuffer.toString('hex'),\r\n  };\r\n  // add human readable form if input contains valid script\r\n  if (this.script) {\r\n    obj.scriptString = this.script.toString();\r\n  }\r\n  if (this.output) {\r\n    obj.output = this.output.toObject();\r\n  }\r\n  return obj;\r\n};\r\n\r\nInput.fromBufferReader = function(br) {\r\n  var input = new Input();\r\n  input.prevTxId = br.readReverse(32);\r\n  input.outputIndex = br.readUInt32LE();\r\n  input._scriptBuffer = br.readVarLengthBuffer();\r\n  input.sequenceNumber = br.readUInt32LE();\r\n  // TODO: return different classes according to which input it is\r\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\r\n  return input;\r\n};\r\n\r\nInput.prototype.toBufferWriter = function(writer) {\r\n  if (!writer) {\r\n    writer = new BufferWriter();\r\n  }\r\n  writer.writeReverse(this.prevTxId);\r\n  writer.writeUInt32LE(this.outputIndex);\r\n  var script = this._scriptBuffer;\r\n  writer.writeVarintNum(script.length);\r\n  writer.write(script);\r\n  writer.writeUInt32LE(this.sequenceNumber);\r\n  return writer;\r\n};\r\n\r\nInput.prototype.setScript = function(script) {\r\n  this._script = null;\r\n  if (script instanceof Script) {\r\n    this._script = script;\r\n    this._script._isInput = true;\r\n    this._scriptBuffer = script.toBuffer();\r\n  } else if (JSUtil.isHexa(script)) {\r\n    // hex string script\r\n    this._scriptBuffer = Buffer.from(script, 'hex');\r\n  } else if (_.isString(script)) {\r\n    // human readable string script\r\n    this._script = new Script(script);\r\n    this._script._isInput = true;\r\n    this._scriptBuffer = this._script.toBuffer();\r\n  } else if (BufferUtil.isBuffer(script)) {\r\n    // buffer script\r\n    this._scriptBuffer = Buffer.from(script);\r\n  } else {\r\n    throw new TypeError('Invalid argument type: script');\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Retrieve signatures for the provided PrivateKey.\r\n *\r\n * @param {Transaction} transaction - the transaction to be signed\r\n * @param {PrivateKey} privateKey - the private key to use when signing\r\n * @param {number} inputIndex - the index of this input in the provided transaction\r\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\r\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\r\n *     public key associated with the private key provided\r\n * @abstract\r\n */\r\nInput.prototype.getSignatures = function() {\r\n  throw new errors.AbstractMethodInvoked(\r\n    'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +\r\n    ' for input: ' + JSON.stringify(this)\r\n  );\r\n};\r\n\r\nInput.prototype.getSatoshisBuffer = function() {\r\n  $.checkState(this.output instanceof Output);\r\n  $.checkState(this.output._satoshisBN);\r\n  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();\r\n};\r\n\r\n\r\nInput.prototype.isFullySigned = function() {\r\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\r\n};\r\n\r\nInput.prototype.isFinal = function() {\r\n  return this.sequenceNumber !== Input.MAXINT;\r\n};\r\n\r\nInput.prototype.addSignature = function() {\r\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\r\n};\r\n\r\nInput.prototype.clearSignatures = function() {\r\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\r\n};\r\n\r\nInput.prototype.hasWitnesses = function() {\r\n  if (this.witnesses && this.witnesses.length > 0) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nInput.prototype.getWitnesses = function() {\r\n  return this.witnesses;\r\n};\r\n\r\nInput.prototype.setWitnesses = function(witnesses) {\r\n  this.witnesses = witnesses;\r\n};\r\n\r\nInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n  // FIXME: Refactor signature so this is not necessary\r\n  signature.signature.nhashtype = signature.sigtype;\r\n  return Sighash.verify(\r\n    transaction,\r\n    signature.signature,\r\n    signature.publicKey,\r\n    signature.inputIndex,\r\n    this.output.script\r\n  );\r\n};\r\n\r\n/**\r\n * @returns true if this is a coinbase input (represents no input)\r\n */\r\nInput.prototype.isNull = function() {\r\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&\r\n    this.outputIndex === 0xffffffff;\r\n};\r\n\r\nInput.prototype._estimateSize = function() {\r\n  return this.toBufferWriter().toBuffer().length;\r\n};\r\n\r\nInput.prototype._getBaseSize = function() {\r\n  return 32 + 4 + 4; // outpoint (32 + 4) + sequence (4)\r\n};\r\n\r\n\r\n/**\r\n * Sets sequence number so that transaction is not valid until the desired seconds\r\n *  since the transaction is mined\r\n *\r\n * @param {Number} time in seconds\r\n * @return {Transaction} this\r\n */\r\nInput.prototype.lockForSeconds = function(seconds) {\r\n  $.checkArgument(_.isNumber(seconds));\r\n  if (seconds < 0 ||  seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\r\n    throw new errors.Transaction.Input.LockTimeRange();\r\n  }\r\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));\r\n\r\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \r\n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG ;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\r\n *\r\n * @param {Number} height\r\n * @return {Transaction} this\r\n */\r\nInput.prototype.lockUntilBlockHeight = function(heightDiff) {\r\n  $.checkArgument(_.isNumber(heightDiff));\r\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\r\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\r\n  }\r\n  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\r\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\r\n  this.sequenceNumber = heightDiff ;\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n *  Returns a semantic version of the input's sequence nLockTime.\r\n *  @return {Number|Date}\r\n *  If sequence lock is disabled  it returns null,\r\n *  if is set to block height lock, returns a block height (number)\r\n *  else it returns a Date object.\r\n */\r\nInput.prototype.getLockTime = function() {\r\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\r\n    return null;\r\n  }\r\n\r\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\r\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\r\n    return seconds;\r\n  } else {\r\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\r\n    return blockHeight;\r\n  }\r\n};\r\n\r\n\r\n\r\n\r\nmodule.exports = Input;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L2lucHV0LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLDREQUFRO0FBQ3hCLFFBQVEsbUJBQU8sQ0FBQywwRUFBMEI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFjO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUE2QjtBQUN4RCxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsNERBQW1CO0FBQzVDLGFBQWEsbUJBQU8sQ0FBQyxvREFBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsd0RBQWM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLDZEQUFZO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQywyREFBVztBQUNoQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsb0RBQW9EO0FBQ3BEO0FBQ0EsMkNBQTJDO0FBQzNDLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvaW5wdXQuanM/OWM4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcclxudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uLy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xyXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9idWZmZXInKTtcclxudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvanMnKTtcclxudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xyXG52YXIgU2lnaGFzaCA9IHJlcXVpcmUoJy4uL3NpZ2hhc2gnKTtcclxudmFyIE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpO1xyXG5cclxudmFyIE1BWElOVCA9IDB4ZmZmZmZmZmY7IC8vIE1hdGgucG93KDIsIDMyKSAtIDE7XHJcbnZhciBERUZBVUxUX1NFUU5VTUJFUiA9IE1BWElOVDtcclxudmFyIERFRkFVTFRfTE9DS1RJTUVfU0VRTlVNQkVSID0gTUFYSU5UIC0gMTtcclxudmFyIERFRkFVTFRfUkJGX1NFUU5VTUJFUiA9IE1BWElOVCAtIDI7XHJcbmNvbnN0IFNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRyA9ICBNYXRoLnBvdygyLDMxKTsgLy8gKDEgPDwgMzEpO1xyXG5jb25zdCBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcgPSBNYXRoLnBvdygyLDIyKTsgLy8gKDEgPDwgMjIpO1xyXG5jb25zdCBTRVFVRU5DRV9MT0NLVElNRV9NQVNLID0gMHhmZmZmO1xyXG5jb25zdCBTRVFVRU5DRV9MT0NLVElNRV9HUkFOVUxBUklUWSA9IDUxMjsgLy8gNTEyIHNlY29uZHNcclxuY29uc3QgU0VRVUVOQ0VfQkxPQ0tESUZGX0xJTUlUID0gTWF0aC5wb3coMiwxNiktMTsgLy8gMTYgYml0cyBcclxuXHJcblxyXG5mdW5jdGlvbiBJbnB1dChwYXJhbXMpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5wdXQpKSB7XHJcbiAgICByZXR1cm4gbmV3IElucHV0KHBhcmFtcyk7XHJcbiAgfVxyXG4gIGlmIChwYXJhbXMpIHtcclxuICAgIHJldHVybiB0aGlzLl9mcm9tT2JqZWN0KHBhcmFtcyk7XHJcbiAgfVxyXG59XHJcblxyXG5JbnB1dC5NQVhJTlQgPSBNQVhJTlQ7XHJcbklucHV0LkRFRkFVTFRfU0VRTlVNQkVSID0gREVGQVVMVF9TRVFOVU1CRVI7XHJcbklucHV0LkRFRkFVTFRfTE9DS1RJTUVfU0VRTlVNQkVSID0gREVGQVVMVF9MT0NLVElNRV9TRVFOVU1CRVI7XHJcbklucHV0LkRFRkFVTFRfUkJGX1NFUU5VTUJFUiA9IERFRkFVTFRfUkJGX1NFUU5VTUJFUjtcclxuSW5wdXQuU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHID0gU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0LnByb3RvdHlwZSwgJ3NjcmlwdCcsIHtcclxuICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9zY3JpcHQpIHtcclxuICAgICAgdGhpcy5fc2NyaXB0ID0gbmV3IFNjcmlwdCh0aGlzLl9zY3JpcHRCdWZmZXIpO1xyXG4gICAgICB0aGlzLl9zY3JpcHQuX2lzSW5wdXQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3NjcmlwdDtcclxuICB9XHJcbn0pO1xyXG5cclxuSW5wdXQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICQuY2hlY2tBcmd1bWVudChfLmlzT2JqZWN0KG9iaikpO1xyXG4gIHZhciBpbnB1dCA9IG5ldyBJbnB1dCgpO1xyXG4gIHJldHVybiBpbnB1dC5fZnJvbU9iamVjdChvYmopO1xyXG59O1xyXG5cclxuSW5wdXQucHJvdG90eXBlLl9mcm9tT2JqZWN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgdmFyIHByZXZUeElkO1xyXG4gIGlmICh0eXBlb2YgcGFyYW1zLnByZXZUeElkID09PSAnc3RyaW5nJyAmJiBKU1V0aWwuaXNIZXhhKHBhcmFtcy5wcmV2VHhJZCkpIHtcclxuICAgIHByZXZUeElkID0gQnVmZmVyLmZyb20ocGFyYW1zLnByZXZUeElkLCAnaGV4Jyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHByZXZUeElkID0gcGFyYW1zLnByZXZUeElkO1xyXG4gIH1cclxuICB0aGlzLndpdG5lc3NlcyA9IFtdO1xyXG4gIHRoaXMub3V0cHV0ID0gcGFyYW1zLm91dHB1dCA/XHJcbiAgICAocGFyYW1zLm91dHB1dCBpbnN0YW5jZW9mIE91dHB1dCA/IHBhcmFtcy5vdXRwdXQgOiBuZXcgT3V0cHV0KHBhcmFtcy5vdXRwdXQpKSA6IHVuZGVmaW5lZDtcclxuICB0aGlzLnByZXZUeElkID0gcHJldlR4SWQgfHwgcGFyYW1zLnR4aWRidWY7XHJcbiAgdGhpcy5vdXRwdXRJbmRleCA9IHBhcmFtcy5vdXRwdXRJbmRleCA9PSBudWxsID8gcGFyYW1zLnR4b3V0bnVtIDogcGFyYW1zLm91dHB1dEluZGV4O1xyXG4gIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBwYXJhbXMuc2VxdWVuY2VOdW1iZXIgPT0gbnVsbCA/XHJcbiAgICAocGFyYW1zLnNlcW51bSA9PSBudWxsID8gREVGQVVMVF9TRVFOVU1CRVIgOiBwYXJhbXMuc2VxbnVtKSA6IHBhcmFtcy5zZXF1ZW5jZU51bWJlcjtcclxuICAvLyBudWxsIHNjcmlwdCBpcyBhbGxvd2VkIGluIHNldFNjcmlwdCgpXHJcbiAgaWYgKHBhcmFtcy5zY3JpcHQgPT09IHVuZGVmaW5lZCAmJiBwYXJhbXMuc2NyaXB0QnVmZmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW5wdXQuTWlzc2luZ1NjcmlwdCgpO1xyXG4gIH1cclxuICB0aGlzLnNldFNjcmlwdChwYXJhbXMuc2NyaXB0QnVmZmVyIHx8IHBhcmFtcy5zY3JpcHQpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuSW5wdXQucHJvdG90eXBlLnRvT2JqZWN0ID0gSW5wdXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xyXG4gIHZhciBvYmogPSB7XHJcbiAgICBwcmV2VHhJZDogdGhpcy5wcmV2VHhJZC50b1N0cmluZygnaGV4JyksXHJcbiAgICBvdXRwdXRJbmRleDogdGhpcy5vdXRwdXRJbmRleCxcclxuICAgIHNlcXVlbmNlTnVtYmVyOiB0aGlzLnNlcXVlbmNlTnVtYmVyLFxyXG4gICAgc2NyaXB0OiB0aGlzLl9zY3JpcHRCdWZmZXIudG9TdHJpbmcoJ2hleCcpLFxyXG4gIH07XHJcbiAgLy8gYWRkIGh1bWFuIHJlYWRhYmxlIGZvcm0gaWYgaW5wdXQgY29udGFpbnMgdmFsaWQgc2NyaXB0XHJcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XHJcbiAgICBvYmouc2NyaXB0U3RyaW5nID0gdGhpcy5zY3JpcHQudG9TdHJpbmcoKTtcclxuICB9XHJcbiAgaWYgKHRoaXMub3V0cHV0KSB7XHJcbiAgICBvYmoub3V0cHV0ID0gdGhpcy5vdXRwdXQudG9PYmplY3QoKTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcbklucHV0LmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbihicikge1xyXG4gIHZhciBpbnB1dCA9IG5ldyBJbnB1dCgpO1xyXG4gIGlucHV0LnByZXZUeElkID0gYnIucmVhZFJldmVyc2UoMzIpO1xyXG4gIGlucHV0Lm91dHB1dEluZGV4ID0gYnIucmVhZFVJbnQzMkxFKCk7XHJcbiAgaW5wdXQuX3NjcmlwdEJ1ZmZlciA9IGJyLnJlYWRWYXJMZW5ndGhCdWZmZXIoKTtcclxuICBpbnB1dC5zZXF1ZW5jZU51bWJlciA9IGJyLnJlYWRVSW50MzJMRSgpO1xyXG4gIC8vIFRPRE86IHJldHVybiBkaWZmZXJlbnQgY2xhc3NlcyBhY2NvcmRpbmcgdG8gd2hpY2ggaW5wdXQgaXQgaXNcclxuICAvLyBlLmc6IENvaW5iYXNlSW5wdXQsIFB1YmxpY0tleUhhc2hJbnB1dCwgTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQsIGV0Yy5cclxuICByZXR1cm4gaW5wdXQ7XHJcbn07XHJcblxyXG5JbnB1dC5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbih3cml0ZXIpIHtcclxuICBpZiAoIXdyaXRlcikge1xyXG4gICAgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gIH1cclxuICB3cml0ZXIud3JpdGVSZXZlcnNlKHRoaXMucHJldlR4SWQpO1xyXG4gIHdyaXRlci53cml0ZVVJbnQzMkxFKHRoaXMub3V0cHV0SW5kZXgpO1xyXG4gIHZhciBzY3JpcHQgPSB0aGlzLl9zY3JpcHRCdWZmZXI7XHJcbiAgd3JpdGVyLndyaXRlVmFyaW50TnVtKHNjcmlwdC5sZW5ndGgpO1xyXG4gIHdyaXRlci53cml0ZShzY3JpcHQpO1xyXG4gIHdyaXRlci53cml0ZVVJbnQzMkxFKHRoaXMuc2VxdWVuY2VOdW1iZXIpO1xyXG4gIHJldHVybiB3cml0ZXI7XHJcbn07XHJcblxyXG5JbnB1dC5wcm90b3R5cGUuc2V0U2NyaXB0ID0gZnVuY3Rpb24oc2NyaXB0KSB7XHJcbiAgdGhpcy5fc2NyaXB0ID0gbnVsbDtcclxuICBpZiAoc2NyaXB0IGluc3RhbmNlb2YgU2NyaXB0KSB7XHJcbiAgICB0aGlzLl9zY3JpcHQgPSBzY3JpcHQ7XHJcbiAgICB0aGlzLl9zY3JpcHQuX2lzSW5wdXQgPSB0cnVlO1xyXG4gICAgdGhpcy5fc2NyaXB0QnVmZmVyID0gc2NyaXB0LnRvQnVmZmVyKCk7XHJcbiAgfSBlbHNlIGlmIChKU1V0aWwuaXNIZXhhKHNjcmlwdCkpIHtcclxuICAgIC8vIGhleCBzdHJpbmcgc2NyaXB0XHJcbiAgICB0aGlzLl9zY3JpcHRCdWZmZXIgPSBCdWZmZXIuZnJvbShzY3JpcHQsICdoZXgnKTtcclxuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoc2NyaXB0KSkge1xyXG4gICAgLy8gaHVtYW4gcmVhZGFibGUgc3RyaW5nIHNjcmlwdFxyXG4gICAgdGhpcy5fc2NyaXB0ID0gbmV3IFNjcmlwdChzY3JpcHQpO1xyXG4gICAgdGhpcy5fc2NyaXB0Ll9pc0lucHV0ID0gdHJ1ZTtcclxuICAgIHRoaXMuX3NjcmlwdEJ1ZmZlciA9IHRoaXMuX3NjcmlwdC50b0J1ZmZlcigpO1xyXG4gIH0gZWxzZSBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcihzY3JpcHQpKSB7XHJcbiAgICAvLyBidWZmZXIgc2NyaXB0XHJcbiAgICB0aGlzLl9zY3JpcHRCdWZmZXIgPSBCdWZmZXIuZnJvbShzY3JpcHQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHR5cGU6IHNjcmlwdCcpO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSBzaWduYXR1cmVzIGZvciB0aGUgcHJvdmlkZWQgUHJpdmF0ZUtleS5cclxuICpcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXHJcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB0byB1c2Ugd2hlbiBzaWduaW5nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dEluZGV4IC0gdGhlIGluZGV4IG9mIHRoaXMgaW5wdXQgaW4gdGhlIHByb3ZpZGVkIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWdUeXBlIC0gZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBhZGRyZXNzSGFzaCAtIGlmIHByb3ZpZGVkLCBkb24ndCBjYWxjdWxhdGUgdGhlIGhhc2ggb2YgdGhlXHJcbiAqICAgICBwdWJsaWMga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJpdmF0ZSBrZXkgcHJvdmlkZWRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5JbnB1dC5wcm90b3R5cGUuZ2V0U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xyXG4gIHRocm93IG5ldyBlcnJvcnMuQWJzdHJhY3RNZXRob2RJbnZva2VkKFxyXG4gICAgJ1RyeWluZyB0byBzaWduIHVuc3VwcG9ydGVkIG91dHB1dCB0eXBlIChvbmx5IFAyUEtIIGFuZCBQMlNIIG11bHRpc2lnIGlucHV0cyBhcmUgc3VwcG9ydGVkKScgK1xyXG4gICAgJyBmb3IgaW5wdXQ6ICcgKyBKU09OLnN0cmluZ2lmeSh0aGlzKVxyXG4gICk7XHJcbn07XHJcblxyXG5JbnB1dC5wcm90b3R5cGUuZ2V0U2F0b3NoaXNCdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQpO1xyXG4gICQuY2hlY2tTdGF0ZSh0aGlzLm91dHB1dC5fc2F0b3NoaXNCTik7XHJcbiAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKS53cml0ZVVJbnQ2NExFQk4odGhpcy5vdXRwdXQuX3NhdG9zaGlzQk4pLnRvQnVmZmVyKCk7XHJcbn07XHJcblxyXG5cclxuSW5wdXQucHJvdG90eXBlLmlzRnVsbHlTaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICB0aHJvdyBuZXcgZXJyb3JzLkFic3RyYWN0TWV0aG9kSW52b2tlZCgnSW5wdXQjaXNGdWxseVNpZ25lZCcpO1xyXG59O1xyXG5cclxuSW5wdXQucHJvdG90eXBlLmlzRmluYWwgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5zZXF1ZW5jZU51bWJlciAhPT0gSW5wdXQuTUFYSU5UO1xyXG59O1xyXG5cclxuSW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHRocm93IG5ldyBlcnJvcnMuQWJzdHJhY3RNZXRob2RJbnZva2VkKCdJbnB1dCNhZGRTaWduYXR1cmUnKTtcclxufTtcclxuXHJcbklucHV0LnByb3RvdHlwZS5jbGVhclNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcclxuICB0aHJvdyBuZXcgZXJyb3JzLkFic3RyYWN0TWV0aG9kSW52b2tlZCgnSW5wdXQjY2xlYXJTaWduYXR1cmVzJyk7XHJcbn07XHJcblxyXG5JbnB1dC5wcm90b3R5cGUuaGFzV2l0bmVzc2VzID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKHRoaXMud2l0bmVzc2VzICYmIHRoaXMud2l0bmVzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5JbnB1dC5wcm90b3R5cGUuZ2V0V2l0bmVzc2VzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMud2l0bmVzc2VzO1xyXG59O1xyXG5cclxuSW5wdXQucHJvdG90eXBlLnNldFdpdG5lc3NlcyA9IGZ1bmN0aW9uKHdpdG5lc3Nlcykge1xyXG4gIHRoaXMud2l0bmVzc2VzID0gd2l0bmVzc2VzO1xyXG59O1xyXG5cclxuSW5wdXQucHJvdG90eXBlLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSB7XHJcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcclxuICAvLyBGSVhNRTogUmVmYWN0b3Igc2lnbmF0dXJlIHNvIHRoaXMgaXMgbm90IG5lY2Vzc2FyeVxyXG4gIHNpZ25hdHVyZS5zaWduYXR1cmUubmhhc2h0eXBlID0gc2lnbmF0dXJlLnNpZ3R5cGU7XHJcbiAgcmV0dXJuIFNpZ2hhc2gudmVyaWZ5KFxyXG4gICAgdHJhbnNhY3Rpb24sXHJcbiAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxyXG4gICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcclxuICAgIHNpZ25hdHVyZS5pbnB1dEluZGV4LFxyXG4gICAgdGhpcy5vdXRwdXQuc2NyaXB0XHJcbiAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSBjb2luYmFzZSBpbnB1dCAocmVwcmVzZW50cyBubyBpbnB1dClcclxuICovXHJcbklucHV0LnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5wcmV2VHhJZC50b1N0cmluZygnaGV4JykgPT09ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyAmJlxyXG4gICAgdGhpcy5vdXRwdXRJbmRleCA9PT0gMHhmZmZmZmZmZjtcclxufTtcclxuXHJcbklucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXJXcml0ZXIoKS50b0J1ZmZlcigpLmxlbmd0aDtcclxufTtcclxuXHJcbklucHV0LnByb3RvdHlwZS5fZ2V0QmFzZVNpemUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gMzIgKyA0ICsgNDsgLy8gb3V0cG9pbnQgKDMyICsgNCkgKyBzZXF1ZW5jZSAoNClcclxufTtcclxuXHJcblxyXG4vKipcclxuICogU2V0cyBzZXF1ZW5jZSBudW1iZXIgc28gdGhhdCB0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWQgdW50aWwgdGhlIGRlc2lyZWQgc2Vjb25kc1xyXG4gKiAgc2luY2UgdGhlIHRyYW5zYWN0aW9uIGlzIG1pbmVkXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGluIHNlY29uZHNcclxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcclxuICovXHJcbklucHV0LnByb3RvdHlwZS5sb2NrRm9yU2Vjb25kcyA9IGZ1bmN0aW9uKHNlY29uZHMpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoXy5pc051bWJlcihzZWNvbmRzKSk7XHJcbiAgaWYgKHNlY29uZHMgPCAwIHx8ICBzZWNvbmRzID49IFNFUVVFTkNFX0xPQ0tUSU1FX0dSQU5VTEFSSVRZICogU0VRVUVOQ0VfTE9DS1RJTUVfTUFTSykge1xyXG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5JbnB1dC5Mb2NrVGltZVJhbmdlKCk7XHJcbiAgfVxyXG4gIHNlY29uZHMgPSBwYXJzZUludChNYXRoLmZsb29yKHNlY29uZHMgLyBTRVFVRU5DRV9MT0NLVElNRV9HUkFOVUxBUklUWSkpO1xyXG5cclxuICAvLyBTRVFVRU5DRV9MT0NLVElNRV9ESVNBQkxFX0ZMQUcgPSAxIFxyXG4gIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBzZWNvbmRzIHwgU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHIDtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHNlcXVlbmNlIG51bWJlciBzbyB0aGF0IHRyYW5zYWN0aW9uIGlzIG5vdCB2YWxpZCB1bnRpbCB0aGUgZGVzaXJlZCBibG9jayBoZWlnaHQgZGlmZmVybmVjZSBzaW5jZSB0aGUgdHggaXMgbWluZWRcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpc1xyXG4gKi9cclxuSW5wdXQucHJvdG90eXBlLmxvY2tVbnRpbEJsb2NrSGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0RGlmZikge1xyXG4gICQuY2hlY2tBcmd1bWVudChfLmlzTnVtYmVyKGhlaWdodERpZmYpKTtcclxuICBpZiAoaGVpZ2h0RGlmZiA8IDAgfHwgaGVpZ2h0RGlmZiA+PSBTRVFVRU5DRV9CTE9DS0RJRkZfTElNSVQpIHtcclxuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW5wdXQuQmxvY2tIZWlnaHRPdXRPZlJhbmdlKCk7XHJcbiAgfVxyXG4gIC8vIFNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBRyA9IDBcclxuICAvLyBTRVFVRU5DRV9MT0NLVElNRV9ESVNBQkxFX0ZMQUcgPSAwXHJcbiAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IGhlaWdodERpZmYgO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIHNlbWFudGljIHZlcnNpb24gb2YgdGhlIGlucHV0J3Mgc2VxdWVuY2UgbkxvY2tUaW1lLlxyXG4gKiAgQHJldHVybiB7TnVtYmVyfERhdGV9XHJcbiAqICBJZiBzZXF1ZW5jZSBsb2NrIGlzIGRpc2FibGVkICBpdCByZXR1cm5zIG51bGwsXHJcbiAqICBpZiBpcyBzZXQgdG8gYmxvY2sgaGVpZ2h0IGxvY2ssIHJldHVybnMgYSBibG9jayBoZWlnaHQgKG51bWJlcilcclxuICogIGVsc2UgaXQgcmV0dXJucyBhIERhdGUgb2JqZWN0LlxyXG4gKi9cclxuSW5wdXQucHJvdG90eXBlLmdldExvY2tUaW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKHRoaXMuc2VxdWVuY2VOdW1iZXIgJiBTRVFVRU5DRV9MT0NLVElNRV9ESVNBQkxFX0ZMQUcpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMuc2VxdWVuY2VOdW1iZXIgJiBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcpIHtcclxuICAgIHZhciBzZWNvbmRzID0gU0VRVUVOQ0VfTE9DS1RJTUVfR1JBTlVMQVJJVFkgKiAodGhpcy5zZXF1ZW5jZU51bWJlciAmIFNFUVVFTkNFX0xPQ0tUSU1FX01BU0spO1xyXG4gICAgcmV0dXJuIHNlY29uZHM7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBibG9ja0hlaWdodCA9IHRoaXMuc2VxdWVuY2VOdW1iZXIgJiBTRVFVRU5DRV9MT0NLVElNRV9NQVNLO1xyXG4gICAgcmV0dXJuIGJsb2NrSGVpZ2h0O1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5wdXQ7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/input/input.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/input/multisig.js":
/*!********************************************************!*\
  !*** ../bitcore-lib/lib/transaction/input/multisig.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar inherits = __webpack_require__(/*! inherits */ \"../bitcore-lib/node_modules/inherits/inherits.js\");\r\nvar Transaction = __webpack_require__(/*! ../transaction */ \"../bitcore-lib/lib/transaction/transaction.js\");\r\nvar Input = __webpack_require__(/*! ./input */ \"../bitcore-lib/lib/transaction/input/input.js\");\r\nvar Output = __webpack_require__(/*! ../output */ \"../bitcore-lib/lib/transaction/output.js\");\r\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nvar Script = __webpack_require__(/*! ../../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar Sighash = __webpack_require__(/*! ../sighash */ \"../bitcore-lib/lib/transaction/sighash.js\");\r\nvar PublicKey = __webpack_require__(/*! ../../publickey */ \"../bitcore-lib/lib/publickey.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"../bitcore-lib/lib/transaction/signature.js\");\r\n\r\n/**\r\n * @constructor\r\n */\r\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\r\n  opts = opts || {};\r\n  Input.apply(this, arguments);\r\n  var self = this;\r\n  pubkeys = pubkeys || input.publicKeys;\r\n  threshold = threshold || input.threshold;\r\n  signatures = signatures || input.signatures;\r\n  if (opts.noSorting) {\r\n    this.publicKeys = pubkeys\r\n  } else  {\r\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\r\n  }\r\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),\r\n    'Provided public keys don\\'t match to the provided output script');\r\n  this.publicKeyIndex = {};\r\n  _.each(this.publicKeys, function(publicKey, index) {\r\n    self.publicKeyIndex[publicKey.toString()] = index;\r\n  });\r\n  this.threshold = threshold;\r\n  // Empty array of signatures\r\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\r\n}\r\ninherits(MultiSigInput, Input);\r\n\r\nMultiSigInput.prototype.toObject = function() {\r\n  var obj = Input.prototype.toObject.apply(this, arguments);\r\n  obj.threshold = this.threshold;\r\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\r\n  obj.signatures = this._serializeSignatures();\r\n  return obj;\r\n};\r\n\r\nMultiSigInput.prototype._deserializeSignatures = function(signatures) {\r\n  return _.map(signatures, function(signature) {\r\n    if (!signature) {\r\n      return undefined;\r\n    }\r\n    return new TransactionSignature(signature);\r\n  });\r\n};\r\n\r\nMultiSigInput.prototype._serializeSignatures = function() {\r\n  return _.map(this.signatures, function(signature) {\r\n    if (!signature) {\r\n      return undefined;\r\n    }\r\n    return signature.toObject();\r\n  });\r\n};\r\n\r\n/**\r\n * Get signatures for this input\r\n * @param {Transaction} transaction - the transaction to be signed\r\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\r\n * @param {number} index - the index of the input in the transaction input vector\r\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\r\n * @param {Buffer} hashData - unused for this input type\r\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr'\r\n * @param {Buffer} merkleRoot - unused for this input type\r\n * @return {Array<TransactionSignature>}\r\n */\r\nMultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\r\n  $.checkState(this.output instanceof Output);\r\n  sigtype = sigtype || Signature.SIGHASH_ALL;\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n\r\n  const results = [];\r\n  for (const publicKey of this.publicKeys || []) {\r\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\r\n      results.push(new TransactionSignature({\r\n        publicKey: privateKey.publicKey,\r\n        prevTxId: this.prevTxId,\r\n        outputIndex: this.outputIndex,\r\n        inputIndex: index,\r\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\r\n        sigtype: sigtype\r\n      }));\r\n    }\r\n  }\r\n\r\n  return results;\r\n};\r\n\r\nMultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {\r\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\r\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], \"Signature Undefined\"),\r\n    'Signature has no matching public key');\r\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), \"Invalid Signature\");\r\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\r\n  this._updateScript();\r\n  return this;\r\n};\r\n\r\nMultiSigInput.prototype._updateScript = function() {\r\n  this.setScript(Script.buildMultisigIn(\r\n    this.publicKeys,\r\n    this.threshold,\r\n    this._createSignatures()\r\n  ));\r\n  return this;\r\n};\r\n\r\nMultiSigInput.prototype._createSignatures = function() {\r\n  return _.map(\r\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\r\n    // Future signature types may need refactor of toDER\r\n    function(signature) {\r\n      return BufferUtil.concat([\r\n        signature.signature.toDER(),\r\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\r\n      ]);\r\n    }\r\n  );\r\n};\r\n\r\nMultiSigInput.prototype.clearSignatures = function() {\r\n  this.signatures = new Array(this.publicKeys.length);\r\n  this._updateScript();\r\n};\r\n\r\nMultiSigInput.prototype.isFullySigned = function() {\r\n  return this.countSignatures() === this.threshold;\r\n};\r\n\r\nMultiSigInput.prototype.countMissingSignatures = function() {\r\n  return this.threshold - this.countSignatures();\r\n};\r\n\r\nMultiSigInput.prototype.countSignatures = function() {\r\n  return _.reduce(this.signatures, function(sum, signature) {\r\n    return sum + (!!signature);\r\n  }, 0);\r\n};\r\n\r\nMultiSigInput.prototype.publicKeysWithoutSignature = function() {\r\n  var self = this;\r\n  return _.filter(this.publicKeys, function(publicKey) {\r\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\r\n  });\r\n};\r\n\r\nMultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n  // FIXME: Refactor signature so this is not necessary\r\n  signature.signature.nhashtype = signature.sigtype;\r\n  return Sighash.verify(\r\n    transaction,\r\n    signature.signature,\r\n    signature.publicKey,\r\n    signature.inputIndex,\r\n    this.output.script\r\n  );\r\n};\r\n\r\n/**\r\n *\r\n * @param {Buffer[]} signatures\r\n * @param {PublicKey[]} publicKeys\r\n * @param {Transaction} transaction\r\n * @param {Integer} inputIndex\r\n * @param {Input} input\r\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\r\n * @returns {TransactionSignature[]}\r\n */\r\nMultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n\r\n  return publicKeys.map(function (pubKey) {\r\n    var signatureMatch = null;\r\n    signatures = signatures.filter(function (signatureBuffer) {\r\n      if (signatureMatch) {\r\n        return true;\r\n      }\r\n\r\n      var signature = new TransactionSignature({\r\n        signature: Signature.fromTxFormat(signatureBuffer),\r\n        publicKey: pubKey,\r\n        prevTxId: input.prevTxId,\r\n        outputIndex: input.outputIndex,\r\n        inputIndex: inputIndex,\r\n        sigtype: Signature.SIGHASH_ALL\r\n      });\r\n\r\n      signature.signature.nhashtype = signature.sigtype;\r\n      var isMatch = Sighash.verify(\r\n          transaction,\r\n          signature.signature,\r\n          signature.publicKey,\r\n          signature.inputIndex,\r\n          input.output.script\r\n      );\r\n\r\n      if (isMatch) {\r\n        signatureMatch = signature;\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    return signatureMatch ? signatureMatch : null;\r\n  });\r\n};\r\n\r\nMultiSigInput.OPCODES_SIZE = 1; // 0\r\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\r\n\r\nMultiSigInput.prototype._estimateSize = function() {\r\n  return this._getBaseSize() + MultiSigInput.OPCODES_SIZE +\r\n    this.threshold * MultiSigInput.SIGNATURE_SIZE;\r\n};\r\n\r\nmodule.exports = MultiSigInput;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L211bHRpc2lnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLG1CQUFPLENBQUMsNERBQVE7QUFDeEIsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFnQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsOERBQVM7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDJEQUFXO0FBQ2hDLFFBQVEsbUJBQU8sQ0FBQywwRUFBMEI7QUFDMUM7QUFDQSxhQUFhLG1CQUFPLENBQUMsd0RBQWM7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQXdCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyw2REFBWTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsNERBQW1CO0FBQzVDLDJCQUEyQixtQkFBTyxDQUFDLGlFQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhEQUE4RCxtQ0FBbUM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw4QkFBOEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsbUNBQW1DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvbXVsdGlzaWcuanM/MmMyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xyXG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuLi90cmFuc2FjdGlvbicpO1xyXG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XHJcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuLi9vdXRwdXQnKTtcclxudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxuXHJcbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcclxudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uLy4uL2NyeXB0by9zaWduYXR1cmUnKTtcclxudmFyIFNpZ2hhc2ggPSByZXF1aXJlKCcuLi9zaWdoYXNoJyk7XHJcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuLi8uLi9wdWJsaWNrZXknKTtcclxudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2J1ZmZlcicpO1xyXG52YXIgVHJhbnNhY3Rpb25TaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE11bHRpU2lnSW5wdXQoaW5wdXQsIHB1YmtleXMsIHRocmVzaG9sZCwgc2lnbmF0dXJlcywgb3B0cykge1xyXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIHB1YmtleXMgPSBwdWJrZXlzIHx8IGlucHV0LnB1YmxpY0tleXM7XHJcbiAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IGlucHV0LnRocmVzaG9sZDtcclxuICBzaWduYXR1cmVzID0gc2lnbmF0dXJlcyB8fCBpbnB1dC5zaWduYXR1cmVzO1xyXG4gIGlmIChvcHRzLm5vU29ydGluZykge1xyXG4gICAgdGhpcy5wdWJsaWNLZXlzID0gcHVia2V5c1xyXG4gIH0gZWxzZSAge1xyXG4gICAgdGhpcy5wdWJsaWNLZXlzID0gXy5zb3J0QnkocHVia2V5cywgZnVuY3Rpb24ocHVibGljS2V5KSB7IHJldHVybiBwdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpOyB9KTtcclxuICB9XHJcbiAgJC5jaGVja1N0YXRlKFNjcmlwdC5idWlsZE11bHRpc2lnT3V0KHRoaXMucHVibGljS2V5cywgdGhyZXNob2xkKS5lcXVhbHModGhpcy5vdXRwdXQuc2NyaXB0KSxcclxuICAgICdQcm92aWRlZCBwdWJsaWMga2V5cyBkb25cXCd0IG1hdGNoIHRvIHRoZSBwcm92aWRlZCBvdXRwdXQgc2NyaXB0Jyk7XHJcbiAgdGhpcy5wdWJsaWNLZXlJbmRleCA9IHt9O1xyXG4gIF8uZWFjaCh0aGlzLnB1YmxpY0tleXMsIGZ1bmN0aW9uKHB1YmxpY0tleSwgaW5kZXgpIHtcclxuICAgIHNlbGYucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldID0gaW5kZXg7XHJcbiAgfSk7XHJcbiAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XHJcbiAgLy8gRW1wdHkgYXJyYXkgb2Ygc2lnbmF0dXJlc1xyXG4gIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXMgPyB0aGlzLl9kZXNlcmlhbGl6ZVNpZ25hdHVyZXMoc2lnbmF0dXJlcykgOiBuZXcgQXJyYXkodGhpcy5wdWJsaWNLZXlzLmxlbmd0aCk7XHJcbn1cclxuaW5oZXJpdHMoTXVsdGlTaWdJbnB1dCwgSW5wdXQpO1xyXG5cclxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgb2JqID0gSW5wdXQucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgb2JqLnRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkO1xyXG4gIG9iai5wdWJsaWNLZXlzID0gXy5tYXAodGhpcy5wdWJsaWNLZXlzLCBmdW5jdGlvbihwdWJsaWNLZXkpIHsgcmV0dXJuIHB1YmxpY0tleS50b1N0cmluZygpOyB9KTtcclxuICBvYmouc2lnbmF0dXJlcyA9IHRoaXMuX3NlcmlhbGl6ZVNpZ25hdHVyZXMoKTtcclxuICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuX2Rlc2VyaWFsaXplU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKHNpZ25hdHVyZXMpIHtcclxuICByZXR1cm4gXy5tYXAoc2lnbmF0dXJlcywgZnVuY3Rpb24oc2lnbmF0dXJlKSB7XHJcbiAgICBpZiAoIXNpZ25hdHVyZSkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblNpZ25hdHVyZShzaWduYXR1cmUpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuX3NlcmlhbGl6ZVNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gXy5tYXAodGhpcy5zaWduYXR1cmVzLCBmdW5jdGlvbihzaWduYXR1cmUpIHtcclxuICAgIGlmICghc2lnbmF0dXJlKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2lnbmF0dXJlLnRvT2JqZWN0KCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHNpZ25hdHVyZXMgZm9yIHRoaXMgaW5wdXRcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXHJcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB3aXRoIHdoaWNoIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgaW5wdXQgaW4gdGhlIHRyYW5zYWN0aW9uIGlucHV0IHZlY3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHNpZ25hdHVyZSwgZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoRGF0YSAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIERFUFJFQ0FURUQgLSBtZXRob2QgdXNlZCB0byBzaWduIC0gJ2VjZHNhJyBvciAnc2Nobm9ycidcclxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgLSB1bnVzZWQgZm9yIHRoaXMgaW5wdXQgdHlwZVxyXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XHJcbiAqL1xyXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlLCBoYXNoRGF0YSwgc2lnbmluZ01ldGhvZCwgbWVya2xlUm9vdCkge1xyXG4gICQuY2hlY2tTdGF0ZSh0aGlzLm91dHB1dCBpbnN0YW5jZW9mIE91dHB1dCk7XHJcbiAgc2lndHlwZSA9IHNpZ3R5cGUgfHwgU2lnbmF0dXJlLlNJR0hBU0hfQUxMO1xyXG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXHJcblxyXG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICBmb3IgKGNvbnN0IHB1YmxpY0tleSBvZiB0aGlzLnB1YmxpY0tleXMgfHwgW10pIHtcclxuICAgIGlmIChwdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHJpdmF0ZUtleS5wdWJsaWNLZXkudG9TdHJpbmcoKSkge1xyXG4gICAgICByZXN1bHRzLnB1c2gobmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcclxuICAgICAgICBwdWJsaWNLZXk6IHByaXZhdGVLZXkucHVibGljS2V5LFxyXG4gICAgICAgIHByZXZUeElkOiB0aGlzLnByZXZUeElkLFxyXG4gICAgICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxyXG4gICAgICAgIGlucHV0SW5kZXg6IGluZGV4LFxyXG4gICAgICAgIHNpZ25hdHVyZTogU2lnaGFzaC5zaWduKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBzaWd0eXBlLCBpbmRleCwgdGhpcy5vdXRwdXQuc2NyaXB0KSxcclxuICAgICAgICBzaWd0eXBlOiBzaWd0eXBlXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHRzO1xyXG59O1xyXG5cclxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuYWRkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xyXG4gICQuY2hlY2tTdGF0ZSghdGhpcy5pc0Z1bGx5U2lnbmVkKCksICdBbGwgbmVlZGVkIHNpZ25hdHVyZXMgaGF2ZSBhbHJlYWR5IGJlZW4gYWRkZWQnKTtcclxuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQodGhpcy5wdWJsaWNLZXlJbmRleFtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCldLCBcIlNpZ25hdHVyZSBVbmRlZmluZWRcIiksXHJcbiAgICAnU2lnbmF0dXJlIGhhcyBubyBtYXRjaGluZyBwdWJsaWMga2V5Jyk7XHJcbiAgJC5jaGVja1N0YXRlKHRoaXMuaXNWYWxpZFNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSwgXCJJbnZhbGlkIFNpZ25hdHVyZVwiKTtcclxuICB0aGlzLnNpZ25hdHVyZXNbdGhpcy5wdWJsaWNLZXlJbmRleFtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCldXSA9IHNpZ25hdHVyZTtcclxuICB0aGlzLl91cGRhdGVTY3JpcHQoKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLl91cGRhdGVTY3JpcHQgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLnNldFNjcmlwdChTY3JpcHQuYnVpbGRNdWx0aXNpZ0luKFxyXG4gICAgdGhpcy5wdWJsaWNLZXlzLFxyXG4gICAgdGhpcy50aHJlc2hvbGQsXHJcbiAgICB0aGlzLl9jcmVhdGVTaWduYXR1cmVzKClcclxuICApKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLl9jcmVhdGVTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIF8ubWFwKFxyXG4gICAgXy5maWx0ZXIodGhpcy5zaWduYXR1cmVzLCBmdW5jdGlvbihzaWduYXR1cmUpIHsgcmV0dXJuICFfLmlzVW5kZWZpbmVkKHNpZ25hdHVyZSk7IH0pLFxyXG4gICAgLy8gRnV0dXJlIHNpZ25hdHVyZSB0eXBlcyBtYXkgbmVlZCByZWZhY3RvciBvZiB0b0RFUlxyXG4gICAgZnVuY3Rpb24oc2lnbmF0dXJlKSB7XHJcbiAgICAgIHJldHVybiBCdWZmZXJVdGlsLmNvbmNhdChbXHJcbiAgICAgICAgc2lnbmF0dXJlLnNpZ25hdHVyZS50b0RFUigpLFxyXG4gICAgICAgIEJ1ZmZlclV0aWwuaW50ZWdlckFzU2luZ2xlQnl0ZUJ1ZmZlcihzaWduYXR1cmUuc2lndHlwZSlcclxuICAgICAgXSk7XHJcbiAgICB9XHJcbiAgKTtcclxufTtcclxuXHJcbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmNsZWFyU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuc2lnbmF0dXJlcyA9IG5ldyBBcnJheSh0aGlzLnB1YmxpY0tleXMubGVuZ3RoKTtcclxuICB0aGlzLl91cGRhdGVTY3JpcHQoKTtcclxufTtcclxuXHJcbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmlzRnVsbHlTaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5jb3VudFNpZ25hdHVyZXMoKSA9PT0gdGhpcy50aHJlc2hvbGQ7XHJcbn07XHJcblxyXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5jb3VudE1pc3NpbmdTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudGhyZXNob2xkIC0gdGhpcy5jb3VudFNpZ25hdHVyZXMoKTtcclxufTtcclxuXHJcbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmNvdW50U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBfLnJlZHVjZSh0aGlzLnNpZ25hdHVyZXMsIGZ1bmN0aW9uKHN1bSwgc2lnbmF0dXJlKSB7XHJcbiAgICByZXR1cm4gc3VtICsgKCEhc2lnbmF0dXJlKTtcclxuICB9LCAwKTtcclxufTtcclxuXHJcbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLnB1YmxpY0tleXNXaXRob3V0U2lnbmF0dXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIHJldHVybiBfLmZpbHRlcih0aGlzLnB1YmxpY0tleXMsIGZ1bmN0aW9uKHB1YmxpY0tleSkge1xyXG4gICAgcmV0dXJuICEoc2VsZi5zaWduYXR1cmVzW3NlbGYucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldXSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xyXG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXHJcbiAgLy8gRklYTUU6IFJlZmFjdG9yIHNpZ25hdHVyZSBzbyB0aGlzIGlzIG5vdCBuZWNlc3NhcnlcclxuICBzaWduYXR1cmUuc2lnbmF0dXJlLm5oYXNodHlwZSA9IHNpZ25hdHVyZS5zaWd0eXBlO1xyXG4gIHJldHVybiBTaWdoYXNoLnZlcmlmeShcclxuICAgIHRyYW5zYWN0aW9uLFxyXG4gICAgc2lnbmF0dXJlLnNpZ25hdHVyZSxcclxuICAgIHNpZ25hdHVyZS5wdWJsaWNLZXksXHJcbiAgICBzaWduYXR1cmUuaW5wdXRJbmRleCxcclxuICAgIHRoaXMub3V0cHV0LnNjcmlwdFxyXG4gICk7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJbXX0gc2lnbmF0dXJlc1xyXG4gKiBAcGFyYW0ge1B1YmxpY0tleVtdfSBwdWJsaWNLZXlzXHJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW5wdXRJbmRleFxyXG4gKiBAcGFyYW0ge0lucHV0fSBpbnB1dFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCBERVBSRUNBVEVEIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInIChmdXR1cmUgc2lnbmluZyBtZXRob2QpXHJcbiAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblNpZ25hdHVyZVtdfVxyXG4gKi9cclxuTXVsdGlTaWdJbnB1dC5ub3JtYWxpemVTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIGlucHV0LCBpbnB1dEluZGV4LCBzaWduYXR1cmVzLCBwdWJsaWNLZXlzLCBzaWduaW5nTWV0aG9kKSB7XHJcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcclxuXHJcbiAgcmV0dXJuIHB1YmxpY0tleXMubWFwKGZ1bmN0aW9uIChwdWJLZXkpIHtcclxuICAgIHZhciBzaWduYXR1cmVNYXRjaCA9IG51bGw7XHJcbiAgICBzaWduYXR1cmVzID0gc2lnbmF0dXJlcy5maWx0ZXIoZnVuY3Rpb24gKHNpZ25hdHVyZUJ1ZmZlcikge1xyXG4gICAgICBpZiAoc2lnbmF0dXJlTWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNpZ25hdHVyZSA9IG5ldyBUcmFuc2FjdGlvblNpZ25hdHVyZSh7XHJcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbVR4Rm9ybWF0KHNpZ25hdHVyZUJ1ZmZlciksXHJcbiAgICAgICAgcHVibGljS2V5OiBwdWJLZXksXHJcbiAgICAgICAgcHJldlR4SWQ6IGlucHV0LnByZXZUeElkLFxyXG4gICAgICAgIG91dHB1dEluZGV4OiBpbnB1dC5vdXRwdXRJbmRleCxcclxuICAgICAgICBpbnB1dEluZGV4OiBpbnB1dEluZGV4LFxyXG4gICAgICAgIHNpZ3R5cGU6IFNpZ25hdHVyZS5TSUdIQVNIX0FMTFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUubmhhc2h0eXBlID0gc2lnbmF0dXJlLnNpZ3R5cGU7XHJcbiAgICAgIHZhciBpc01hdGNoID0gU2lnaGFzaC52ZXJpZnkoXHJcbiAgICAgICAgICB0cmFuc2FjdGlvbixcclxuICAgICAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXHJcbiAgICAgICAgICBzaWduYXR1cmUucHVibGljS2V5LFxyXG4gICAgICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXHJcbiAgICAgICAgICBpbnB1dC5vdXRwdXQuc2NyaXB0XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoaXNNYXRjaCkge1xyXG4gICAgICAgIHNpZ25hdHVyZU1hdGNoID0gc2lnbmF0dXJlO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gc2lnbmF0dXJlTWF0Y2ggPyBzaWduYXR1cmVNYXRjaCA6IG51bGw7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5NdWx0aVNpZ0lucHV0Lk9QQ09ERVNfU0laRSA9IDE7IC8vIDBcclxuTXVsdGlTaWdJbnB1dC5TSUdOQVRVUkVfU0laRSA9IDczOyAvLyBzaXplICgxKSArIERFUiAoPD03MilcclxuXHJcbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLl9lc3RpbWF0ZVNpemUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5fZ2V0QmFzZVNpemUoKSArIE11bHRpU2lnSW5wdXQuT1BDT0RFU19TSVpFICtcclxuICAgIHRoaXMudGhyZXNob2xkICogTXVsdGlTaWdJbnB1dC5TSUdOQVRVUkVfU0laRTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTXVsdGlTaWdJbnB1dDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/input/multisig.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/input/multisigscripthash.js":
/*!******************************************************************!*\
  !*** ../bitcore-lib/lib/transaction/input/multisigscripthash.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\n/* jshint maxparams:5 */\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar inherits = __webpack_require__(/*! inherits */ \"../bitcore-lib/node_modules/inherits/inherits.js\");\r\nvar Input = __webpack_require__(/*! ./input */ \"../bitcore-lib/lib/transaction/input/input.js\");\r\nvar Output = __webpack_require__(/*! ../output */ \"../bitcore-lib/lib/transaction/output.js\");\r\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nvar Address = __webpack_require__(/*! ../../address */ \"../bitcore-lib/lib/address.js\");\r\nvar Script = __webpack_require__(/*! ../../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar Sighash = __webpack_require__(/*! ../sighash */ \"../bitcore-lib/lib/transaction/sighash.js\");\r\nvar SighashWitness = __webpack_require__(/*! ../sighashwitness */ \"../bitcore-lib/lib/transaction/sighashwitness.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"../bitcore-lib/lib/transaction/signature.js\");\r\n\r\n/**\r\n * @constructor\r\n */\r\nfunction MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {\r\n  /* jshint maxstatements:20 */\r\n  opts = opts || {};\r\n  Input.apply(this, arguments);\r\n  pubkeys = pubkeys || input.publicKeys;\r\n  threshold = threshold || input.threshold;\r\n  signatures = signatures || input.signatures;\r\n  if (opts.noSorting) {\r\n    this.publicKeys = pubkeys;\r\n  } else  {\r\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\r\n  }\r\n  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);\r\n  var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);\r\n  if (nested.equals(this.output.script)) {\r\n    this.nestedWitness = false;\r\n    this.type = Address.PayToWitnessScriptHash;\r\n  } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {\r\n    this.nestedWitness = true;\r\n    this.type = Address.PayToScriptHash;\r\n  } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {\r\n    this.nestedWitness = false;\r\n    this.type = Address.PayToScriptHash;\r\n  } else {\r\n    throw new Error('Provided public keys don\\'t hash to the provided output');\r\n  }\r\n\r\n  if (this.nestedWitness) {\r\n    var scriptSig = new Script();\r\n    scriptSig.add(nested.toBuffer());\r\n    this.setScript(scriptSig);\r\n  }\r\n\r\n  this.publicKeyIndex = {};\r\n  for (let index = 0; index < this.publicKeys.length; index++) {\r\n    const publicKey = this.publicKeys[index];\r\n    this.publicKeyIndex[publicKey.toString()] = index;\r\n  }\r\n  this.threshold = threshold;\r\n  // Empty array of signatures\r\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\r\n}\r\ninherits(MultiSigScriptHashInput, Input);\r\n\r\nMultiSigScriptHashInput.prototype.toObject = function() {\r\n  var obj = Input.prototype.toObject.apply(this, arguments);\r\n  obj.threshold = this.threshold;\r\n  obj.publicKeys = this.publicKeys.map(function(publicKey) { return publicKey.toString(); });\r\n  obj.signatures = this._serializeSignatures();\r\n  return obj;\r\n};\r\n\r\nMultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {\r\n  return signatures.map(function(signature) {\r\n    if (!signature) {\r\n      return undefined;\r\n    }\r\n    return new TransactionSignature(signature);\r\n  });\r\n};\r\n\r\nMultiSigScriptHashInput.prototype._serializeSignatures = function() {\r\n  return this.signatures.map(function(signature) {\r\n    if (!signature) {\r\n      return undefined;\r\n    }\r\n    return signature.toObject();\r\n  });\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.getScriptCode = function() {\r\n  var writer = new BufferWriter();\r\n  if (!this.redeemScript.hasCodeseparators()) {\r\n    var redeemScriptBuffer = this.redeemScript.toBuffer();\r\n    writer.writeVarintNum(redeemScriptBuffer.length);\r\n    writer.write(redeemScriptBuffer);\r\n  } else {\r\n    throw new Error('@TODO');\r\n  }\r\n  return writer.toBuffer();\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\r\n  var hash;\r\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\r\n    var scriptCode = this.getScriptCode();\r\n    var satoshisBuffer = this.getSatoshisBuffer();\r\n    hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\r\n  } else  {\r\n    hash = Sighash.sighash(transaction, sigtype, index, this.redeemScript);\r\n  }\r\n  return hash;\r\n};\r\n\r\n/**\r\n * Get signatures for this input\r\n * @param {Transaction} transaction - the transaction to be signed\r\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\r\n * @param {number} index - the index of the input in the transaction input vector\r\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\r\n * @param {Buffer} hashData - unused for this input type\r\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr'\r\n * @param {Buffer} merkleRoot - unused for this input type\r\n * @return {Array<TransactionSignature>}\r\n */\r\nMultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\r\n  $.checkState(this.output instanceof Output);\r\n  sigtype = sigtype || Signature.SIGHASH_ALL;\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n\r\n  const results = [];\r\n  for (const publicKey of this.publicKeys) {\r\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\r\n      var signature;\r\n      if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\r\n        var scriptCode = this.getScriptCode();\r\n        var satoshisBuffer = this.getSatoshisBuffer();\r\n        signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer);\r\n      } else  {\r\n        signature = Sighash.sign(transaction, privateKey, sigtype, index, this.redeemScript);\r\n      }\r\n      results.push(new TransactionSignature({\r\n        publicKey: privateKey.publicKey,\r\n        prevTxId: this.prevTxId,\r\n        outputIndex: this.outputIndex,\r\n        inputIndex: index,\r\n        signature: signature,\r\n        sigtype: sigtype\r\n      }));\r\n    }\r\n  }\r\n  return results;\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\r\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\r\n  $.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] != null,\r\n                  'Signature has no matching public key');\r\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Invalid Signature!');\r\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\r\n  this._updateScript();\r\n  return this;\r\n};\r\n\r\nMultiSigScriptHashInput.prototype._updateScript = function() {\r\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\r\n    var stack = [\r\n      Buffer.alloc(0),\r\n    ];\r\n    var signatures = this._createSignatures();\r\n    for (var i = 0; i < signatures.length; i++) {\r\n      stack.push(signatures[i]);\r\n    }\r\n    stack.push(this.redeemScript.toBuffer());\r\n    this.setWitnesses(stack);\r\n  } else {\r\n    var scriptSig = Script.buildP2SHMultisigIn(\r\n      this.publicKeys,\r\n      this.threshold,\r\n      this._createSignatures(),\r\n      { cachedMultisig: this.redeemScript }\r\n    );\r\n    this.setScript(scriptSig);\r\n  }\r\n  return this;\r\n};\r\n\r\nMultiSigScriptHashInput.prototype._createSignatures = function() {\r\n  return this.signatures\r\n    .filter(function(signature) { return signature != null; })\r\n    .map(function(signature) {\r\n      return BufferUtil.concat([\r\n        signature.signature.toDER(),\r\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\r\n      ]);\r\n    });\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.clearSignatures = function() {\r\n  this.signatures = new Array(this.publicKeys.length);\r\n  this._updateScript();\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.isFullySigned = function() {\r\n  return this.countSignatures() === this.threshold;\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.countMissingSignatures = function() {\r\n  return this.threshold - this.countSignatures();\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.countSignatures = function() {\r\n  return this.signatures.reduce(function(sum, signature) {\r\n    return sum + (!!signature);\r\n  }, 0);\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {\r\n  return this.publicKeys.filter((publicKey) => {\r\n    return !(this.signatures[this.publicKeyIndex[publicKey.toString()]]);\r\n  });\r\n};\r\n\r\nMultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\r\n    signature.signature.nhashtype = signature.sigtype;\r\n    var scriptCode = this.getScriptCode();\r\n    var satoshisBuffer = this.getSatoshisBuffer();\r\n    return SighashWitness.verify(\r\n      transaction,\r\n      signature.signature,\r\n      signature.publicKey,\r\n      signature.inputIndex,\r\n      scriptCode,\r\n      satoshisBuffer\r\n    );\r\n  } else {\r\n    // FIXME: Refactor signature so this is not necessary\r\n    signature.signature.nhashtype = signature.sigtype;\r\n    return Sighash.verify(\r\n      transaction,\r\n      signature.signature,\r\n      signature.publicKey,\r\n      signature.inputIndex,\r\n      this.redeemScript\r\n    );\r\n  }\r\n};\r\n\r\nMultiSigScriptHashInput.MAX_OPCODES_SIZE = 8; // serialized size (<=3) + 0 .. OP_PUSHDATAx N .. M OP_CHECKMULTISIG\r\nMultiSigScriptHashInput.MAX_SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\r\nMultiSigScriptHashInput.MAX_PUBKEY_SIZE = 34; // size (1) + DER (<=33)\r\nMultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34; // OP_0 (1) + scriptHash (1 + 32)\r\n\r\nMultiSigScriptHashInput.prototype._estimateSize = function() {\r\n  let result = this._getBaseSize();\r\n  const WITNESS_DISCOUNT = 4;\r\n  const witnessSize = MultiSigScriptHashInput.MAX_OPCODES_SIZE +\r\n    this.threshold * MultiSigScriptHashInput.MAX_SIGNATURE_SIZE +\r\n    this.publicKeys.length * MultiSigScriptHashInput.MAX_PUBKEY_SIZE;\r\n  if (this.type === Address.PayToWitnessScriptHash) {\r\n    result += witnessSize / WITNESS_DISCOUNT;\r\n  } else if (this.nestedWitness) {\r\n    result += witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;\r\n  } else {\r\n    result += witnessSize;\r\n  }\r\n  return result;\r\n};\r\n\r\nmodule.exports = MultiSigScriptHashInput;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L211bHRpc2lnc2NyaXB0aGFzaC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFPLENBQUMsNERBQVE7QUFDeEIsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyw4REFBUztBQUM3QixhQUFhLG1CQUFPLENBQUMsMkRBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLDBFQUEwQjtBQUMxQztBQUNBLGNBQWMsbUJBQU8sQ0FBQyxvREFBZTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsd0RBQWM7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQXdCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyw2REFBWTtBQUNsQyxxQkFBcUIsbUJBQU8sQ0FBQywyRUFBbUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQTZCO0FBQ3hELGlCQUFpQixtQkFBTyxDQUFDLDREQUFtQjtBQUM1QywyQkFBMkIsbUJBQU8sQ0FBQyxpRUFBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw4REFBOEQsbUNBQW1DO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw4QkFBOEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFNO0FBQ1o7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxpREFBaUQ7QUFDakQsOENBQThDO0FBQzlDLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvbXVsdGlzaWdzY3JpcHRoYXNoLmpzPzA1NGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoganNoaW50IG1heHBhcmFtczo1ICovXHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xyXG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XHJcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuLi9vdXRwdXQnKTtcclxudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxuXHJcbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi4vLi4vYWRkcmVzcycpO1xyXG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XHJcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi8uLi9jcnlwdG8vc2lnbmF0dXJlJyk7XHJcbnZhciBTaWdoYXNoID0gcmVxdWlyZSgnLi4vc2lnaGFzaCcpO1xyXG52YXIgU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuLi9zaWdoYXNod2l0bmVzcycpO1xyXG52YXIgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9idWZmZXInKTtcclxudmFyIFRyYW5zYWN0aW9uU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dChpbnB1dCwgcHVia2V5cywgdGhyZXNob2xkLCBzaWduYXR1cmVzLCBvcHRzKSB7XHJcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6MjAgKi9cclxuICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIHB1YmtleXMgPSBwdWJrZXlzIHx8IGlucHV0LnB1YmxpY0tleXM7XHJcbiAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IGlucHV0LnRocmVzaG9sZDtcclxuICBzaWduYXR1cmVzID0gc2lnbmF0dXJlcyB8fCBpbnB1dC5zaWduYXR1cmVzO1xyXG4gIGlmIChvcHRzLm5vU29ydGluZykge1xyXG4gICAgdGhpcy5wdWJsaWNLZXlzID0gcHVia2V5cztcclxuICB9IGVsc2UgIHtcclxuICAgIHRoaXMucHVibGljS2V5cyA9IF8uc29ydEJ5KHB1YmtleXMsIGZ1bmN0aW9uKHB1YmxpY0tleSkgeyByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKTsgfSk7XHJcbiAgfVxyXG4gIHRoaXMucmVkZWVtU2NyaXB0ID0gU2NyaXB0LmJ1aWxkTXVsdGlzaWdPdXQodGhpcy5wdWJsaWNLZXlzLCB0aHJlc2hvbGQsIG9wdHMpO1xyXG4gIHZhciBuZXN0ZWQgPSBTY3JpcHQuYnVpbGRXaXRuZXNzTXVsdGlzaWdPdXRGcm9tU2NyaXB0KHRoaXMucmVkZWVtU2NyaXB0KTtcclxuICBpZiAobmVzdGVkLmVxdWFscyh0aGlzLm91dHB1dC5zY3JpcHQpKSB7XHJcbiAgICB0aGlzLm5lc3RlZFdpdG5lc3MgPSBmYWxzZTtcclxuICAgIHRoaXMudHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaDtcclxuICB9IGVsc2UgaWYgKFNjcmlwdC5idWlsZFNjcmlwdEhhc2hPdXQobmVzdGVkKS5lcXVhbHModGhpcy5vdXRwdXQuc2NyaXB0KSkge1xyXG4gICAgdGhpcy5uZXN0ZWRXaXRuZXNzID0gdHJ1ZTtcclxuICAgIHRoaXMudHlwZSA9IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xyXG4gIH0gZWxzZSBpZiAoU2NyaXB0LmJ1aWxkU2NyaXB0SGFzaE91dCh0aGlzLnJlZGVlbVNjcmlwdCkuZXF1YWxzKHRoaXMub3V0cHV0LnNjcmlwdCkpIHtcclxuICAgIHRoaXMubmVzdGVkV2l0bmVzcyA9IGZhbHNlO1xyXG4gICAgdGhpcy50eXBlID0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgcHVibGljIGtleXMgZG9uXFwndCBoYXNoIHRvIHRoZSBwcm92aWRlZCBvdXRwdXQnKTtcclxuICB9XHJcblxyXG4gIGlmICh0aGlzLm5lc3RlZFdpdG5lc3MpIHtcclxuICAgIHZhciBzY3JpcHRTaWcgPSBuZXcgU2NyaXB0KCk7XHJcbiAgICBzY3JpcHRTaWcuYWRkKG5lc3RlZC50b0J1ZmZlcigpKTtcclxuICAgIHRoaXMuc2V0U2NyaXB0KHNjcmlwdFNpZyk7XHJcbiAgfVxyXG5cclxuICB0aGlzLnB1YmxpY0tleUluZGV4ID0ge307XHJcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucHVibGljS2V5cy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5c1tpbmRleF07XHJcbiAgICB0aGlzLnB1YmxpY0tleUluZGV4W3B1YmxpY0tleS50b1N0cmluZygpXSA9IGluZGV4O1xyXG4gIH1cclxuICB0aGlzLnRocmVzaG9sZCA9IHRocmVzaG9sZDtcclxuICAvLyBFbXB0eSBhcnJheSBvZiBzaWduYXR1cmVzXHJcbiAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcyA/IHRoaXMuX2Rlc2VyaWFsaXplU2lnbmF0dXJlcyhzaWduYXR1cmVzKSA6IG5ldyBBcnJheSh0aGlzLnB1YmxpY0tleXMubGVuZ3RoKTtcclxufVxyXG5pbmhlcml0cyhNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dCwgSW5wdXQpO1xyXG5cclxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIG9iaiA9IElucHV0LnByb3RvdHlwZS50b09iamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIG9iai50aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZDtcclxuICBvYmoucHVibGljS2V5cyA9IHRoaXMucHVibGljS2V5cy5tYXAoZnVuY3Rpb24ocHVibGljS2V5KSB7IHJldHVybiBwdWJsaWNLZXkudG9TdHJpbmcoKTsgfSk7XHJcbiAgb2JqLnNpZ25hdHVyZXMgPSB0aGlzLl9zZXJpYWxpemVTaWduYXR1cmVzKCk7XHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5fZGVzZXJpYWxpemVTaWduYXR1cmVzID0gZnVuY3Rpb24oc2lnbmF0dXJlcykge1xyXG4gIHJldHVybiBzaWduYXR1cmVzLm1hcChmdW5jdGlvbihzaWduYXR1cmUpIHtcclxuICAgIGlmICghc2lnbmF0dXJlKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuX3NlcmlhbGl6ZVNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5zaWduYXR1cmVzLm1hcChmdW5jdGlvbihzaWduYXR1cmUpIHtcclxuICAgIGlmICghc2lnbmF0dXJlKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2lnbmF0dXJlLnRvT2JqZWN0KCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuZ2V0U2NyaXB0Q29kZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciB3cml0ZXIgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XHJcbiAgaWYgKCF0aGlzLnJlZGVlbVNjcmlwdC5oYXNDb2Rlc2VwYXJhdG9ycygpKSB7XHJcbiAgICB2YXIgcmVkZWVtU2NyaXB0QnVmZmVyID0gdGhpcy5yZWRlZW1TY3JpcHQudG9CdWZmZXIoKTtcclxuICAgIHdyaXRlci53cml0ZVZhcmludE51bShyZWRlZW1TY3JpcHRCdWZmZXIubGVuZ3RoKTtcclxuICAgIHdyaXRlci53cml0ZShyZWRlZW1TY3JpcHRCdWZmZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0BUT0RPJyk7XHJcbiAgfVxyXG4gIHJldHVybiB3cml0ZXIudG9CdWZmZXIoKTtcclxufTtcclxuXHJcbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5nZXRTaWdoYXNoID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlKSB7XHJcbiAgdmFyIGhhc2g7XHJcbiAgaWYgKHRoaXMubmVzdGVkV2l0bmVzcyB8fCB0aGlzLnR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xyXG4gICAgdmFyIHNjcmlwdENvZGUgPSB0aGlzLmdldFNjcmlwdENvZGUoKTtcclxuICAgIHZhciBzYXRvc2hpc0J1ZmZlciA9IHRoaXMuZ2V0U2F0b3NoaXNCdWZmZXIoKTtcclxuICAgIGhhc2ggPSBTaWdoYXNoV2l0bmVzcy5zaWdoYXNoKHRyYW5zYWN0aW9uLCBzaWd0eXBlLCBpbmRleCwgc2NyaXB0Q29kZSwgc2F0b3NoaXNCdWZmZXIpO1xyXG4gIH0gZWxzZSAge1xyXG4gICAgaGFzaCA9IFNpZ2hhc2guc2lnaGFzaCh0cmFuc2FjdGlvbiwgc2lndHlwZSwgaW5kZXgsIHRoaXMucmVkZWVtU2NyaXB0KTtcclxuICB9XHJcbiAgcmV0dXJuIGhhc2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHNpZ25hdHVyZXMgZm9yIHRoaXMgaW5wdXRcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXHJcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB3aXRoIHdoaWNoIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgaW5wdXQgaW4gdGhlIHRyYW5zYWN0aW9uIGlucHV0IHZlY3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHNpZ25hdHVyZSwgZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoRGF0YSAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIERFUFJFQ0FURUQgLSBtZXRob2QgdXNlZCB0byBzaWduIC0gJ2VjZHNhJyBvciAnc2Nobm9ycidcclxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgLSB1bnVzZWQgZm9yIHRoaXMgaW5wdXQgdHlwZVxyXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XHJcbiAqL1xyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuZ2V0U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBpbmRleCwgc2lndHlwZSwgaGFzaERhdGEsIHNpZ25pbmdNZXRob2QsIG1lcmtsZVJvb3QpIHtcclxuICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQpO1xyXG4gIHNpZ3R5cGUgPSBzaWd0eXBlIHx8IFNpZ25hdHVyZS5TSUdIQVNIX0FMTDtcclxuICBzaWduaW5nTWV0aG9kID0gc2lnbmluZ01ldGhvZCB8fCAnZWNkc2EnOyAvLyB1bnVzZWQuIEtlZXBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgbGlic1xyXG5cclxuICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgZm9yIChjb25zdCBwdWJsaWNLZXkgb2YgdGhpcy5wdWJsaWNLZXlzKSB7XHJcbiAgICBpZiAocHVibGljS2V5LnRvU3RyaW5nKCkgPT09IHByaXZhdGVLZXkucHVibGljS2V5LnRvU3RyaW5nKCkpIHtcclxuICAgICAgdmFyIHNpZ25hdHVyZTtcclxuICAgICAgaWYgKHRoaXMubmVzdGVkV2l0bmVzcyB8fCB0aGlzLnR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xyXG4gICAgICAgIHZhciBzY3JpcHRDb2RlID0gdGhpcy5nZXRTY3JpcHRDb2RlKCk7XHJcbiAgICAgICAgdmFyIHNhdG9zaGlzQnVmZmVyID0gdGhpcy5nZXRTYXRvc2hpc0J1ZmZlcigpO1xyXG4gICAgICAgIHNpZ25hdHVyZSA9IFNpZ2hhc2hXaXRuZXNzLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XHJcbiAgICAgIH0gZWxzZSAge1xyXG4gICAgICAgIHNpZ25hdHVyZSA9IFNpZ2hhc2guc2lnbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgc2lndHlwZSwgaW5kZXgsIHRoaXMucmVkZWVtU2NyaXB0KTtcclxuICAgICAgfVxyXG4gICAgICByZXN1bHRzLnB1c2gobmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcclxuICAgICAgICBwdWJsaWNLZXk6IHByaXZhdGVLZXkucHVibGljS2V5LFxyXG4gICAgICAgIHByZXZUeElkOiB0aGlzLnByZXZUeElkLFxyXG4gICAgICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxyXG4gICAgICAgIGlucHV0SW5kZXg6IGluZGV4LFxyXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxyXG4gICAgICAgIHNpZ3R5cGU6IHNpZ3R5cGVcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0cztcclxufTtcclxuXHJcbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5hZGRTaWduYXR1cmUgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSB7XHJcbiAgJC5jaGVja1N0YXRlKCF0aGlzLmlzRnVsbHlTaWduZWQoKSwgJ0FsbCBuZWVkZWQgc2lnbmF0dXJlcyBoYXZlIGFscmVhZHkgYmVlbiBhZGRlZCcpO1xyXG4gICQuY2hlY2tBcmd1bWVudCh0aGlzLnB1YmxpY0tleUluZGV4W3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKV0gIT0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgJ1NpZ25hdHVyZSBoYXMgbm8gbWF0Y2hpbmcgcHVibGljIGtleScpO1xyXG4gICQuY2hlY2tTdGF0ZSh0aGlzLmlzVmFsaWRTaWduYXR1cmUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCksICdJbnZhbGlkIFNpZ25hdHVyZSEnKTtcclxuICB0aGlzLnNpZ25hdHVyZXNbdGhpcy5wdWJsaWNLZXlJbmRleFtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCldXSA9IHNpZ25hdHVyZTtcclxuICB0aGlzLl91cGRhdGVTY3JpcHQoKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5fdXBkYXRlU2NyaXB0ID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKHRoaXMubmVzdGVkV2l0bmVzcyB8fCB0aGlzLnR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xyXG4gICAgdmFyIHN0YWNrID0gW1xyXG4gICAgICBCdWZmZXIuYWxsb2MoMCksXHJcbiAgICBdO1xyXG4gICAgdmFyIHNpZ25hdHVyZXMgPSB0aGlzLl9jcmVhdGVTaWduYXR1cmVzKCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ25hdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc3RhY2sucHVzaChzaWduYXR1cmVzW2ldKTtcclxuICAgIH1cclxuICAgIHN0YWNrLnB1c2godGhpcy5yZWRlZW1TY3JpcHQudG9CdWZmZXIoKSk7XHJcbiAgICB0aGlzLnNldFdpdG5lc3NlcyhzdGFjayk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBzY3JpcHRTaWcgPSBTY3JpcHQuYnVpbGRQMlNITXVsdGlzaWdJbihcclxuICAgICAgdGhpcy5wdWJsaWNLZXlzLFxyXG4gICAgICB0aGlzLnRocmVzaG9sZCxcclxuICAgICAgdGhpcy5fY3JlYXRlU2lnbmF0dXJlcygpLFxyXG4gICAgICB7IGNhY2hlZE11bHRpc2lnOiB0aGlzLnJlZGVlbVNjcmlwdCB9XHJcbiAgICApO1xyXG4gICAgdGhpcy5zZXRTY3JpcHQoc2NyaXB0U2lnKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuX2NyZWF0ZVNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5zaWduYXR1cmVzXHJcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKHNpZ25hdHVyZSkgeyByZXR1cm4gc2lnbmF0dXJlICE9IG51bGw7IH0pXHJcbiAgICAubWFwKGZ1bmN0aW9uKHNpZ25hdHVyZSkge1xyXG4gICAgICByZXR1cm4gQnVmZmVyVXRpbC5jb25jYXQoW1xyXG4gICAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9ERVIoKSxcclxuICAgICAgICBCdWZmZXJVdGlsLmludGVnZXJBc1NpbmdsZUJ5dGVCdWZmZXIoc2lnbmF0dXJlLnNpZ3R5cGUpXHJcbiAgICAgIF0pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5zaWduYXR1cmVzID0gbmV3IEFycmF5KHRoaXMucHVibGljS2V5cy5sZW5ndGgpO1xyXG4gIHRoaXMuX3VwZGF0ZVNjcmlwdCgpO1xyXG59O1xyXG5cclxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLmlzRnVsbHlTaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5jb3VudFNpZ25hdHVyZXMoKSA9PT0gdGhpcy50aHJlc2hvbGQ7XHJcbn07XHJcblxyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuY291bnRNaXNzaW5nU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLnRocmVzaG9sZCAtIHRoaXMuY291bnRTaWduYXR1cmVzKCk7XHJcbn07XHJcblxyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuY291bnRTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBzaWduYXR1cmUpIHtcclxuICAgIHJldHVybiBzdW0gKyAoISFzaWduYXR1cmUpO1xyXG4gIH0sIDApO1xyXG59O1xyXG5cclxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLnB1YmxpY0tleXNXaXRob3V0U2lnbmF0dXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMucHVibGljS2V5cy5maWx0ZXIoKHB1YmxpY0tleSkgPT4ge1xyXG4gICAgcmV0dXJuICEodGhpcy5zaWduYXR1cmVzW3RoaXMucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldXSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcclxuICBzaWduaW5nTWV0aG9kID0gc2lnbmluZ01ldGhvZCB8fCAnZWNkc2EnOyAvLyB1bnVzZWQuIEtlZXBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgbGlic1xyXG4gIGlmICh0aGlzLm5lc3RlZFdpdG5lc3MgfHwgdGhpcy50eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2gpIHtcclxuICAgIHNpZ25hdHVyZS5zaWduYXR1cmUubmhhc2h0eXBlID0gc2lnbmF0dXJlLnNpZ3R5cGU7XHJcbiAgICB2YXIgc2NyaXB0Q29kZSA9IHRoaXMuZ2V0U2NyaXB0Q29kZSgpO1xyXG4gICAgdmFyIHNhdG9zaGlzQnVmZmVyID0gdGhpcy5nZXRTYXRvc2hpc0J1ZmZlcigpO1xyXG4gICAgcmV0dXJuIFNpZ2hhc2hXaXRuZXNzLnZlcmlmeShcclxuICAgICAgdHJhbnNhY3Rpb24sXHJcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXHJcbiAgICAgIHNpZ25hdHVyZS5wdWJsaWNLZXksXHJcbiAgICAgIHNpZ25hdHVyZS5pbnB1dEluZGV4LFxyXG4gICAgICBzY3JpcHRDb2RlLFxyXG4gICAgICBzYXRvc2hpc0J1ZmZlclxyXG4gICAgKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gRklYTUU6IFJlZmFjdG9yIHNpZ25hdHVyZSBzbyB0aGlzIGlzIG5vdCBuZWNlc3NhcnlcclxuICAgIHNpZ25hdHVyZS5zaWduYXR1cmUubmhhc2h0eXBlID0gc2lnbmF0dXJlLnNpZ3R5cGU7XHJcbiAgICByZXR1cm4gU2lnaGFzaC52ZXJpZnkoXHJcbiAgICAgIHRyYW5zYWN0aW9uLFxyXG4gICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxyXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxyXG4gICAgICBzaWduYXR1cmUuaW5wdXRJbmRleCxcclxuICAgICAgdGhpcy5yZWRlZW1TY3JpcHRcclxuICAgICk7XHJcbiAgfVxyXG59O1xyXG5cclxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQuTUFYX09QQ09ERVNfU0laRSA9IDg7IC8vIHNlcmlhbGl6ZWQgc2l6ZSAoPD0zKSArIDAgLi4gT1BfUFVTSERBVEF4IE4gLi4gTSBPUF9DSEVDS01VTFRJU0lHXHJcbk11bHRpU2lnU2NyaXB0SGFzaElucHV0Lk1BWF9TSUdOQVRVUkVfU0laRSA9IDc0OyAvLyBzaXplICgxKSArIERFUiAoPD03MikgKyBzaWdoYXNoICgxKVxyXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5NQVhfUFVCS0VZX1NJWkUgPSAzNDsgLy8gc2l6ZSAoMSkgKyBERVIgKDw9MzMpXHJcbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LlJFREVFTV9TQ1JJUFRfU0laRSA9IDM0OyAvLyBPUF8wICgxKSArIHNjcmlwdEhhc2ggKDEgKyAzMilcclxuXHJcbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgbGV0IHJlc3VsdCA9IHRoaXMuX2dldEJhc2VTaXplKCk7XHJcbiAgY29uc3QgV0lUTkVTU19ESVNDT1VOVCA9IDQ7XHJcbiAgY29uc3Qgd2l0bmVzc1NpemUgPSBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5NQVhfT1BDT0RFU19TSVpFICtcclxuICAgIHRoaXMudGhyZXNob2xkICogTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQuTUFYX1NJR05BVFVSRV9TSVpFICtcclxuICAgIHRoaXMucHVibGljS2V5cy5sZW5ndGggKiBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5NQVhfUFVCS0VZX1NJWkU7XHJcbiAgaWYgKHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XHJcbiAgICByZXN1bHQgKz0gd2l0bmVzc1NpemUgLyBXSVRORVNTX0RJU0NPVU5UO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5uZXN0ZWRXaXRuZXNzKSB7XHJcbiAgICByZXN1bHQgKz0gd2l0bmVzc1NpemUgLyBXSVRORVNTX0RJU0NPVU5UICsgTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQuUkVERUVNX1NDUklQVF9TSVpFO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXN1bHQgKz0gd2l0bmVzc1NpemU7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpU2lnU2NyaXB0SGFzaElucHV0O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/input/multisigscripthash.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/input/publickey.js":
/*!*********************************************************!*\
  !*** ../bitcore-lib/lib/transaction/input/publickey.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar inherits = __webpack_require__(/*! inherits */ \"../bitcore-lib/node_modules/inherits/inherits.js\");\r\n\r\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\n\r\nvar Input = __webpack_require__(/*! ./input */ \"../bitcore-lib/lib/transaction/input/input.js\");\r\nvar Output = __webpack_require__(/*! ../output */ \"../bitcore-lib/lib/transaction/output.js\");\r\nvar Sighash = __webpack_require__(/*! ../sighash */ \"../bitcore-lib/lib/transaction/sighash.js\");\r\nvar Script = __webpack_require__(/*! ../../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"../bitcore-lib/lib/transaction/signature.js\");\r\n\r\n/**\r\n * Represents a special kind of input of PayToPublicKey kind.\r\n * @constructor\r\n */\r\nfunction PublicKeyInput() {\r\n  Input.apply(this, arguments);\r\n}\r\ninherits(PublicKeyInput, Input);\r\n\r\n/**\r\n * @param {Transaction} transaction - the transaction to be signed\r\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\r\n * @param {number} index - the index of the input in the transaction input vector\r\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\r\n * @param {Buffer} hashData - unused for this input type \r\n * @param {String} signingMethod DEPRECATED - method used to sign input - 'ecdsa' or 'schnorr'\r\n * @return {Array} of objects that can be\r\n */\r\nPublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\r\n  $.checkState(this.output instanceof Output);\r\n  sigtype = sigtype || Signature.SIGHASH_ALL;\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n  var publicKey = privateKey.toPublicKey();\r\n  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\r\n    return [new TransactionSignature({\r\n      publicKey: publicKey,\r\n      prevTxId: this.prevTxId,\r\n      outputIndex: this.outputIndex,\r\n      inputIndex: index,\r\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\r\n      sigtype: sigtype\r\n    })];\r\n  }\r\n  return [];\r\n};\r\n\r\n/**\r\n * Add the provided signature\r\n *\r\n * @param {Object} signature\r\n * @param {PublicKey} signature.publicKey\r\n * @param {Signature} signature.signature\r\n * @param {number=} signature.sigtype\r\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\r\n * @return {PublicKeyInput} this, for chaining\r\n */\r\nPublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {\r\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\r\n  this.setScript(Script.buildPublicKeyIn(\r\n    signature.signature.toDER(),\r\n    signature.sigtype\r\n  ));\r\n  return this;\r\n};\r\n\r\n/**\r\n * Clear the input's signature\r\n * @return {PublicKeyHashInput} this, for chaining\r\n */\r\nPublicKeyInput.prototype.clearSignatures = function() {\r\n  this.setScript(Script.empty());\r\n  return this;\r\n};\r\n\r\n/**\r\n * Query whether the input is signed\r\n * @return {boolean}\r\n */\r\nPublicKeyInput.prototype.isFullySigned = function() {\r\n  return this.script.isPublicKeyIn();\r\n};\r\n\r\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\r\n\r\nPublicKeyInput.prototype._estimateSize = function() {\r\n  return this._getBaseSize() + PublicKeyInput.SCRIPT_MAX_SIZE;\r\n};\r\n\r\nmodule.exports = PublicKeyInput;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3B1YmxpY2tleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLDBFQUEwQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBbUI7QUFDNUM7QUFDQSxZQUFZLG1CQUFPLENBQUMsOERBQVM7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDJEQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyw2REFBWTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsd0RBQWM7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQXdCO0FBQ2hELDJCQUEyQixtQkFBTyxDQUFDLGlFQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvcHVibGlja2V5LmpzP2Q4OWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcclxuXHJcbnZhciAkID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9idWZmZXInKTtcclxuXHJcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcclxudmFyIE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpO1xyXG52YXIgU2lnaGFzaCA9IHJlcXVpcmUoJy4uL3NpZ2hhc2gnKTtcclxudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xyXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xyXG52YXIgVHJhbnNhY3Rpb25TaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc3BlY2lhbCBraW5kIG9mIGlucHV0IG9mIFBheVRvUHVibGljS2V5IGtpbmQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gUHVibGljS2V5SW5wdXQoKSB7XHJcbiAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5pbmhlcml0cyhQdWJsaWNLZXlJbnB1dCwgSW5wdXQpO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIC0gdGhlIHRyYW5zYWN0aW9uIHRvIGJlIHNpZ25lZFxyXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXkgLSB0aGUgcHJpdmF0ZSBrZXkgd2l0aCB3aGljaCB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGlucHV0IGluIHRoZSB0cmFuc2FjdGlvbiBpbnB1dCB2ZWN0b3JcclxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ3R5cGUgLSB0aGUgdHlwZSBvZiBzaWduYXR1cmUsIGRlZmF1bHRzIHRvIFNpZ25hdHVyZS5TSUdIQVNIX0FMTFxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaERhdGEgLSB1bnVzZWQgZm9yIHRoaXMgaW5wdXQgdHlwZSBcclxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25pbmdNZXRob2QgREVQUkVDQVRFRCAtIG1ldGhvZCB1c2VkIHRvIHNpZ24gaW5wdXQgLSAnZWNkc2EnIG9yICdzY2hub3JyJ1xyXG4gKiBAcmV0dXJuIHtBcnJheX0gb2Ygb2JqZWN0cyB0aGF0IGNhbiBiZVxyXG4gKi9cclxuUHVibGljS2V5SW5wdXQucHJvdG90eXBlLmdldFNpZ25hdHVyZXMgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUsIGhhc2hEYXRhLCBzaWduaW5nTWV0aG9kKSB7XHJcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgT3V0cHV0KTtcclxuICBzaWd0eXBlID0gc2lndHlwZSB8fCBTaWduYXR1cmUuU0lHSEFTSF9BTEw7XHJcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcclxuICB2YXIgcHVibGljS2V5ID0gcHJpdmF0ZUtleS50b1B1YmxpY0tleSgpO1xyXG4gIGlmIChwdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gdGhpcy5vdXRwdXQuc2NyaXB0LmdldFB1YmxpY0tleSgpLnRvU3RyaW5nKCdoZXgnKSkge1xyXG4gICAgcmV0dXJuIFtuZXcgVHJhbnNhY3Rpb25TaWduYXR1cmUoe1xyXG4gICAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcclxuICAgICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQsXHJcbiAgICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxyXG4gICAgICBpbnB1dEluZGV4OiBpbmRleCxcclxuICAgICAgc2lnbmF0dXJlOiBTaWdoYXNoLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCB0aGlzLm91dHB1dC5zY3JpcHQpLFxyXG4gICAgICBzaWd0eXBlOiBzaWd0eXBlXHJcbiAgICB9KV07XHJcbiAgfVxyXG4gIHJldHVybiBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgdGhlIHByb3ZpZGVkIHNpZ25hdHVyZVxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBzaWduYXR1cmUucHVibGljS2V5XHJcbiAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWduYXR1cmUuc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2lnbmF0dXJlLnNpZ3R5cGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25pbmdNZXRob2QgLSBtZXRob2QgdXNlZCB0byBzaWduIC0gJ2VjZHNhJyBvciAnc2Nobm9ycicgKGZ1dHVyZSBzaWduaW5nIG1ldGhvZClcclxuICogQHJldHVybiB7UHVibGljS2V5SW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xyXG4gKi9cclxuUHVibGljS2V5SW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcclxuICAkLmNoZWNrU3RhdGUodGhpcy5pc1ZhbGlkU2lnbmF0dXJlKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpLCAnU2lnbmF0dXJlIGlzIGludmFsaWQnKTtcclxuICB0aGlzLnNldFNjcmlwdChTY3JpcHQuYnVpbGRQdWJsaWNLZXlJbihcclxuICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9ERVIoKSxcclxuICAgIHNpZ25hdHVyZS5zaWd0eXBlXHJcbiAgKSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xlYXIgdGhlIGlucHV0J3Mgc2lnbmF0dXJlXHJcbiAqIEByZXR1cm4ge1B1YmxpY0tleUhhc2hJbnB1dH0gdGhpcywgZm9yIGNoYWluaW5nXHJcbiAqL1xyXG5QdWJsaWNLZXlJbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5zZXRTY3JpcHQoU2NyaXB0LmVtcHR5KCkpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFF1ZXJ5IHdoZXRoZXIgdGhlIGlucHV0IGlzIHNpZ25lZFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuUHVibGljS2V5SW5wdXQucHJvdG90eXBlLmlzRnVsbHlTaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5zY3JpcHQuaXNQdWJsaWNLZXlJbigpO1xyXG59O1xyXG5cclxuUHVibGljS2V5SW5wdXQuU0NSSVBUX01BWF9TSVpFID0gNzM7IC8vIHNpZ3NpemUgKDEgKyA3MilcclxuXHJcblB1YmxpY0tleUlucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMuX2dldEJhc2VTaXplKCkgKyBQdWJsaWNLZXlJbnB1dC5TQ1JJUFRfTUFYX1NJWkU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFB1YmxpY0tleUlucHV0O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/input/publickey.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/input/publickeyhash.js":
/*!*************************************************************!*\
  !*** ../bitcore-lib/lib/transaction/input/publickeyhash.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar inherits = __webpack_require__(/*! inherits */ \"../bitcore-lib/node_modules/inherits/inherits.js\");\r\n\r\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\n\r\nvar Address = __webpack_require__(/*! ../../address */ \"../bitcore-lib/lib/address.js\");\r\nvar Hash = __webpack_require__(/*! ../../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar Input = __webpack_require__(/*! ./input */ \"../bitcore-lib/lib/transaction/input/input.js\");\r\nvar Output = __webpack_require__(/*! ../output */ \"../bitcore-lib/lib/transaction/output.js\");\r\nvar Sighash = __webpack_require__(/*! ../sighash */ \"../bitcore-lib/lib/transaction/sighash.js\");\r\nvar SighashWitness = __webpack_require__(/*! ../sighashwitness */ \"../bitcore-lib/lib/transaction/sighashwitness.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar Script = __webpack_require__(/*! ../../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"../bitcore-lib/lib/transaction/signature.js\");\r\n\r\n/**\r\n * Represents a special kind of input of PayToPublicKeyHash kind.\r\n * @constructor\r\n */\r\nfunction PublicKeyHashInput() {\r\n  Input.apply(this, arguments);\r\n}\r\ninherits(PublicKeyHashInput, Input);\r\n\r\nPublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {\r\n  if (!this.redeemScript) {\r\n    var redeemScript = Script.buildWitnessV0Out(publicKey);\r\n    if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {\r\n      var scriptSig = new Script();\r\n      scriptSig.add(redeemScript.toBuffer());\r\n      this.setScript(scriptSig);\r\n      this.redeemScript = redeemScript;\r\n    }\r\n  }\r\n  return this.redeemScript;\r\n};\r\n\r\nPublicKeyHashInput.prototype.getScriptCode = function(publicKey) {\r\n  var writer = new BufferWriter();\r\n  var script;\r\n  if (this.output.script.isScriptHashOut()) {\r\n    script = this.getRedeemScript(publicKey);\r\n  } else {\r\n    script = this.output.script;\r\n  }\r\n  var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();\r\n  writer.writeVarintNum(scriptBuffer.length);\r\n  writer.write(scriptBuffer);\r\n  return writer.toBuffer();\r\n};\r\n\r\nPublicKeyHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\r\n  var scriptCode = this.getScriptCode(privateKey);\r\n  var satoshisBuffer = this.getSatoshisBuffer();\r\n  return SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\r\n};\r\n\r\n/**\r\n * @param {Transaction} transaction - the transaction to be signed\r\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\r\n * @param {number} index - the index of the input in the transaction input vector\r\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\r\n * @param {Buffer} hashData - the precalculated hash of the public key associated with the privateKey provided\r\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\r\n * @param {Buffer} merkleRoot - unused for this input type\r\n * @return {Array<TransactionSignature>}\r\n */\r\nPublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\r\n  $.checkState(this.output instanceof Output);\r\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\r\n  sigtype = sigtype || Signature.SIGHASH_ALL;\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n\r\n  var script;\r\n  if (this.output.script.isScriptHashOut()) {\r\n    script = this.getRedeemScript(privateKey.publicKey);\r\n  } else {\r\n    script = this.output.script;\r\n  }\r\n\r\n  if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {\r\n    var signature;\r\n    if (script.isWitnessPublicKeyHashOut()) {\r\n      var satoshisBuffer = this.getSatoshisBuffer();\r\n      var scriptCode = this.getScriptCode(privateKey.publicKey);\r\n      signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer);\r\n    } else {\r\n      signature = Sighash.sign(transaction, privateKey, sigtype, index, this.output.script);\r\n    }\r\n\r\n    return [new TransactionSignature({\r\n      publicKey: privateKey.publicKey,\r\n      prevTxId: this.prevTxId,\r\n      outputIndex: this.outputIndex,\r\n      inputIndex: index,\r\n      signature: signature,\r\n      sigtype: sigtype\r\n    })];\r\n  }\r\n  return [];\r\n};\r\n/* jshint maxparams: 3 */\r\n\r\n/**\r\n * Add the provided signature\r\n *\r\n * @param {Transaction} transaction\r\n * @param {Object} signature\r\n * @param {PublicKey} signature.publicKey\r\n * @param {Signature} signature.signature\r\n * @param {number=} signature.sigtype\r\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\r\n * @return {PublicKeyHashInput} this, for chaining\r\n */\r\nPublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\r\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\r\n\r\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\r\n    this.setWitnesses([\r\n      BufferUtil.concat([\r\n        signature.signature.toDER(),\r\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\r\n      ]),\r\n      signature.publicKey.toBuffer()\r\n    ]);\r\n  } else {\r\n    this.setScript(Script.buildPublicKeyHashIn(\r\n      signature.publicKey,\r\n      signature.signature.toDER(),\r\n      signature.sigtype\r\n    ));\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Clear the input's signature\r\n * @return {PublicKeyHashInput} this, for chaining\r\n */\r\nPublicKeyHashInput.prototype.clearSignatures = function() {\r\n  this.setScript(Script.empty());\r\n  this.setWitnesses([]);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Query whether the input is signed\r\n * @return {boolean}\r\n */\r\nPublicKeyHashInput.prototype.isFullySigned = function() {\r\n  return this.script.isPublicKeyHashIn() || this.hasWitnesses();\r\n};\r\n\r\nPublicKeyHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\r\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\r\n  // FIXME: Refactor signature so this is not necessary\r\n  signature.signature.nhashtype = signature.sigtype;\r\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\r\n    var scriptCode = this.getScriptCode();\r\n    var satoshisBuffer = this.getSatoshisBuffer();\r\n    return SighashWitness.verify(\r\n      transaction,\r\n      signature.signature,\r\n      signature.publicKey,\r\n      signature.inputIndex,\r\n      scriptCode,\r\n      satoshisBuffer\r\n    );\r\n  } else {\r\n    return Sighash.verify(\r\n      transaction,\r\n      signature.signature,\r\n      signature.publicKey,\r\n      signature.inputIndex,\r\n      this.output.script\r\n    );\r\n  }\r\n};\r\n\r\n\r\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\r\nPublicKeyHashInput.REDEEM_SCRIPT_SIZE = 1 + 22; // len (1) OP_0 (1) pubkeyhash (1 + 20)\r\n\r\nPublicKeyHashInput.prototype._estimateSize = function() {\r\n  let result = this._getBaseSize();\r\n  result += 1; // script size\r\n  const WITNESS_DISCOUNT = 4;\r\n  const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\r\n  if (this.output.script.isWitnessPublicKeyHashOut()) {\r\n    result += witnessSize;\r\n  } else if (this.output.script.isScriptHashOut()) {\r\n    result += witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;\r\n  } else {\r\n    result += PublicKeyHashInput.SCRIPT_MAX_SIZE;\r\n  }\r\n  return result;\r\n};\r\n\r\nmodule.exports = PublicKeyHashInput;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3B1YmxpY2tleWhhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrRUFBVTtBQUNqQztBQUNBLFFBQVEsbUJBQU8sQ0FBQywwRUFBMEI7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsNERBQW1CO0FBQzVDO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLG9EQUFlO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyw0REFBbUI7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLDhEQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQywyREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsNkRBQVk7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsMkVBQW1CO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLGdGQUE2QjtBQUN4RCxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBbUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLHdEQUFjO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHNFQUF3QjtBQUNoRCwyQkFBMkIsbUJBQU8sQ0FBQyxpRUFBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3B1YmxpY2tleWhhc2guanM/ODcyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2J1ZmZlcicpO1xyXG5cclxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi8uLi9hZGRyZXNzJyk7XHJcbnZhciBIYXNoID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL2hhc2gnKTtcclxudmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xyXG52YXIgT3V0cHV0ID0gcmVxdWlyZSgnLi4vb3V0cHV0Jyk7XHJcbnZhciBTaWdoYXNoID0gcmVxdWlyZSgnLi4vc2lnaGFzaCcpO1xyXG52YXIgU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuLi9zaWdoYXNod2l0bmVzcycpO1xyXG52YXIgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XHJcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9idWZmZXInKTtcclxudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xyXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xyXG52YXIgVHJhbnNhY3Rpb25TaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc3BlY2lhbCBraW5kIG9mIGlucHV0IG9mIFBheVRvUHVibGljS2V5SGFzaCBraW5kLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIFB1YmxpY0tleUhhc2hJbnB1dCgpIHtcclxuICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbmluaGVyaXRzKFB1YmxpY0tleUhhc2hJbnB1dCwgSW5wdXQpO1xyXG5cclxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5nZXRSZWRlZW1TY3JpcHQgPSBmdW5jdGlvbihwdWJsaWNLZXkpIHtcclxuICBpZiAoIXRoaXMucmVkZWVtU2NyaXB0KSB7XHJcbiAgICB2YXIgcmVkZWVtU2NyaXB0ID0gU2NyaXB0LmJ1aWxkV2l0bmVzc1YwT3V0KHB1YmxpY0tleSk7XHJcbiAgICBpZiAoU2NyaXB0LmJ1aWxkU2NyaXB0SGFzaE91dChyZWRlZW1TY3JpcHQpLmVxdWFscyh0aGlzLm91dHB1dC5zY3JpcHQpKSB7XHJcbiAgICAgIHZhciBzY3JpcHRTaWcgPSBuZXcgU2NyaXB0KCk7XHJcbiAgICAgIHNjcmlwdFNpZy5hZGQocmVkZWVtU2NyaXB0LnRvQnVmZmVyKCkpO1xyXG4gICAgICB0aGlzLnNldFNjcmlwdChzY3JpcHRTaWcpO1xyXG4gICAgICB0aGlzLnJlZGVlbVNjcmlwdCA9IHJlZGVlbVNjcmlwdDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXMucmVkZWVtU2NyaXB0O1xyXG59O1xyXG5cclxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5nZXRTY3JpcHRDb2RlID0gZnVuY3Rpb24ocHVibGljS2V5KSB7XHJcbiAgdmFyIHdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICB2YXIgc2NyaXB0O1xyXG4gIGlmICh0aGlzLm91dHB1dC5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkpIHtcclxuICAgIHNjcmlwdCA9IHRoaXMuZ2V0UmVkZWVtU2NyaXB0KHB1YmxpY0tleSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNjcmlwdCA9IHRoaXMub3V0cHV0LnNjcmlwdDtcclxuICB9XHJcbiAgdmFyIHNjcmlwdEJ1ZmZlciA9IFNjcmlwdC5idWlsZFB1YmxpY0tleUhhc2hPdXQoc2NyaXB0LnRvQWRkcmVzcygpKS50b0J1ZmZlcigpO1xyXG4gIHdyaXRlci53cml0ZVZhcmludE51bShzY3JpcHRCdWZmZXIubGVuZ3RoKTtcclxuICB3cml0ZXIud3JpdGUoc2NyaXB0QnVmZmVyKTtcclxuICByZXR1cm4gd3JpdGVyLnRvQnVmZmVyKCk7XHJcbn07XHJcblxyXG5QdWJsaWNLZXlIYXNoSW5wdXQucHJvdG90eXBlLmdldFNpZ2hhc2ggPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUpIHtcclxuICB2YXIgc2NyaXB0Q29kZSA9IHRoaXMuZ2V0U2NyaXB0Q29kZShwcml2YXRlS2V5KTtcclxuICB2YXIgc2F0b3NoaXNCdWZmZXIgPSB0aGlzLmdldFNhdG9zaGlzQnVmZmVyKCk7XHJcbiAgcmV0dXJuIFNpZ2hhc2hXaXRuZXNzLnNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ3R5cGUsIGluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXHJcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB3aXRoIHdoaWNoIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgaW5wdXQgaW4gdGhlIHRyYW5zYWN0aW9uIGlucHV0IHZlY3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHNpZ25hdHVyZSwgZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoRGF0YSAtIHRoZSBwcmVjYWxjdWxhdGVkIGhhc2ggb2YgdGhlIHB1YmxpYyBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcml2YXRlS2V5IHByb3ZpZGVkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXJrbGVSb290IC0gdW51c2VkIGZvciB0aGlzIGlucHV0IHR5cGVcclxuICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxyXG4gKi9cclxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlLCBoYXNoRGF0YSwgc2lnbmluZ01ldGhvZCwgbWVya2xlUm9vdCkge1xyXG4gICQuY2hlY2tTdGF0ZSh0aGlzLm91dHB1dCBpbnN0YW5jZW9mIE91dHB1dCk7XHJcbiAgaGFzaERhdGEgPSBoYXNoRGF0YSB8fCBIYXNoLnNoYTI1NnJpcGVtZDE2MChwcml2YXRlS2V5LnB1YmxpY0tleS50b0J1ZmZlcigpKTtcclxuICBzaWd0eXBlID0gc2lndHlwZSB8fCBTaWduYXR1cmUuU0lHSEFTSF9BTEw7XHJcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcclxuXHJcbiAgdmFyIHNjcmlwdDtcclxuICBpZiAodGhpcy5vdXRwdXQuc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpKSB7XHJcbiAgICBzY3JpcHQgPSB0aGlzLmdldFJlZGVlbVNjcmlwdChwcml2YXRlS2V5LnB1YmxpY0tleSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNjcmlwdCA9IHRoaXMub3V0cHV0LnNjcmlwdDtcclxuICB9XHJcblxyXG4gIGlmIChzY3JpcHQgJiYgQnVmZmVyVXRpbC5lcXVhbHMoaGFzaERhdGEsIHNjcmlwdC5nZXRQdWJsaWNLZXlIYXNoKCkpKSB7XHJcbiAgICB2YXIgc2lnbmF0dXJlO1xyXG4gICAgaWYgKHNjcmlwdC5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkpIHtcclxuICAgICAgdmFyIHNhdG9zaGlzQnVmZmVyID0gdGhpcy5nZXRTYXRvc2hpc0J1ZmZlcigpO1xyXG4gICAgICB2YXIgc2NyaXB0Q29kZSA9IHRoaXMuZ2V0U2NyaXB0Q29kZShwcml2YXRlS2V5LnB1YmxpY0tleSk7XHJcbiAgICAgIHNpZ25hdHVyZSA9IFNpZ2hhc2hXaXRuZXNzLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzaWduYXR1cmUgPSBTaWdoYXNoLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCB0aGlzLm91dHB1dC5zY3JpcHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcclxuICAgICAgcHVibGljS2V5OiBwcml2YXRlS2V5LnB1YmxpY0tleSxcclxuICAgICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQsXHJcbiAgICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxyXG4gICAgICBpbnB1dEluZGV4OiBpbmRleCxcclxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXHJcbiAgICAgIHNpZ3R5cGU6IHNpZ3R5cGVcclxuICAgIH0pXTtcclxuICB9XHJcbiAgcmV0dXJuIFtdO1xyXG59O1xyXG4vKiBqc2hpbnQgbWF4cGFyYW1zOiAzICovXHJcblxyXG4vKipcclxuICogQWRkIHRoZSBwcm92aWRlZCBzaWduYXR1cmVcclxuICpcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IHNpZ25hdHVyZVxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gc2lnbmF0dXJlLnB1YmxpY0tleVxyXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlLnNpZ25hdHVyZVxyXG4gKiBAcGFyYW0ge251bWJlcj19IHNpZ25hdHVyZS5zaWd0eXBlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInIChmdXR1cmUgc2lnbmluZyBtZXRob2QpXHJcbiAqIEByZXR1cm4ge1B1YmxpY0tleUhhc2hJbnB1dH0gdGhpcywgZm9yIGNoYWluaW5nXHJcbiAqL1xyXG5QdWJsaWNLZXlIYXNoSW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcclxuICAkLmNoZWNrU3RhdGUodGhpcy5pc1ZhbGlkU2lnbmF0dXJlKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpLCAnU2lnbmF0dXJlIGlzIGludmFsaWQnKTtcclxuXHJcbiAgaWYgKHRoaXMub3V0cHV0LnNjcmlwdC5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkgfHwgdGhpcy5vdXRwdXQuc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpKSB7XHJcbiAgICB0aGlzLnNldFdpdG5lc3NlcyhbXHJcbiAgICAgIEJ1ZmZlclV0aWwuY29uY2F0KFtcclxuICAgICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLnRvREVSKCksXHJcbiAgICAgICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ25hdHVyZS5zaWd0eXBlKVxyXG4gICAgICBdKSxcclxuICAgICAgc2lnbmF0dXJlLnB1YmxpY0tleS50b0J1ZmZlcigpXHJcbiAgICBdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5zZXRTY3JpcHQoU2NyaXB0LmJ1aWxkUHVibGljS2V5SGFzaEluKFxyXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxyXG4gICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLnRvREVSKCksXHJcbiAgICAgIHNpZ25hdHVyZS5zaWd0eXBlXHJcbiAgICApKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xlYXIgdGhlIGlucHV0J3Mgc2lnbmF0dXJlXHJcbiAqIEByZXR1cm4ge1B1YmxpY0tleUhhc2hJbnB1dH0gdGhpcywgZm9yIGNoYWluaW5nXHJcbiAqL1xyXG5QdWJsaWNLZXlIYXNoSW5wdXQucHJvdG90eXBlLmNsZWFyU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuc2V0U2NyaXB0KFNjcmlwdC5lbXB0eSgpKTtcclxuICB0aGlzLnNldFdpdG5lc3NlcyhbXSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUXVlcnkgd2hldGhlciB0aGUgaW5wdXQgaXMgc2lnbmVkXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5QdWJsaWNLZXlIYXNoSW5wdXQucHJvdG90eXBlLmlzRnVsbHlTaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5zY3JpcHQuaXNQdWJsaWNLZXlIYXNoSW4oKSB8fCB0aGlzLmhhc1dpdG5lc3NlcygpO1xyXG59O1xyXG5cclxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xyXG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXHJcbiAgLy8gRklYTUU6IFJlZmFjdG9yIHNpZ25hdHVyZSBzbyB0aGlzIGlzIG5vdCBuZWNlc3NhcnlcclxuICBzaWduYXR1cmUuc2lnbmF0dXJlLm5oYXNodHlwZSA9IHNpZ25hdHVyZS5zaWd0eXBlO1xyXG4gIGlmICh0aGlzLm91dHB1dC5zY3JpcHQuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCgpIHx8IHRoaXMub3V0cHV0LnNjcmlwdC5pc1NjcmlwdEhhc2hPdXQoKSkge1xyXG4gICAgdmFyIHNjcmlwdENvZGUgPSB0aGlzLmdldFNjcmlwdENvZGUoKTtcclxuICAgIHZhciBzYXRvc2hpc0J1ZmZlciA9IHRoaXMuZ2V0U2F0b3NoaXNCdWZmZXIoKTtcclxuICAgIHJldHVybiBTaWdoYXNoV2l0bmVzcy52ZXJpZnkoXHJcbiAgICAgIHRyYW5zYWN0aW9uLFxyXG4gICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxyXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxyXG4gICAgICBzaWduYXR1cmUuaW5wdXRJbmRleCxcclxuICAgICAgc2NyaXB0Q29kZSxcclxuICAgICAgc2F0b3NoaXNCdWZmZXJcclxuICAgICk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBTaWdoYXNoLnZlcmlmeShcclxuICAgICAgdHJhbnNhY3Rpb24sXHJcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXHJcbiAgICAgIHNpZ25hdHVyZS5wdWJsaWNLZXksXHJcbiAgICAgIHNpZ25hdHVyZS5pbnB1dEluZGV4LFxyXG4gICAgICB0aGlzLm91dHB1dC5zY3JpcHRcclxuICAgICk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcblB1YmxpY0tleUhhc2hJbnB1dC5TQ1JJUFRfTUFYX1NJWkUgPSA3MyArIDM0OyAvLyBzaWdzaXplICgxICsgNzIpICsgcHVia2V5ICgxICsgMzMpXHJcblB1YmxpY0tleUhhc2hJbnB1dC5SRURFRU1fU0NSSVBUX1NJWkUgPSAxICsgMjI7IC8vIGxlbiAoMSkgT1BfMCAoMSkgcHVia2V5aGFzaCAoMSArIDIwKVxyXG5cclxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgbGV0IHJlc3VsdCA9IHRoaXMuX2dldEJhc2VTaXplKCk7XHJcbiAgcmVzdWx0ICs9IDE7IC8vIHNjcmlwdCBzaXplXHJcbiAgY29uc3QgV0lUTkVTU19ESVNDT1VOVCA9IDQ7XHJcbiAgY29uc3Qgd2l0bmVzc1NpemUgPSBQdWJsaWNLZXlIYXNoSW5wdXQuU0NSSVBUX01BWF9TSVpFIC8gV0lUTkVTU19ESVNDT1VOVDtcclxuICBpZiAodGhpcy5vdXRwdXQuc2NyaXB0LmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSkge1xyXG4gICAgcmVzdWx0ICs9IHdpdG5lc3NTaXplO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5vdXRwdXQuc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpKSB7XHJcbiAgICByZXN1bHQgKz0gd2l0bmVzc1NpemUgKyBQdWJsaWNLZXlIYXNoSW5wdXQuUkVERUVNX1NDUklQVF9TSVpFO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXN1bHQgKz0gUHVibGljS2V5SGFzaElucHV0LlNDUklQVF9NQVhfU0laRTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHVibGljS2V5SGFzaElucHV0O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/input/publickeyhash.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/input/taproot.js":
/*!*******************************************************!*\
  !*** ../bitcore-lib/lib/transaction/input/taproot.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const inherits = __webpack_require__(/*! inherits */ \"../bitcore-lib/node_modules/inherits/inherits.js\");\r\nconst $ = __webpack_require__(/*! ../../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nconst PubKeyHashInput = __webpack_require__(/*! ./publickeyhash */ \"../bitcore-lib/lib/transaction/input/publickeyhash.js\");\r\nconst SighashSchnorr = __webpack_require__(/*! ../sighashschnorr */ \"../bitcore-lib/lib/transaction/sighashschnorr.js\");\r\nconst Signature = __webpack_require__(/*! ../../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nconst TransactionSignature = __webpack_require__(/*! ../signature */ \"../bitcore-lib/lib/transaction/signature.js\");\r\nconst Output = __webpack_require__(/*! ../output */ \"../bitcore-lib/lib/transaction/output.js\");\r\nconst PrivateKey = __webpack_require__(/*! ../../privatekey */ \"../bitcore-lib/lib/privatekey.js\");\r\n\r\nfunction TaprootInput() {\r\n  PubKeyHashInput.apply(this, arguments);\r\n}\r\ninherits(TaprootInput, PubKeyHashInput);\r\n\r\n/**\r\n * Get signatures for this input\r\n * @param {Transaction} transaction - the transaction to be signed\r\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\r\n * @param {number} index - the index of the input in the transaction input vector\r\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\r\n * @param {Buffer} hashData - unused for this input type\r\n * @param {String} signingMethod - always schnorr for taproot\r\n * @param {Buffer} merkleRoot - the merkle root of the taproot tree\r\n * @return {Array<TransactionSignature>}\r\n */\r\nTaprootInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\r\n  $.checkState(this.output instanceof Output);\r\n  sigtype = sigtype || Signature.SIGHASH_DEFAULT;\r\n  \r\n  const inputIndex = transaction.inputs.indexOf(this);\r\n  const tweakedPk = privateKey.createTapTweak(merkleRoot).tweakedPrivKey;\r\n  const signature = SighashSchnorr.sign(\r\n    transaction,\r\n    tweakedPk,\r\n    sigtype,\r\n    inputIndex,\r\n    Signature.Version.TAPROOT,\r\n    null\r\n  );\r\n  if (!signature) {\r\n    return [];\r\n  }\r\n  return [new TransactionSignature({\r\n    publicKey: privateKey.publicKey,\r\n    prevTxId: this.prevTxId,\r\n    outputIndex: this.outputIndex,\r\n    inputIndex,\r\n    signature: Signature.fromSchnorr(signature),\r\n    sigtype: sigtype\r\n  })];\r\n};\r\n\r\n\r\nTaprootInput.prototype.isValidSignature = function(transaction, signature) {\r\n  $.checkState(transaction.inputs.indexOf(this) >= 0, 'Signature has no matching input');\r\n  $.checkState(this.output instanceof Output, 'output is not instance of Output');\r\n  \r\n  if (!this.output.script.isTaproot()) {\r\n    return false;\r\n  }\r\n\r\n  return SighashSchnorr.verify(\r\n    transaction,\r\n    signature.signature,\r\n    this.output.script.chunks[1].buf,\r\n    Signature.Version.TAPROOT,\r\n    transaction.inputs.indexOf(this),\r\n    null\r\n  );\r\n};\r\n\r\n/**\r\n * Query whether the input is signed\r\n * @return {boolean}\r\n */\r\nTaprootInput.prototype.isFullySigned = function() {\r\n  return this.output.script.isTaproot() || this.hasWitnesses();\r\n};\r\n\r\n/**\r\n * Add the provided signature\r\n *\r\n * @param {Transaction} transaction\r\n * @param {Object} signature\r\n * @param {PublicKey} signature.publicKey\r\n * @param {Signature} signature.signature\r\n * @param {number} signature.sigtype\r\n * @return {TaprootInput} this, for chaining\r\n */\r\nTaprootInput.prototype.addSignature = function(transaction, signature) {\r\n  if (this.isValidSignature(transaction, signature)) {\r\n    this.setWitnesses([\r\n      signature.signature.toBuffer(),\r\n    ]);\r\n  }\r\n  // else... do nothing?\r\n  // When tx.sign(keys) is called, the given keys are used to try to sign all\r\n  // inputs. Invalid sigs may be created, in which case we should not add them here.\r\n  // The flow is kind of weird since this fn name is saying to add the signature.\r\n  // Maybe the validation check should be upstream to keep the code lexically obedient?\r\n\r\n  return this;\r\n};\r\n\r\n\r\nmodule.exports = TaprootInput;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3RhcHJvb3QuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsa0VBQVU7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLDBFQUEwQjtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsMkVBQW1CO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLHNFQUF3QjtBQUNsRCw2QkFBNkIsbUJBQU8sQ0FBQyxpRUFBYztBQUNuRCxlQUFlLG1CQUFPLENBQUMsMkRBQVc7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsMERBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3RhcHJvb3QuanM/NmQwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XHJcbmNvbnN0ICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxuY29uc3QgUHViS2V5SGFzaElucHV0ID0gcmVxdWlyZSgnLi9wdWJsaWNrZXloYXNoJyk7XHJcbmNvbnN0IFNpZ2hhc2hTY2hub3JyID0gcmVxdWlyZSgnLi4vc2lnaGFzaHNjaG5vcnInKTtcclxuY29uc3QgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xyXG5jb25zdCBUcmFuc2FjdGlvblNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL3NpZ25hdHVyZScpO1xyXG5jb25zdCBPdXRwdXQgPSByZXF1aXJlKCcuLi9vdXRwdXQnKTtcclxuY29uc3QgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uLy4uL3ByaXZhdGVrZXknKTtcclxuXHJcbmZ1bmN0aW9uIFRhcHJvb3RJbnB1dCgpIHtcclxuICBQdWJLZXlIYXNoSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5pbmhlcml0cyhUYXByb290SW5wdXQsIFB1YktleUhhc2hJbnB1dCk7XHJcblxyXG4vKipcclxuICogR2V0IHNpZ25hdHVyZXMgZm9yIHRoaXMgaW5wdXRcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXHJcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB3aXRoIHdoaWNoIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgaW5wdXQgaW4gdGhlIHRyYW5zYWN0aW9uIGlucHV0IHZlY3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHNpZ25hdHVyZSwgZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoRGF0YSAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIC0gYWx3YXlzIHNjaG5vcnIgZm9yIHRhcHJvb3RcclxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgLSB0aGUgbWVya2xlIHJvb3Qgb2YgdGhlIHRhcHJvb3QgdHJlZVxyXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XHJcbiAqL1xyXG5UYXByb290SW5wdXQucHJvdG90eXBlLmdldFNpZ25hdHVyZXMgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUsIGhhc2hEYXRhLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XHJcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgT3V0cHV0KTtcclxuICBzaWd0eXBlID0gc2lndHlwZSB8fCBTaWduYXR1cmUuU0lHSEFTSF9ERUZBVUxUO1xyXG4gIFxyXG4gIGNvbnN0IGlucHV0SW5kZXggPSB0cmFuc2FjdGlvbi5pbnB1dHMuaW5kZXhPZih0aGlzKTtcclxuICBjb25zdCB0d2Vha2VkUGsgPSBwcml2YXRlS2V5LmNyZWF0ZVRhcFR3ZWFrKG1lcmtsZVJvb3QpLnR3ZWFrZWRQcml2S2V5O1xyXG4gIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ2hhc2hTY2hub3JyLnNpZ24oXHJcbiAgICB0cmFuc2FjdGlvbixcclxuICAgIHR3ZWFrZWRQayxcclxuICAgIHNpZ3R5cGUsXHJcbiAgICBpbnB1dEluZGV4LFxyXG4gICAgU2lnbmF0dXJlLlZlcnNpb24uVEFQUk9PVCxcclxuICAgIG51bGxcclxuICApO1xyXG4gIGlmICghc2lnbmF0dXJlKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIHJldHVybiBbbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcclxuICAgIHB1YmxpY0tleTogcHJpdmF0ZUtleS5wdWJsaWNLZXksXHJcbiAgICBwcmV2VHhJZDogdGhpcy5wcmV2VHhJZCxcclxuICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxyXG4gICAgaW5wdXRJbmRleCxcclxuICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb21TY2hub3JyKHNpZ25hdHVyZSksXHJcbiAgICBzaWd0eXBlOiBzaWd0eXBlXHJcbiAgfSldO1xyXG59O1xyXG5cclxuXHJcblRhcHJvb3RJbnB1dC5wcm90b3R5cGUuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcclxuICAkLmNoZWNrU3RhdGUodHJhbnNhY3Rpb24uaW5wdXRzLmluZGV4T2YodGhpcykgPj0gMCwgJ1NpZ25hdHVyZSBoYXMgbm8gbWF0Y2hpbmcgaW5wdXQnKTtcclxuICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQsICdvdXRwdXQgaXMgbm90IGluc3RhbmNlIG9mIE91dHB1dCcpO1xyXG4gIFxyXG4gIGlmICghdGhpcy5vdXRwdXQuc2NyaXB0LmlzVGFwcm9vdCgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gU2lnaGFzaFNjaG5vcnIudmVyaWZ5KFxyXG4gICAgdHJhbnNhY3Rpb24sXHJcbiAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxyXG4gICAgdGhpcy5vdXRwdXQuc2NyaXB0LmNodW5rc1sxXS5idWYsXHJcbiAgICBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09ULFxyXG4gICAgdHJhbnNhY3Rpb24uaW5wdXRzLmluZGV4T2YodGhpcyksXHJcbiAgICBudWxsXHJcbiAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBRdWVyeSB3aGV0aGVyIHRoZSBpbnB1dCBpcyBzaWduZWRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcblRhcHJvb3RJbnB1dC5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLm91dHB1dC5zY3JpcHQuaXNUYXByb290KCkgfHwgdGhpcy5oYXNXaXRuZXNzZXMoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgdGhlIHByb3ZpZGVkIHNpZ25hdHVyZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBzaWduYXR1cmUucHVibGljS2V5XHJcbiAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWduYXR1cmUuc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWduYXR1cmUuc2lndHlwZVxyXG4gKiBAcmV0dXJuIHtUYXByb290SW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xyXG4gKi9cclxuVGFwcm9vdElucHV0LnByb3RvdHlwZS5hZGRTaWduYXR1cmUgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XHJcbiAgaWYgKHRoaXMuaXNWYWxpZFNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSkge1xyXG4gICAgdGhpcy5zZXRXaXRuZXNzZXMoW1xyXG4gICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLnRvQnVmZmVyKCksXHJcbiAgICBdKTtcclxuICB9XHJcbiAgLy8gZWxzZS4uLiBkbyBub3RoaW5nP1xyXG4gIC8vIFdoZW4gdHguc2lnbihrZXlzKSBpcyBjYWxsZWQsIHRoZSBnaXZlbiBrZXlzIGFyZSB1c2VkIHRvIHRyeSB0byBzaWduIGFsbFxyXG4gIC8vIGlucHV0cy4gSW52YWxpZCBzaWdzIG1heSBiZSBjcmVhdGVkLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBub3QgYWRkIHRoZW0gaGVyZS5cclxuICAvLyBUaGUgZmxvdyBpcyBraW5kIG9mIHdlaXJkIHNpbmNlIHRoaXMgZm4gbmFtZSBpcyBzYXlpbmcgdG8gYWRkIHRoZSBzaWduYXR1cmUuXHJcbiAgLy8gTWF5YmUgdGhlIHZhbGlkYXRpb24gY2hlY2sgc2hvdWxkIGJlIHVwc3RyZWFtIHRvIGtlZXAgdGhlIGNvZGUgbGV4aWNhbGx5IG9iZWRpZW50P1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRhcHJvb3RJbnB1dDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/input/taproot.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/output.js":
/*!************************************************!*\
  !*** ../bitcore-lib/lib/transaction/output.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar bufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar Script = __webpack_require__(/*! ../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nconst Interpreter = __webpack_require__(/*! ../script/interpreter */ \"../bitcore-lib/lib/script/interpreter.js\");\r\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"../bitcore-lib/lib/crypto/taggedhash.js\");\r\n\r\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\r\n\r\nfunction Output(args) {\r\n  if (!(this instanceof Output)) {\r\n    return new Output(args);\r\n  }\r\n  if (_.isObject(args)) {\r\n    this.satoshis = args.satoshis;\r\n    if (bufferUtil.isBuffer(args.script)) {\r\n      this.setScriptFromBuffer(args.script);\r\n    } else {\r\n      var script;\r\n      if (_.isString(args.script) && JSUtil.isHexa(args.script)) {\r\n        script = Buffer.from(args.script, 'hex');\r\n      } else {\r\n        script = args.script;\r\n      }\r\n      this.setScript(script);\r\n    }\r\n\r\n    if (args.type === 'taproot') {\r\n      this.branch = [];\r\n      Object.defineProperty(this, 'isValid', {\r\n        configurable: false,\r\n        enumerable: false,\r\n        get: function() {\r\n          this._isValid || this._branch.length === 0;\r\n        },\r\n        set: function(isValid) {\r\n          this._isValid = isValid;\r\n        }\r\n      });\r\n      Object.defineProperty(this, 'isComplete', {\r\n        configurable: false,\r\n        enumerable: false,\r\n        get: function() {\r\n          return this.isValid && (this._branch.length === 0 || (this._branch.length === 1 && !!this._branch[0]));\r\n        }\r\n      });\r\n    }\r\n  } else {\r\n    throw new TypeError('Unrecognized argument for Output');\r\n  }\r\n}\r\n\r\nObject.defineProperty(Output.prototype, 'script', {\r\n  configurable: false,\r\n  enumerable: true,\r\n  get: function() {\r\n    if (this._script) {\r\n      return this._script;\r\n    } else {\r\n      this.setScriptFromBuffer(this._scriptBuffer);\r\n      return this._script;\r\n    }\r\n\r\n  }\r\n});\r\n\r\nObject.defineProperty(Output.prototype, 'satoshis', {\r\n  configurable: false,\r\n  enumerable: true,\r\n  get: function() {\r\n    return this._satoshis;\r\n  },\r\n  set: function(num) {\r\n    if (num instanceof BN) {\r\n      this._satoshisBN = num;\r\n      this._satoshis = num.toNumber();\r\n    } else if (_.isString(num)) {\r\n      this._satoshis = parseInt(num);\r\n      this._satoshisBN = BN.fromNumber(this._satoshis);\r\n    } else {\r\n      $.checkArgument(\r\n        JSUtil.isNaturalNumber(num),\r\n        'Output satoshis is not a natural number'\r\n      );\r\n      this._satoshisBN = BN.fromNumber(num);\r\n      this._satoshis = num;\r\n    }\r\n    $.checkState(\r\n      JSUtil.isNaturalNumber(this._satoshis),\r\n      'Output satoshis is not a natural number'\r\n    );\r\n  }\r\n});\r\n\r\nOutput.prototype.invalidSatoshis = function() {\r\n  if (this._satoshis > MAX_SAFE_INTEGER) {\r\n    return 'transaction txout satoshis greater than max safe integer';\r\n  }\r\n  if (this._satoshis !== this._satoshisBN.toNumber()) {\r\n    return 'transaction txout satoshis has corrupted value';\r\n  }\r\n  if (this._satoshis < 0) {\r\n    return 'transaction txout negative';\r\n  }\r\n  return false;\r\n};\r\n\r\nOutput.prototype.toObject = Output.prototype.toJSON = function toObject() {\r\n  var obj = {\r\n    satoshis: this.satoshis\r\n  };\r\n  obj.script = this._scriptBuffer.toString('hex');\r\n  return obj;\r\n};\r\n\r\nOutput.fromObject = function(data) {\r\n  return new Output(data);\r\n};\r\n\r\nOutput.prototype.setScriptFromBuffer = function(buffer) {\r\n  this._scriptBuffer = buffer;\r\n  try {\r\n    this._script = Script.fromBuffer(this._scriptBuffer);\r\n    this._script._isOutput = true;\r\n  } catch(e) {\r\n    if (e instanceof errors.Script.InvalidBuffer) {\r\n      this._script = null;\r\n    } else {\r\n      throw e;\r\n    }\r\n  }\r\n};\r\n\r\nOutput.prototype.setScript = function(script) {\r\n  if (script instanceof Script) {\r\n    this._scriptBuffer = script.toBuffer();\r\n    this._script = script;\r\n    this._script._isOutput = true;\r\n  } else if (_.isString(script)) {\r\n    this._script = Script.fromString(script);\r\n    this._scriptBuffer = this._script.toBuffer();\r\n    this._script._isOutput = true;\r\n  } else if (bufferUtil.isBuffer(script)) {\r\n    this.setScriptFromBuffer(script);\r\n  } else {\r\n    throw new TypeError('Invalid argument type: script');\r\n  }\r\n  return this;\r\n};\r\n\r\nOutput.prototype.inspect = function() {\r\n  var scriptStr;\r\n  if (this.script) {\r\n    scriptStr = this.script.inspect();\r\n  } else {\r\n    scriptStr = this._scriptBuffer.toString('hex');\r\n  }\r\n  return '<Output (' + this.satoshis + ' sats) ' + scriptStr + '>';\r\n};\r\n\r\nOutput.fromBufferReader = function(br) {\r\n  var obj = {};\r\n  obj.satoshis = br.readUInt64LEBN();\r\n  var size = br.readVarintNum();\r\n  if (size !== 0) {\r\n    obj.script = br.read(size);\r\n  } else {\r\n    obj.script = Buffer.from([]);\r\n  }\r\n  return new Output(obj);\r\n};\r\n\r\nOutput.prototype.toBufferWriter = function(writer) {\r\n  if (!writer) {\r\n    writer = new BufferWriter();\r\n  }\r\n  writer.writeUInt64LEBN(this._satoshisBN);\r\n  var script = this._scriptBuffer;\r\n  writer.writeVarintNum(script.length);\r\n  writer.write(script);\r\n  return writer;\r\n};\r\n\r\nOutput.prototype.calculateSize = function() {\r\n  let result = 8; // satoshis\r\n  result += BufferWriter.varintBufNum(this._scriptBuffer.length).length;\r\n  result += this._scriptBuffer.length;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Taproot only\r\n * Add a new script at a certain depth in the tree. Add() operations must be called\r\n *  in depth-first traversal order of binary tree. If track is true, it will be included in\r\n *  the GetSpendData() output.\r\n * @param {Number} depth Tree depth at which to insert the node (depth is 0-based)\r\n * @param {Script} script \r\n * @param {Number} leafVersion \r\n * @param {Boolean} track If true, the leaf will be included in GetSpendData() output\r\n */\r\nOutput.prototype.add = function(depth, script, leafVersion, track = true) {\r\n  $.checkArgument((leafVersion & ~Interpreter.TAPROOT_LEAF_MASK) === 0, 'invalid leafVersion');\r\n  if (!this.isValid) {\r\n    return;\r\n  }\r\n\r\n  const node = {\r\n    hash: TaggedHash.TAPLEAF.writeUInt8(leafVersion).write(script.toBuffer()).finalize(),\r\n    leaves: []\r\n  };\r\n  if (track) {\r\n    const leafInfo = {\r\n      script,\r\n      leafVersion,\r\n      merkleBranch: []\r\n    };\r\n    node.leaves.push(leafInfo);\r\n  }\r\n  this._insertNode(node, depth);\r\n  return this;\r\n};\r\n\r\n\r\nOutput.prototype._insertNode = function(node, depth) {\r\n  $.checkArgument(depth >= 0 && depth <= Interpreter.TAPROOT_CONTROL_MAX_NODE_COUNT, 'invalid depth');\r\n  /* We cannot insert a leaf at a lower depth while a deeper branch is unfinished. Doing\r\n   * so would mean the Add() invocations do not correspond to a DFS traversal of a\r\n   * binary tree. */\r\n  if (depth + 1 < this._branch.length) {\r\n    this.isValid = false;\r\n    return;\r\n  }\r\n  /* As long as an entry in the branch exists at the specified depth, combine it and propagate up.\r\n   * The 'node' variable is overwritten here with the newly combined node. */\r\n  while (this.isValid && this._branch.length > depth && this._branch[depth]) {\r\n    node = this._combineNodes(node, this._branch[depth]);\r\n    this._branch = this._branch.slice(0, this._branch.length - 2);\r\n    if (depth == 0) {\r\n      this.isValid = false; /* Can't propagate further up than the root */\r\n    }\r\n    depth--;\r\n  }\r\n  if (this.isValid) {\r\n    /* Make sure the branch is big enough to place the new node. */\r\n    if (this._branch.length <= depth) {\r\n      this._branch = this._branch.slice(0, depth + 1);\r\n    }\r\n    $.checkState(!this._nodes[depth]);\r\n    m_branch[depth] = node;\r\n  }\r\n};\r\n\r\nOutput.prototype._combineNodes = function(a, b) {\r\n  const ret = {\r\n    hash: null,\r\n    leaves: []\r\n  };\r\n  /* Iterate over all tracked leaves in a, add b's hash to their Merkle branch, and move them to ret. */\r\n  for (let leaf of a.leaves) {\r\n    leaf.merkleBranch.push(b.hash);\r\n    ret.leaves.push(leaf);\r\n  }\r\n  /* Iterate over all tracked leaves in b, add a's hash to their Merkle branch, and move them to ret. */\r\n  for (let leaf of b.leaves) {\r\n    leaf.merkleBranch.push(a.hash);\r\n    ret.leaves.push(leaf);\r\n  }\r\n  /* Lexicographically sort a and b's hash, and compute parent hash. */\r\n  if (a.hash.compare(b.hash) === -1) {\r\n    ret.hash = TaggedHash.TAPBRANCH.write(a.hash).write(b.hash).finalize();\r\n  } else {\r\n    ret.hash = TaggedHash.TAPBRANCH.write(b.hash).write(a.hash).finalize();\r\n  }\r\n  return ret;\r\n};\r\n\r\n\r\n/**\r\n * Finalize the construction. Can only be called when IsComplete() is true.\r\n *  internal_key.IsFullyValid() must be true.\r\n * @param {PublicKey} pubKey \r\n */\r\nOutput.prototype.finalize = function(pubKey) {\r\n  $.checkState(this.isComplete === true, 'finalize can only be called when isComplete is true');\r\n  const ret = pubKey.createTapTweak(this._branch.length === 0 ? null : this._branch[0].hash);\r\n\r\n};\r\n\r\nmodule.exports = Output;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL291dHB1dC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QixTQUFTLG1CQUFPLENBQUMscURBQWM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMseURBQWdCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxpREFBWTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBMEI7QUFDckQsYUFBYSxtQkFBTyxDQUFDLHFEQUFXO0FBQ2hDLFFBQVEsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLHFEQUFXO0FBQ2hDLG9CQUFvQixtQkFBTyxDQUFDLHVFQUF1QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxxRUFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL291dHB1dC5qcz9lMGU5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xyXG52YXIgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XHJcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcclxudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XHJcbmNvbnN0IEludGVycHJldGVyID0gcmVxdWlyZSgnLi4vc2NyaXB0L2ludGVycHJldGVyJyk7XHJcbmNvbnN0IFRhZ2dlZEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vdGFnZ2VkaGFzaCcpO1xyXG5cclxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmO1xyXG5cclxuZnVuY3Rpb24gT3V0cHV0KGFyZ3MpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3V0cHV0KSkge1xyXG4gICAgcmV0dXJuIG5ldyBPdXRwdXQoYXJncyk7XHJcbiAgfVxyXG4gIGlmIChfLmlzT2JqZWN0KGFyZ3MpKSB7XHJcbiAgICB0aGlzLnNhdG9zaGlzID0gYXJncy5zYXRvc2hpcztcclxuICAgIGlmIChidWZmZXJVdGlsLmlzQnVmZmVyKGFyZ3Muc2NyaXB0KSkge1xyXG4gICAgICB0aGlzLnNldFNjcmlwdEZyb21CdWZmZXIoYXJncy5zY3JpcHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHNjcmlwdDtcclxuICAgICAgaWYgKF8uaXNTdHJpbmcoYXJncy5zY3JpcHQpICYmIEpTVXRpbC5pc0hleGEoYXJncy5zY3JpcHQpKSB7XHJcbiAgICAgICAgc2NyaXB0ID0gQnVmZmVyLmZyb20oYXJncy5zY3JpcHQsICdoZXgnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzY3JpcHQgPSBhcmdzLnNjcmlwdDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNldFNjcmlwdChzY3JpcHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmdzLnR5cGUgPT09ICd0YXByb290Jykge1xyXG4gICAgICB0aGlzLmJyYW5jaCA9IFtdO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzVmFsaWQnLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdGhpcy5faXNWYWxpZCB8fCB0aGlzLl9icmFuY2gubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihpc1ZhbGlkKSB7XHJcbiAgICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNWYWxpZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzQ29tcGxldGUnLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCAmJiAodGhpcy5fYnJhbmNoLmxlbmd0aCA9PT0gMCB8fCAodGhpcy5fYnJhbmNoLmxlbmd0aCA9PT0gMSAmJiAhIXRoaXMuX2JyYW5jaFswXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVjb2duaXplZCBhcmd1bWVudCBmb3IgT3V0cHV0Jyk7XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT3V0cHV0LnByb3RvdHlwZSwgJ3NjcmlwdCcsIHtcclxuICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLl9zY3JpcHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2V0U2NyaXB0RnJvbUJ1ZmZlcih0aGlzLl9zY3JpcHRCdWZmZXIpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fc2NyaXB0O1xyXG4gICAgfVxyXG5cclxuICB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE91dHB1dC5wcm90b3R5cGUsICdzYXRvc2hpcycsIHtcclxuICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9zYXRvc2hpcztcclxuICB9LFxyXG4gIHNldDogZnVuY3Rpb24obnVtKSB7XHJcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcclxuICAgICAgdGhpcy5fc2F0b3NoaXNCTiA9IG51bTtcclxuICAgICAgdGhpcy5fc2F0b3NoaXMgPSBudW0udG9OdW1iZXIoKTtcclxuICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhudW0pKSB7XHJcbiAgICAgIHRoaXMuX3NhdG9zaGlzID0gcGFyc2VJbnQobnVtKTtcclxuICAgICAgdGhpcy5fc2F0b3NoaXNCTiA9IEJOLmZyb21OdW1iZXIodGhpcy5fc2F0b3NoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJC5jaGVja0FyZ3VtZW50KFxyXG4gICAgICAgIEpTVXRpbC5pc05hdHVyYWxOdW1iZXIobnVtKSxcclxuICAgICAgICAnT3V0cHV0IHNhdG9zaGlzIGlzIG5vdCBhIG5hdHVyYWwgbnVtYmVyJ1xyXG4gICAgICApO1xyXG4gICAgICB0aGlzLl9zYXRvc2hpc0JOID0gQk4uZnJvbU51bWJlcihudW0pO1xyXG4gICAgICB0aGlzLl9zYXRvc2hpcyA9IG51bTtcclxuICAgIH1cclxuICAgICQuY2hlY2tTdGF0ZShcclxuICAgICAgSlNVdGlsLmlzTmF0dXJhbE51bWJlcih0aGlzLl9zYXRvc2hpcyksXHJcbiAgICAgICdPdXRwdXQgc2F0b3NoaXMgaXMgbm90IGEgbmF0dXJhbCBudW1iZXInXHJcbiAgICApO1xyXG4gIH1cclxufSk7XHJcblxyXG5PdXRwdXQucHJvdG90eXBlLmludmFsaWRTYXRvc2hpcyA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICh0aGlzLl9zYXRvc2hpcyA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcclxuICAgIHJldHVybiAndHJhbnNhY3Rpb24gdHhvdXQgc2F0b3NoaXMgZ3JlYXRlciB0aGFuIG1heCBzYWZlIGludGVnZXInO1xyXG4gIH1cclxuICBpZiAodGhpcy5fc2F0b3NoaXMgIT09IHRoaXMuX3NhdG9zaGlzQk4udG9OdW1iZXIoKSkge1xyXG4gICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCBzYXRvc2hpcyBoYXMgY29ycnVwdGVkIHZhbHVlJztcclxuICB9XHJcbiAgaWYgKHRoaXMuX3NhdG9zaGlzIDwgMCkge1xyXG4gICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCBuZWdhdGl2ZSc7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbk91dHB1dC5wcm90b3R5cGUudG9PYmplY3QgPSBPdXRwdXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xyXG4gIHZhciBvYmogPSB7XHJcbiAgICBzYXRvc2hpczogdGhpcy5zYXRvc2hpc1xyXG4gIH07XHJcbiAgb2JqLnNjcmlwdCA9IHRoaXMuX3NjcmlwdEJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcbk91dHB1dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gIHJldHVybiBuZXcgT3V0cHV0KGRhdGEpO1xyXG59O1xyXG5cclxuT3V0cHV0LnByb3RvdHlwZS5zZXRTY3JpcHRGcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XHJcbiAgdGhpcy5fc2NyaXB0QnVmZmVyID0gYnVmZmVyO1xyXG4gIHRyeSB7XHJcbiAgICB0aGlzLl9zY3JpcHQgPSBTY3JpcHQuZnJvbUJ1ZmZlcih0aGlzLl9zY3JpcHRCdWZmZXIpO1xyXG4gICAgdGhpcy5fc2NyaXB0Ll9pc091dHB1dCA9IHRydWU7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICBpZiAoZSBpbnN0YW5jZW9mIGVycm9ycy5TY3JpcHQuSW52YWxpZEJ1ZmZlcikge1xyXG4gICAgICB0aGlzLl9zY3JpcHQgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5PdXRwdXQucHJvdG90eXBlLnNldFNjcmlwdCA9IGZ1bmN0aW9uKHNjcmlwdCkge1xyXG4gIGlmIChzY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQpIHtcclxuICAgIHRoaXMuX3NjcmlwdEJ1ZmZlciA9IHNjcmlwdC50b0J1ZmZlcigpO1xyXG4gICAgdGhpcy5fc2NyaXB0ID0gc2NyaXB0O1xyXG4gICAgdGhpcy5fc2NyaXB0Ll9pc091dHB1dCA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHNjcmlwdCkpIHtcclxuICAgIHRoaXMuX3NjcmlwdCA9IFNjcmlwdC5mcm9tU3RyaW5nKHNjcmlwdCk7XHJcbiAgICB0aGlzLl9zY3JpcHRCdWZmZXIgPSB0aGlzLl9zY3JpcHQudG9CdWZmZXIoKTtcclxuICAgIHRoaXMuX3NjcmlwdC5faXNPdXRwdXQgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoYnVmZmVyVXRpbC5pc0J1ZmZlcihzY3JpcHQpKSB7XHJcbiAgICB0aGlzLnNldFNjcmlwdEZyb21CdWZmZXIoc2NyaXB0KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCB0eXBlOiBzY3JpcHQnKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5PdXRwdXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgc2NyaXB0U3RyO1xyXG4gIGlmICh0aGlzLnNjcmlwdCkge1xyXG4gICAgc2NyaXB0U3RyID0gdGhpcy5zY3JpcHQuaW5zcGVjdCgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzY3JpcHRTdHIgPSB0aGlzLl9zY3JpcHRCdWZmZXIudG9TdHJpbmcoJ2hleCcpO1xyXG4gIH1cclxuICByZXR1cm4gJzxPdXRwdXQgKCcgKyB0aGlzLnNhdG9zaGlzICsgJyBzYXRzKSAnICsgc2NyaXB0U3RyICsgJz4nO1xyXG59O1xyXG5cclxuT3V0cHV0LmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbihicikge1xyXG4gIHZhciBvYmogPSB7fTtcclxuICBvYmouc2F0b3NoaXMgPSBici5yZWFkVUludDY0TEVCTigpO1xyXG4gIHZhciBzaXplID0gYnIucmVhZFZhcmludE51bSgpO1xyXG4gIGlmIChzaXplICE9PSAwKSB7XHJcbiAgICBvYmouc2NyaXB0ID0gYnIucmVhZChzaXplKTtcclxuICB9IGVsc2Uge1xyXG4gICAgb2JqLnNjcmlwdCA9IEJ1ZmZlci5mcm9tKFtdKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBPdXRwdXQob2JqKTtcclxufTtcclxuXHJcbk91dHB1dC5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbih3cml0ZXIpIHtcclxuICBpZiAoIXdyaXRlcikge1xyXG4gICAgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gIH1cclxuICB3cml0ZXIud3JpdGVVSW50NjRMRUJOKHRoaXMuX3NhdG9zaGlzQk4pO1xyXG4gIHZhciBzY3JpcHQgPSB0aGlzLl9zY3JpcHRCdWZmZXI7XHJcbiAgd3JpdGVyLndyaXRlVmFyaW50TnVtKHNjcmlwdC5sZW5ndGgpO1xyXG4gIHdyaXRlci53cml0ZShzY3JpcHQpO1xyXG4gIHJldHVybiB3cml0ZXI7XHJcbn07XHJcblxyXG5PdXRwdXQucHJvdG90eXBlLmNhbGN1bGF0ZVNpemUgPSBmdW5jdGlvbigpIHtcclxuICBsZXQgcmVzdWx0ID0gODsgLy8gc2F0b3NoaXNcclxuICByZXN1bHQgKz0gQnVmZmVyV3JpdGVyLnZhcmludEJ1Zk51bSh0aGlzLl9zY3JpcHRCdWZmZXIubGVuZ3RoKS5sZW5ndGg7XHJcbiAgcmVzdWx0ICs9IHRoaXMuX3NjcmlwdEJ1ZmZlci5sZW5ndGg7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUYXByb290IG9ubHlcclxuICogQWRkIGEgbmV3IHNjcmlwdCBhdCBhIGNlcnRhaW4gZGVwdGggaW4gdGhlIHRyZWUuIEFkZCgpIG9wZXJhdGlvbnMgbXVzdCBiZSBjYWxsZWRcclxuICogIGluIGRlcHRoLWZpcnN0IHRyYXZlcnNhbCBvcmRlciBvZiBiaW5hcnkgdHJlZS4gSWYgdHJhY2sgaXMgdHJ1ZSwgaXQgd2lsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiAgdGhlIEdldFNwZW5kRGF0YSgpIG91dHB1dC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIFRyZWUgZGVwdGggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBub2RlIChkZXB0aCBpcyAwLWJhc2VkKVxyXG4gKiBAcGFyYW0ge1NjcmlwdH0gc2NyaXB0IFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbGVhZlZlcnNpb24gXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJhY2sgSWYgdHJ1ZSwgdGhlIGxlYWYgd2lsbCBiZSBpbmNsdWRlZCBpbiBHZXRTcGVuZERhdGEoKSBvdXRwdXRcclxuICovXHJcbk91dHB1dC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZGVwdGgsIHNjcmlwdCwgbGVhZlZlcnNpb24sIHRyYWNrID0gdHJ1ZSkge1xyXG4gICQuY2hlY2tBcmd1bWVudCgobGVhZlZlcnNpb24gJiB+SW50ZXJwcmV0ZXIuVEFQUk9PVF9MRUFGX01BU0spID09PSAwLCAnaW52YWxpZCBsZWFmVmVyc2lvbicpO1xyXG4gIGlmICghdGhpcy5pc1ZhbGlkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCBub2RlID0ge1xyXG4gICAgaGFzaDogVGFnZ2VkSGFzaC5UQVBMRUFGLndyaXRlVUludDgobGVhZlZlcnNpb24pLndyaXRlKHNjcmlwdC50b0J1ZmZlcigpKS5maW5hbGl6ZSgpLFxyXG4gICAgbGVhdmVzOiBbXVxyXG4gIH07XHJcbiAgaWYgKHRyYWNrKSB7XHJcbiAgICBjb25zdCBsZWFmSW5mbyA9IHtcclxuICAgICAgc2NyaXB0LFxyXG4gICAgICBsZWFmVmVyc2lvbixcclxuICAgICAgbWVya2xlQnJhbmNoOiBbXVxyXG4gICAgfTtcclxuICAgIG5vZGUubGVhdmVzLnB1c2gobGVhZkluZm8pO1xyXG4gIH1cclxuICB0aGlzLl9pbnNlcnROb2RlKG5vZGUsIGRlcHRoKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5PdXRwdXQucHJvdG90eXBlLl9pbnNlcnROb2RlID0gZnVuY3Rpb24obm9kZSwgZGVwdGgpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoZGVwdGggPj0gMCAmJiBkZXB0aCA8PSBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTUFYX05PREVfQ09VTlQsICdpbnZhbGlkIGRlcHRoJyk7XHJcbiAgLyogV2UgY2Fubm90IGluc2VydCBhIGxlYWYgYXQgYSBsb3dlciBkZXB0aCB3aGlsZSBhIGRlZXBlciBicmFuY2ggaXMgdW5maW5pc2hlZC4gRG9pbmdcclxuICAgKiBzbyB3b3VsZCBtZWFuIHRoZSBBZGQoKSBpbnZvY2F0aW9ucyBkbyBub3QgY29ycmVzcG9uZCB0byBhIERGUyB0cmF2ZXJzYWwgb2YgYVxyXG4gICAqIGJpbmFyeSB0cmVlLiAqL1xyXG4gIGlmIChkZXB0aCArIDEgPCB0aGlzLl9icmFuY2gubGVuZ3RoKSB7XHJcbiAgICB0aGlzLmlzVmFsaWQgPSBmYWxzZTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgLyogQXMgbG9uZyBhcyBhbiBlbnRyeSBpbiB0aGUgYnJhbmNoIGV4aXN0cyBhdCB0aGUgc3BlY2lmaWVkIGRlcHRoLCBjb21iaW5lIGl0IGFuZCBwcm9wYWdhdGUgdXAuXHJcbiAgICogVGhlICdub2RlJyB2YXJpYWJsZSBpcyBvdmVyd3JpdHRlbiBoZXJlIHdpdGggdGhlIG5ld2x5IGNvbWJpbmVkIG5vZGUuICovXHJcbiAgd2hpbGUgKHRoaXMuaXNWYWxpZCAmJiB0aGlzLl9icmFuY2gubGVuZ3RoID4gZGVwdGggJiYgdGhpcy5fYnJhbmNoW2RlcHRoXSkge1xyXG4gICAgbm9kZSA9IHRoaXMuX2NvbWJpbmVOb2Rlcyhub2RlLCB0aGlzLl9icmFuY2hbZGVwdGhdKTtcclxuICAgIHRoaXMuX2JyYW5jaCA9IHRoaXMuX2JyYW5jaC5zbGljZSgwLCB0aGlzLl9icmFuY2gubGVuZ3RoIC0gMik7XHJcbiAgICBpZiAoZGVwdGggPT0gMCkge1xyXG4gICAgICB0aGlzLmlzVmFsaWQgPSBmYWxzZTsgLyogQ2FuJ3QgcHJvcGFnYXRlIGZ1cnRoZXIgdXAgdGhhbiB0aGUgcm9vdCAqL1xyXG4gICAgfVxyXG4gICAgZGVwdGgtLTtcclxuICB9XHJcbiAgaWYgKHRoaXMuaXNWYWxpZCkge1xyXG4gICAgLyogTWFrZSBzdXJlIHRoZSBicmFuY2ggaXMgYmlnIGVub3VnaCB0byBwbGFjZSB0aGUgbmV3IG5vZGUuICovXHJcbiAgICBpZiAodGhpcy5fYnJhbmNoLmxlbmd0aCA8PSBkZXB0aCkge1xyXG4gICAgICB0aGlzLl9icmFuY2ggPSB0aGlzLl9icmFuY2guc2xpY2UoMCwgZGVwdGggKyAxKTtcclxuICAgIH1cclxuICAgICQuY2hlY2tTdGF0ZSghdGhpcy5fbm9kZXNbZGVwdGhdKTtcclxuICAgIG1fYnJhbmNoW2RlcHRoXSA9IG5vZGU7XHJcbiAgfVxyXG59O1xyXG5cclxuT3V0cHV0LnByb3RvdHlwZS5fY29tYmluZU5vZGVzID0gZnVuY3Rpb24oYSwgYikge1xyXG4gIGNvbnN0IHJldCA9IHtcclxuICAgIGhhc2g6IG51bGwsXHJcbiAgICBsZWF2ZXM6IFtdXHJcbiAgfTtcclxuICAvKiBJdGVyYXRlIG92ZXIgYWxsIHRyYWNrZWQgbGVhdmVzIGluIGEsIGFkZCBiJ3MgaGFzaCB0byB0aGVpciBNZXJrbGUgYnJhbmNoLCBhbmQgbW92ZSB0aGVtIHRvIHJldC4gKi9cclxuICBmb3IgKGxldCBsZWFmIG9mIGEubGVhdmVzKSB7XHJcbiAgICBsZWFmLm1lcmtsZUJyYW5jaC5wdXNoKGIuaGFzaCk7XHJcbiAgICByZXQubGVhdmVzLnB1c2gobGVhZik7XHJcbiAgfVxyXG4gIC8qIEl0ZXJhdGUgb3ZlciBhbGwgdHJhY2tlZCBsZWF2ZXMgaW4gYiwgYWRkIGEncyBoYXNoIHRvIHRoZWlyIE1lcmtsZSBicmFuY2gsIGFuZCBtb3ZlIHRoZW0gdG8gcmV0LiAqL1xyXG4gIGZvciAobGV0IGxlYWYgb2YgYi5sZWF2ZXMpIHtcclxuICAgIGxlYWYubWVya2xlQnJhbmNoLnB1c2goYS5oYXNoKTtcclxuICAgIHJldC5sZWF2ZXMucHVzaChsZWFmKTtcclxuICB9XHJcbiAgLyogTGV4aWNvZ3JhcGhpY2FsbHkgc29ydCBhIGFuZCBiJ3MgaGFzaCwgYW5kIGNvbXB1dGUgcGFyZW50IGhhc2guICovXHJcbiAgaWYgKGEuaGFzaC5jb21wYXJlKGIuaGFzaCkgPT09IC0xKSB7XHJcbiAgICByZXQuaGFzaCA9IFRhZ2dlZEhhc2guVEFQQlJBTkNILndyaXRlKGEuaGFzaCkud3JpdGUoYi5oYXNoKS5maW5hbGl6ZSgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXQuaGFzaCA9IFRhZ2dlZEhhc2guVEFQQlJBTkNILndyaXRlKGIuaGFzaCkud3JpdGUoYS5oYXNoKS5maW5hbGl6ZSgpO1xyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBGaW5hbGl6ZSB0aGUgY29uc3RydWN0aW9uLiBDYW4gb25seSBiZSBjYWxsZWQgd2hlbiBJc0NvbXBsZXRlKCkgaXMgdHJ1ZS5cclxuICogIGludGVybmFsX2tleS5Jc0Z1bGx5VmFsaWQoKSBtdXN0IGJlIHRydWUuXHJcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJLZXkgXHJcbiAqL1xyXG5PdXRwdXQucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24ocHViS2V5KSB7XHJcbiAgJC5jaGVja1N0YXRlKHRoaXMuaXNDb21wbGV0ZSA9PT0gdHJ1ZSwgJ2ZpbmFsaXplIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIGlzQ29tcGxldGUgaXMgdHJ1ZScpO1xyXG4gIGNvbnN0IHJldCA9IHB1YktleS5jcmVhdGVUYXBUd2Vhayh0aGlzLl9icmFuY2gubGVuZ3RoID09PSAwID8gbnVsbCA6IHRoaXMuX2JyYW5jaFswXS5oYXNoKTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE91dHB1dDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/output.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/sighash.js":
/*!*************************************************!*\
  !*** ../bitcore-lib/lib/transaction/sighash.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar Script = __webpack_require__(/*! ../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar Output = __webpack_require__(/*! ./output */ \"../bitcore-lib/lib/transaction/output.js\");\r\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar ECDSA = __webpack_require__(/*! ../crypto/ecdsa */ \"../bitcore-lib/lib/crypto/ecdsa.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\r\nvar BITS_64_ON = 'ffffffffffffffff';\r\n\r\n/**\r\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\r\n * for OP_CHECKSIG.\r\n *\r\n * @name Signing.sighash\r\n * @param {Transaction} transaction the transaction to sign\r\n * @param {number} sighashType the type of the hash\r\n * @param {number} inputNumber the input index for the signature\r\n * @param {Script} subscript the script that will be signed\r\n */\r\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\r\n  var Transaction = __webpack_require__(/*! ./transaction */ \"../bitcore-lib/lib/transaction/transaction.js\");\r\n  var Input = __webpack_require__(/*! ./input */ \"../bitcore-lib/lib/transaction/input/index.js\");\r\n\r\n  // Convert a string to a number\r\n  inputNumber = parseInt(inputNumber);\r\n\r\n  var i;\r\n  // Copy transaction\r\n  var txcopy = Transaction.shallowCopy(transaction);\r\n\r\n  // Copy script\r\n  subscript = new Script(subscript);\r\n  subscript.removeCodeseparators();\r\n\r\n  for (i = 0; i < txcopy.inputs.length; i++) {\r\n    // Blank signatures for other inputs\r\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\r\n  }\r\n\r\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\r\n\r\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\r\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\r\n\r\n    // clear all sequenceNumbers\r\n    for (i = 0; i < txcopy.inputs.length; i++) {\r\n      if (i !== inputNumber) {\r\n        txcopy.inputs[i].sequenceNumber = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\r\n    txcopy.outputs = [];\r\n\r\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\r\n    // The SIGHASH_SINGLE bug.\r\n    // https://bitcointalk.org/index.php?topic=260595.0\r\n    if (inputNumber >= txcopy.outputs.length) {\r\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\r\n    }\r\n\r\n    txcopy.outputs.length = inputNumber + 1;\r\n\r\n    for (i = 0; i < inputNumber; i++) {\r\n      txcopy.outputs[i] = new Output({\r\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\r\n        script: Script.empty()\r\n      });\r\n    }\r\n  }\r\n\r\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\r\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\r\n  }\r\n\r\n  var buf = new BufferWriter()\r\n    .write(txcopy.toBuffer())\r\n    .writeInt32LE(sighashType)\r\n    .toBuffer();\r\n  var ret = Hash.sha256sha256(buf);\r\n  ret = new BufferReader(ret).readReverse();\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Create a signature\r\n *\r\n * @name Signing.sign\r\n * @param {Transaction} transaction\r\n * @param {PrivateKey} privateKey\r\n * @param {number} sighash\r\n * @param {number} inputIndex\r\n * @param {Script} subscript\r\n * @return {Signature}\r\n */\r\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript) {\r\n  let hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\r\n  return ECDSA.sign(hashbuf, privateKey, 'little').set({ nhashtype: sighashType })\r\n};\r\n\r\n/**\r\n * Verify a signature\r\n *\r\n * @name Signing.verify\r\n * @param {Transaction} transaction\r\n * @param {Signature} signature\r\n * @param {PublicKey} publicKey\r\n * @param {number} inputIndex\r\n * @param {Script} subscript\r\n * @return {boolean}\r\n */\r\nfunction verify(transaction, signature, publicKey, inputIndex, subscript) {\r\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\r\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\r\n\r\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\r\n  return ECDSA.verify(hashbuf, signature, publicKey, 'little');\r\n};\r\n\r\n/**\r\n * @namespace Signing\r\n */\r\nmodule.exports = {\r\n  sighash: sighash,\r\n  sign: sign,\r\n  verify: verify\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2guanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBcUI7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLHFEQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQywwREFBVTtBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBMEI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsNkVBQTBCO0FBQ3JELFNBQVMsbUJBQU8sQ0FBQyxxREFBYztBQUMvQixXQUFXLG1CQUFPLENBQUMseURBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQywyREFBaUI7QUFDckMsUUFBUSxtQkFBTyxDQUFDLHVFQUF1QjtBQUN2QyxRQUFRLG1CQUFPLENBQUMsNERBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxvRUFBZTtBQUMzQyxjQUFjLG1CQUFPLENBQUMsOERBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2guanM/YWExZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xyXG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XHJcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuL291dHB1dCcpO1xyXG52YXIgQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVycmVhZGVyJyk7XHJcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcclxudmFyIEJOID0gcmVxdWlyZSgnLi4vY3J5cHRvL2JuJyk7XHJcbnZhciBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcclxudmFyIEVDRFNBID0gcmVxdWlyZSgnLi4vY3J5cHRvL2VjZHNhJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG52YXIgU0lHSEFTSF9TSU5HTEVfQlVHID0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnO1xyXG52YXIgQklUU182NF9PTiA9ICdmZmZmZmZmZmZmZmZmZmZmJztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgYnVmZmVyIG9mIGxlbmd0aCAzMiBieXRlcyB3aXRoIHRoZSBoYXNoIHRoYXQgbmVlZHMgdG8gYmUgc2lnbmVkXHJcbiAqIGZvciBPUF9DSEVDS1NJRy5cclxuICpcclxuICogQG5hbWUgU2lnbmluZy5zaWdoYXNoXHJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIHRoZSB0cmFuc2FjdGlvbiB0byBzaWduXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWdoYXNoVHlwZSB0aGUgdHlwZSBvZiB0aGUgaGFzaFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5wdXROdW1iZXIgdGhlIGlucHV0IGluZGV4IGZvciB0aGUgc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7U2NyaXB0fSBzdWJzY3JpcHQgdGhlIHNjcmlwdCB0aGF0IHdpbGwgYmUgc2lnbmVkXHJcbiAqL1xyXG52YXIgc2lnaGFzaCA9IGZ1bmN0aW9uIHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dE51bWJlciwgc3Vic2NyaXB0KSB7XHJcbiAgdmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi90cmFuc2FjdGlvbicpO1xyXG4gIHZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcclxuXHJcbiAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIG51bWJlclxyXG4gIGlucHV0TnVtYmVyID0gcGFyc2VJbnQoaW5wdXROdW1iZXIpO1xyXG5cclxuICB2YXIgaTtcclxuICAvLyBDb3B5IHRyYW5zYWN0aW9uXHJcbiAgdmFyIHR4Y29weSA9IFRyYW5zYWN0aW9uLnNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcclxuXHJcbiAgLy8gQ29weSBzY3JpcHRcclxuICBzdWJzY3JpcHQgPSBuZXcgU2NyaXB0KHN1YnNjcmlwdCk7XHJcbiAgc3Vic2NyaXB0LnJlbW92ZUNvZGVzZXBhcmF0b3JzKCk7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCB0eGNvcHkuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAvLyBCbGFuayBzaWduYXR1cmVzIGZvciBvdGhlciBpbnB1dHNcclxuICAgIHR4Y29weS5pbnB1dHNbaV0gPSBuZXcgSW5wdXQodHhjb3B5LmlucHV0c1tpXSkuc2V0U2NyaXB0KFNjcmlwdC5lbXB0eSgpKTtcclxuICB9XHJcblxyXG4gIHR4Y29weS5pbnB1dHNbaW5wdXROdW1iZXJdID0gbmV3IElucHV0KHR4Y29weS5pbnB1dHNbaW5wdXROdW1iZXJdKS5zZXRTY3JpcHQoc3Vic2NyaXB0KTtcclxuXHJcbiAgaWYgKChzaWdoYXNoVHlwZSAmIDMxKSA9PT0gU2lnbmF0dXJlLlNJR0hBU0hfTk9ORSB8fFxyXG4gICAgKHNpZ2hhc2hUeXBlICYgMzEpID09PSBTaWduYXR1cmUuU0lHSEFTSF9TSU5HTEUpIHtcclxuXHJcbiAgICAvLyBjbGVhciBhbGwgc2VxdWVuY2VOdW1iZXJzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHhjb3B5LmlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoaSAhPT0gaW5wdXROdW1iZXIpIHtcclxuICAgICAgICB0eGNvcHkuaW5wdXRzW2ldLnNlcXVlbmNlTnVtYmVyID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKChzaWdoYXNoVHlwZSAmIDMxKSA9PT0gU2lnbmF0dXJlLlNJR0hBU0hfTk9ORSkge1xyXG4gICAgdHhjb3B5Lm91dHB1dHMgPSBbXTtcclxuXHJcbiAgfSBlbHNlIGlmICgoc2lnaGFzaFR5cGUgJiAzMSkgPT09IFNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSkge1xyXG4gICAgLy8gVGhlIFNJR0hBU0hfU0lOR0xFIGJ1Zy5cclxuICAgIC8vIGh0dHBzOi8vYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz0yNjA1OTUuMFxyXG4gICAgaWYgKGlucHV0TnVtYmVyID49IHR4Y29weS5vdXRwdXRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oU0lHSEFTSF9TSU5HTEVfQlVHLCAnaGV4Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdHhjb3B5Lm91dHB1dHMubGVuZ3RoID0gaW5wdXROdW1iZXIgKyAxO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dE51bWJlcjsgaSsrKSB7XHJcbiAgICAgIHR4Y29weS5vdXRwdXRzW2ldID0gbmV3IE91dHB1dCh7XHJcbiAgICAgICAgc2F0b3NoaXM6IEJOLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oQklUU182NF9PTiwgJ2hleCcpKSxcclxuICAgICAgICBzY3JpcHQ6IFNjcmlwdC5lbXB0eSgpXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHNpZ2hhc2hUeXBlICYgU2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSB7XHJcbiAgICB0eGNvcHkuaW5wdXRzID0gW3R4Y29weS5pbnB1dHNbaW5wdXROdW1iZXJdXTtcclxuICB9XHJcblxyXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyV3JpdGVyKClcclxuICAgIC53cml0ZSh0eGNvcHkudG9CdWZmZXIoKSlcclxuICAgIC53cml0ZUludDMyTEUoc2lnaGFzaFR5cGUpXHJcbiAgICAudG9CdWZmZXIoKTtcclxuICB2YXIgcmV0ID0gSGFzaC5zaGEyNTZzaGEyNTYoYnVmKTtcclxuICByZXQgPSBuZXcgQnVmZmVyUmVhZGVyKHJldCkucmVhZFJldmVyc2UoKTtcclxuICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIHNpZ25hdHVyZVxyXG4gKlxyXG4gKiBAbmFtZSBTaWduaW5nLnNpZ25cclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlS2V5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWdoYXNoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dEluZGV4XHJcbiAqIEBwYXJhbSB7U2NyaXB0fSBzdWJzY3JpcHRcclxuICogQHJldHVybiB7U2lnbmF0dXJlfVxyXG4gKi9cclxuZnVuY3Rpb24gc2lnbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgc2lnaGFzaFR5cGUsIGlucHV0SW5kZXgsIHN1YnNjcmlwdCkge1xyXG4gIGxldCBoYXNoYnVmID0gc2lnaGFzaCh0cmFuc2FjdGlvbiwgc2lnaGFzaFR5cGUsIGlucHV0SW5kZXgsIHN1YnNjcmlwdCk7XHJcbiAgcmV0dXJuIEVDRFNBLnNpZ24oaGFzaGJ1ZiwgcHJpdmF0ZUtleSwgJ2xpdHRsZScpLnNldCh7IG5oYXNodHlwZTogc2lnaGFzaFR5cGUgfSlcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWZXJpZnkgYSBzaWduYXR1cmVcclxuICpcclxuICogQG5hbWUgU2lnbmluZy52ZXJpZnlcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVibGljS2V5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dEluZGV4XHJcbiAqIEBwYXJhbSB7U2NyaXB0fSBzdWJzY3JpcHRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHZlcmlmeSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBwdWJsaWNLZXksIGlucHV0SW5kZXgsIHN1YnNjcmlwdCkge1xyXG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZCh0cmFuc2FjdGlvbiksIFwiVHJhbnNhY3Rpb24gVW5kZWZpbmVkXCIpO1xyXG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZChzaWduYXR1cmUpICYmICFfLmlzVW5kZWZpbmVkKHNpZ25hdHVyZS5uaGFzaHR5cGUpLCBcIlNpZ25hdHVyZSBVbmRlZmluZWRcIik7XHJcblxyXG4gIGxldCBoYXNoYnVmID0gc2lnaGFzaCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLm5oYXNodHlwZSwgaW5wdXRJbmRleCwgc3Vic2NyaXB0KTtcclxuICByZXR1cm4gRUNEU0EudmVyaWZ5KGhhc2hidWYsIHNpZ25hdHVyZSwgcHVibGljS2V5LCAnbGl0dGxlJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBTaWduaW5nXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBzaWdoYXNoOiBzaWdoYXNoLFxyXG4gIHNpZ246IHNpZ24sXHJcbiAgdmVyaWZ5OiB2ZXJpZnlcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/sighash.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/sighashschnorr.js":
/*!********************************************************!*\
  !*** ../bitcore-lib/lib/transaction/sighashschnorr.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\n/* jshint maxparams:5 */\r\n\r\nconst Signature = __webpack_require__(/*! ../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nconst Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nconst Schnorr = __webpack_require__(/*! ../crypto/schnorr */ \"../bitcore-lib/lib/crypto/schnorr.js\");\r\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"../bitcore-lib/lib/crypto/taggedhash.js\");\r\nconst PrivateKey = __webpack_require__(/*! ../privatekey */ \"../bitcore-lib/lib/privatekey.js\");\r\n\r\n/**\r\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\r\n * for witness v1 programs as defined by:\r\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\r\n *\r\n * @name Signing.sighash\r\n * @param {Transaction} transaction the transaction to sign\r\n * @param {Number} sighashType the type of the hash\r\n * @param {Number} inputNumber the input index for the signature\r\n * @param {Number} sigversion Taproot or Tapscript version number\r\n * @param {Object} execdata Object with directives and data for creating the signature hash\r\n */\r\nfunction _signatureHash(transaction, sighashType, inputNumber, sigversion, execdata) {\r\n  let extFlag, keyVersion;\r\n\r\n  switch (sigversion) {\r\n    case Signature.Version.TAPROOT:\r\n      extFlag = 0;\r\n      // keyVersion is not used and left uninitialized.\r\n      break;\r\n    case Signature.Version.TAPSCRIPT:\r\n      extFlag = 1;\r\n      // keyVersion must be 0 for now, representing the current version of\r\n      // 32-byte public keys in the tapscript signature opcode execution.\r\n      // An upgradable public key version (with a size not 32-byte) may\r\n      // request a different keyVersion with a new sigversion.\r\n      keyVersion = 0;\r\n      break;\r\n    default:\r\n      return false;\r\n  }\r\n  $.checkArgument(inputNumber < transaction.inputs.length, 'inputNumber is greater than number of inputs');\r\n\r\n  const ss = TaggedHash.TAPSIGHASH;\r\n\r\n  // Epoch\r\n  ss.writeUInt8(0);\r\n\r\n  // Hash type\r\n  const outputType = (sighashType == Signature.SIGHASH_DEFAULT) ? Signature.SIGHASH_ALL : (sighashType & Signature.SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\r\n  const inputType = sighashType & Signature.SIGHASH_INPUT_MASK;\r\n  if (!(sighashType <= 0x03 || (sighashType >= 0x81 && sighashType <= 0x83))) { // Check valid sighashtype (Signature.SIGHASH_*)\r\n    return false;\r\n  }\r\n  ss.writeUInt8(sighashType);\r\n\r\n  // Transaction level data\r\n  ss.writeInt32LE(transaction.version);\r\n  ss.writeUInt32LE(transaction.nLockTime);\r\n  if (inputType !== Signature.SIGHASH_ANYONECANPAY) {\r\n    const prevoutsBW = new BufferWriter();\r\n    const spentAmountsBW = new BufferWriter();\r\n    const spentScriptsBW = new BufferWriter();\r\n    const sequencesBW = new BufferWriter();\r\n\r\n    for(let vin of transaction.inputs) {\r\n      prevoutsBW.writeReverse(vin.prevTxId);\r\n      prevoutsBW.writeInt32LE(vin.outputIndex);\r\n\r\n      spentAmountsBW.writeUInt64LEBN(vin.output._satoshisBN);\r\n\r\n      const scriptBuf = vin.output.script.toBuffer();\r\n      spentScriptsBW.writeUInt8(scriptBuf.length);\r\n      spentScriptsBW.write(scriptBuf);\r\n\r\n      sequencesBW.writeUInt32LE(vin.sequenceNumber);\r\n    }\r\n\r\n    // ss << cache.m_prevouts_single_hash;\r\n    const prevoutsSingleHash = Hash.sha256(prevoutsBW.toBuffer());\r\n    ss.write(prevoutsSingleHash);\r\n\r\n    // ss << cache.m_spent_amounts_single_hash;\r\n    const spentAmountsSingleHash = Hash.sha256(spentAmountsBW.toBuffer());\r\n    ss.write(spentAmountsSingleHash);\r\n\r\n    // ss << cache.m_spent_scripts_single_hash;\r\n    const spentScriptsSingleHash = Hash.sha256(spentScriptsBW.toBuffer());\r\n    ss.write(spentScriptsSingleHash);\r\n\r\n    // ss << cache.m_sequences_single_hash;\r\n    const sequencesSingleHash = Hash.sha256(sequencesBW.toBuffer());\r\n    ss.write(sequencesSingleHash);\r\n  }\r\n  if (outputType === Signature.SIGHASH_ALL) {\r\n    const outputsBW = new BufferWriter();\r\n    for (let vout of transaction.outputs) {\r\n      outputsBW.write(vout.toBufferWriter().toBuffer());\r\n    }\r\n    // ss << cache.m_outputs_single_hash;\r\n    const outputsSingleHash = Hash.sha256(outputsBW.toBuffer());\r\n    ss.write(outputsSingleHash);\r\n  }\r\n\r\n  // Data about the input/prevout being spent\r\n  $.checkArgument(execdata.annexInit, 'missing or invalid annexInit');\r\n  const spendType = (extFlag << 1) + (execdata.annexPresent ? 1 : 0); // The low bit indicates whether an annex is present.\r\n  ss.writeUInt8(spendType);\r\n  if (inputType === Signature.SIGHASH_ANYONECANPAY) {\r\n    // ss << tx_to.vin[in_pos].prevout;\r\n    const buf = new BufferWriter();\r\n    buf.writeReverse(transaction.inputs[inputNumber].prevTxId);\r\n    buf.writeInt32LE(transaction.inputs[inputNumber].outputIndex);\r\n    ss.write(buf.toBuffer());\r\n    // ss << cache.m_spent_outputs[inputNumber];\r\n    ss.write(transaction.inputs[inputNumber].output.toBufferWriter().toBuffer());\r\n    ss.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\r\n  } else {\r\n    ss.writeUInt32LE(inputNumber);\r\n  }\r\n  if (execdata.annexPresent) {\r\n    ss.write(execdata.annexHash);\r\n  }\r\n\r\n  // Data about the output (if only one).\r\n  if (outputType === Signature.SIGHASH_SINGLE) {\r\n    if (inputNumber >= transaction.outputs.length) {\r\n      return false;\r\n    }\r\n    const bw = new BufferWriter();\r\n    bw.writeUInt64LEBN(transaction.outputs[inputNumber]._satoshisBN);\r\n    const buf = transaction.outputs[inputNumber].script.toBuffer();\r\n    bw.writeVarintNum(buf.length);\r\n    bw.write(buf);\r\n    ss.write(Hash.sha256(bw.toBuffer()));\r\n  }\r\n\r\n  // Additional data for BIP 342 signatures\r\n  if (sigversion == Signature.Version.TAPSCRIPT) {\r\n    $.checkArgument(execdata.tapleafHashInit, 'missing or invalid tapleafHashInit');\r\n    ss.write(execdata.tapleafHash);\r\n    ss.writeUInt8(keyVersion);\r\n    $.checkArgument(execdata.codeseparatorPosInit, 'missing or invalid codeseparatorPosInit');\r\n    ss.writeUInt32LE(execdata.codeseparatorPos);\r\n  }\r\n\r\n  // Return the SHA256 hash\r\n  return ss.finalize();\r\n};\r\n\r\n\r\nfunction _getExecData(sigversion, leafHash) {\r\n  const execdata = { annexInit: true, annexPresent: false };\r\n  if (sigversion === Signature.Version.TAPSCRIPT) {\r\n    execdata.codeseparatorPosInit = true;\r\n    execdata.codeseparatorPos = 0xFFFFFFFF; // Only support non-OP_CODESEPARATOR BIP342 signing for now.\r\n    if (!leafHash) return false; // BIP342 signing needs leaf hash.\r\n    execdata.tapleafHashInit = true;\r\n    execdata.tapleafHash = leafHash;\r\n  }\r\n  return execdata;\r\n}\r\n\r\n\r\n/**\r\n * Create a Schnorr signature\r\n *\r\n * @name Signing.sign\r\n * @param {Transaction} transaction\r\n * @param {Buffer|BN|PrivateKey} privateKey\r\n * @param {number} sighash\r\n * @param {number} inputIndex\r\n * @param {number} sigversion\r\n * @param {Buffer} leafHash\r\n * @return {Signature}\r\n */\r\nfunction sign(transaction, privateKey, sighashType, inputIndex, sigversion, leafHash) {\r\n  $.checkArgument(sigversion === Signature.Version.TAPROOT || sigversion === Signature.Version.TAPSCRIPT, 'Invalid sigversion');\r\n  \r\n  const execdata = _getExecData(sigversion, leafHash);\r\n  const hashbuf = _signatureHash(transaction, sighashType, inputIndex, sigversion, execdata);\r\n  if (!hashbuf) {\r\n    return false;\r\n  }\r\n  const sig = Schnorr.sign(privateKey, hashbuf);\r\n  if (sighashType !== Signature.SIGHASH_DEFAULT) {\r\n    return Buffer.concat([sig, Buffer.from([sighashType])]); // 65 bytes\r\n  }\r\n  return sig; // 64 bytes\r\n};\r\n\r\n\r\n/**\r\n * Verify a Schnorr signature\r\n *\r\n * @name Signing.verify\r\n * @param {Transaction} transaction\r\n * @param {Signature} signature\r\n * @param {PublicKey} publicKey\r\n * @param {Number} inputIndex\r\n * @param {object|Buffer|null} execdata If given, can be full execdata object or just the leafHash buffer\r\n * @return {Boolean}\r\n */\r\nfunction verify(transaction, signature, publicKey, sigversion, inputIndex, execdata) {\r\n  $.checkArgument(transaction != null, 'Transaction Undefined');\r\n\r\n  if (!execdata || Buffer.isBuffer(execdata)) {\r\n    const leafHash = execdata;\r\n    execdata = _getExecData(sigversion, leafHash);\r\n  }\r\n\r\n  $.checkArgument(execdata.annexInit, 'invalid execdata');\r\n\r\n  const hashbuf = _signatureHash(transaction, signature.nhashtype, inputIndex, sigversion, execdata);\r\n  if (!hashbuf) {\r\n    return false;\r\n  }\r\n  const verified = Schnorr.verify(publicKey, hashbuf, signature);\r\n  return verified;\r\n};\r\n\r\n/**\r\n * @namespace Signing\r\n */\r\nmodule.exports = {\r\n  sign: sign,\r\n  verify: verify\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2hzY2hub3JyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFxQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBMEI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLHlEQUFnQjtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQywrREFBbUI7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLHVFQUF1QjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxxRUFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsdURBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUlBQXlJO0FBQ3pJO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTSxjQUFjLE1BQU0sd0JBQXdCO0FBQzdEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2hzY2hub3JyLmpzP2ZjYzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoganNoaW50IG1heHBhcmFtczo1ICovXHJcblxyXG5jb25zdCBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9jcnlwdG8vc2lnbmF0dXJlJyk7XHJcbmNvbnN0IEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xyXG5jb25zdCBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcclxuY29uc3QgU2Nobm9yciA9IHJlcXVpcmUoJy4uL2NyeXB0by9zY2hub3JyJyk7XHJcbmNvbnN0ICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by90YWdnZWRoYXNoJyk7XHJcbmNvbnN0IFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRla2V5Jyk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGJ1ZmZlciBvZiBsZW5ndGggMzIgYnl0ZXMgd2l0aCB0aGUgaGFzaCB0aGF0IG5lZWRzIHRvIGJlIHNpZ25lZFxyXG4gKiBmb3Igd2l0bmVzcyB2MSBwcm9ncmFtcyBhcyBkZWZpbmVkIGJ5OlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxyXG4gKlxyXG4gKiBAbmFtZSBTaWduaW5nLnNpZ2hhc2hcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gdGhlIHRyYW5zYWN0aW9uIHRvIHNpZ25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ2hhc2hUeXBlIHRoZSB0eXBlIG9mIHRoZSBoYXNoXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnB1dE51bWJlciB0aGUgaW5wdXQgaW5kZXggZm9yIHRoZSBzaWduYXR1cmVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ3ZlcnNpb24gVGFwcm9vdCBvciBUYXBzY3JpcHQgdmVyc2lvbiBudW1iZXJcclxuICogQHBhcmFtIHtPYmplY3R9IGV4ZWNkYXRhIE9iamVjdCB3aXRoIGRpcmVjdGl2ZXMgYW5kIGRhdGEgZm9yIGNyZWF0aW5nIHRoZSBzaWduYXR1cmUgaGFzaFxyXG4gKi9cclxuZnVuY3Rpb24gX3NpZ25hdHVyZUhhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dE51bWJlciwgc2lndmVyc2lvbiwgZXhlY2RhdGEpIHtcclxuICBsZXQgZXh0RmxhZywga2V5VmVyc2lvbjtcclxuXHJcbiAgc3dpdGNoIChzaWd2ZXJzaW9uKSB7XHJcbiAgICBjYXNlIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFJPT1Q6XHJcbiAgICAgIGV4dEZsYWcgPSAwO1xyXG4gICAgICAvLyBrZXlWZXJzaW9uIGlzIG5vdCB1c2VkIGFuZCBsZWZ0IHVuaW5pdGlhbGl6ZWQuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQ6XHJcbiAgICAgIGV4dEZsYWcgPSAxO1xyXG4gICAgICAvLyBrZXlWZXJzaW9uIG11c3QgYmUgMCBmb3Igbm93LCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgdmVyc2lvbiBvZlxyXG4gICAgICAvLyAzMi1ieXRlIHB1YmxpYyBrZXlzIGluIHRoZSB0YXBzY3JpcHQgc2lnbmF0dXJlIG9wY29kZSBleGVjdXRpb24uXHJcbiAgICAgIC8vIEFuIHVwZ3JhZGFibGUgcHVibGljIGtleSB2ZXJzaW9uICh3aXRoIGEgc2l6ZSBub3QgMzItYnl0ZSkgbWF5XHJcbiAgICAgIC8vIHJlcXVlc3QgYSBkaWZmZXJlbnQga2V5VmVyc2lvbiB3aXRoIGEgbmV3IHNpZ3ZlcnNpb24uXHJcbiAgICAgIGtleVZlcnNpb24gPSAwO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgJC5jaGVja0FyZ3VtZW50KGlucHV0TnVtYmVyIDwgdHJhbnNhY3Rpb24uaW5wdXRzLmxlbmd0aCwgJ2lucHV0TnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBudW1iZXIgb2YgaW5wdXRzJyk7XHJcblxyXG4gIGNvbnN0IHNzID0gVGFnZ2VkSGFzaC5UQVBTSUdIQVNIO1xyXG5cclxuICAvLyBFcG9jaFxyXG4gIHNzLndyaXRlVUludDgoMCk7XHJcblxyXG4gIC8vIEhhc2ggdHlwZVxyXG4gIGNvbnN0IG91dHB1dFR5cGUgPSAoc2lnaGFzaFR5cGUgPT0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCkgPyBTaWduYXR1cmUuU0lHSEFTSF9BTEwgOiAoc2lnaGFzaFR5cGUgJiBTaWduYXR1cmUuU0lHSEFTSF9PVVRQVVRfTUFTSyk7IC8vIERlZmF1bHQgKG5vIHNpZ2hhc2ggYnl0ZSkgaXMgZXF1aXZhbGVudCB0byBTSUdIQVNIX0FMTFxyXG4gIGNvbnN0IGlucHV0VHlwZSA9IHNpZ2hhc2hUeXBlICYgU2lnbmF0dXJlLlNJR0hBU0hfSU5QVVRfTUFTSztcclxuICBpZiAoIShzaWdoYXNoVHlwZSA8PSAweDAzIHx8IChzaWdoYXNoVHlwZSA+PSAweDgxICYmIHNpZ2hhc2hUeXBlIDw9IDB4ODMpKSkgeyAvLyBDaGVjayB2YWxpZCBzaWdoYXNodHlwZSAoU2lnbmF0dXJlLlNJR0hBU0hfKilcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgc3Mud3JpdGVVSW50OChzaWdoYXNoVHlwZSk7XHJcblxyXG4gIC8vIFRyYW5zYWN0aW9uIGxldmVsIGRhdGFcclxuICBzcy53cml0ZUludDMyTEUodHJhbnNhY3Rpb24udmVyc2lvbik7XHJcbiAgc3Mud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5uTG9ja1RpbWUpO1xyXG4gIGlmIChpbnB1dFR5cGUgIT09IFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSkge1xyXG4gICAgY29uc3QgcHJldm91dHNCVyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICAgIGNvbnN0IHNwZW50QW1vdW50c0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gICAgY29uc3Qgc3BlbnRTY3JpcHRzQlcgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XHJcbiAgICBjb25zdCBzZXF1ZW5jZXNCVyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuXHJcbiAgICBmb3IobGV0IHZpbiBvZiB0cmFuc2FjdGlvbi5pbnB1dHMpIHtcclxuICAgICAgcHJldm91dHNCVy53cml0ZVJldmVyc2UodmluLnByZXZUeElkKTtcclxuICAgICAgcHJldm91dHNCVy53cml0ZUludDMyTEUodmluLm91dHB1dEluZGV4KTtcclxuXHJcbiAgICAgIHNwZW50QW1vdW50c0JXLndyaXRlVUludDY0TEVCTih2aW4ub3V0cHV0Ll9zYXRvc2hpc0JOKTtcclxuXHJcbiAgICAgIGNvbnN0IHNjcmlwdEJ1ZiA9IHZpbi5vdXRwdXQuc2NyaXB0LnRvQnVmZmVyKCk7XHJcbiAgICAgIHNwZW50U2NyaXB0c0JXLndyaXRlVUludDgoc2NyaXB0QnVmLmxlbmd0aCk7XHJcbiAgICAgIHNwZW50U2NyaXB0c0JXLndyaXRlKHNjcmlwdEJ1Zik7XHJcblxyXG4gICAgICBzZXF1ZW5jZXNCVy53cml0ZVVJbnQzMkxFKHZpbi5zZXF1ZW5jZU51bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3MgPDwgY2FjaGUubV9wcmV2b3V0c19zaW5nbGVfaGFzaDtcclxuICAgIGNvbnN0IHByZXZvdXRzU2luZ2xlSGFzaCA9IEhhc2guc2hhMjU2KHByZXZvdXRzQlcudG9CdWZmZXIoKSk7XHJcbiAgICBzcy53cml0ZShwcmV2b3V0c1NpbmdsZUhhc2gpO1xyXG5cclxuICAgIC8vIHNzIDw8IGNhY2hlLm1fc3BlbnRfYW1vdW50c19zaW5nbGVfaGFzaDtcclxuICAgIGNvbnN0IHNwZW50QW1vdW50c1NpbmdsZUhhc2ggPSBIYXNoLnNoYTI1NihzcGVudEFtb3VudHNCVy50b0J1ZmZlcigpKTtcclxuICAgIHNzLndyaXRlKHNwZW50QW1vdW50c1NpbmdsZUhhc2gpO1xyXG5cclxuICAgIC8vIHNzIDw8IGNhY2hlLm1fc3BlbnRfc2NyaXB0c19zaW5nbGVfaGFzaDtcclxuICAgIGNvbnN0IHNwZW50U2NyaXB0c1NpbmdsZUhhc2ggPSBIYXNoLnNoYTI1NihzcGVudFNjcmlwdHNCVy50b0J1ZmZlcigpKTtcclxuICAgIHNzLndyaXRlKHNwZW50U2NyaXB0c1NpbmdsZUhhc2gpO1xyXG5cclxuICAgIC8vIHNzIDw8IGNhY2hlLm1fc2VxdWVuY2VzX3NpbmdsZV9oYXNoO1xyXG4gICAgY29uc3Qgc2VxdWVuY2VzU2luZ2xlSGFzaCA9IEhhc2guc2hhMjU2KHNlcXVlbmNlc0JXLnRvQnVmZmVyKCkpO1xyXG4gICAgc3Mud3JpdGUoc2VxdWVuY2VzU2luZ2xlSGFzaCk7XHJcbiAgfVxyXG4gIGlmIChvdXRwdXRUeXBlID09PSBTaWduYXR1cmUuU0lHSEFTSF9BTEwpIHtcclxuICAgIGNvbnN0IG91dHB1dHNCVyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICAgIGZvciAobGV0IHZvdXQgb2YgdHJhbnNhY3Rpb24ub3V0cHV0cykge1xyXG4gICAgICBvdXRwdXRzQlcud3JpdGUodm91dC50b0J1ZmZlcldyaXRlcigpLnRvQnVmZmVyKCkpO1xyXG4gICAgfVxyXG4gICAgLy8gc3MgPDwgY2FjaGUubV9vdXRwdXRzX3NpbmdsZV9oYXNoO1xyXG4gICAgY29uc3Qgb3V0cHV0c1NpbmdsZUhhc2ggPSBIYXNoLnNoYTI1NihvdXRwdXRzQlcudG9CdWZmZXIoKSk7XHJcbiAgICBzcy53cml0ZShvdXRwdXRzU2luZ2xlSGFzaCk7XHJcbiAgfVxyXG5cclxuICAvLyBEYXRhIGFib3V0IHRoZSBpbnB1dC9wcmV2b3V0IGJlaW5nIHNwZW50XHJcbiAgJC5jaGVja0FyZ3VtZW50KGV4ZWNkYXRhLmFubmV4SW5pdCwgJ21pc3Npbmcgb3IgaW52YWxpZCBhbm5leEluaXQnKTtcclxuICBjb25zdCBzcGVuZFR5cGUgPSAoZXh0RmxhZyA8PCAxKSArIChleGVjZGF0YS5hbm5leFByZXNlbnQgPyAxIDogMCk7IC8vIFRoZSBsb3cgYml0IGluZGljYXRlcyB3aGV0aGVyIGFuIGFubmV4IGlzIHByZXNlbnQuXHJcbiAgc3Mud3JpdGVVSW50OChzcGVuZFR5cGUpO1xyXG4gIGlmIChpbnB1dFR5cGUgPT09IFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSkge1xyXG4gICAgLy8gc3MgPDwgdHhfdG8udmluW2luX3Bvc10ucHJldm91dDtcclxuICAgIGNvbnN0IGJ1ZiA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICAgIGJ1Zi53cml0ZVJldmVyc2UodHJhbnNhY3Rpb24uaW5wdXRzW2lucHV0TnVtYmVyXS5wcmV2VHhJZCk7XHJcbiAgICBidWYud3JpdGVJbnQzMkxFKHRyYW5zYWN0aW9uLmlucHV0c1tpbnB1dE51bWJlcl0ub3V0cHV0SW5kZXgpO1xyXG4gICAgc3Mud3JpdGUoYnVmLnRvQnVmZmVyKCkpO1xyXG4gICAgLy8gc3MgPDwgY2FjaGUubV9zcGVudF9vdXRwdXRzW2lucHV0TnVtYmVyXTtcclxuICAgIHNzLndyaXRlKHRyYW5zYWN0aW9uLmlucHV0c1tpbnB1dE51bWJlcl0ub3V0cHV0LnRvQnVmZmVyV3JpdGVyKCkudG9CdWZmZXIoKSk7XHJcbiAgICBzcy53cml0ZVVJbnQzMkxFKHRyYW5zYWN0aW9uLmlucHV0c1tpbnB1dE51bWJlcl0uc2VxdWVuY2VOdW1iZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzcy53cml0ZVVJbnQzMkxFKGlucHV0TnVtYmVyKTtcclxuICB9XHJcbiAgaWYgKGV4ZWNkYXRhLmFubmV4UHJlc2VudCkge1xyXG4gICAgc3Mud3JpdGUoZXhlY2RhdGEuYW5uZXhIYXNoKTtcclxuICB9XHJcblxyXG4gIC8vIERhdGEgYWJvdXQgdGhlIG91dHB1dCAoaWYgb25seSBvbmUpLlxyXG4gIGlmIChvdXRwdXRUeXBlID09PSBTaWduYXR1cmUuU0lHSEFTSF9TSU5HTEUpIHtcclxuICAgIGlmIChpbnB1dE51bWJlciA+PSB0cmFuc2FjdGlvbi5vdXRwdXRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBidyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICAgIGJ3LndyaXRlVUludDY0TEVCTih0cmFuc2FjdGlvbi5vdXRwdXRzW2lucHV0TnVtYmVyXS5fc2F0b3NoaXNCTik7XHJcbiAgICBjb25zdCBidWYgPSB0cmFuc2FjdGlvbi5vdXRwdXRzW2lucHV0TnVtYmVyXS5zY3JpcHQudG9CdWZmZXIoKTtcclxuICAgIGJ3LndyaXRlVmFyaW50TnVtKGJ1Zi5sZW5ndGgpO1xyXG4gICAgYncud3JpdGUoYnVmKTtcclxuICAgIHNzLndyaXRlKEhhc2guc2hhMjU2KGJ3LnRvQnVmZmVyKCkpKTtcclxuICB9XHJcblxyXG4gIC8vIEFkZGl0aW9uYWwgZGF0YSBmb3IgQklQIDM0MiBzaWduYXR1cmVzXHJcbiAgaWYgKHNpZ3ZlcnNpb24gPT0gU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUKSB7XHJcbiAgICAkLmNoZWNrQXJndW1lbnQoZXhlY2RhdGEudGFwbGVhZkhhc2hJbml0LCAnbWlzc2luZyBvciBpbnZhbGlkIHRhcGxlYWZIYXNoSW5pdCcpO1xyXG4gICAgc3Mud3JpdGUoZXhlY2RhdGEudGFwbGVhZkhhc2gpO1xyXG4gICAgc3Mud3JpdGVVSW50OChrZXlWZXJzaW9uKTtcclxuICAgICQuY2hlY2tBcmd1bWVudChleGVjZGF0YS5jb2Rlc2VwYXJhdG9yUG9zSW5pdCwgJ21pc3Npbmcgb3IgaW52YWxpZCBjb2Rlc2VwYXJhdG9yUG9zSW5pdCcpO1xyXG4gICAgc3Mud3JpdGVVSW50MzJMRShleGVjZGF0YS5jb2Rlc2VwYXJhdG9yUG9zKTtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB0aGUgU0hBMjU2IGhhc2hcclxuICByZXR1cm4gc3MuZmluYWxpemUoKTtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBfZ2V0RXhlY0RhdGEoc2lndmVyc2lvbiwgbGVhZkhhc2gpIHtcclxuICBjb25zdCBleGVjZGF0YSA9IHsgYW5uZXhJbml0OiB0cnVlLCBhbm5leFByZXNlbnQ6IGZhbHNlIH07XHJcbiAgaWYgKHNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVCkge1xyXG4gICAgZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvc0luaXQgPSB0cnVlO1xyXG4gICAgZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvcyA9IDB4RkZGRkZGRkY7IC8vIE9ubHkgc3VwcG9ydCBub24tT1BfQ09ERVNFUEFSQVRPUiBCSVAzNDIgc2lnbmluZyBmb3Igbm93LlxyXG4gICAgaWYgKCFsZWFmSGFzaCkgcmV0dXJuIGZhbHNlOyAvLyBCSVAzNDIgc2lnbmluZyBuZWVkcyBsZWFmIGhhc2guXHJcbiAgICBleGVjZGF0YS50YXBsZWFmSGFzaEluaXQgPSB0cnVlO1xyXG4gICAgZXhlY2RhdGEudGFwbGVhZkhhc2ggPSBsZWFmSGFzaDtcclxuICB9XHJcbiAgcmV0dXJuIGV4ZWNkYXRhO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIFNjaG5vcnIgc2lnbmF0dXJlXHJcbiAqXHJcbiAqIEBuYW1lIFNpZ25pbmcuc2lnblxyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge0J1ZmZlcnxCTnxQcml2YXRlS2V5fSBwcml2YXRlS2V5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWdoYXNoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dEluZGV4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWd2ZXJzaW9uXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBsZWFmSGFzaFxyXG4gKiBAcmV0dXJuIHtTaWduYXR1cmV9XHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBzaWdoYXNoVHlwZSwgaW5wdXRJbmRleCwgc2lndmVyc2lvbiwgbGVhZkhhc2gpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uVEFQUk9PVCB8fCBzaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQsICdJbnZhbGlkIHNpZ3ZlcnNpb24nKTtcclxuICBcclxuICBjb25zdCBleGVjZGF0YSA9IF9nZXRFeGVjRGF0YShzaWd2ZXJzaW9uLCBsZWFmSGFzaCk7XHJcbiAgY29uc3QgaGFzaGJ1ZiA9IF9zaWduYXR1cmVIYXNoKHRyYW5zYWN0aW9uLCBzaWdoYXNoVHlwZSwgaW5wdXRJbmRleCwgc2lndmVyc2lvbiwgZXhlY2RhdGEpO1xyXG4gIGlmICghaGFzaGJ1Zikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCBzaWcgPSBTY2hub3JyLnNpZ24ocHJpdmF0ZUtleSwgaGFzaGJ1Zik7XHJcbiAgaWYgKHNpZ2hhc2hUeXBlICE9PSBTaWduYXR1cmUuU0lHSEFTSF9ERUZBVUxUKSB7XHJcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbc2lnLCBCdWZmZXIuZnJvbShbc2lnaGFzaFR5cGVdKV0pOyAvLyA2NSBieXRlc1xyXG4gIH1cclxuICByZXR1cm4gc2lnOyAvLyA2NCBieXRlc1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBWZXJpZnkgYSBTY2hub3JyIHNpZ25hdHVyZVxyXG4gKlxyXG4gKiBAbmFtZSBTaWduaW5nLnZlcmlmeVxyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJsaWNLZXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGlucHV0SW5kZXhcclxuICogQHBhcmFtIHtvYmplY3R8QnVmZmVyfG51bGx9IGV4ZWNkYXRhIElmIGdpdmVuLCBjYW4gYmUgZnVsbCBleGVjZGF0YSBvYmplY3Qgb3IganVzdCB0aGUgbGVhZkhhc2ggYnVmZmVyXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiB2ZXJpZnkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgcHVibGljS2V5LCBzaWd2ZXJzaW9uLCBpbnB1dEluZGV4LCBleGVjZGF0YSkge1xyXG4gICQuY2hlY2tBcmd1bWVudCh0cmFuc2FjdGlvbiAhPSBudWxsLCAnVHJhbnNhY3Rpb24gVW5kZWZpbmVkJyk7XHJcblxyXG4gIGlmICghZXhlY2RhdGEgfHwgQnVmZmVyLmlzQnVmZmVyKGV4ZWNkYXRhKSkge1xyXG4gICAgY29uc3QgbGVhZkhhc2ggPSBleGVjZGF0YTtcclxuICAgIGV4ZWNkYXRhID0gX2dldEV4ZWNEYXRhKHNpZ3ZlcnNpb24sIGxlYWZIYXNoKTtcclxuICB9XHJcblxyXG4gICQuY2hlY2tBcmd1bWVudChleGVjZGF0YS5hbm5leEluaXQsICdpbnZhbGlkIGV4ZWNkYXRhJyk7XHJcblxyXG4gIGNvbnN0IGhhc2hidWYgPSBfc2lnbmF0dXJlSGFzaCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLm5oYXNodHlwZSwgaW5wdXRJbmRleCwgc2lndmVyc2lvbiwgZXhlY2RhdGEpO1xyXG4gIGlmICghaGFzaGJ1Zikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCB2ZXJpZmllZCA9IFNjaG5vcnIudmVyaWZ5KHB1YmxpY0tleSwgaGFzaGJ1Ziwgc2lnbmF0dXJlKTtcclxuICByZXR1cm4gdmVyaWZpZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBTaWduaW5nXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBzaWduOiBzaWduLFxyXG4gIHZlcmlmeTogdmVyaWZ5XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/sighashschnorr.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/sighashwitness.js":
/*!********************************************************!*\
  !*** ../bitcore-lib/lib/transaction/sighashwitness.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\n/* jshint maxparams:5 */\r\n\r\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar Script = __webpack_require__(/*! ../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar ECDSA = __webpack_require__(/*! ../crypto/ecdsa */ \"../bitcore-lib/lib/crypto/ecdsa.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\n/**\r\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\r\n * for witness programs as defined by:\r\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\r\n *\r\n * @name Signing.sighash\r\n * @param {Transaction} transaction the transaction to sign\r\n * @param {number} sighashType the type of the hash\r\n * @param {number} inputNumber the input index for the signature\r\n * @param {Buffer} scriptCode\r\n * @param {Buffer} satoshisBuffer\r\n */\r\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\r\n  /* jshint maxstatements: 50 */\r\n\r\n  var hashPrevouts = Buffer.alloc(32);\r\n  var hashSequence = Buffer.alloc(32);\r\n  var hashOutputs = Buffer.alloc(32);\r\n\r\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\r\n    var buffers = [];\r\n    for (var n = 0; n < transaction.inputs.length; n++) {\r\n      var input = transaction.inputs[n];\r\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\r\n      buffers.push(prevTxIdBuffer);\r\n      var outputIndexBuffer = Buffer.alloc(4);\r\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\r\n      buffers.push(outputIndexBuffer);\r\n    }\r\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\r\n  }\r\n\r\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\r\n      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\r\n\r\n    var sequenceBuffers = [];\r\n    for (var m = 0; m < transaction.inputs.length; m++) {\r\n      var sequenceBuffer = Buffer.alloc(4);\r\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\r\n      sequenceBuffers.push(sequenceBuffer);\r\n    }\r\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\r\n  }\r\n\r\n  var outputWriter = new BufferWriter();\r\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\r\n    for (var p = 0; p < transaction.outputs.length; p++) {\r\n      transaction.outputs[p].toBufferWriter(outputWriter);\r\n    }\r\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\r\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\r\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\r\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\r\n  }\r\n\r\n  // Version\r\n  var writer = new BufferWriter();\r\n  writer.writeUInt32LE(transaction.version);\r\n\r\n  // Input prevouts/nSequence (none/all, depending on flags)\r\n  writer.write(hashPrevouts);\r\n  writer.write(hashSequence);\r\n\r\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\r\n  // The prevout may already be contained in hashPrevout, and the nSequence\r\n  // may already be contain in hashSequence.\r\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\r\n  writer.write(outpointId);\r\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\r\n\r\n  writer.write(scriptCode);\r\n\r\n  writer.write(satoshisBuffer);\r\n\r\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\r\n\r\n  // Outputs (none/one/all, depending on flags)\r\n  writer.write(hashOutputs);\r\n\r\n  // Locktime\r\n  writer.writeUInt32LE(transaction.nLockTime);\r\n\r\n  // Sighash type\r\n  writer.writeInt32LE(sighashType);\r\n\r\n  return Hash.sha256sha256(writer.toBuffer());\r\n\r\n};\r\n\r\n/**\r\n * Create a signature\r\n *\r\n * @name Signing.sign\r\n * @param {Transaction} transaction\r\n * @param {PrivateKey} privateKey\r\n * @param {number} sighash\r\n * @param {number} inputIndex\r\n * @param {Script} subscript\r\n * @return {Signature}\r\n */\r\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer) {\r\n  let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\r\n  return ECDSA.sign(hashbuf, privateKey).set({ nhashtype: sighashType });\r\n}\r\n\r\n/**\r\n * Verify a signature\r\n *\r\n * @name Signing.verify\r\n * @param {Transaction} transaction\r\n * @param {Signature} signature\r\n * @param {PublicKey} publicKey\r\n * @param {number} inputIndex\r\n * @param {Script} subscript\r\n * @return {boolean}\r\n */\r\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer) {\r\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\r\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\r\n\r\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\r\n  return ECDSA.verify(hashbuf, signature, publicKey);\r\n}\r\n\r\n/**\r\n * @namespace Signing\r\n */\r\nmodule.exports = {\r\n  sighash: sighash,\r\n  sign: sign,\r\n  verify: verify\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2h3aXRuZXNzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFxQjtBQUM3QyxhQUFhLG1CQUFPLENBQUMscURBQVc7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsNkVBQTBCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDZFQUEwQjtBQUNyRCxXQUFXLG1CQUFPLENBQUMseURBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQywyREFBaUI7QUFDckMsUUFBUSxtQkFBTyxDQUFDLHVFQUF1QjtBQUN2QyxRQUFRLG1CQUFPLENBQUMsNERBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0IscUJBQXFCLE1BQU07QUFDM0Isb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25ELDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vc2lnaGFzaHdpdG5lc3MuanM/OGNjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vKiBqc2hpbnQgbWF4cGFyYW1zOjUgKi9cclxuXHJcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9jcnlwdG8vc2lnbmF0dXJlJyk7XHJcbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcclxudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xyXG52YXIgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XHJcbnZhciBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcclxudmFyIEVDRFNBID0gcmVxdWlyZSgnLi4vY3J5cHRvL2VjZHNhJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGJ1ZmZlciBvZiBsZW5ndGggMzIgYnl0ZXMgd2l0aCB0aGUgaGFzaCB0aGF0IG5lZWRzIHRvIGJlIHNpZ25lZFxyXG4gKiBmb3Igd2l0bmVzcyBwcm9ncmFtcyBhcyBkZWZpbmVkIGJ5OlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMTQzLm1lZGlhd2lraVxyXG4gKlxyXG4gKiBAbmFtZSBTaWduaW5nLnNpZ2hhc2hcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gdGhlIHRyYW5zYWN0aW9uIHRvIHNpZ25cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ2hhc2hUeXBlIHRoZSB0eXBlIG9mIHRoZSBoYXNoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dE51bWJlciB0aGUgaW5wdXQgaW5kZXggZm9yIHRoZSBzaWduYXR1cmVcclxuICogQHBhcmFtIHtCdWZmZXJ9IHNjcmlwdENvZGVcclxuICogQHBhcmFtIHtCdWZmZXJ9IHNhdG9zaGlzQnVmZmVyXHJcbiAqL1xyXG52YXIgc2lnaGFzaCA9IGZ1bmN0aW9uIHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dE51bWJlciwgc2NyaXB0Q29kZSwgc2F0b3NoaXNCdWZmZXIpIHtcclxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogNTAgKi9cclxuXHJcbiAgdmFyIGhhc2hQcmV2b3V0cyA9IEJ1ZmZlci5hbGxvYygzMik7XHJcbiAgdmFyIGhhc2hTZXF1ZW5jZSA9IEJ1ZmZlci5hbGxvYygzMik7XHJcbiAgdmFyIGhhc2hPdXRwdXRzID0gQnVmZmVyLmFsbG9jKDMyKTtcclxuXHJcbiAgaWYgKCEoc2lnaGFzaFR5cGUgJiBTaWduYXR1cmUuU0lHSEFTSF9BTllPTkVDQU5QQVkpKSB7XHJcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xyXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0cmFuc2FjdGlvbi5pbnB1dHMubGVuZ3RoOyBuKyspIHtcclxuICAgICAgdmFyIGlucHV0ID0gdHJhbnNhY3Rpb24uaW5wdXRzW25dO1xyXG4gICAgICB2YXIgcHJldlR4SWRCdWZmZXIgPSBuZXcgQnVmZmVyUmVhZGVyKGlucHV0LnByZXZUeElkKS5yZWFkUmV2ZXJzZSgpO1xyXG4gICAgICBidWZmZXJzLnB1c2gocHJldlR4SWRCdWZmZXIpO1xyXG4gICAgICB2YXIgb3V0cHV0SW5kZXhCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XHJcbiAgICAgIG91dHB1dEluZGV4QnVmZmVyLndyaXRlVUludDMyTEUoaW5wdXQub3V0cHV0SW5kZXgsIDApO1xyXG4gICAgICBidWZmZXJzLnB1c2gob3V0cHV0SW5kZXhCdWZmZXIpO1xyXG4gICAgfVxyXG4gICAgaGFzaFByZXZvdXRzID0gSGFzaC5zaGEyNTZzaGEyNTYoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIShzaWdoYXNoVHlwZSAmIFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSkgJiZcclxuICAgICAgKHNpZ2hhc2hUeXBlICYgMHgxZikgIT09IFNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSAmJiAoc2lnaGFzaFR5cGUgJiAweDFmKSAhPT0gU2lnbmF0dXJlLlNJR0hBU0hfTk9ORSkge1xyXG5cclxuICAgIHZhciBzZXF1ZW5jZUJ1ZmZlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgdHJhbnNhY3Rpb24uaW5wdXRzLmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgIHZhciBzZXF1ZW5jZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcclxuICAgICAgc2VxdWVuY2VCdWZmZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbbV0uc2VxdWVuY2VOdW1iZXIsIDApO1xyXG4gICAgICBzZXF1ZW5jZUJ1ZmZlcnMucHVzaChzZXF1ZW5jZUJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBoYXNoU2VxdWVuY2UgPSBIYXNoLnNoYTI1NnNoYTI1NihCdWZmZXIuY29uY2F0KHNlcXVlbmNlQnVmZmVycykpO1xyXG4gIH1cclxuXHJcbiAgdmFyIG91dHB1dFdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICBpZiAoKHNpZ2hhc2hUeXBlICYgMHgxZikgIT09IFNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSAmJiAoc2lnaGFzaFR5cGUgJiAweDFmKSAhPT0gU2lnbmF0dXJlLlNJR0hBU0hfTk9ORSkge1xyXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCB0cmFuc2FjdGlvbi5vdXRwdXRzLmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgIHRyYW5zYWN0aW9uLm91dHB1dHNbcF0udG9CdWZmZXJXcml0ZXIob3V0cHV0V3JpdGVyKTtcclxuICAgIH1cclxuICAgIGhhc2hPdXRwdXRzID0gSGFzaC5zaGEyNTZzaGEyNTYob3V0cHV0V3JpdGVyLnRvQnVmZmVyKCkpO1xyXG4gIH0gZWxzZSBpZiAoKHNpZ2hhc2hUeXBlICYgMHgxZikgPT09IFNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSAmJiBpbnB1dE51bWJlciA8IHRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoKSB7XHJcbiAgICB0cmFuc2FjdGlvbi5vdXRwdXRzW2lucHV0TnVtYmVyXS50b0J1ZmZlcldyaXRlcihvdXRwdXRXcml0ZXIpO1xyXG4gICAgaGFzaE91dHB1dHMgPSBIYXNoLnNoYTI1NnNoYTI1NihvdXRwdXRXcml0ZXIudG9CdWZmZXIoKSk7XHJcbiAgfVxyXG5cclxuICAvLyBWZXJzaW9uXHJcbiAgdmFyIHdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi52ZXJzaW9uKTtcclxuXHJcbiAgLy8gSW5wdXQgcHJldm91dHMvblNlcXVlbmNlIChub25lL2FsbCwgZGVwZW5kaW5nIG9uIGZsYWdzKVxyXG4gIHdyaXRlci53cml0ZShoYXNoUHJldm91dHMpO1xyXG4gIHdyaXRlci53cml0ZShoYXNoU2VxdWVuY2UpO1xyXG5cclxuICAvLyBUaGUgaW5wdXQgYmVpbmcgc2lnbmVkIChyZXBsYWNpbmcgdGhlIHNjcmlwdFNpZyB3aXRoIHNjcmlwdENvZGUgKyBhbW91bnQpXHJcbiAgLy8gVGhlIHByZXZvdXQgbWF5IGFscmVhZHkgYmUgY29udGFpbmVkIGluIGhhc2hQcmV2b3V0LCBhbmQgdGhlIG5TZXF1ZW5jZVxyXG4gIC8vIG1heSBhbHJlYWR5IGJlIGNvbnRhaW4gaW4gaGFzaFNlcXVlbmNlLlxyXG4gIHZhciBvdXRwb2ludElkID0gbmV3IEJ1ZmZlclJlYWRlcih0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLnByZXZUeElkKS5yZWFkUmV2ZXJzZSgpO1xyXG4gIHdyaXRlci53cml0ZShvdXRwb2ludElkKTtcclxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLm91dHB1dEluZGV4KTtcclxuXHJcbiAgd3JpdGVyLndyaXRlKHNjcmlwdENvZGUpO1xyXG5cclxuICB3cml0ZXIud3JpdGUoc2F0b3NoaXNCdWZmZXIpO1xyXG5cclxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLnNlcXVlbmNlTnVtYmVyKTtcclxuXHJcbiAgLy8gT3V0cHV0cyAobm9uZS9vbmUvYWxsLCBkZXBlbmRpbmcgb24gZmxhZ3MpXHJcbiAgd3JpdGVyLndyaXRlKGhhc2hPdXRwdXRzKTtcclxuXHJcbiAgLy8gTG9ja3RpbWVcclxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5uTG9ja1RpbWUpO1xyXG5cclxuICAvLyBTaWdoYXNoIHR5cGVcclxuICB3cml0ZXIud3JpdGVJbnQzMkxFKHNpZ2hhc2hUeXBlKTtcclxuXHJcbiAgcmV0dXJuIEhhc2guc2hhMjU2c2hhMjU2KHdyaXRlci50b0J1ZmZlcigpKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgc2lnbmF0dXJlXHJcbiAqXHJcbiAqIEBuYW1lIFNpZ25pbmcuc2lnblxyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXlcclxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ2hhc2hcclxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0SW5kZXhcclxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdFxyXG4gKiBAcmV0dXJuIHtTaWduYXR1cmV9XHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBzaWdoYXNoVHlwZSwgaW5wdXRJbmRleCwgc2NyaXB0Q29kZSwgc2F0b3NoaXNCdWZmZXIpIHtcclxuICBsZXQgaGFzaGJ1ZiA9IHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dEluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XHJcbiAgcmV0dXJuIEVDRFNBLnNpZ24oaGFzaGJ1ZiwgcHJpdmF0ZUtleSkuc2V0KHsgbmhhc2h0eXBlOiBzaWdoYXNoVHlwZSB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZlcmlmeSBhIHNpZ25hdHVyZVxyXG4gKlxyXG4gKiBAbmFtZSBTaWduaW5nLnZlcmlmeVxyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJsaWNLZXlcclxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0SW5kZXhcclxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gdmVyaWZ5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHB1YmxpY0tleSwgaW5wdXRJbmRleCwgc2NyaXB0Q29kZSwgc2F0b3NoaXNCdWZmZXIpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQodHJhbnNhY3Rpb24pLCBcIlRyYW5zYWN0aW9uIFVuZGVmaW5lZFwiKTtcclxuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQoc2lnbmF0dXJlKSAmJiAhXy5pc1VuZGVmaW5lZChzaWduYXR1cmUubmhhc2h0eXBlKSwgXCJTaWduYXR1cmUgVW5kZWZpbmVkXCIpO1xyXG5cclxuICBsZXQgaGFzaGJ1ZiA9IHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ25hdHVyZS5uaGFzaHR5cGUsIGlucHV0SW5kZXgsIHNjcmlwdENvZGUsIHNhdG9zaGlzQnVmZmVyKTtcclxuICByZXR1cm4gRUNEU0EudmVyaWZ5KGhhc2hidWYsIHNpZ25hdHVyZSwgcHVibGljS2V5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgU2lnbmluZ1xyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgc2lnaGFzaDogc2lnaGFzaCxcclxuICBzaWduOiBzaWduLFxyXG4gIHZlcmlmeTogdmVyaWZ5XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/sighashwitness.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/signature.js":
/*!***************************************************!*\
  !*** ../bitcore-lib/lib/transaction/signature.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar inherits = __webpack_require__(/*! inherits */ \"../bitcore-lib/node_modules/inherits/inherits.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\n\r\nvar PublicKey = __webpack_require__(/*! ../publickey */ \"../bitcore-lib/lib/publickey.js\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\n\r\n/**\r\n * @desc\r\n * Wrapper around Signature with fields related to signing a transaction specifically\r\n *\r\n * @param {Object|string|TransactionSignature} arg\r\n * @constructor\r\n */\r\nfunction TransactionSignature(arg) {\r\n  if (!(this instanceof TransactionSignature)) {\r\n    return new TransactionSignature(arg);\r\n  }\r\n  if (arg instanceof TransactionSignature) {\r\n    return arg;\r\n  }\r\n  if (arg && typeof arg === 'object') {\r\n    return this._fromObject(arg);\r\n  }\r\n  throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object');\r\n}\r\ninherits(TransactionSignature, Signature);\r\n\r\nTransactionSignature.prototype._fromObject = function(arg) {\r\n  this._checkObjectArgs(arg);\r\n  this.publicKey = new PublicKey(arg.publicKey);\r\n  this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');\r\n  this.outputIndex = arg.outputIndex;\r\n  this.inputIndex = arg.inputIndex;\r\n  this.signature = (arg.signature instanceof Signature) ? arg.signature :\r\n                     BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) :\r\n                     Signature.fromString(arg.signature);\r\n  this.sigtype = arg.sigtype;\r\n  return this;\r\n};\r\n\r\nTransactionSignature.prototype._checkObjectArgs = function(arg) {\r\n  $.checkArgument(PublicKey(arg.publicKey), 'invalid publicKey');\r\n  $.checkArgument(arg.inputIndex != null, 'missing inputIndex');\r\n  $.checkArgument(arg.outputIndex != null, 'missing outputIndex');\r\n  $.checkState(!isNaN(arg.inputIndex), 'inputIndex must be a number');\r\n  $.checkState(!isNaN(arg.outputIndex), 'outputIndex must be a number');\r\n  $.checkArgument(arg.signature, 'missing signature');\r\n  $.checkArgument(arg.prevTxId, 'missing prevTxId');\r\n  $.checkState(arg.signature instanceof Signature ||\r\n               BufferUtil.isBuffer(arg.signature) ||\r\n               JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');\r\n  $.checkState(BufferUtil.isBuffer(arg.prevTxId) ||\r\n               JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');\r\n  $.checkArgument(arg.sigtype != null, 'missing sigtype');\r\n  $.checkState(!isNaN(arg.sigtype), 'sigtype must be a number');\r\n};\r\n\r\n/**\r\n * Serializes a transaction to a plain JS object\r\n * @return {Object}\r\n */\r\nTransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() {\r\n  return {\r\n    publicKey: this.publicKey.toString(),\r\n    prevTxId: this.prevTxId.toString('hex'),\r\n    outputIndex: this.outputIndex,\r\n    inputIndex: this.inputIndex,\r\n    signature: this.signature.toString(),\r\n    sigtype: this.sigtype\r\n  };\r\n};\r\n\r\n/**\r\n * Builds a TransactionSignature from an object\r\n * @param {Object} object\r\n * @return {TransactionSignature}\r\n */\r\nTransactionSignature.fromObject = function(object) {\r\n  $.checkArgument(object);\r\n  return new TransactionSignature(object);\r\n};\r\n\r\nmodule.exports = TransactionSignature;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLFFBQVEsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHlEQUFnQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsaURBQVk7QUFDakM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBYztBQUN0QyxhQUFhLG1CQUFPLENBQUMscURBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vc2lnbmF0dXJlLmpzP2E3MzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcclxudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xyXG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9qcycpO1xyXG5cclxudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4uL3B1YmxpY2tleScpO1xyXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XHJcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9jcnlwdG8vc2lnbmF0dXJlJyk7XHJcblxyXG4vKipcclxuICogQGRlc2NcclxuICogV3JhcHBlciBhcm91bmQgU2lnbmF0dXJlIHdpdGggZmllbGRzIHJlbGF0ZWQgdG8gc2lnbmluZyBhIHRyYW5zYWN0aW9uIHNwZWNpZmljYWxseVxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd8VHJhbnNhY3Rpb25TaWduYXR1cmV9IGFyZ1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIFRyYW5zYWN0aW9uU2lnbmF0dXJlKGFyZykge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2FjdGlvblNpZ25hdHVyZSkpIHtcclxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25TaWduYXR1cmUoYXJnKTtcclxuICB9XHJcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uU2lnbmF0dXJlKSB7XHJcbiAgICByZXR1cm4gYXJnO1xyXG4gIH1cclxuICBpZiAoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZnJvbU9iamVjdChhcmcpO1xyXG4gIH1cclxuICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudCgnVHJhbnNhY3Rpb25TaWduYXR1cmVzIG11c3QgYmUgaW5zdGFudGlhdGVkIGZyb20gYW4gb2JqZWN0Jyk7XHJcbn1cclxuaW5oZXJpdHMoVHJhbnNhY3Rpb25TaWduYXR1cmUsIFNpZ25hdHVyZSk7XHJcblxyXG5UcmFuc2FjdGlvblNpZ25hdHVyZS5wcm90b3R5cGUuX2Zyb21PYmplY3QgPSBmdW5jdGlvbihhcmcpIHtcclxuICB0aGlzLl9jaGVja09iamVjdEFyZ3MoYXJnKTtcclxuICB0aGlzLnB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoYXJnLnB1YmxpY0tleSk7XHJcbiAgdGhpcy5wcmV2VHhJZCA9IEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnLnByZXZUeElkKSA/IGFyZy5wcmV2VHhJZCA6IEJ1ZmZlci5mcm9tKGFyZy5wcmV2VHhJZCwgJ2hleCcpO1xyXG4gIHRoaXMub3V0cHV0SW5kZXggPSBhcmcub3V0cHV0SW5kZXg7XHJcbiAgdGhpcy5pbnB1dEluZGV4ID0gYXJnLmlucHV0SW5kZXg7XHJcbiAgdGhpcy5zaWduYXR1cmUgPSAoYXJnLnNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSkgPyBhcmcuc2lnbmF0dXJlIDpcclxuICAgICAgICAgICAgICAgICAgICAgQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcuc2lnbmF0dXJlKSA/IFNpZ25hdHVyZS5mcm9tQnVmZmVyKGFyZy5zaWduYXR1cmUpIDpcclxuICAgICAgICAgICAgICAgICAgICAgU2lnbmF0dXJlLmZyb21TdHJpbmcoYXJnLnNpZ25hdHVyZSk7XHJcbiAgdGhpcy5zaWd0eXBlID0gYXJnLnNpZ3R5cGU7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2FjdGlvblNpZ25hdHVyZS5wcm90b3R5cGUuX2NoZWNrT2JqZWN0QXJncyA9IGZ1bmN0aW9uKGFyZykge1xyXG4gICQuY2hlY2tBcmd1bWVudChQdWJsaWNLZXkoYXJnLnB1YmxpY0tleSksICdpbnZhbGlkIHB1YmxpY0tleScpO1xyXG4gICQuY2hlY2tBcmd1bWVudChhcmcuaW5wdXRJbmRleCAhPSBudWxsLCAnbWlzc2luZyBpbnB1dEluZGV4Jyk7XHJcbiAgJC5jaGVja0FyZ3VtZW50KGFyZy5vdXRwdXRJbmRleCAhPSBudWxsLCAnbWlzc2luZyBvdXRwdXRJbmRleCcpO1xyXG4gICQuY2hlY2tTdGF0ZSghaXNOYU4oYXJnLmlucHV0SW5kZXgpLCAnaW5wdXRJbmRleCBtdXN0IGJlIGEgbnVtYmVyJyk7XHJcbiAgJC5jaGVja1N0YXRlKCFpc05hTihhcmcub3V0cHV0SW5kZXgpLCAnb3V0cHV0SW5kZXggbXVzdCBiZSBhIG51bWJlcicpO1xyXG4gICQuY2hlY2tBcmd1bWVudChhcmcuc2lnbmF0dXJlLCAnbWlzc2luZyBzaWduYXR1cmUnKTtcclxuICAkLmNoZWNrQXJndW1lbnQoYXJnLnByZXZUeElkLCAnbWlzc2luZyBwcmV2VHhJZCcpO1xyXG4gICQuY2hlY2tTdGF0ZShhcmcuc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlIHx8XHJcbiAgICAgICAgICAgICAgIEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnLnNpZ25hdHVyZSkgfHxcclxuICAgICAgICAgICAgICAgSlNVdGlsLmlzSGV4YShhcmcuc2lnbmF0dXJlKSwgJ3NpZ25hdHVyZSBtdXN0IGJlIGEgYnVmZmVyIG9yIGhleGEgdmFsdWUnKTtcclxuICAkLmNoZWNrU3RhdGUoQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcucHJldlR4SWQpIHx8XHJcbiAgICAgICAgICAgICAgIEpTVXRpbC5pc0hleGEoYXJnLnByZXZUeElkKSwgJ3ByZXZUeElkIG11c3QgYmUgYSBidWZmZXIgb3IgaGV4YSB2YWx1ZScpO1xyXG4gICQuY2hlY2tBcmd1bWVudChhcmcuc2lndHlwZSAhPSBudWxsLCAnbWlzc2luZyBzaWd0eXBlJyk7XHJcbiAgJC5jaGVja1N0YXRlKCFpc05hTihhcmcuc2lndHlwZSksICdzaWd0eXBlIG11c3QgYmUgYSBudW1iZXInKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXJpYWxpemVzIGEgdHJhbnNhY3Rpb24gdG8gYSBwbGFpbiBKUyBvYmplY3RcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuVHJhbnNhY3Rpb25TaWduYXR1cmUucHJvdG90eXBlLnRvT2JqZWN0ID0gVHJhbnNhY3Rpb25TaWduYXR1cmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5LnRvU3RyaW5nKCksXHJcbiAgICBwcmV2VHhJZDogdGhpcy5wcmV2VHhJZC50b1N0cmluZygnaGV4JyksXHJcbiAgICBvdXRwdXRJbmRleDogdGhpcy5vdXRwdXRJbmRleCxcclxuICAgIGlucHV0SW5kZXg6IHRoaXMuaW5wdXRJbmRleCxcclxuICAgIHNpZ25hdHVyZTogdGhpcy5zaWduYXR1cmUudG9TdHJpbmcoKSxcclxuICAgIHNpZ3R5cGU6IHRoaXMuc2lndHlwZVxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQnVpbGRzIGEgVHJhbnNhY3Rpb25TaWduYXR1cmUgZnJvbSBhbiBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvblNpZ25hdHVyZX1cclxuICovXHJcblRyYW5zYWN0aW9uU2lnbmF0dXJlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QpIHtcclxuICAkLmNoZWNrQXJndW1lbnQob2JqZWN0KTtcclxuICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKG9iamVjdCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uU2lnbmF0dXJlO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/signature.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/transaction.js":
/*!*****************************************************!*\
  !*** ../bitcore-lib/lib/transaction/transaction.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\r\nvar compare = Buffer.compare || __webpack_require__(/*! buffer-compare */ \"../bitcore-lib/node_modules/buffer-compare/index.js\");\r\n\r\nvar errors = __webpack_require__(/*! ../errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"../bitcore-lib/lib/util/buffer.js\");\r\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"../bitcore-lib/lib/encoding/bufferreader.js\");\r\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"../bitcore-lib/lib/encoding/bufferwriter.js\");\r\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"../bitcore-lib/lib/crypto/hash.js\");\r\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"../bitcore-lib/lib/crypto/signature.js\");\r\nvar Sighash = __webpack_require__(/*! ./sighash */ \"../bitcore-lib/lib/transaction/sighash.js\");\r\nvar SighashWitness = __webpack_require__(/*! ./sighashwitness */ \"../bitcore-lib/lib/transaction/sighashwitness.js\");\r\nconst SighashSchnorr = __webpack_require__(/*! ./sighashschnorr */ \"../bitcore-lib/lib/transaction/sighashschnorr.js\");\r\n\r\nvar Address = __webpack_require__(/*! ../address */ \"../bitcore-lib/lib/address.js\");\r\nvar UnspentOutput = __webpack_require__(/*! ./unspentoutput */ \"../bitcore-lib/lib/transaction/unspentoutput.js\");\r\nvar Input = __webpack_require__(/*! ./input */ \"../bitcore-lib/lib/transaction/input/index.js\");\r\nvar PublicKeyHashInput = Input.PublicKeyHash;\r\nvar PublicKeyInput = Input.PublicKey;\r\nvar MultiSigScriptHashInput = Input.MultiSigScriptHash;\r\nvar MultiSigInput = Input.MultiSig;\r\nconst TaprootInput = Input.Taproot;\r\nvar Output = __webpack_require__(/*! ./output */ \"../bitcore-lib/lib/transaction/output.js\");\r\nvar Script = __webpack_require__(/*! ../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar PrivateKey = __webpack_require__(/*! ../privatekey */ \"../bitcore-lib/lib/privatekey.js\");\r\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"../bitcore-lib/lib/crypto/bn.js\");\r\n\r\n/**\r\n * Represents a transaction, a set of inputs and outputs to change ownership of tokens\r\n *\r\n * @param {*} serialized\r\n * @constructor\r\n */\r\nfunction Transaction(serialized, opts) {\r\n  if (!(this instanceof Transaction)) {\r\n    return new Transaction(serialized);\r\n  }\r\n  this.inputs = [];\r\n  this.outputs = [];\r\n  this._inputAmount = undefined;\r\n  this._outputAmount = undefined;\r\n\r\n  if (serialized) {\r\n    if (serialized instanceof Transaction) {\r\n      return Transaction.shallowCopy(serialized);\r\n    } else if (JSUtil.isHexa(serialized)) {\r\n      this.fromString(serialized);\r\n    } else if (BufferUtil.isBuffer(serialized)) {\r\n      this.fromBuffer(serialized);\r\n    } else if (_.isObject(serialized)) {\r\n      this.fromObject(serialized, opts);\r\n    } else {\r\n      throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');\r\n    }\r\n  } else {\r\n    this._newTransaction();\r\n  }\r\n}\r\nvar CURRENT_VERSION = 2;\r\nvar DEFAULT_NLOCKTIME = 0;\r\nvar MAX_BLOCK_SIZE = 1000000;\r\n\r\n// Minimum amount for an output for it not to be considered a dust output\r\nTransaction.DUST_AMOUNT = 546;\r\n\r\n// Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big difference\r\nTransaction.FEE_SECURITY_MARGIN = 150;\r\n\r\n// max amount of satoshis in circulation\r\nTransaction.MAX_MONEY = 21000000 * 1e8;\r\n\r\n// nlocktime limit to be considered block height rather than a timestamp\r\nTransaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;\r\n\r\n// Max value for an unsigned 32 bit value\r\nTransaction.NLOCKTIME_MAX_VALUE = 4294967295;\r\n\r\n// Value used for fee estimation (satoshis per kilobyte)\r\nTransaction.FEE_PER_KB = 100000;\r\n\r\n// Safe upper bound for change address script size in bytes\r\nTransaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;\r\nTransaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;\r\n\r\n/* Constructors and Serialization */\r\n\r\n/**\r\n * Create a 'shallow' copy of the transaction, by serializing and deserializing\r\n * it dropping any additional information that inputs and outputs may have hold\r\n *\r\n * @param {Transaction} transaction\r\n * @return {Transaction}\r\n */\r\nTransaction.shallowCopy = function(transaction) {\r\n  var copy = new Transaction(transaction.toBuffer());\r\n  return copy;\r\n};\r\n\r\nvar hashProperty = {\r\n  configurable: false,\r\n  enumerable: true,\r\n  get: function() {\r\n    this._hash = new BufferReader(this._getHash()).readReverse().toString('hex');\r\n    return this._hash;\r\n  }\r\n};\r\n\r\nvar witnessHashProperty = {\r\n  configurable: false,\r\n  enumerable: true,\r\n  get: function() {\r\n    return new BufferReader(this._getWitnessHash()).readReverse().toString('hex');\r\n  }\r\n};\r\n\r\nObject.defineProperty(Transaction.prototype, 'witnessHash', witnessHashProperty);\r\nObject.defineProperty(Transaction.prototype, 'hash', hashProperty);\r\nObject.defineProperty(Transaction.prototype, 'id', hashProperty);\r\n\r\nvar ioProperty = {\r\n  configurable: false,\r\n  enumerable: true,\r\n  get: function() {\r\n    return this._getInputAmount();\r\n  }\r\n};\r\nObject.defineProperty(Transaction.prototype, 'inputAmount', ioProperty);\r\nioProperty.get = function() {\r\n  return this._getOutputAmount();\r\n};\r\nObject.defineProperty(Transaction.prototype, 'outputAmount', ioProperty);\r\n\r\nObject.defineProperty(Transaction.prototype, 'size', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  get: function() {\r\n    return this._calculateSize();\r\n  }\r\n});\r\n\r\nObject.defineProperty(Transaction.prototype, 'vsize', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  get: function() {\r\n    return this._calculateVSize();\r\n  }\r\n});\r\n\r\nObject.defineProperty(Transaction.prototype, 'weight', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  get: function() {\r\n    return this._calculateWeight();\r\n  }\r\n});\r\n\r\n/**\r\n * Retrieve the little endian hash of the transaction (used for serialization)\r\n * @return {Buffer}\r\n */\r\nTransaction.prototype._getHash = function() {\r\n  return Hash.sha256sha256(this.toBuffer(true));\r\n};\r\n\r\n/**\r\n * Retrieve the little endian hash of the transaction including witness data\r\n * @return {Buffer}\r\n */\r\nTransaction.prototype._getWitnessHash = function() {\r\n  return Hash.sha256sha256(this.toBuffer(false));\r\n};\r\n\r\n/**\r\n * Retrieve a hexa string that can be used with bitcoind's CLI interface\r\n * (decoderawtransaction, sendrawtransaction)\r\n *\r\n * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,\r\n *   it's expected to contain a set of flags to skip certain tests:\r\n * * `disableAll`: disable all checks\r\n * * `disableSmallFees`: disable checking for fees that are too small\r\n * * `disableLargeFees`: disable checking for fees that are too large\r\n * * `disableIsFullySigned`: disable checking if all inputs are fully signed\r\n * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts\r\n * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than the sum of the input amounts\r\n * @return {string}\r\n */\r\nTransaction.prototype.serialize = function(unsafe) {\r\n  if (true === unsafe || unsafe && unsafe.disableAll) {\r\n    return this.uncheckedSerialize();\r\n  } else {\r\n    return this.checkedSerialize(unsafe);\r\n  }\r\n};\r\n\r\nTransaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {\r\n  return this.toBuffer().toString('hex');\r\n};\r\n\r\n/**\r\n * Retrieve a hexa string that can be used with bitcoind's CLI interface\r\n * (decoderawtransaction, sendrawtransaction)\r\n *\r\n * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\r\n * @return {string}\r\n */\r\nTransaction.prototype.checkedSerialize = function(opts) {\r\n  var serializationError = this.getSerializationError(opts);\r\n  if (serializationError) {\r\n    serializationError.message += ' - For more information please see: ' +\r\n      'https://github.com/bitpay/bitcore/blob/master/packages/bitcore-lib/docs/transaction.md#serialization-checks';\r\n    throw serializationError;\r\n  }\r\n  return this.uncheckedSerialize();\r\n};\r\n\r\nTransaction.prototype.invalidSatoshis = function() {\r\n  var invalid = false;\r\n  for (var i = 0; i < this.outputs.length; i++) {\r\n    if (this.outputs[i].invalidSatoshis()) {\r\n      invalid = true;\r\n    }\r\n  }\r\n  return invalid;\r\n};\r\n\r\n/**\r\n * Retrieve a possible error that could appear when trying to serialize and\r\n * broadcast this transaction.\r\n *\r\n * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\r\n * @return {bitcore.Error}\r\n */\r\nTransaction.prototype.getSerializationError = function(opts) {\r\n  opts = opts || {};\r\n\r\n  if (this.invalidSatoshis()) {\r\n    return new errors.Transaction.InvalidSatoshis();\r\n  }\r\n\r\n  var unspent = this._getUnspentValue();\r\n  var unspentError;\r\n  if (unspent < 0) {\r\n    if (!opts.disableMoreOutputThanInput) {\r\n      unspentError = new errors.Transaction.InvalidOutputAmountSum();\r\n    }\r\n  } else {\r\n    unspentError = this._hasFeeError(opts, unspent);\r\n  }\r\n\r\n  return unspentError ||\r\n    this._hasDustOutputs(opts) ||\r\n    this._isMissingSignatures(opts);\r\n};\r\n\r\nTransaction.prototype._hasFeeError = function(opts, unspent) {\r\n\r\n  if (this._fee != null && this._fee !== unspent) {\r\n    return new errors.Transaction.FeeError.Different(\r\n      'Unspent value is ' + unspent + ' but specified fee is ' + this._fee\r\n    );\r\n  }\r\n\r\n  if (!opts.disableLargeFees) {\r\n    var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());\r\n    if (unspent > maximumFee) {\r\n      if (this._missingChange()) {\r\n        return new errors.Transaction.ChangeAddressMissing(\r\n          'Fee is too large and no change address was provided'\r\n        );\r\n      }\r\n      return new errors.Transaction.FeeError.TooLarge(\r\n        'expected less than ' + maximumFee + ' but got ' + unspent\r\n      );\r\n    }\r\n  }\r\n\r\n  if (!opts.disableSmallFees) {\r\n    var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);\r\n    if (unspent < minimumFee) {\r\n      return new errors.Transaction.FeeError.TooSmall(\r\n        'expected more than ' + minimumFee + ' but got ' + unspent\r\n      );\r\n    }\r\n  }\r\n};\r\n\r\nTransaction.prototype._missingChange = function() {\r\n  return !this._changeScript;\r\n};\r\n\r\nTransaction.prototype._hasDustOutputs = function(opts) {\r\n  if (opts.disableDustOutputs) {\r\n    return;\r\n  }\r\n  var index, output;\r\n  for (index in this.outputs) {\r\n    output = this.outputs[index];\r\n    if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut()) {\r\n      return new errors.Transaction.DustOutputs();\r\n    }\r\n  }\r\n};\r\n\r\nTransaction.prototype._isMissingSignatures = function(opts) {\r\n  if (opts.disableIsFullySigned) {\r\n    return;\r\n  }\r\n  if (!this.isFullySigned()) {\r\n    return new errors.Transaction.MissingSignatures();\r\n  }\r\n};\r\n\r\nTransaction.prototype.inspect = function() {\r\n  return '<Transaction: ' + this.uncheckedSerialize() + '>';\r\n};\r\n\r\nTransaction.prototype.toBuffer = function(noWitness) {\r\n  var writer = new BufferWriter();\r\n  return this.toBufferWriter(writer, noWitness).toBuffer();\r\n};\r\n\r\nTransaction.prototype.hasWitnesses = function() {\r\n  for (var i = 0; i < this.inputs.length; i++) {\r\n    if (this.inputs[i].hasWitnesses()) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nTransaction.prototype.toBufferWriter = function(writer, noWitness) {\r\n  writer.writeInt32LE(this.version);\r\n\r\n  const hasWitnesses = this.hasWitnesses();\r\n\r\n  if (hasWitnesses && !noWitness) {\r\n    writer.write(Buffer.from('0001', 'hex'));\r\n  }\r\n\r\n  writer.writeVarintNum(this.inputs ? this.inputs.length : 0);\r\n  for (const input of this.inputs || []) {\r\n    input.toBufferWriter(writer);\r\n  }\r\n\r\n  writer.writeVarintNum(this.outputs ? this.outputs.length : 0);\r\n  for (const output of this.outputs || []) {\r\n    output.toBufferWriter(writer);\r\n  }\r\n\r\n  if (hasWitnesses && !noWitness) {\r\n    for (const input of this.inputs) {\r\n      const witnesses = input.getWitnesses();\r\n      writer.writeVarintNum(witnesses.length);\r\n      for (let j = 0; j < witnesses.length; j++) {\r\n        writer.writeVarintNum(witnesses[j].length);\r\n        writer.write(witnesses[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  writer.writeUInt32LE(this.nLockTime);\r\n  return writer;\r\n};\r\n\r\nTransaction.prototype.fromBuffer = function(buffer) {\r\n  var reader = new BufferReader(buffer);\r\n  return this.fromBufferReader(reader);\r\n};\r\n\r\nTransaction.prototype.fromBufferReader = function(reader) {\r\n  $.checkArgument(!reader.finished(), 'No transaction data received');\r\n\r\n  this.version = reader.readInt32LE();\r\n  var sizeTxIns = reader.readVarintNum();\r\n\r\n  // check for segwit\r\n  var hasWitnesses = false;\r\n  if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) {\r\n    reader.pos += 1;\r\n    hasWitnesses = true;\r\n    sizeTxIns = reader.readVarintNum();\r\n  }\r\n\r\n  for (var i = 0; i < sizeTxIns; i++) {\r\n    var input = Input.fromBufferReader(reader);\r\n    this.inputs.push(input);\r\n  }\r\n\r\n  var sizeTxOuts = reader.readVarintNum();\r\n  for (var j = 0; j < sizeTxOuts; j++) {\r\n    this.outputs.push(Output.fromBufferReader(reader));\r\n  }\r\n\r\n  if (hasWitnesses) {\r\n    for (var k = 0; k < sizeTxIns; k++) {\r\n      var itemCount = reader.readVarintNum();\r\n      var witnesses = [];\r\n      for (var l = 0; l < itemCount; l++) {\r\n        var size = reader.readVarintNum();\r\n        var item = reader.read(size);\r\n        witnesses.push(item);\r\n      }\r\n      this.inputs[k].setWitnesses(witnesses);\r\n    }\r\n  }\r\n\r\n  this.nLockTime = reader.readUInt32LE();\r\n  return this;\r\n};\r\n\r\n\r\nTransaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() {\r\n  var inputs = [];\r\n  this.inputs.forEach(function(input) {\r\n    inputs.push(input.toObject());\r\n  });\r\n  var outputs = [];\r\n  this.outputs.forEach(function(output) {\r\n    outputs.push(output.toObject());\r\n  });\r\n  var obj = {\r\n    hash: this.hash,\r\n    version: this.version,\r\n    inputs: inputs,\r\n    outputs: outputs,\r\n    nLockTime: this.nLockTime\r\n  };\r\n  if (this._changeScript) {\r\n    obj.changeScript = this._changeScript.toString();\r\n  }\r\n  if (this._changeIndex != null) {\r\n    obj.changeIndex = this._changeIndex;\r\n  }\r\n  if (this._fee != null) {\r\n    obj.fee = this._fee;\r\n  }\r\n  return obj;\r\n};\r\n\r\nTransaction.prototype.fromObject = function fromObject(arg, opts) {\r\n  /* jshint maxstatements: 20 */\r\n  $.checkArgument(_.isObject(arg) || arg instanceof Transaction);\r\n  var transaction;\r\n  if (arg instanceof Transaction) {\r\n    transaction = arg.toObject();\r\n  } else {\r\n    transaction = arg;\r\n  }\r\n  for (const input of transaction.inputs || []) {\r\n    if (!input.output || !input.output.script) {\r\n      this.uncheckedAddInput(new Input(input));\r\n      continue;\r\n    }\r\n    var script = new Script(input.output.script);\r\n    var txin;\r\n    if ((script.isScriptHashOut() || script.isWitnessScriptHashOut()) && input.publicKeys && input.threshold) {\r\n      txin = new Input.MultiSigScriptHash(\r\n        input, input.publicKeys, input.threshold, input.signatures, opts\r\n      );\r\n    } else if (script.isPublicKeyHashOut() || script.isWitnessPublicKeyHashOut() || script.isScriptHashOut()) {\r\n      txin = new Input.PublicKeyHash(input);\r\n    } else if (script.isPublicKeyOut()) {\r\n      txin = new Input.PublicKey(input);\r\n    } else {\r\n      throw new errors.Transaction.Input.UnsupportedScript(input.output.script);\r\n    }\r\n    this.addInput(txin);\r\n  }\r\n  for (const output of transaction.outputs || []) {\r\n    this.addOutput(new Output(output));\r\n  }\r\n  if (transaction.changeIndex) {\r\n    this._changeIndex = transaction.changeIndex;\r\n  }\r\n  if (transaction.changeScript) {\r\n    this._changeScript = new Script(transaction.changeScript);\r\n  }\r\n  if (transaction.fee) {\r\n    this._fee = transaction.fee;\r\n  }\r\n  this.nLockTime = transaction.nLockTime;\r\n  this.version = transaction.version;\r\n  this._checkConsistency(arg);\r\n  return this;\r\n};\r\n\r\nTransaction.prototype._checkConsistency = function(arg) {\r\n  if (this._changeIndex != null) {\r\n    $.checkState(this._changeScript, 'Change script is expected.');\r\n    $.checkState(this.outputs[this._changeIndex], 'Change index points to undefined output.');\r\n    $.checkState(this.outputs[this._changeIndex].script.toString() ===\r\n      this._changeScript.toString(), 'Change output has an unexpected script.');\r\n  }\r\n  if (arg && arg.hash) {\r\n    $.checkState(arg.hash === this.hash, 'Hash in object does not match transaction hash.');\r\n  }\r\n};\r\n\r\n/**\r\n * Sets nLockTime so that transaction is not valid until the desired date(a\r\n * timestamp in seconds since UNIX epoch is also accepted)\r\n *\r\n * @param {Date | Number} time\r\n * @return {Transaction} this\r\n */\r\nTransaction.prototype.lockUntilDate = function(time) {\r\n  $.checkArgument(time);\r\n  if (!isNaN(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\r\n    throw new errors.Transaction.LockTimeTooEarly();\r\n  }\r\n  if (_.isDate(time)) {\r\n    time = time.getTime() / 1000;\r\n  }\r\n\r\n  for (var i = 0; i < this.inputs.length; i++) {\r\n    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){\r\n      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\r\n    }\r\n  }\r\n\r\n  this.nLockTime = time;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets nLockTime so that transaction is not valid until the desired block\r\n * height.\r\n *\r\n * @param {Number} height\r\n * @return {Transaction} this\r\n */\r\nTransaction.prototype.lockUntilBlockHeight = function(height) {\r\n  $.checkArgument(!isNaN(height));\r\n  if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\r\n    throw new errors.Transaction.BlockHeightTooHigh();\r\n  }\r\n  if (height < 0) {\r\n    throw new errors.Transaction.NLockTimeOutOfRange();\r\n  }\r\n\r\n  for (var i = 0; i < this.inputs.length; i++) {\r\n    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){\r\n      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\r\n    }\r\n  }\r\n\r\n\r\n  this.nLockTime = height;\r\n  return this;\r\n};\r\n\r\n/**\r\n *  Returns a semantic version of the transaction's nLockTime.\r\n *  @return {Number|Date}\r\n *  If nLockTime is 0, it returns null,\r\n *  if it is < 500000000, it returns a block height (number)\r\n *  else it returns a Date object.\r\n */\r\nTransaction.prototype.getLockTime = function() {\r\n  if (!this.nLockTime) {\r\n    return null;\r\n  }\r\n  if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\r\n    return this.nLockTime;\r\n  }\r\n  return new Date(1000 * this.nLockTime);\r\n};\r\n\r\nTransaction.prototype.fromString = function(string) {\r\n  this.fromBuffer(buffer.Buffer.from(string, 'hex'));\r\n};\r\n\r\nTransaction.prototype._newTransaction = function() {\r\n  this.version = CURRENT_VERSION;\r\n  this.nLockTime = DEFAULT_NLOCKTIME;\r\n};\r\n\r\n/* Transaction creation interface */\r\n\r\n/**\r\n * @typedef {Object} Transaction~fromObject\r\n * @property {string} prevTxId\r\n * @property {number} outputIndex\r\n * @property {(Buffer|string|Script)} script\r\n * @property {number} satoshis\r\n */\r\n\r\n/**\r\n * Add an input to this transaction. This is a high level interface\r\n * to add an input, for more control, use @{link Transaction#addInput}.\r\n *\r\n * Can receive, as output information, the output of bitcoind's `listunspent` command,\r\n * and a slightly fancier format recognized by bitcore:\r\n *\r\n * ```\r\n * {\r\n *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',\r\n *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',\r\n *  outputIndex: 0,\r\n *  script: Script.empty(),\r\n *  satoshis: 1020000\r\n * }\r\n * ```\r\n * Where `address` can be either a string or a bitcore Address object. The\r\n * same is true for `script`, which can be a string or a bitcore Script.\r\n *\r\n * Beware that this resets all the signatures for inputs (in further versions,\r\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\r\n *\r\n * @example\r\n * ```javascript\r\n * var transaction = new Transaction();\r\n *\r\n * // From a pay to public key hash output from bitcoind's listunspent\r\n * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});\r\n *\r\n * // From a pay to public key hash output\r\n * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});\r\n *\r\n * // From a multisig P2SH output\r\n * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},\r\n *                  ['03000...', '02000...'], 2);\r\n * ```\r\n *\r\n * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} utxo\r\n * @param {Array=} pubkeys\r\n * @param {number=} threshold\r\n * @param {Object=} opts - Several options:\r\n *        - noSorting: defaults to false, if true and is multisig, don't\r\n *                      sort the given public keys before creating the script\r\n */\r\nTransaction.prototype.from = function(utxo, pubkeys, threshold, opts) {\r\n  if (Array.isArray(utxo)) {\r\n    for(const u of utxo) {\r\n      this.from(u, pubkeys, threshold, opts);\r\n    };\r\n    return this;\r\n  }\r\n  const exists = this.inputs.some(function(input) {\r\n    // TODO: Maybe prevTxId should be a string? Or defined as read only property?\r\n    return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex;\r\n  });\r\n  if (exists) {\r\n    return this;\r\n  }\r\n  if (pubkeys && threshold) {\r\n    this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);\r\n  } else {\r\n    this._fromNonP2SH(utxo, opts);\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * associateInputs - Update inputs with utxos, allowing you to specify value, and pubkey.\r\n * Populating these inputs allows for them to be signed with .sign(privKeys)\r\n *\r\n * @param {Array<Object>} utxos\r\n * @param {Array<string | PublicKey>} pubkeys\r\n * @param {number} threshold\r\n * @param {Object} opts\r\n * @returns {Array<number>}\r\n */\r\nTransaction.prototype.associateInputs = function(utxos, pubkeys, threshold, opts = {}) {\r\n  let indexes = [];\r\n  for(let utxo of utxos) {\r\n    const index = this.inputs.findIndex(i => i.prevTxId.toString('hex') === utxo.txId && i.outputIndex === utxo.outputIndex);\r\n    indexes.push(index);\r\n    if(index >= 0) {\r\n      const sequenceNumber = this.inputs[index].sequenceNumber; // preserve the set sequence number\r\n      this.inputs[index] = this._getInputFrom(utxo, pubkeys, threshold, opts);\r\n      this.inputs[index].sequenceNumber = sequenceNumber;\r\n    }\r\n  }\r\n  return indexes;\r\n}\r\n\r\n\r\nTransaction.prototype._selectInputType = function(utxo, pubkeys, threshold) {\r\n  var clazz;\r\n  utxo = new UnspentOutput(utxo);\r\n  if(pubkeys && threshold) {\r\n    if (utxo.script.isMultisigOut()) {\r\n      clazz = MultiSigInput;\r\n    } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {\r\n      clazz = MultiSigScriptHashInput;\r\n    }\r\n  } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {\r\n    clazz = PublicKeyHashInput;\r\n  } else if (utxo.script.isTaproot()) {\r\n    clazz = TaprootInput;\r\n  } else if (utxo.script.isPublicKeyOut()) {\r\n    clazz = PublicKeyInput;\r\n  } else {\r\n    clazz = Input;\r\n  }\r\n  return clazz;\r\n}\r\n\r\n\r\nTransaction.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts = {}) {\r\n  utxo = new UnspentOutput(utxo);\r\n  const InputClass = this._selectInputType(utxo, pubkeys, threshold);\r\n  const input = {\r\n    output: new Output({\r\n      script: utxo.script,\r\n      satoshis: utxo.satoshis\r\n    }),\r\n    prevTxId: utxo.txId,\r\n    outputIndex: utxo.outputIndex,\r\n    sequenceNumber: opts.sequenceNumber,\r\n    script: Script.empty()\r\n  };\r\n  let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : []\r\n  return new InputClass(input, ...args);\r\n}\r\n\r\nTransaction.prototype._fromNonP2SH = function(utxo, opts) {\r\n  const input = this._getInputFrom(utxo, null, null, opts);\r\n  this.addInput(input);\r\n};\r\n\r\nTransaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {\r\n  $.checkArgument(threshold <= pubkeys.length,\r\n    'Number of required signatures must be greater than the number of public keys');\r\n  const input = this._getInputFrom(utxo, pubkeys, threshold, opts);\r\n  this.addInput(input);\r\n};\r\n\r\n/**\r\n * Add an input to this transaction. The input must be an instance of the `Input` class.\r\n * It should have information about the Output that it's spending, but if it's not already\r\n * set, two additional parameters, `outputScript` and `satoshis` can be provided.\r\n *\r\n * @param {Input} input\r\n * @param {String|Script} outputScript\r\n * @param {number} satoshis\r\n * @return Transaction this, for chaining\r\n */\r\nTransaction.prototype.addInput = function(input, outputScript, satoshis) {\r\n  $.checkArgumentType(input, Input, 'input');\r\n  if (!input.output && (outputScript == null || satoshis == null)) {\r\n    throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');\r\n  }\r\n  if (!input.output && outputScript && satoshis != null) {\r\n    outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);\r\n    $.checkArgumentType(satoshis, 'number', 'satoshis');\r\n    input.output = new Output({\r\n      script: outputScript,\r\n      satoshis: satoshis\r\n    });\r\n  }\r\n  return this.uncheckedAddInput(input);\r\n};\r\n\r\n/**\r\n * Add an input to this transaction, without checking that the input has information about\r\n * the output that it's spending.\r\n *\r\n * @param {Input} input\r\n * @return Transaction this, for chaining\r\n */\r\nTransaction.prototype.uncheckedAddInput = function(input) {\r\n  $.checkArgumentType(input, Input, 'input');\r\n  this.inputs.push(input);\r\n  this._inputAmount = undefined;\r\n  this._updateChangeOutput();\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns true if the transaction has enough info on all inputs to be correctly validated\r\n *\r\n * @return {boolean}\r\n */\r\nTransaction.prototype.hasAllUtxoInfo = function() {\r\n  return this.inputs.every(function(input) {\r\n    return !!input.output;\r\n  });\r\n};\r\n\r\n/**\r\n * Manually set the fee for this transaction. Beware that this resets all the signatures\r\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\r\n * be reset).\r\n *\r\n * @param {number} amount satoshis to be sent\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.fee = function(amount) {\r\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\r\n  this._fee = amount;\r\n  this._updateChangeOutput();\r\n  return this;\r\n};\r\n\r\n/**\r\n * Manually set the fee per KB for this transaction. Beware that this resets all the signatures\r\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\r\n * be reset).\r\n *\r\n * @param {number} amount satoshis per KB to be sent\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.feePerKb = function(amount) {\r\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\r\n  this._feePerKb = amount;\r\n  this._updateChangeOutput();\r\n  return this;\r\n};\r\n\r\n/**\r\n * Manually set the fee per Byte for this transaction. Beware that this resets all the signatures\r\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\r\n * be reset).\r\n * fee per Byte will be ignored if fee per KB is set\r\n *\r\n * @param {number} amount satoshis per Byte to be sent\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.feePerByte = function (amount) {\r\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\r\n  this._feePerByte = amount;\r\n  this._updateChangeOutput();\r\n  return this;\r\n};\r\n\r\n/* Output management */\r\n\r\n/**\r\n * Set the change address for this transaction\r\n *\r\n * Beware that this resets all the signatures for inputs (in further versions,\r\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\r\n *\r\n * @param {Address} address An address for change to be sent to.\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.change = function(address) {\r\n  $.checkArgument(address, 'address is required');\r\n  this._changeScript = Script.fromAddress(address);\r\n  this._updateChangeOutput();\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n * @return {Output} change output, if it exists\r\n */\r\nTransaction.prototype.getChangeOutput = function() {\r\n  if (this._changeIndex != null) {\r\n    return this.outputs[this._changeIndex];\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * @typedef {Object} Transaction~toObject\r\n * @property {(string|Address)} address\r\n * @property {number} satoshis\r\n */\r\n\r\n/**\r\n * Add an output to the transaction.\r\n *\r\n * Beware that this resets all the signatures for inputs (in further versions,\r\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\r\n *\r\n * @param {(string|Address|Array.<Transaction~toObject>)} address\r\n * @param {number} amount in satoshis\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.to = function(address, amount) {\r\n  if (Array.isArray(address)) {\r\n    for (const to of address) {\r\n      this.to(to.address, to.satoshis);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  $.checkArgument(\r\n    JSUtil.isNaturalNumber(amount),\r\n    'Amount is expected to be a positive integer'\r\n  );\r\n  this.addOutput(new Output({\r\n    script: Script(new Address(address)),\r\n    satoshis: amount\r\n  }));\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add an OP_RETURN output to the transaction.\r\n *\r\n * Beware that this resets all the signatures for inputs (in further versions,\r\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\r\n *\r\n * @param {Buffer|string} value the data to be stored in the OP_RETURN output.\r\n *    In case of a string, the UTF-8 representation will be stored\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.addData = function(value) {\r\n  this.addOutput(new Output({\r\n    script: Script.buildDataOut(value),\r\n    satoshis: 0\r\n  }));\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n * Add an output to the transaction.\r\n *\r\n * @param {Output} output the output to add.\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.addOutput = function(output) {\r\n  $.checkArgumentType(output, Output, 'output');\r\n  this._addOutput(output);\r\n  this._updateChangeOutput();\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n * Remove all outputs from the transaction.\r\n *\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.clearOutputs = function() {\r\n  this.outputs = [];\r\n  this._clearSignatures();\r\n  this._outputAmount = undefined;\r\n  this._changeIndex = undefined;\r\n  this._updateChangeOutput();\r\n  return this;\r\n};\r\n\r\n\r\nTransaction.prototype._addOutput = function(output) {\r\n  this.outputs.push(output);\r\n  this._outputAmount = undefined;\r\n};\r\n\r\n\r\n/**\r\n * Calculates or gets the total output amount in satoshis\r\n *\r\n * @return {Number} the transaction total output amount\r\n */\r\nTransaction.prototype._getOutputAmount = function() {\r\n  if (this._outputAmount == null) {\r\n    var self = this;\r\n    this._outputAmount = 0;\r\n    for (const output of this.outputs || []) {\r\n      self._outputAmount += output.satoshis;\r\n    }\r\n  }\r\n  return this._outputAmount;\r\n};\r\n\r\n\r\n/**\r\n * Calculates or gets the total input amount in satoshis\r\n *\r\n * @return {Number} the transaction total input amount\r\n */\r\nTransaction.prototype._getInputAmount = function() {\r\n  if (this._inputAmount == null) {\r\n    this._inputAmount = _.sumBy(this.inputs, function(input) {\r\n      if (input.output == null) {\r\n        throw new errors.Transaction.Input.MissingPreviousOutput();\r\n      }\r\n      return input.output.satoshis;\r\n    });\r\n  }\r\n  return this._inputAmount;\r\n};\r\n\r\nTransaction.prototype._updateChangeOutput = function(noClearSigs) {\r\n  if (!this._changeScript) {\r\n    return;\r\n  }\r\n  if (!noClearSigs) {\r\n    this._clearSignatures();\r\n  }\r\n  if (this._changeIndex != null) {\r\n    this._removeOutput(this._changeIndex);\r\n  }\r\n  var available = this._getUnspentValue();\r\n  var fee = this.getFee();\r\n  var changeAmount = available - fee;\r\n  if (changeAmount > Transaction.DUST_AMOUNT) {\r\n    this._changeIndex = this.outputs.length;\r\n    this._addOutput(new Output({\r\n      script: this._changeScript,\r\n      satoshis: changeAmount\r\n    }));\r\n  } else {\r\n    this._changeIndex = undefined;\r\n  }\r\n};\r\n/**\r\n * Calculates the fee of the transaction.\r\n *\r\n * If there's a fixed fee set, return that.\r\n *\r\n * If there is no change output set, the fee is the\r\n * total value of the outputs minus inputs. Note that\r\n * a serialized transaction only specifies the value\r\n * of its outputs. (The value of inputs are recorded\r\n * in the previous transaction outputs being spent.)\r\n * This method therefore raises a \"MissingPreviousOutput\"\r\n * error when called on a serialized transaction.\r\n *\r\n * If there's no fee set and no change address,\r\n * estimate the fee based on size.\r\n *\r\n * @return {Number} fee of this transaction in satoshis\r\n */\r\nTransaction.prototype.getFee = function() {\r\n  if (this.isCoinbase()) {\r\n    return 0;\r\n  }\r\n  if (this._fee != null) {\r\n    return this._fee;\r\n  }\r\n  // if no change output is set, fees should equal all the unspent amount\r\n  if (!this._changeScript) {\r\n    return this._getUnspentValue();\r\n  }\r\n  return this._estimateFee();\r\n};\r\n\r\n/**\r\n * Estimates fee from serialized transaction size in bytes.\r\n */\r\nTransaction.prototype._estimateFee = function () {\r\n  const estimatedSize = this._estimateSize();\r\n  const available = this._getUnspentValue();\r\n  const feeRate = this._feePerByte || (this._feePerKb || Transaction.FEE_PER_KB) / 1000;\r\n  function getFee(size) {\r\n    return size * feeRate;\r\n  }\r\n  const fee = Math.ceil(getFee(estimatedSize));\r\n  const feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(this._estimateSizeOfChangeOutput()));\r\n  if (!this._changeScript || available <= feeWithChange) {\r\n    return fee;\r\n  }\r\n  return feeWithChange;\r\n};\r\n\r\nTransaction.prototype._estimateSizeOfChangeOutput = function () {\r\n  if (!this._changeScript) {\r\n    return 0;\r\n  }\r\n  const scriptLen = this._changeScript.toBuffer().length;\r\n  // 8 bytes for satoshis + script size + actual script size\r\n  return 8 + BufferWriter.varintBufNum(scriptLen).length + scriptLen;\r\n};\r\n\r\nTransaction.prototype._getUnspentValue = function() {\r\n  return this._getInputAmount() - this._getOutputAmount();\r\n};\r\n\r\nTransaction.prototype._clearSignatures = function() {\r\n  for (const input of this.inputs || []) {\r\n    input.clearSignatures();\r\n  }\r\n};\r\n\r\n/**\r\n * Estimate the tx size before input signatures are added.\r\n */\r\nTransaction.prototype._estimateSize = function() {\r\n  let result = 4; // version\r\n\r\n  if (this.hasWitnesses()) {\r\n    result += .5;\r\n  }\r\n\r\n  result += BufferWriter.varintBufNum(this.inputs.length).length;\r\n  for (const input of this.inputs || []) {\r\n    result += input._estimateSize();\r\n  }\r\n\r\n  result += BufferWriter.varintBufNum(this.outputs.length).length;\r\n  for (const output of this.outputs || []) {\r\n    result += output.calculateSize();\r\n  }\r\n\r\n  result += 4; // nLockTime\r\n  return Math.ceil(result);\r\n};\r\n\r\nTransaction.prototype._calculateSize = function() {\r\n  return this.toBuffer().length;\r\n};\r\n\r\nTransaction.prototype._calculateVSize = function(noRound) {\r\n  const vsize = this._calculateWeight() / 4;\r\n  return noRound ? vsize : Math.ceil(vsize);\r\n};\r\n\r\nTransaction.prototype._calculateWeight = function() {\r\n  return (this.toBuffer(true).length * 3) + this.toBuffer(false).length;\r\n};\r\n\r\nTransaction.prototype._removeOutput = function(index) {\r\n  var output = this.outputs[index];\r\n  this.outputs = _.without(this.outputs, output);\r\n  this._outputAmount = undefined;\r\n};\r\n\r\nTransaction.prototype.removeOutput = function(index) {\r\n  this._removeOutput(index);\r\n  this._updateChangeOutput();\r\n};\r\n\r\n/**\r\n * Sort a transaction's inputs and outputs according to BIP69\r\n *\r\n * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}\r\n * @return {Transaction} this\r\n */\r\nTransaction.prototype.sort = function() {\r\n  this.sortInputs(function(inputs) {\r\n    var copy = Array.prototype.concat.apply([], inputs);\r\n    let i = 0;\r\n    copy.forEach((x) => { x.i = i++});\r\n    copy.sort(function(first, second) {\r\n     return compare(first.prevTxId, second.prevTxId)\r\n        || first.outputIndex - second.outputIndex\r\n        || first.i - second.i;  // to ensure stable sort\r\n    });\r\n    return copy;\r\n  });\r\n  this.sortOutputs(function(outputs) {\r\n    var copy = Array.prototype.concat.apply([], outputs);\r\n    let i = 0;\r\n    copy.forEach((x) => { x.i = i++});\r\n    copy.sort(function(first, second) {\r\n      return first.satoshis - second.satoshis\r\n        || compare(first.script.toBuffer(), second.script.toBuffer())\r\n        || first.i - second.i;  // to ensure stable sort\r\n    });\r\n    return copy;\r\n  });\r\n  return this;\r\n};\r\n\r\n/**\r\n * Randomize this transaction's outputs ordering. The shuffling algorithm is a\r\n * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle().\r\n *\r\n * @return {Transaction} this\r\n */\r\nTransaction.prototype.shuffleOutputs = function() {\r\n  return this.sortOutputs(_.shuffle);\r\n};\r\n\r\n/**\r\n * Sort this transaction's outputs, according to a given sorting function that\r\n * takes an array as argument and returns a new array, with the same elements\r\n * but with a different order. The argument function MUST NOT modify the order\r\n * of the original array\r\n *\r\n * @param {Function} sortingFunction\r\n * @return {Transaction} this\r\n */\r\nTransaction.prototype.sortOutputs = function(sortingFunction) {\r\n  var outs = sortingFunction(this.outputs);\r\n  return this._newOutputOrder(outs);\r\n};\r\n\r\n/**\r\n * Sort this transaction's inputs, according to a given sorting function that\r\n * takes an array as argument and returns a new array, with the same elements\r\n * but with a different order.\r\n *\r\n * @param {Function} sortingFunction\r\n * @return {Transaction} this\r\n */\r\nTransaction.prototype.sortInputs = function(sortingFunction) {\r\n  this.inputs = sortingFunction(this.inputs);\r\n  this._clearSignatures();\r\n  return this;\r\n};\r\n\r\nTransaction.prototype._newOutputOrder = function(newOutputs) {\r\n  var isInvalidSorting = (this.outputs.length !== newOutputs.length ||\r\n                          _.difference(this.outputs, newOutputs).length !== 0);\r\n  if (isInvalidSorting) {\r\n    throw new errors.Transaction.InvalidSorting();\r\n  }\r\n\r\n  if (this._changeIndex != null) {\r\n    var changeOutput = this.outputs[this._changeIndex];\r\n    this._changeIndex = newOutputs.indexOf(changeOutput);\r\n  }\r\n\r\n  this.outputs = newOutputs;\r\n  return this;\r\n};\r\n\r\nTransaction.prototype.removeInput = function(txId, outputIndex) {\r\n  var index;\r\n  if (!outputIndex && !isNaN(txId)) {\r\n    index = txId;\r\n  } else {\r\n    index = this.inputs.findIndex(function(input) {\r\n      return input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex;\r\n    });\r\n  }\r\n  if (index < 0 || index >= this.inputs.length) {\r\n    throw new errors.Transaction.InvalidIndex(index, this.inputs.length);\r\n  }\r\n  var input = this.inputs[index];\r\n  this.inputs = _.without(this.inputs, input);\r\n  this._inputAmount = undefined;\r\n  this._updateChangeOutput();\r\n};\r\n\r\n/* Signature handling */\r\n\r\n/**\r\n * Sign the transaction using one or more private keys.\r\n *\r\n * It tries to sign each input, verifying that the signature will be valid\r\n * (matches a public key).\r\n *\r\n * @param {Array|String|PrivateKey} privateKey\r\n * @param {number} sigtype\r\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\r\n * @param {Buffer|String} merkleRoot - merkle root for taproot signing\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.sign = function(privateKey, sigtype, signingMethod, merkleRoot) {\r\n  $.checkState(this.hasAllUtxoInfo(), 'Not all utxo information is available to sign the transaction.');\r\n  if (Array.isArray(privateKey)) {\r\n    for (const pk of privateKey) {\r\n      this.sign(pk, sigtype, signingMethod, merkleRoot);\r\n    }\r\n    return this;\r\n  }\r\n  for (const signature of this.getSignatures(privateKey, sigtype, signingMethod, merkleRoot)) {\r\n    this.applySignature(signature, signingMethod);\r\n  }\r\n  return this;\r\n};\r\n\r\nTransaction.prototype.getSignatures = function(privKey, sigtype, signingMethod, merkleRoot) {\r\n  if (typeof merkleRoot === 'string') {\r\n    merkleRoot = Buffer.from(merkleRoot, 'hex');\r\n  }\r\n  privKey = new PrivateKey(privKey);\r\n  const results = [];\r\n  const hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());\r\n  for (let i = 0; i < this.inputs.length; i++) {\r\n    const input = this.inputs[i];\r\n    for (const signature of input.getSignatures(this, privKey, i, sigtype, hashData, signingMethod, merkleRoot)) {\r\n      results.push(signature);\r\n    }\r\n  }\r\n  return results;\r\n};\r\n\r\n/**\r\n * Add a signature to the transaction\r\n *\r\n * @param {Object} signature\r\n * @param {number} signature.inputIndex\r\n * @param {number} signature.sigtype\r\n * @param {PublicKey} signature.publicKey\r\n * @param {Signature} signature.signature\r\n * @param {String} signingMethod - 'ecdsa' to sign transaction\r\n * @return {Transaction} this, for chaining\r\n */\r\nTransaction.prototype.applySignature = function(signature, signingMethod) {\r\n  this.inputs[signature.inputIndex].addSignature(this, signature, signingMethod);\r\n  return this;\r\n};\r\n\r\nTransaction.prototype.isFullySigned = function() {\r\n  for (const input of this.inputs || []) {\r\n    if (input.isFullySigned === Input.prototype.isFullySigned) {\r\n      throw new errors.Transaction.UnableToVerifySignature(\r\n        'Unrecognized script kind, or not enough information to execute script.' +\r\n        'This usually happens when creating a transaction from a serialized transaction'\r\n      );\r\n    }\r\n  }\r\n  return this.inputs.every(function(input) {\r\n    return input.isFullySigned();\r\n  });\r\n};\r\n\r\nTransaction.prototype.isValidSignature = function(signature, signingMethod) {\r\n  if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {\r\n    throw new errors.Transaction.UnableToVerifySignature(\r\n      'Unrecognized script kind, or not enough information to execute script.' +\r\n      'This usually happens when creating a transaction from a serialized transaction'\r\n    );\r\n  }\r\n  return this.inputs[signature.inputIndex].isValidSignature(this, signature, signingMethod);\r\n};\r\n\r\n\r\n/**\r\n * Verify ECDSA signature\r\n * @param {Signature} sig \r\n * @param {PublicKey} pubkey \r\n * @param {Number} nin \r\n * @param {Script} subscript \r\n * @param {Number} satoshis \r\n * @returns {Boolean}\r\n */\r\nTransaction.prototype.checkEcdsaSignature = function(sig, pubkey, nin, subscript, satoshis) {\r\n  var subscriptBuffer = subscript.toBuffer();\r\n  var scriptCodeWriter = new BufferWriter();\r\n  scriptCodeWriter.writeVarintNum(subscriptBuffer.length);\r\n  scriptCodeWriter.write(subscriptBuffer);\r\n\r\n  var satoshisBuffer;\r\n  if (satoshis) {\r\n    $.checkState(JSUtil.isNaturalNumber(satoshis), 'satoshis needs to be a natural number');\r\n    satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();\r\n  } else {\r\n    satoshisBuffer = this.inputs[nin].getSatoshisBuffer();\r\n  }\r\n  var verified = SighashWitness.verify(\r\n    this,\r\n    sig,\r\n    pubkey,\r\n    nin,\r\n    scriptCodeWriter.toBuffer(),\r\n    satoshisBuffer\r\n  );\r\n  return verified;\r\n};\r\n\r\n\r\n/**\r\n * Verify Schnorr signature\r\n * @param {Signature|Buffer} sig \r\n * @param {PublicKey|Buffer} pubkey \r\n * @param {Number} nin \r\n * @param {Number} sigversion \r\n * @param {Object} execdata \r\n * @returns {Boolean}\r\n */\r\nTransaction.prototype.checkSchnorrSignature = function(sig, pubkey, nin, sigversion, execdata) {\r\n  if ($.isType(pubkey, 'PublicKey')) {\r\n    pubkey = pubkey.point.x.toBuffer();\r\n  }\r\n  $.checkArgument(pubkey && pubkey.length === 32, 'Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.');\r\n\r\n  if (Buffer.isBuffer(sig)) {\r\n    if (sig.length !== 64 && sig.length !== 65) {\r\n      return false;\r\n    }\r\n    sig = Signature.fromSchnorr(sig);\r\n  }\r\n  // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\r\n  // abort script execution). This is implemented in Interpreter.evalChecksigTapscript, which won't invoke\r\n  // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\r\n  // size different from 64 or 65.\r\n  $.checkArgument(sig.isSchnorr, 'Signature must be schnorr');\r\n\r\n  if (!SighashSchnorr.verify(this, sig, pubkey, sigversion, nin, execdata)) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * This is here largely for legacy reasons. However, if the sig type\r\n * is already known (via sigversion), then it would be better to call\r\n * checkEcdsaSignature or checkSchnorrSignature directly.\r\n * @param {Signature|Buffer} sig Signature to verify\r\n * @param {PublicKey|Buffer} pubkey Public key used to verify sig\r\n * @param {Number} nin Tx input index to verify signature against\r\n * @param {Script} subscript ECDSA only\r\n * @param {Number} sigversion See Signature.Version for valid versions (default: 0 or Signature.Version.BASE)\r\n * @param {Number} satoshis ECDSA only\r\n * @param {Object} execdata Schnorr only\r\n * @returns {Boolean} whether the signature is valid for this transaction input\r\n */\r\nTransaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion, satoshis, execdata) {\r\n  if (sigversion == null) {\r\n    sigversion = Signature.Version.BASE;\r\n  }\r\n\r\n  switch(sigversion) {\r\n    case Signature.Version.WITNESS_V0:\r\n      return this.checkEcdsaSignature(sig, pubkey, nin, subscript, satoshis);\r\n    case Signature.Version.TAPROOT:\r\n    case Signature.Version.TAPSCRIPT:\r\n      return this.checkSchnorrSignature(sig, pubkey, nin, sigversion, execdata);\r\n    case Signature.Version.BASE:\r\n    default:\r\n      return Sighash.verify(this, sig, pubkey, nin, subscript);\r\n  }\r\n};\r\n\r\n/**\r\n * Check that a transaction passes basic sanity tests. If not, return a string\r\n * describing the error. This function contains the same logic as\r\n * CheckTransaction in bitcoin core.\r\n */\r\nTransaction.prototype.verify = function() {\r\n  // Basic checks that don't depend on any context\r\n  if (this.inputs.length === 0) {\r\n    return 'transaction txins empty';\r\n  }\r\n\r\n  if (this.outputs.length === 0) {\r\n    return 'transaction txouts empty';\r\n  }\r\n\r\n  // Check for negative or overflow output values\r\n  var valueoutbn = new BN(0);\r\n  for (var i = 0; i < this.outputs.length; i++) {\r\n    var txout = this.outputs[i];\r\n\r\n    if (txout.invalidSatoshis()) {\r\n      return 'transaction txout ' + i + ' satoshis is invalid';\r\n    }\r\n    if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {\r\n      return 'transaction txout ' + i + ' greater than MAX_MONEY';\r\n    }\r\n    valueoutbn = valueoutbn.add(txout._satoshisBN);\r\n    if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {\r\n      return 'transaction txout ' + i + ' total output greater than MAX_MONEY';\r\n    }\r\n  }\r\n\r\n  // Size limits\r\n  if (this.toBuffer().length > MAX_BLOCK_SIZE) {\r\n    return 'transaction over the maximum block size';\r\n  }\r\n\r\n  // Check for duplicate inputs\r\n  var txinmap = {};\r\n  for (i = 0; i < this.inputs.length; i++) {\r\n    var txin = this.inputs[i];\r\n\r\n    var inputid = txin.prevTxId + ':' + txin.outputIndex;\r\n    if (txinmap[inputid] != null) {\r\n      return 'transaction input ' + i + ' duplicate input';\r\n    }\r\n    txinmap[inputid] = true;\r\n  }\r\n\r\n  var isCoinbase = this.isCoinbase();\r\n  if (isCoinbase) {\r\n    var buf = this.inputs[0]._scriptBuffer;\r\n    if (buf.length < 2 || buf.length > 100) {\r\n      return 'coinbase transaction script size invalid';\r\n    }\r\n  } else {\r\n    for (i = 0; i < this.inputs.length; i++) {\r\n      if (this.inputs[i].isNull()) {\r\n        return 'transaction input ' + i + ' has null input';\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Analogous to bitcoind's IsCoinBase function in transaction.h\r\n */\r\nTransaction.prototype.isCoinbase = function() {\r\n  return (this.inputs.length === 1 && this.inputs[0].isNull());\r\n};\r\n\r\n/**\r\n * Determines if this transaction can be replaced in the mempool with another\r\n * transaction that provides a sufficiently higher fee (RBF).\r\n */\r\nTransaction.prototype.isRBF = function() {\r\n  for (var i = 0; i < this.inputs.length; i++) {\r\n    var input = this.inputs[i];\r\n    if (input.sequenceNumber < Input.MAXINT - 1) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Enable this transaction to be replaced in the mempool (RBF) if a transaction\r\n * includes a sufficiently higher fee. It will set the sequenceNumber to\r\n * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not\r\n * already enable RBF.\r\n */\r\nTransaction.prototype.enableRBF = function() {\r\n  for (var i = 0; i < this.inputs.length; i++) {\r\n    var input = this.inputs[i];\r\n    if (input.sequenceNumber >= Input.MAXINT - 1) {\r\n      input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\nTransaction.prototype.setVersion = function(version) {\r\n  $.checkArgument(\r\n    JSUtil.isNaturalNumber(version) && version <= CURRENT_VERSION,\r\n    'Wrong version number');\r\n  this.version = version;\r\n  return this;\r\n};\r\n\r\n\r\n\r\nmodule.exports = Transaction;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLDREQUFRO0FBQ3hCLFFBQVEsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGNBQWMsTUFBTSxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3hEO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHFEQUFXO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLHlEQUFnQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsaURBQVk7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsNkVBQTBCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDZFQUEwQjtBQUNyRCxXQUFXLG1CQUFPLENBQUMseURBQWdCO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFxQjtBQUM3QyxjQUFjLG1CQUFPLENBQUMsNERBQVc7QUFDakMscUJBQXFCLG1CQUFPLENBQUMsMEVBQWtCO0FBQy9DLHVCQUF1QixtQkFBTyxDQUFDLDBFQUFrQjtBQUNqRDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxpREFBWTtBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDN0MsWUFBWSxtQkFBTyxDQUFDLDhEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsMERBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHFEQUFXO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLHVEQUFlO0FBQ3hDLFNBQVMsbUJBQU8sQ0FBQyxxREFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047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QTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Y3Rpb24uanM/YWJmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xyXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XHJcbnZhciBjb21wYXJlID0gQnVmZmVyLmNvbXBhcmUgfHwgcmVxdWlyZSgnYnVmZmVyLWNvbXBhcmUnKTtcclxuXHJcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcclxudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xyXG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9qcycpO1xyXG52YXIgQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVycmVhZGVyJyk7XHJcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcclxudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xyXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xyXG52YXIgU2lnaGFzaCA9IHJlcXVpcmUoJy4vc2lnaGFzaCcpO1xyXG52YXIgU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuL3NpZ2hhc2h3aXRuZXNzJyk7XHJcbmNvbnN0IFNpZ2hhc2hTY2hub3JyID0gcmVxdWlyZSgnLi9zaWdoYXNoc2Nobm9ycicpO1xyXG5cclxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi9hZGRyZXNzJyk7XHJcbnZhciBVbnNwZW50T3V0cHV0ID0gcmVxdWlyZSgnLi91bnNwZW50b3V0cHV0Jyk7XHJcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcclxudmFyIFB1YmxpY0tleUhhc2hJbnB1dCA9IElucHV0LlB1YmxpY0tleUhhc2g7XHJcbnZhciBQdWJsaWNLZXlJbnB1dCA9IElucHV0LlB1YmxpY0tleTtcclxudmFyIE11bHRpU2lnU2NyaXB0SGFzaElucHV0ID0gSW5wdXQuTXVsdGlTaWdTY3JpcHRIYXNoO1xyXG52YXIgTXVsdGlTaWdJbnB1dCA9IElucHV0Lk11bHRpU2lnO1xyXG5jb25zdCBUYXByb290SW5wdXQgPSBJbnB1dC5UYXByb290O1xyXG52YXIgT3V0cHV0ID0gcmVxdWlyZSgnLi9vdXRwdXQnKTtcclxudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xyXG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGVrZXknKTtcclxudmFyIEJOID0gcmVxdWlyZSgnLi4vY3J5cHRvL2JuJyk7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHRyYW5zYWN0aW9uLCBhIHNldCBvZiBpbnB1dHMgYW5kIG91dHB1dHMgdG8gY2hhbmdlIG93bmVyc2hpcCBvZiB0b2tlbnNcclxuICpcclxuICogQHBhcmFtIHsqfSBzZXJpYWxpemVkXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gVHJhbnNhY3Rpb24oc2VyaWFsaXplZCwgb3B0cykge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcclxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oc2VyaWFsaXplZCk7XHJcbiAgfVxyXG4gIHRoaXMuaW5wdXRzID0gW107XHJcbiAgdGhpcy5vdXRwdXRzID0gW107XHJcbiAgdGhpcy5faW5wdXRBbW91bnQgPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5fb3V0cHV0QW1vdW50ID0gdW5kZWZpbmVkO1xyXG5cclxuICBpZiAoc2VyaWFsaXplZCkge1xyXG4gICAgaWYgKHNlcmlhbGl6ZWQgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikge1xyXG4gICAgICByZXR1cm4gVHJhbnNhY3Rpb24uc2hhbGxvd0NvcHkoc2VyaWFsaXplZCk7XHJcbiAgICB9IGVsc2UgaWYgKEpTVXRpbC5pc0hleGEoc2VyaWFsaXplZCkpIHtcclxuICAgICAgdGhpcy5mcm9tU3RyaW5nKHNlcmlhbGl6ZWQpO1xyXG4gICAgfSBlbHNlIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKHNlcmlhbGl6ZWQpKSB7XHJcbiAgICAgIHRoaXMuZnJvbUJ1ZmZlcihzZXJpYWxpemVkKTtcclxuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChzZXJpYWxpemVkKSkge1xyXG4gICAgICB0aGlzLmZyb21PYmplY3Qoc2VyaWFsaXplZCwgb3B0cyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudCgnTXVzdCBwcm92aWRlIGFuIG9iamVjdCBvciBzdHJpbmcgdG8gZGVzZXJpYWxpemUgYSB0cmFuc2FjdGlvbicpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLl9uZXdUcmFuc2FjdGlvbigpO1xyXG4gIH1cclxufVxyXG52YXIgQ1VSUkVOVF9WRVJTSU9OID0gMjtcclxudmFyIERFRkFVTFRfTkxPQ0tUSU1FID0gMDtcclxudmFyIE1BWF9CTE9DS19TSVpFID0gMTAwMDAwMDtcclxuXHJcbi8vIE1pbmltdW0gYW1vdW50IGZvciBhbiBvdXRwdXQgZm9yIGl0IG5vdCB0byBiZSBjb25zaWRlcmVkIGEgZHVzdCBvdXRwdXRcclxuVHJhbnNhY3Rpb24uRFVTVF9BTU9VTlQgPSA1NDY7XHJcblxyXG4vLyBNYXJnaW4gb2YgZXJyb3IgdG8gYWxsb3cgZmVlcyBpbiB0aGUgdmVjaW5pdHkgb2YgdGhlIGV4cGVjdGVkIHZhbHVlIGJ1dCBkb2Vzbid0IGFsbG93IGEgYmlnIGRpZmZlcmVuY2VcclxuVHJhbnNhY3Rpb24uRkVFX1NFQ1VSSVRZX01BUkdJTiA9IDE1MDtcclxuXHJcbi8vIG1heCBhbW91bnQgb2Ygc2F0b3NoaXMgaW4gY2lyY3VsYXRpb25cclxuVHJhbnNhY3Rpb24uTUFYX01PTkVZID0gMjEwMDAwMDAgKiAxZTg7XHJcblxyXG4vLyBubG9ja3RpbWUgbGltaXQgdG8gYmUgY29uc2lkZXJlZCBibG9jayBoZWlnaHQgcmF0aGVyIHRoYW4gYSB0aW1lc3RhbXBcclxuVHJhbnNhY3Rpb24uTkxPQ0tUSU1FX0JMT0NLSEVJR0hUX0xJTUlUID0gNWU4O1xyXG5cclxuLy8gTWF4IHZhbHVlIGZvciBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWVcclxuVHJhbnNhY3Rpb24uTkxPQ0tUSU1FX01BWF9WQUxVRSA9IDQyOTQ5NjcyOTU7XHJcblxyXG4vLyBWYWx1ZSB1c2VkIGZvciBmZWUgZXN0aW1hdGlvbiAoc2F0b3NoaXMgcGVyIGtpbG9ieXRlKVxyXG5UcmFuc2FjdGlvbi5GRUVfUEVSX0tCID0gMTAwMDAwO1xyXG5cclxuLy8gU2FmZSB1cHBlciBib3VuZCBmb3IgY2hhbmdlIGFkZHJlc3Mgc2NyaXB0IHNpemUgaW4gYnl0ZXNcclxuVHJhbnNhY3Rpb24uQ0hBTkdFX09VVFBVVF9NQVhfU0laRSA9IDIwICsgNCArIDM0ICsgNDtcclxuVHJhbnNhY3Rpb24uTUFYSU1VTV9FWFRSQV9TSVpFID0gNCArIDkgKyA5ICsgNDtcclxuXHJcbi8qIENvbnN0cnVjdG9ycyBhbmQgU2VyaWFsaXphdGlvbiAqL1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhICdzaGFsbG93JyBjb3B5IG9mIHRoZSB0cmFuc2FjdGlvbiwgYnkgc2VyaWFsaXppbmcgYW5kIGRlc2VyaWFsaXppbmdcclxuICogaXQgZHJvcHBpbmcgYW55IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdGhhdCBpbnB1dHMgYW5kIG91dHB1dHMgbWF5IGhhdmUgaG9sZFxyXG4gKlxyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn1cclxuICovXHJcblRyYW5zYWN0aW9uLnNoYWxsb3dDb3B5ID0gZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICB2YXIgY29weSA9IG5ldyBUcmFuc2FjdGlvbih0cmFuc2FjdGlvbi50b0J1ZmZlcigpKTtcclxuICByZXR1cm4gY29weTtcclxufTtcclxuXHJcbnZhciBoYXNoUHJvcGVydHkgPSB7XHJcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9oYXNoID0gbmV3IEJ1ZmZlclJlYWRlcih0aGlzLl9nZXRIYXNoKCkpLnJlYWRSZXZlcnNlKCkudG9TdHJpbmcoJ2hleCcpO1xyXG4gICAgcmV0dXJuIHRoaXMuX2hhc2g7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHdpdG5lc3NIYXNoUHJvcGVydHkgPSB7XHJcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IEJ1ZmZlclJlYWRlcih0aGlzLl9nZXRXaXRuZXNzSGFzaCgpKS5yZWFkUmV2ZXJzZSgpLnRvU3RyaW5nKCdoZXgnKTtcclxuICB9XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCAnd2l0bmVzc0hhc2gnLCB3aXRuZXNzSGFzaFByb3BlcnR5KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ2hhc2gnLCBoYXNoUHJvcGVydHkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCAnaWQnLCBoYXNoUHJvcGVydHkpO1xyXG5cclxudmFyIGlvUHJvcGVydHkgPSB7XHJcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0SW5wdXRBbW91bnQoKTtcclxuICB9XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsICdpbnB1dEFtb3VudCcsIGlvUHJvcGVydHkpO1xyXG5pb1Byb3BlcnR5LmdldCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLl9nZXRPdXRwdXRBbW91bnQoKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ291dHB1dEFtb3VudCcsIGlvUHJvcGVydHkpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ3NpemUnLCB7XHJcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVNpemUoKTtcclxuICB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ3ZzaXplJywge1xyXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVWU2l6ZSgpO1xyXG4gIH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCAnd2VpZ2h0Jywge1xyXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVXZWlnaHQoKTtcclxuICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlIHRoZSBsaXR0bGUgZW5kaWFuIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uICh1c2VkIGZvciBzZXJpYWxpemF0aW9uKVxyXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2dldEhhc2ggPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gSGFzaC5zaGEyNTZzaGEyNTYodGhpcy50b0J1ZmZlcih0cnVlKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgdGhlIGxpdHRsZSBlbmRpYW4gaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gaW5jbHVkaW5nIHdpdG5lc3MgZGF0YVxyXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2dldFdpdG5lc3NIYXNoID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIEhhc2guc2hhMjU2c2hhMjU2KHRoaXMudG9CdWZmZXIoZmFsc2UpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSBhIGhleGEgc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBiaXRjb2luZCdzIENMSSBpbnRlcmZhY2VcclxuICogKGRlY29kZXJhd3RyYW5zYWN0aW9uLCBzZW5kcmF3dHJhbnNhY3Rpb24pXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW49fSB1bnNhZmUgaWYgdHJ1ZSwgc2tpcCBhbGwgdGVzdHMuIGlmIGl0J3MgYW4gb2JqZWN0LFxyXG4gKiAgIGl0J3MgZXhwZWN0ZWQgdG8gY29udGFpbiBhIHNldCBvZiBmbGFncyB0byBza2lwIGNlcnRhaW4gdGVzdHM6XHJcbiAqICogYGRpc2FibGVBbGxgOiBkaXNhYmxlIGFsbCBjaGVja3NcclxuICogKiBgZGlzYWJsZVNtYWxsRmVlc2A6IGRpc2FibGUgY2hlY2tpbmcgZm9yIGZlZXMgdGhhdCBhcmUgdG9vIHNtYWxsXHJcbiAqICogYGRpc2FibGVMYXJnZUZlZXNgOiBkaXNhYmxlIGNoZWNraW5nIGZvciBmZWVzIHRoYXQgYXJlIHRvbyBsYXJnZVxyXG4gKiAqIGBkaXNhYmxlSXNGdWxseVNpZ25lZGA6IGRpc2FibGUgY2hlY2tpbmcgaWYgYWxsIGlucHV0cyBhcmUgZnVsbHkgc2lnbmVkXHJcbiAqICogYGRpc2FibGVEdXN0T3V0cHV0c2A6IGRpc2FibGUgY2hlY2tpbmcgaWYgdGhlcmUgYXJlIG5vIG91dHB1dHMgdGhhdCBhcmUgZHVzdCBhbW91bnRzXHJcbiAqICogYGRpc2FibGVNb3JlT3V0cHV0VGhhbklucHV0YDogZGlzYWJsZSBjaGVja2luZyBpZiB0aGUgdHJhbnNhY3Rpb24gc3BlbmRzIG1vcmUgYml0Y29pbnMgdGhhbiB0aGUgc3VtIG9mIHRoZSBpbnB1dCBhbW91bnRzXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbih1bnNhZmUpIHtcclxuICBpZiAodHJ1ZSA9PT0gdW5zYWZlIHx8IHVuc2FmZSAmJiB1bnNhZmUuZGlzYWJsZUFsbCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5jaGVja2VkU2VyaWFsaXplKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB0aGlzLmNoZWNrZWRTZXJpYWxpemUodW5zYWZlKTtcclxuICB9XHJcbn07XHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUudW5jaGVja2VkU2VyaWFsaXplID0gVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgYSBoZXhhIHN0cmluZyB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYml0Y29pbmQncyBDTEkgaW50ZXJmYWNlXHJcbiAqIChkZWNvZGVyYXd0cmFuc2FjdGlvbiwgc2VuZHJhd3RyYW5zYWN0aW9uKVxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBhbGxvd3MgdG8gc2tpcCBjZXJ0YWluIHRlc3RzLiB7QHNlZSBUcmFuc2FjdGlvbiNzZXJpYWxpemV9XHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5jaGVja2VkU2VyaWFsaXplID0gZnVuY3Rpb24ob3B0cykge1xyXG4gIHZhciBzZXJpYWxpemF0aW9uRXJyb3IgPSB0aGlzLmdldFNlcmlhbGl6YXRpb25FcnJvcihvcHRzKTtcclxuICBpZiAoc2VyaWFsaXphdGlvbkVycm9yKSB7XHJcbiAgICBzZXJpYWxpemF0aW9uRXJyb3IubWVzc2FnZSArPSAnIC0gRm9yIG1vcmUgaW5mb3JtYXRpb24gcGxlYXNlIHNlZTogJyArXHJcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vYml0cGF5L2JpdGNvcmUvYmxvYi9tYXN0ZXIvcGFja2FnZXMvYml0Y29yZS1saWIvZG9jcy90cmFuc2FjdGlvbi5tZCNzZXJpYWxpemF0aW9uLWNoZWNrcyc7XHJcbiAgICB0aHJvdyBzZXJpYWxpemF0aW9uRXJyb3I7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLnVuY2hlY2tlZFNlcmlhbGl6ZSgpO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmludmFsaWRTYXRvc2hpcyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBpbnZhbGlkID0gZmFsc2U7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICh0aGlzLm91dHB1dHNbaV0uaW52YWxpZFNhdG9zaGlzKCkpIHtcclxuICAgICAgaW52YWxpZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBpbnZhbGlkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlIGEgcG9zc2libGUgZXJyb3IgdGhhdCBjb3VsZCBhcHBlYXIgd2hlbiB0cnlpbmcgdG8gc2VyaWFsaXplIGFuZFxyXG4gKiBicm9hZGNhc3QgdGhpcyB0cmFuc2FjdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgYWxsb3dzIHRvIHNraXAgY2VydGFpbiB0ZXN0cy4ge0BzZWUgVHJhbnNhY3Rpb24jc2VyaWFsaXplfVxyXG4gKiBAcmV0dXJuIHtiaXRjb3JlLkVycm9yfVxyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldFNlcmlhbGl6YXRpb25FcnJvciA9IGZ1bmN0aW9uKG9wdHMpIHtcclxuICBvcHRzID0gb3B0cyB8fCB7fTtcclxuXHJcbiAgaWYgKHRoaXMuaW52YWxpZFNhdG9zaGlzKCkpIHtcclxuICAgIHJldHVybiBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkludmFsaWRTYXRvc2hpcygpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHVuc3BlbnQgPSB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcclxuICB2YXIgdW5zcGVudEVycm9yO1xyXG4gIGlmICh1bnNwZW50IDwgMCkge1xyXG4gICAgaWYgKCFvcHRzLmRpc2FibGVNb3JlT3V0cHV0VGhhbklucHV0KSB7XHJcbiAgICAgIHVuc3BlbnRFcnJvciA9IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW52YWxpZE91dHB1dEFtb3VudFN1bSgpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB1bnNwZW50RXJyb3IgPSB0aGlzLl9oYXNGZWVFcnJvcihvcHRzLCB1bnNwZW50KTtcclxuICB9XHJcblxyXG4gIHJldHVybiB1bnNwZW50RXJyb3IgfHxcclxuICAgIHRoaXMuX2hhc0R1c3RPdXRwdXRzKG9wdHMpIHx8XHJcbiAgICB0aGlzLl9pc01pc3NpbmdTaWduYXR1cmVzKG9wdHMpO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9oYXNGZWVFcnJvciA9IGZ1bmN0aW9uKG9wdHMsIHVuc3BlbnQpIHtcclxuXHJcbiAgaWYgKHRoaXMuX2ZlZSAhPSBudWxsICYmIHRoaXMuX2ZlZSAhPT0gdW5zcGVudCkge1xyXG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uRmVlRXJyb3IuRGlmZmVyZW50KFxyXG4gICAgICAnVW5zcGVudCB2YWx1ZSBpcyAnICsgdW5zcGVudCArICcgYnV0IHNwZWNpZmllZCBmZWUgaXMgJyArIHRoaXMuX2ZlZVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGlmICghb3B0cy5kaXNhYmxlTGFyZ2VGZWVzKSB7XHJcbiAgICB2YXIgbWF4aW11bUZlZSA9IE1hdGguZmxvb3IoVHJhbnNhY3Rpb24uRkVFX1NFQ1VSSVRZX01BUkdJTiAqIHRoaXMuX2VzdGltYXRlRmVlKCkpO1xyXG4gICAgaWYgKHVuc3BlbnQgPiBtYXhpbXVtRmVlKSB7XHJcbiAgICAgIGlmICh0aGlzLl9taXNzaW5nQ2hhbmdlKCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5DaGFuZ2VBZGRyZXNzTWlzc2luZyhcclxuICAgICAgICAgICdGZWUgaXMgdG9vIGxhcmdlIGFuZCBubyBjaGFuZ2UgYWRkcmVzcyB3YXMgcHJvdmlkZWQnXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5GZWVFcnJvci5Ub29MYXJnZShcclxuICAgICAgICAnZXhwZWN0ZWQgbGVzcyB0aGFuICcgKyBtYXhpbXVtRmVlICsgJyBidXQgZ290ICcgKyB1bnNwZW50XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIW9wdHMuZGlzYWJsZVNtYWxsRmVlcykge1xyXG4gICAgdmFyIG1pbmltdW1GZWUgPSBNYXRoLmNlaWwodGhpcy5fZXN0aW1hdGVGZWUoKSAvIFRyYW5zYWN0aW9uLkZFRV9TRUNVUklUWV9NQVJHSU4pO1xyXG4gICAgaWYgKHVuc3BlbnQgPCBtaW5pbXVtRmVlKSB7XHJcbiAgICAgIHJldHVybiBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkZlZUVycm9yLlRvb1NtYWxsKFxyXG4gICAgICAgICdleHBlY3RlZCBtb3JlIHRoYW4gJyArIG1pbmltdW1GZWUgKyAnIGJ1dCBnb3QgJyArIHVuc3BlbnRcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX21pc3NpbmdDaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gIXRoaXMuX2NoYW5nZVNjcmlwdDtcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5faGFzRHVzdE91dHB1dHMgPSBmdW5jdGlvbihvcHRzKSB7XHJcbiAgaWYgKG9wdHMuZGlzYWJsZUR1c3RPdXRwdXRzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBpbmRleCwgb3V0cHV0O1xyXG4gIGZvciAoaW5kZXggaW4gdGhpcy5vdXRwdXRzKSB7XHJcbiAgICBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaW5kZXhdO1xyXG4gICAgaWYgKG91dHB1dC5zYXRvc2hpcyA8IFRyYW5zYWN0aW9uLkRVU1RfQU1PVU5UICYmICFvdXRwdXQuc2NyaXB0LmlzRGF0YU91dCgpKSB7XHJcbiAgICAgIHJldHVybiBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkR1c3RPdXRwdXRzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9pc01pc3NpbmdTaWduYXR1cmVzID0gZnVuY3Rpb24ob3B0cykge1xyXG4gIGlmIChvcHRzLmRpc2FibGVJc0Z1bGx5U2lnbmVkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICghdGhpcy5pc0Z1bGx5U2lnbmVkKCkpIHtcclxuICAgIHJldHVybiBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLk1pc3NpbmdTaWduYXR1cmVzKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gJzxUcmFuc2FjdGlvbjogJyArIHRoaXMudW5jaGVja2VkU2VyaWFsaXplKCkgKyAnPic7XHJcbn07XHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbihub1dpdG5lc3MpIHtcclxuICB2YXIgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gIHJldHVybiB0aGlzLnRvQnVmZmVyV3JpdGVyKHdyaXRlciwgbm9XaXRuZXNzKS50b0J1ZmZlcigpO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmhhc1dpdG5lc3NlcyA9IGZ1bmN0aW9uKCkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICh0aGlzLmlucHV0c1tpXS5oYXNXaXRuZXNzZXMoKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvQnVmZmVyV3JpdGVyID0gZnVuY3Rpb24od3JpdGVyLCBub1dpdG5lc3MpIHtcclxuICB3cml0ZXIud3JpdGVJbnQzMkxFKHRoaXMudmVyc2lvbik7XHJcblxyXG4gIGNvbnN0IGhhc1dpdG5lc3NlcyA9IHRoaXMuaGFzV2l0bmVzc2VzKCk7XHJcblxyXG4gIGlmIChoYXNXaXRuZXNzZXMgJiYgIW5vV2l0bmVzcykge1xyXG4gICAgd3JpdGVyLndyaXRlKEJ1ZmZlci5mcm9tKCcwMDAxJywgJ2hleCcpKTtcclxuICB9XHJcblxyXG4gIHdyaXRlci53cml0ZVZhcmludE51bSh0aGlzLmlucHV0cyA/IHRoaXMuaW5wdXRzLmxlbmd0aCA6IDApO1xyXG4gIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMgfHwgW10pIHtcclxuICAgIGlucHV0LnRvQnVmZmVyV3JpdGVyKHdyaXRlcik7XHJcbiAgfVxyXG5cclxuICB3cml0ZXIud3JpdGVWYXJpbnROdW0odGhpcy5vdXRwdXRzID8gdGhpcy5vdXRwdXRzLmxlbmd0aCA6IDApO1xyXG4gIGZvciAoY29uc3Qgb3V0cHV0IG9mIHRoaXMub3V0cHV0cyB8fCBbXSkge1xyXG4gICAgb3V0cHV0LnRvQnVmZmVyV3JpdGVyKHdyaXRlcik7XHJcbiAgfVxyXG5cclxuICBpZiAoaGFzV2l0bmVzc2VzICYmICFub1dpdG5lc3MpIHtcclxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMpIHtcclxuICAgICAgY29uc3Qgd2l0bmVzc2VzID0gaW5wdXQuZ2V0V2l0bmVzc2VzKCk7XHJcbiAgICAgIHdyaXRlci53cml0ZVZhcmludE51bSh3aXRuZXNzZXMubGVuZ3RoKTtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aXRuZXNzZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICB3cml0ZXIud3JpdGVWYXJpbnROdW0od2l0bmVzc2VzW2pdLmxlbmd0aCk7XHJcbiAgICAgICAgd3JpdGVyLndyaXRlKHdpdG5lc3Nlc1tqXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdyaXRlci53cml0ZVVJbnQzMkxFKHRoaXMubkxvY2tUaW1lKTtcclxuICByZXR1cm4gd3JpdGVyO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcclxuICB2YXIgcmVhZGVyID0gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpO1xyXG4gIHJldHVybiB0aGlzLmZyb21CdWZmZXJSZWFkZXIocmVhZGVyKTtcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24ocmVhZGVyKSB7XHJcbiAgJC5jaGVja0FyZ3VtZW50KCFyZWFkZXIuZmluaXNoZWQoKSwgJ05vIHRyYW5zYWN0aW9uIGRhdGEgcmVjZWl2ZWQnKTtcclxuXHJcbiAgdGhpcy52ZXJzaW9uID0gcmVhZGVyLnJlYWRJbnQzMkxFKCk7XHJcbiAgdmFyIHNpemVUeElucyA9IHJlYWRlci5yZWFkVmFyaW50TnVtKCk7XHJcblxyXG4gIC8vIGNoZWNrIGZvciBzZWd3aXRcclxuICB2YXIgaGFzV2l0bmVzc2VzID0gZmFsc2U7XHJcbiAgaWYgKHNpemVUeElucyA9PT0gMCAmJiByZWFkZXIuYnVmW3JlYWRlci5wb3NdICE9PSAwKSB7XHJcbiAgICByZWFkZXIucG9zICs9IDE7XHJcbiAgICBoYXNXaXRuZXNzZXMgPSB0cnVlO1xyXG4gICAgc2l6ZVR4SW5zID0gcmVhZGVyLnJlYWRWYXJpbnROdW0oKTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVR4SW5zOyBpKyspIHtcclxuICAgIHZhciBpbnB1dCA9IElucHV0LmZyb21CdWZmZXJSZWFkZXIocmVhZGVyKTtcclxuICAgIHRoaXMuaW5wdXRzLnB1c2goaW5wdXQpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHNpemVUeE91dHMgPSByZWFkZXIucmVhZFZhcmludE51bSgpO1xyXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVR4T3V0czsgaisrKSB7XHJcbiAgICB0aGlzLm91dHB1dHMucHVzaChPdXRwdXQuZnJvbUJ1ZmZlclJlYWRlcihyZWFkZXIpKTtcclxuICB9XHJcblxyXG4gIGlmIChoYXNXaXRuZXNzZXMpIHtcclxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2l6ZVR4SW5zOyBrKyspIHtcclxuICAgICAgdmFyIGl0ZW1Db3VudCA9IHJlYWRlci5yZWFkVmFyaW50TnVtKCk7XHJcbiAgICAgIHZhciB3aXRuZXNzZXMgPSBbXTtcclxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBpdGVtQ291bnQ7IGwrKykge1xyXG4gICAgICAgIHZhciBzaXplID0gcmVhZGVyLnJlYWRWYXJpbnROdW0oKTtcclxuICAgICAgICB2YXIgaXRlbSA9IHJlYWRlci5yZWFkKHNpemUpO1xyXG4gICAgICAgIHdpdG5lc3Nlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuaW5wdXRzW2tdLnNldFdpdG5lc3Nlcyh3aXRuZXNzZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGhpcy5uTG9ja1RpbWUgPSByZWFkZXIucmVhZFVJbnQzMkxFKCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvT2JqZWN0ID0gVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xyXG4gIHZhciBpbnB1dHMgPSBbXTtcclxuICB0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICBpbnB1dHMucHVzaChpbnB1dC50b09iamVjdCgpKTtcclxuICB9KTtcclxuICB2YXIgb3V0cHV0cyA9IFtdO1xyXG4gIHRoaXMub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKG91dHB1dCkge1xyXG4gICAgb3V0cHV0cy5wdXNoKG91dHB1dC50b09iamVjdCgpKTtcclxuICB9KTtcclxuICB2YXIgb2JqID0ge1xyXG4gICAgaGFzaDogdGhpcy5oYXNoLFxyXG4gICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxyXG4gICAgaW5wdXRzOiBpbnB1dHMsXHJcbiAgICBvdXRwdXRzOiBvdXRwdXRzLFxyXG4gICAgbkxvY2tUaW1lOiB0aGlzLm5Mb2NrVGltZVxyXG4gIH07XHJcbiAgaWYgKHRoaXMuX2NoYW5nZVNjcmlwdCkge1xyXG4gICAgb2JqLmNoYW5nZVNjcmlwdCA9IHRoaXMuX2NoYW5nZVNjcmlwdC50b1N0cmluZygpO1xyXG4gIH1cclxuICBpZiAodGhpcy5fY2hhbmdlSW5kZXggIT0gbnVsbCkge1xyXG4gICAgb2JqLmNoYW5nZUluZGV4ID0gdGhpcy5fY2hhbmdlSW5kZXg7XHJcbiAgfVxyXG4gIGlmICh0aGlzLl9mZWUgIT0gbnVsbCkge1xyXG4gICAgb2JqLmZlZSA9IHRoaXMuX2ZlZTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChhcmcsIG9wdHMpIHtcclxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cclxuICAkLmNoZWNrQXJndW1lbnQoXy5pc09iamVjdChhcmcpIHx8IGFyZyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKTtcclxuICB2YXIgdHJhbnNhY3Rpb247XHJcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XHJcbiAgICB0cmFuc2FjdGlvbiA9IGFyZy50b09iamVjdCgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0cmFuc2FjdGlvbiA9IGFyZztcclxuICB9XHJcbiAgZm9yIChjb25zdCBpbnB1dCBvZiB0cmFuc2FjdGlvbi5pbnB1dHMgfHwgW10pIHtcclxuICAgIGlmICghaW5wdXQub3V0cHV0IHx8ICFpbnB1dC5vdXRwdXQuc2NyaXB0KSB7XHJcbiAgICAgIHRoaXMudW5jaGVja2VkQWRkSW5wdXQobmV3IElucHV0KGlucHV0KSk7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoaW5wdXQub3V0cHV0LnNjcmlwdCk7XHJcbiAgICB2YXIgdHhpbjtcclxuICAgIGlmICgoc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpIHx8IHNjcmlwdC5pc1dpdG5lc3NTY3JpcHRIYXNoT3V0KCkpICYmIGlucHV0LnB1YmxpY0tleXMgJiYgaW5wdXQudGhyZXNob2xkKSB7XHJcbiAgICAgIHR4aW4gPSBuZXcgSW5wdXQuTXVsdGlTaWdTY3JpcHRIYXNoKFxyXG4gICAgICAgIGlucHV0LCBpbnB1dC5wdWJsaWNLZXlzLCBpbnB1dC50aHJlc2hvbGQsIGlucHV0LnNpZ25hdHVyZXMsIG9wdHNcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoc2NyaXB0LmlzUHVibGljS2V5SGFzaE91dCgpIHx8IHNjcmlwdC5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkgfHwgc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpKSB7XHJcbiAgICAgIHR4aW4gPSBuZXcgSW5wdXQuUHVibGljS2V5SGFzaChpbnB1dCk7XHJcbiAgICB9IGVsc2UgaWYgKHNjcmlwdC5pc1B1YmxpY0tleU91dCgpKSB7XHJcbiAgICAgIHR4aW4gPSBuZXcgSW5wdXQuUHVibGljS2V5KGlucHV0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW5wdXQuVW5zdXBwb3J0ZWRTY3JpcHQoaW5wdXQub3V0cHV0LnNjcmlwdCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZElucHV0KHR4aW4pO1xyXG4gIH1cclxuICBmb3IgKGNvbnN0IG91dHB1dCBvZiB0cmFuc2FjdGlvbi5vdXRwdXRzIHx8IFtdKSB7XHJcbiAgICB0aGlzLmFkZE91dHB1dChuZXcgT3V0cHV0KG91dHB1dCkpO1xyXG4gIH1cclxuICBpZiAodHJhbnNhY3Rpb24uY2hhbmdlSW5kZXgpIHtcclxuICAgIHRoaXMuX2NoYW5nZUluZGV4ID0gdHJhbnNhY3Rpb24uY2hhbmdlSW5kZXg7XHJcbiAgfVxyXG4gIGlmICh0cmFuc2FjdGlvbi5jaGFuZ2VTY3JpcHQpIHtcclxuICAgIHRoaXMuX2NoYW5nZVNjcmlwdCA9IG5ldyBTY3JpcHQodHJhbnNhY3Rpb24uY2hhbmdlU2NyaXB0KTtcclxuICB9XHJcbiAgaWYgKHRyYW5zYWN0aW9uLmZlZSkge1xyXG4gICAgdGhpcy5fZmVlID0gdHJhbnNhY3Rpb24uZmVlO1xyXG4gIH1cclxuICB0aGlzLm5Mb2NrVGltZSA9IHRyYW5zYWN0aW9uLm5Mb2NrVGltZTtcclxuICB0aGlzLnZlcnNpb24gPSB0cmFuc2FjdGlvbi52ZXJzaW9uO1xyXG4gIHRoaXMuX2NoZWNrQ29uc2lzdGVuY3koYXJnKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fY2hlY2tDb25zaXN0ZW5jeSA9IGZ1bmN0aW9uKGFyZykge1xyXG4gIGlmICh0aGlzLl9jaGFuZ2VJbmRleCAhPSBudWxsKSB7XHJcbiAgICAkLmNoZWNrU3RhdGUodGhpcy5fY2hhbmdlU2NyaXB0LCAnQ2hhbmdlIHNjcmlwdCBpcyBleHBlY3RlZC4nKTtcclxuICAgICQuY2hlY2tTdGF0ZSh0aGlzLm91dHB1dHNbdGhpcy5fY2hhbmdlSW5kZXhdLCAnQ2hhbmdlIGluZGV4IHBvaW50cyB0byB1bmRlZmluZWQgb3V0cHV0LicpO1xyXG4gICAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0c1t0aGlzLl9jaGFuZ2VJbmRleF0uc2NyaXB0LnRvU3RyaW5nKCkgPT09XHJcbiAgICAgIHRoaXMuX2NoYW5nZVNjcmlwdC50b1N0cmluZygpLCAnQ2hhbmdlIG91dHB1dCBoYXMgYW4gdW5leHBlY3RlZCBzY3JpcHQuJyk7XHJcbiAgfVxyXG4gIGlmIChhcmcgJiYgYXJnLmhhc2gpIHtcclxuICAgICQuY2hlY2tTdGF0ZShhcmcuaGFzaCA9PT0gdGhpcy5oYXNoLCAnSGFzaCBpbiBvYmplY3QgZG9lcyBub3QgbWF0Y2ggdHJhbnNhY3Rpb24gaGFzaC4nKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBuTG9ja1RpbWUgc28gdGhhdCB0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWQgdW50aWwgdGhlIGRlc2lyZWQgZGF0ZShhXHJcbiAqIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIFVOSVggZXBvY2ggaXMgYWxzbyBhY2NlcHRlZClcclxuICpcclxuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyfSB0aW1lXHJcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUubG9ja1VudGlsRGF0ZSA9IGZ1bmN0aW9uKHRpbWUpIHtcclxuICAkLmNoZWNrQXJndW1lbnQodGltZSk7XHJcbiAgaWYgKCFpc05hTih0aW1lKSAmJiB0aW1lIDwgVHJhbnNhY3Rpb24uTkxPQ0tUSU1FX0JMT0NLSEVJR0hUX0xJTUlUKSB7XHJcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkxvY2tUaW1lVG9vRWFybHkoKTtcclxuICB9XHJcbiAgaWYgKF8uaXNEYXRlKHRpbWUpKSB7XHJcbiAgICB0aW1lID0gdGltZS5nZXRUaW1lKCkgLyAxMDAwO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHRoaXMuaW5wdXRzW2ldLnNlcXVlbmNlTnVtYmVyID09PSBJbnB1dC5ERUZBVUxUX1NFUU5VTUJFUil7XHJcbiAgICAgIHRoaXMuaW5wdXRzW2ldLnNlcXVlbmNlTnVtYmVyID0gSW5wdXQuREVGQVVMVF9MT0NLVElNRV9TRVFOVU1CRVI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLm5Mb2NrVGltZSA9IHRpbWU7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBuTG9ja1RpbWUgc28gdGhhdCB0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWQgdW50aWwgdGhlIGRlc2lyZWQgYmxvY2tcclxuICogaGVpZ2h0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUubG9ja1VudGlsQmxvY2tIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoIWlzTmFOKGhlaWdodCkpO1xyXG4gIGlmIChoZWlnaHQgPj0gVHJhbnNhY3Rpb24uTkxPQ0tUSU1FX0JMT0NLSEVJR0hUX0xJTUlUKSB7XHJcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkJsb2NrSGVpZ2h0VG9vSGlnaCgpO1xyXG4gIH1cclxuICBpZiAoaGVpZ2h0IDwgMCkge1xyXG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5OTG9ja1RpbWVPdXRPZlJhbmdlKCk7XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAodGhpcy5pbnB1dHNbaV0uc2VxdWVuY2VOdW1iZXIgPT09IElucHV0LkRFRkFVTFRfU0VRTlVNQkVSKXtcclxuICAgICAgdGhpcy5pbnB1dHNbaV0uc2VxdWVuY2VOdW1iZXIgPSBJbnB1dC5ERUZBVUxUX0xPQ0tUSU1FX1NFUU5VTUJFUjtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICB0aGlzLm5Mb2NrVGltZSA9IGhlaWdodDtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIHNlbWFudGljIHZlcnNpb24gb2YgdGhlIHRyYW5zYWN0aW9uJ3MgbkxvY2tUaW1lLlxyXG4gKiAgQHJldHVybiB7TnVtYmVyfERhdGV9XHJcbiAqICBJZiBuTG9ja1RpbWUgaXMgMCwgaXQgcmV0dXJucyBudWxsLFxyXG4gKiAgaWYgaXQgaXMgPCA1MDAwMDAwMDAsIGl0IHJldHVybnMgYSBibG9jayBoZWlnaHQgKG51bWJlcilcclxuICogIGVsc2UgaXQgcmV0dXJucyBhIERhdGUgb2JqZWN0LlxyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldExvY2tUaW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKCF0aGlzLm5Mb2NrVGltZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGlmICh0aGlzLm5Mb2NrVGltZSA8IFRyYW5zYWN0aW9uLk5MT0NLVElNRV9CTE9DS0hFSUdIVF9MSU1JVCkge1xyXG4gICAgcmV0dXJuIHRoaXMubkxvY2tUaW1lO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IERhdGUoMTAwMCAqIHRoaXMubkxvY2tUaW1lKTtcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlci5CdWZmZXIuZnJvbShzdHJpbmcsICdoZXgnKSk7XHJcbn07XHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX25ld1RyYW5zYWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy52ZXJzaW9uID0gQ1VSUkVOVF9WRVJTSU9OO1xyXG4gIHRoaXMubkxvY2tUaW1lID0gREVGQVVMVF9OTE9DS1RJTUU7XHJcbn07XHJcblxyXG4vKiBUcmFuc2FjdGlvbiBjcmVhdGlvbiBpbnRlcmZhY2UgKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmFuc2FjdGlvbn5mcm9tT2JqZWN0XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcmV2VHhJZFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3V0cHV0SW5kZXhcclxuICogQHByb3BlcnR5IHsoQnVmZmVyfHN0cmluZ3xTY3JpcHQpfSBzY3JpcHRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNhdG9zaGlzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhbiBpbnB1dCB0byB0aGlzIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGEgaGlnaCBsZXZlbCBpbnRlcmZhY2VcclxuICogdG8gYWRkIGFuIGlucHV0LCBmb3IgbW9yZSBjb250cm9sLCB1c2UgQHtsaW5rIFRyYW5zYWN0aW9uI2FkZElucHV0fS5cclxuICpcclxuICogQ2FuIHJlY2VpdmUsIGFzIG91dHB1dCBpbmZvcm1hdGlvbiwgdGhlIG91dHB1dCBvZiBiaXRjb2luZCdzIGBsaXN0dW5zcGVudGAgY29tbWFuZCxcclxuICogYW5kIGEgc2xpZ2h0bHkgZmFuY2llciBmb3JtYXQgcmVjb2duaXplZCBieSBiaXRjb3JlOlxyXG4gKlxyXG4gKiBgYGBcclxuICoge1xyXG4gKiAgYWRkcmVzczogJ21zellxVm5xS29ReDRqY1RkSlh4d0tBaXNzRTNKYnJyYzEnLFxyXG4gKiAgdHhJZDogJ2E0NzdhZjZiMjY2N2MyOTY3MDQ2N2U0ZTA3MjhiNjg1ZWUwN2IyNDAyMzU3NzE4NjIzMThlMjlkZGJlNTg0NTgnLFxyXG4gKiAgb3V0cHV0SW5kZXg6IDAsXHJcbiAqICBzY3JpcHQ6IFNjcmlwdC5lbXB0eSgpLFxyXG4gKiAgc2F0b3NoaXM6IDEwMjAwMDBcclxuICogfVxyXG4gKiBgYGBcclxuICogV2hlcmUgYGFkZHJlc3NgIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBiaXRjb3JlIEFkZHJlc3Mgb2JqZWN0LiBUaGVcclxuICogc2FtZSBpcyB0cnVlIGZvciBgc2NyaXB0YCwgd2hpY2ggY2FuIGJlIGEgc3RyaW5nIG9yIGEgYml0Y29yZSBTY3JpcHQuXHJcbiAqXHJcbiAqIEJld2FyZSB0aGF0IHRoaXMgcmVzZXRzIGFsbCB0aGUgc2lnbmF0dXJlcyBmb3IgaW5wdXRzIChpbiBmdXJ0aGVyIHZlcnNpb25zLFxyXG4gKiBTSUdIQVNIX1NJTkdMRSBvciBTSUdIQVNIX05PTkUgc2lnbmF0dXJlcyB3aWxsIG5vdCBiZSByZXNldCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogdmFyIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XHJcbiAqXHJcbiAqIC8vIEZyb20gYSBwYXkgdG8gcHVibGljIGtleSBoYXNoIG91dHB1dCBmcm9tIGJpdGNvaW5kJ3MgbGlzdHVuc3BlbnRcclxuICogdHJhbnNhY3Rpb24uZnJvbSh7J3R4aWQnOiAnMDAwMC4uLicsIHZvdXQ6IDAsIGFtb3VudDogMC4xLCBzY3JpcHRQdWJLZXk6ICdPUF9EVVAgLi4uJ30pO1xyXG4gKlxyXG4gKiAvLyBGcm9tIGEgcGF5IHRvIHB1YmxpYyBrZXkgaGFzaCBvdXRwdXRcclxuICogdHJhbnNhY3Rpb24uZnJvbSh7J3R4SWQnOiAnMDAwMC4uLicsIG91dHB1dEluZGV4OiAwLCBzYXRvc2hpczogMTAwMCwgc2NyaXB0OiAnT1BfRFVQIC4uLid9KTtcclxuICpcclxuICogLy8gRnJvbSBhIG11bHRpc2lnIFAyU0ggb3V0cHV0XHJcbiAqIHRyYW5zYWN0aW9uLmZyb20oeyd0eElkJzogJzAwMDAuLi4nLCBpbnB1dEluZGV4OiAwLCBzYXRvc2hpczogMTAwMCwgc2NyaXB0OiAnLi4uIE9QX0hBU0gnfSxcclxuICogICAgICAgICAgICAgICAgICBbJzAzMDAwLi4uJywgJzAyMDAwLi4uJ10sIDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHsoQXJyYXkuPFRyYW5zYWN0aW9ufmZyb21PYmplY3Q+fFRyYW5zYWN0aW9ufmZyb21PYmplY3QpfSB1dHhvXHJcbiAqIEBwYXJhbSB7QXJyYXk9fSBwdWJrZXlzXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gdGhyZXNob2xkXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0cyAtIFNldmVyYWwgb3B0aW9uczpcclxuICogICAgICAgIC0gbm9Tb3J0aW5nOiBkZWZhdWx0cyB0byBmYWxzZSwgaWYgdHJ1ZSBhbmQgaXMgbXVsdGlzaWcsIGRvbid0XHJcbiAqICAgICAgICAgICAgICAgICAgICAgIHNvcnQgdGhlIGdpdmVuIHB1YmxpYyBrZXlzIGJlZm9yZSBjcmVhdGluZyB0aGUgc2NyaXB0XHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cykge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHV0eG8pKSB7XHJcbiAgICBmb3IoY29uc3QgdSBvZiB1dHhvKSB7XHJcbiAgICAgIHRoaXMuZnJvbSh1LCBwdWJrZXlzLCB0aHJlc2hvbGQsIG9wdHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBjb25zdCBleGlzdHMgPSB0aGlzLmlucHV0cy5zb21lKGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAvLyBUT0RPOiBNYXliZSBwcmV2VHhJZCBzaG91bGQgYmUgYSBzdHJpbmc/IE9yIGRlZmluZWQgYXMgcmVhZCBvbmx5IHByb3BlcnR5P1xyXG4gICAgcmV0dXJuIGlucHV0LnByZXZUeElkLnRvU3RyaW5nKCdoZXgnKSA9PT0gdXR4by50eElkICYmIGlucHV0Lm91dHB1dEluZGV4ID09PSB1dHhvLm91dHB1dEluZGV4O1xyXG4gIH0pO1xyXG4gIGlmIChleGlzdHMpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBpZiAocHVia2V5cyAmJiB0aHJlc2hvbGQpIHtcclxuICAgIHRoaXMuX2Zyb21NdWx0aXNpZ1V0eG8odXR4bywgcHVia2V5cywgdGhyZXNob2xkLCBvcHRzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5fZnJvbU5vblAyU0godXR4bywgb3B0cyk7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGFzc29jaWF0ZUlucHV0cyAtIFVwZGF0ZSBpbnB1dHMgd2l0aCB1dHhvcywgYWxsb3dpbmcgeW91IHRvIHNwZWNpZnkgdmFsdWUsIGFuZCBwdWJrZXkuXHJcbiAqIFBvcHVsYXRpbmcgdGhlc2UgaW5wdXRzIGFsbG93cyBmb3IgdGhlbSB0byBiZSBzaWduZWQgd2l0aCAuc2lnbihwcml2S2V5cylcclxuICpcclxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB1dHhvc1xyXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZyB8IFB1YmxpY0tleT59IHB1YmtleXNcclxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5hc3NvY2lhdGVJbnB1dHMgPSBmdW5jdGlvbih1dHhvcywgcHVia2V5cywgdGhyZXNob2xkLCBvcHRzID0ge30pIHtcclxuICBsZXQgaW5kZXhlcyA9IFtdO1xyXG4gIGZvcihsZXQgdXR4byBvZiB1dHhvcykge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmlucHV0cy5maW5kSW5kZXgoaSA9PiBpLnByZXZUeElkLnRvU3RyaW5nKCdoZXgnKSA9PT0gdXR4by50eElkICYmIGkub3V0cHV0SW5kZXggPT09IHV0eG8ub3V0cHV0SW5kZXgpO1xyXG4gICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcclxuICAgIGlmKGluZGV4ID49IDApIHtcclxuICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSB0aGlzLmlucHV0c1tpbmRleF0uc2VxdWVuY2VOdW1iZXI7IC8vIHByZXNlcnZlIHRoZSBzZXQgc2VxdWVuY2UgbnVtYmVyXHJcbiAgICAgIHRoaXMuaW5wdXRzW2luZGV4XSA9IHRoaXMuX2dldElucHV0RnJvbSh1dHhvLCBwdWJrZXlzLCB0aHJlc2hvbGQsIG9wdHMpO1xyXG4gICAgICB0aGlzLmlucHV0c1tpbmRleF0uc2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGluZGV4ZXM7XHJcbn1cclxuXHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX3NlbGVjdElucHV0VHlwZSA9IGZ1bmN0aW9uKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCkge1xyXG4gIHZhciBjbGF6ejtcclxuICB1dHhvID0gbmV3IFVuc3BlbnRPdXRwdXQodXR4byk7XHJcbiAgaWYocHVia2V5cyAmJiB0aHJlc2hvbGQpIHtcclxuICAgIGlmICh1dHhvLnNjcmlwdC5pc011bHRpc2lnT3V0KCkpIHtcclxuICAgICAgY2xhenogPSBNdWx0aVNpZ0lucHV0O1xyXG4gICAgfSBlbHNlIGlmICh1dHhvLnNjcmlwdC5pc1NjcmlwdEhhc2hPdXQoKSB8fCB1dHhvLnNjcmlwdC5pc1dpdG5lc3NTY3JpcHRIYXNoT3V0KCkpIHtcclxuICAgICAgY2xhenogPSBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dDtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHV0eG8uc2NyaXB0LmlzUHVibGljS2V5SGFzaE91dCgpIHx8IHV0eG8uc2NyaXB0LmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSB8fCB1dHhvLnNjcmlwdC5pc1NjcmlwdEhhc2hPdXQoKSkge1xyXG4gICAgY2xhenogPSBQdWJsaWNLZXlIYXNoSW5wdXQ7XHJcbiAgfSBlbHNlIGlmICh1dHhvLnNjcmlwdC5pc1RhcHJvb3QoKSkge1xyXG4gICAgY2xhenogPSBUYXByb290SW5wdXQ7XHJcbiAgfSBlbHNlIGlmICh1dHhvLnNjcmlwdC5pc1B1YmxpY0tleU91dCgpKSB7XHJcbiAgICBjbGF6eiA9IFB1YmxpY0tleUlucHV0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjbGF6eiA9IElucHV0O1xyXG4gIH1cclxuICByZXR1cm4gY2xheno7XHJcbn1cclxuXHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2dldElucHV0RnJvbSA9IGZ1bmN0aW9uKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyA9IHt9KSB7XHJcbiAgdXR4byA9IG5ldyBVbnNwZW50T3V0cHV0KHV0eG8pO1xyXG4gIGNvbnN0IElucHV0Q2xhc3MgPSB0aGlzLl9zZWxlY3RJbnB1dFR5cGUodXR4bywgcHVia2V5cywgdGhyZXNob2xkKTtcclxuICBjb25zdCBpbnB1dCA9IHtcclxuICAgIG91dHB1dDogbmV3IE91dHB1dCh7XHJcbiAgICAgIHNjcmlwdDogdXR4by5zY3JpcHQsXHJcbiAgICAgIHNhdG9zaGlzOiB1dHhvLnNhdG9zaGlzXHJcbiAgICB9KSxcclxuICAgIHByZXZUeElkOiB1dHhvLnR4SWQsXHJcbiAgICBvdXRwdXRJbmRleDogdXR4by5vdXRwdXRJbmRleCxcclxuICAgIHNlcXVlbmNlTnVtYmVyOiBvcHRzLnNlcXVlbmNlTnVtYmVyLFxyXG4gICAgc2NyaXB0OiBTY3JpcHQuZW1wdHkoKVxyXG4gIH07XHJcbiAgbGV0IGFyZ3MgPSBwdWJrZXlzICYmIHRocmVzaG9sZCA/IFtwdWJrZXlzLCB0aHJlc2hvbGQsIGZhbHNlLCBvcHRzXSA6IFtdXHJcbiAgcmV0dXJuIG5ldyBJbnB1dENsYXNzKGlucHV0LCAuLi5hcmdzKTtcclxufVxyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9mcm9tTm9uUDJTSCA9IGZ1bmN0aW9uKHV0eG8sIG9wdHMpIHtcclxuICBjb25zdCBpbnB1dCA9IHRoaXMuX2dldElucHV0RnJvbSh1dHhvLCBudWxsLCBudWxsLCBvcHRzKTtcclxuICB0aGlzLmFkZElucHV0KGlucHV0KTtcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZnJvbU11bHRpc2lnVXR4byA9IGZ1bmN0aW9uKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cykge1xyXG4gICQuY2hlY2tBcmd1bWVudCh0aHJlc2hvbGQgPD0gcHVia2V5cy5sZW5ndGgsXHJcbiAgICAnTnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBwdWJsaWMga2V5cycpO1xyXG4gIGNvbnN0IGlucHV0ID0gdGhpcy5fZ2V0SW5wdXRGcm9tKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyk7XHJcbiAgdGhpcy5hZGRJbnB1dChpbnB1dCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGFuIGlucHV0IHRvIHRoaXMgdHJhbnNhY3Rpb24uIFRoZSBpbnB1dCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHRoZSBgSW5wdXRgIGNsYXNzLlxyXG4gKiBJdCBzaG91bGQgaGF2ZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgT3V0cHV0IHRoYXQgaXQncyBzcGVuZGluZywgYnV0IGlmIGl0J3Mgbm90IGFscmVhZHlcclxuICogc2V0LCB0d28gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLCBgb3V0cHV0U2NyaXB0YCBhbmQgYHNhdG9zaGlzYCBjYW4gYmUgcHJvdmlkZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfFNjcmlwdH0gb3V0cHV0U2NyaXB0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYXRvc2hpc1xyXG4gKiBAcmV0dXJuIFRyYW5zYWN0aW9uIHRoaXMsIGZvciBjaGFpbmluZ1xyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFkZElucHV0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dFNjcmlwdCwgc2F0b3NoaXMpIHtcclxuICAkLmNoZWNrQXJndW1lbnRUeXBlKGlucHV0LCBJbnB1dCwgJ2lucHV0Jyk7XHJcbiAgaWYgKCFpbnB1dC5vdXRwdXQgJiYgKG91dHB1dFNjcmlwdCA9PSBudWxsIHx8IHNhdG9zaGlzID09IG51bGwpKSB7XHJcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLk5lZWRNb3JlSW5mbygnTmVlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgVVRYTyBzY3JpcHQgYW5kIHNhdG9zaGlzJyk7XHJcbiAgfVxyXG4gIGlmICghaW5wdXQub3V0cHV0ICYmIG91dHB1dFNjcmlwdCAmJiBzYXRvc2hpcyAhPSBudWxsKSB7XHJcbiAgICBvdXRwdXRTY3JpcHQgPSBvdXRwdXRTY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQgPyBvdXRwdXRTY3JpcHQgOiBuZXcgU2NyaXB0KG91dHB1dFNjcmlwdCk7XHJcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKHNhdG9zaGlzLCAnbnVtYmVyJywgJ3NhdG9zaGlzJyk7XHJcbiAgICBpbnB1dC5vdXRwdXQgPSBuZXcgT3V0cHV0KHtcclxuICAgICAgc2NyaXB0OiBvdXRwdXRTY3JpcHQsXHJcbiAgICAgIHNhdG9zaGlzOiBzYXRvc2hpc1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLnVuY2hlY2tlZEFkZElucHV0KGlucHV0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYW4gaW5wdXQgdG8gdGhpcyB0cmFuc2FjdGlvbiwgd2l0aG91dCBjaGVja2luZyB0aGF0IHRoZSBpbnB1dCBoYXMgaW5mb3JtYXRpb24gYWJvdXRcclxuICogdGhlIG91dHB1dCB0aGF0IGl0J3Mgc3BlbmRpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XHJcbiAqIEByZXR1cm4gVHJhbnNhY3Rpb24gdGhpcywgZm9yIGNoYWluaW5nXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUudW5jaGVja2VkQWRkSW5wdXQgPSBmdW5jdGlvbihpbnB1dCkge1xyXG4gICQuY2hlY2tBcmd1bWVudFR5cGUoaW5wdXQsIElucHV0LCAnaW5wdXQnKTtcclxuICB0aGlzLmlucHV0cy5wdXNoKGlucHV0KTtcclxuICB0aGlzLl9pbnB1dEFtb3VudCA9IHVuZGVmaW5lZDtcclxuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBlbm91Z2ggaW5mbyBvbiBhbGwgaW5wdXRzIHRvIGJlIGNvcnJlY3RseSB2YWxpZGF0ZWRcclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5oYXNBbGxVdHhvSW5mbyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLmlucHV0cy5ldmVyeShmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgcmV0dXJuICEhaW5wdXQub3V0cHV0O1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXNcclxuICogZm9yIGlucHV0cyAoaW4gZnVydGhlciB2ZXJzaW9ucywgU0lHSEFTSF9TSU5HTEUgb3IgU0lHSEFTSF9OT05FIHNpZ25hdHVyZXMgd2lsbCBub3RcclxuICogYmUgcmVzZXQpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IHNhdG9zaGlzIHRvIGJlIHNlbnRcclxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXMsIGZvciBjaGFpbmluZ1xyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZlZSA9IGZ1bmN0aW9uKGFtb3VudCkge1xyXG4gICQuY2hlY2tBcmd1bWVudCghaXNOYU4oYW1vdW50KSwgJ2Ftb3VudCBtdXN0IGJlIGEgbnVtYmVyJyk7XHJcbiAgdGhpcy5fZmVlID0gYW1vdW50O1xyXG4gIHRoaXMuX3VwZGF0ZUNoYW5nZU91dHB1dCgpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIHBlciBLQiBmb3IgdGhpcyB0cmFuc2FjdGlvbi4gQmV3YXJlIHRoYXQgdGhpcyByZXNldHMgYWxsIHRoZSBzaWduYXR1cmVzXHJcbiAqIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90XHJcbiAqIGJlIHJlc2V0KS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBzYXRvc2hpcyBwZXIgS0IgdG8gYmUgc2VudFxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZmVlUGVyS2IgPSBmdW5jdGlvbihhbW91bnQpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoIWlzTmFOKGFtb3VudCksICdhbW91bnQgbXVzdCBiZSBhIG51bWJlcicpO1xyXG4gIHRoaXMuX2ZlZVBlcktiID0gYW1vdW50O1xyXG4gIHRoaXMuX3VwZGF0ZUNoYW5nZU91dHB1dCgpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIHBlciBCeXRlIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXNcclxuICogZm9yIGlucHV0cyAoaW4gZnVydGhlciB2ZXJzaW9ucywgU0lHSEFTSF9TSU5HTEUgb3IgU0lHSEFTSF9OT05FIHNpZ25hdHVyZXMgd2lsbCBub3RcclxuICogYmUgcmVzZXQpLlxyXG4gKiBmZWUgcGVyIEJ5dGUgd2lsbCBiZSBpZ25vcmVkIGlmIGZlZSBwZXIgS0IgaXMgc2V0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgc2F0b3NoaXMgcGVyIEJ5dGUgdG8gYmUgc2VudFxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZmVlUGVyQnl0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAkLmNoZWNrQXJndW1lbnQoIWlzTmFOKGFtb3VudCksICdhbW91bnQgbXVzdCBiZSBhIG51bWJlcicpO1xyXG4gIHRoaXMuX2ZlZVBlckJ5dGUgPSBhbW91bnQ7XHJcbiAgdGhpcy5fdXBkYXRlQ2hhbmdlT3V0cHV0KCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKiBPdXRwdXQgbWFuYWdlbWVudCAqL1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY2hhbmdlIGFkZHJlc3MgZm9yIHRoaXMgdHJhbnNhY3Rpb25cclxuICpcclxuICogQmV3YXJlIHRoYXQgdGhpcyByZXNldHMgYWxsIHRoZSBzaWduYXR1cmVzIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsXHJcbiAqIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90IGJlIHJlc2V0KS5cclxuICpcclxuICogQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzIEFuIGFkZHJlc3MgZm9yIGNoYW5nZSB0byBiZSBzZW50IHRvLlxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuY2hhbmdlID0gZnVuY3Rpb24oYWRkcmVzcykge1xyXG4gICQuY2hlY2tBcmd1bWVudChhZGRyZXNzLCAnYWRkcmVzcyBpcyByZXF1aXJlZCcpO1xyXG4gIHRoaXMuX2NoYW5nZVNjcmlwdCA9IFNjcmlwdC5mcm9tQWRkcmVzcyhhZGRyZXNzKTtcclxuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQHJldHVybiB7T3V0cHV0fSBjaGFuZ2Ugb3V0cHV0LCBpZiBpdCBleGlzdHNcclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRDaGFuZ2VPdXRwdXQgPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5fY2hhbmdlSW5kZXggIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0c1t0aGlzLl9jaGFuZ2VJbmRleF07XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zYWN0aW9ufnRvT2JqZWN0XHJcbiAqIEBwcm9wZXJ0eSB7KHN0cmluZ3xBZGRyZXNzKX0gYWRkcmVzc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2F0b3NoaXNcclxuICovXHJcblxyXG4vKipcclxuICogQWRkIGFuIG91dHB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqXHJcbiAqIEJld2FyZSB0aGF0IHRoaXMgcmVzZXRzIGFsbCB0aGUgc2lnbmF0dXJlcyBmb3IgaW5wdXRzIChpbiBmdXJ0aGVyIHZlcnNpb25zLFxyXG4gKiBTSUdIQVNIX1NJTkdMRSBvciBTSUdIQVNIX05PTkUgc2lnbmF0dXJlcyB3aWxsIG5vdCBiZSByZXNldCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7KHN0cmluZ3xBZGRyZXNzfEFycmF5LjxUcmFuc2FjdGlvbn50b09iamVjdD4pfSBhZGRyZXNzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgaW4gc2F0b3NoaXNcclxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXMsIGZvciBjaGFpbmluZ1xyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oYWRkcmVzcywgYW1vdW50KSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYWRkcmVzcykpIHtcclxuICAgIGZvciAoY29uc3QgdG8gb2YgYWRkcmVzcykge1xyXG4gICAgICB0aGlzLnRvKHRvLmFkZHJlc3MsIHRvLnNhdG9zaGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgJC5jaGVja0FyZ3VtZW50KFxyXG4gICAgSlNVdGlsLmlzTmF0dXJhbE51bWJlcihhbW91bnQpLFxyXG4gICAgJ0Ftb3VudCBpcyBleHBlY3RlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXInXHJcbiAgKTtcclxuICB0aGlzLmFkZE91dHB1dChuZXcgT3V0cHV0KHtcclxuICAgIHNjcmlwdDogU2NyaXB0KG5ldyBBZGRyZXNzKGFkZHJlc3MpKSxcclxuICAgIHNhdG9zaGlzOiBhbW91bnRcclxuICB9KSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGFuIE9QX1JFVFVSTiBvdXRwdXQgdG8gdGhlIHRyYW5zYWN0aW9uLlxyXG4gKlxyXG4gKiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXMgZm9yIGlucHV0cyAoaW4gZnVydGhlciB2ZXJzaW9ucyxcclxuICogU0lHSEFTSF9TSU5HTEUgb3IgU0lHSEFTSF9OT05FIHNpZ25hdHVyZXMgd2lsbCBub3QgYmUgcmVzZXQpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IHZhbHVlIHRoZSBkYXRhIHRvIGJlIHN0b3JlZCBpbiB0aGUgT1BfUkVUVVJOIG91dHB1dC5cclxuICogICAgSW4gY2FzZSBvZiBhIHN0cmluZywgdGhlIFVURi04IHJlcHJlc2VudGF0aW9uIHdpbGwgYmUgc3RvcmVkXHJcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGREYXRhID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICB0aGlzLmFkZE91dHB1dChuZXcgT3V0cHV0KHtcclxuICAgIHNjcmlwdDogU2NyaXB0LmJ1aWxkRGF0YU91dCh2YWx1ZSksXHJcbiAgICBzYXRvc2hpczogMFxyXG4gIH0pKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQWRkIGFuIG91dHB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T3V0cHV0fSBvdXRwdXQgdGhlIG91dHB1dCB0byBhZGQuXHJcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGRPdXRwdXQgPSBmdW5jdGlvbihvdXRwdXQpIHtcclxuICAkLmNoZWNrQXJndW1lbnRUeXBlKG91dHB1dCwgT3V0cHV0LCAnb3V0cHV0Jyk7XHJcbiAgdGhpcy5fYWRkT3V0cHV0KG91dHB1dCk7XHJcbiAgdGhpcy5fdXBkYXRlQ2hhbmdlT3V0cHV0KCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhbGwgb3V0cHV0cyBmcm9tIHRoZSB0cmFuc2FjdGlvbi5cclxuICpcclxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXMsIGZvciBjaGFpbmluZ1xyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmNsZWFyT3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMub3V0cHV0cyA9IFtdO1xyXG4gIHRoaXMuX2NsZWFyU2lnbmF0dXJlcygpO1xyXG4gIHRoaXMuX291dHB1dEFtb3VudCA9IHVuZGVmaW5lZDtcclxuICB0aGlzLl9jaGFuZ2VJbmRleCA9IHVuZGVmaW5lZDtcclxuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2FkZE91dHB1dCA9IGZ1bmN0aW9uKG91dHB1dCkge1xyXG4gIHRoaXMub3V0cHV0cy5wdXNoKG91dHB1dCk7XHJcbiAgdGhpcy5fb3V0cHV0QW1vdW50ID0gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIG9yIGdldHMgdGhlIHRvdGFsIG91dHB1dCBhbW91bnQgaW4gc2F0b3NoaXNcclxuICpcclxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgdHJhbnNhY3Rpb24gdG90YWwgb3V0cHV0IGFtb3VudFxyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRPdXRwdXRBbW91bnQgPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5fb3V0cHV0QW1vdW50ID09IG51bGwpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHRoaXMuX291dHB1dEFtb3VudCA9IDA7XHJcbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiB0aGlzLm91dHB1dHMgfHwgW10pIHtcclxuICAgICAgc2VsZi5fb3V0cHV0QW1vdW50ICs9IG91dHB1dC5zYXRvc2hpcztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXMuX291dHB1dEFtb3VudDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBvciBnZXRzIHRoZSB0b3RhbCBpbnB1dCBhbW91bnQgaW4gc2F0b3NoaXNcclxuICpcclxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgdHJhbnNhY3Rpb24gdG90YWwgaW5wdXQgYW1vdW50XHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2dldElucHV0QW1vdW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKHRoaXMuX2lucHV0QW1vdW50ID09IG51bGwpIHtcclxuICAgIHRoaXMuX2lucHV0QW1vdW50ID0gXy5zdW1CeSh0aGlzLmlucHV0cywgZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgaWYgKGlucHV0Lm91dHB1dCA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5JbnB1dC5NaXNzaW5nUHJldmlvdXNPdXRwdXQoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaW5wdXQub3V0cHV0LnNhdG9zaGlzO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLl9pbnB1dEFtb3VudDtcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlQ2hhbmdlT3V0cHV0ID0gZnVuY3Rpb24obm9DbGVhclNpZ3MpIHtcclxuICBpZiAoIXRoaXMuX2NoYW5nZVNjcmlwdCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoIW5vQ2xlYXJTaWdzKSB7XHJcbiAgICB0aGlzLl9jbGVhclNpZ25hdHVyZXMoKTtcclxuICB9XHJcbiAgaWYgKHRoaXMuX2NoYW5nZUluZGV4ICE9IG51bGwpIHtcclxuICAgIHRoaXMuX3JlbW92ZU91dHB1dCh0aGlzLl9jaGFuZ2VJbmRleCk7XHJcbiAgfVxyXG4gIHZhciBhdmFpbGFibGUgPSB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcclxuICB2YXIgZmVlID0gdGhpcy5nZXRGZWUoKTtcclxuICB2YXIgY2hhbmdlQW1vdW50ID0gYXZhaWxhYmxlIC0gZmVlO1xyXG4gIGlmIChjaGFuZ2VBbW91bnQgPiBUcmFuc2FjdGlvbi5EVVNUX0FNT1VOVCkge1xyXG4gICAgdGhpcy5fY2hhbmdlSW5kZXggPSB0aGlzLm91dHB1dHMubGVuZ3RoO1xyXG4gICAgdGhpcy5fYWRkT3V0cHV0KG5ldyBPdXRwdXQoe1xyXG4gICAgICBzY3JpcHQ6IHRoaXMuX2NoYW5nZVNjcmlwdCxcclxuICAgICAgc2F0b3NoaXM6IGNoYW5nZUFtb3VudFxyXG4gICAgfSkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLl9jaGFuZ2VJbmRleCA9IHVuZGVmaW5lZDtcclxuICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBmZWUgb2YgdGhlIHRyYW5zYWN0aW9uLlxyXG4gKlxyXG4gKiBJZiB0aGVyZSdzIGEgZml4ZWQgZmVlIHNldCwgcmV0dXJuIHRoYXQuXHJcbiAqXHJcbiAqIElmIHRoZXJlIGlzIG5vIGNoYW5nZSBvdXRwdXQgc2V0LCB0aGUgZmVlIGlzIHRoZVxyXG4gKiB0b3RhbCB2YWx1ZSBvZiB0aGUgb3V0cHV0cyBtaW51cyBpbnB1dHMuIE5vdGUgdGhhdFxyXG4gKiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb25seSBzcGVjaWZpZXMgdGhlIHZhbHVlXHJcbiAqIG9mIGl0cyBvdXRwdXRzLiAoVGhlIHZhbHVlIG9mIGlucHV0cyBhcmUgcmVjb3JkZWRcclxuICogaW4gdGhlIHByZXZpb3VzIHRyYW5zYWN0aW9uIG91dHB1dHMgYmVpbmcgc3BlbnQuKVxyXG4gKiBUaGlzIG1ldGhvZCB0aGVyZWZvcmUgcmFpc2VzIGEgXCJNaXNzaW5nUHJldmlvdXNPdXRwdXRcIlxyXG4gKiBlcnJvciB3aGVuIGNhbGxlZCBvbiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXHJcbiAqXHJcbiAqIElmIHRoZXJlJ3Mgbm8gZmVlIHNldCBhbmQgbm8gY2hhbmdlIGFkZHJlc3MsXHJcbiAqIGVzdGltYXRlIHRoZSBmZWUgYmFzZWQgb24gc2l6ZS5cclxuICpcclxuICogQHJldHVybiB7TnVtYmVyfSBmZWUgb2YgdGhpcyB0cmFuc2FjdGlvbiBpbiBzYXRvc2hpc1xyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldEZlZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICh0aGlzLmlzQ29pbmJhc2UoKSkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIGlmICh0aGlzLl9mZWUgIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZlZTtcclxuICB9XHJcbiAgLy8gaWYgbm8gY2hhbmdlIG91dHB1dCBpcyBzZXQsIGZlZXMgc2hvdWxkIGVxdWFsIGFsbCB0aGUgdW5zcGVudCBhbW91bnRcclxuICBpZiAoIXRoaXMuX2NoYW5nZVNjcmlwdCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldFVuc3BlbnRWYWx1ZSgpO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcy5fZXN0aW1hdGVGZWUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFc3RpbWF0ZXMgZmVlIGZyb20gc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBzaXplIGluIGJ5dGVzLlxyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9lc3RpbWF0ZUZlZSA9IGZ1bmN0aW9uICgpIHtcclxuICBjb25zdCBlc3RpbWF0ZWRTaXplID0gdGhpcy5fZXN0aW1hdGVTaXplKCk7XHJcbiAgY29uc3QgYXZhaWxhYmxlID0gdGhpcy5fZ2V0VW5zcGVudFZhbHVlKCk7XHJcbiAgY29uc3QgZmVlUmF0ZSA9IHRoaXMuX2ZlZVBlckJ5dGUgfHwgKHRoaXMuX2ZlZVBlcktiIHx8IFRyYW5zYWN0aW9uLkZFRV9QRVJfS0IpIC8gMTAwMDtcclxuICBmdW5jdGlvbiBnZXRGZWUoc2l6ZSkge1xyXG4gICAgcmV0dXJuIHNpemUgKiBmZWVSYXRlO1xyXG4gIH1cclxuICBjb25zdCBmZWUgPSBNYXRoLmNlaWwoZ2V0RmVlKGVzdGltYXRlZFNpemUpKTtcclxuICBjb25zdCBmZWVXaXRoQ2hhbmdlID0gTWF0aC5jZWlsKGdldEZlZShlc3RpbWF0ZWRTaXplKSArIGdldEZlZSh0aGlzLl9lc3RpbWF0ZVNpemVPZkNoYW5nZU91dHB1dCgpKSk7XHJcbiAgaWYgKCF0aGlzLl9jaGFuZ2VTY3JpcHQgfHwgYXZhaWxhYmxlIDw9IGZlZVdpdGhDaGFuZ2UpIHtcclxuICAgIHJldHVybiBmZWU7XHJcbiAgfVxyXG4gIHJldHVybiBmZWVXaXRoQ2hhbmdlO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9lc3RpbWF0ZVNpemVPZkNoYW5nZU91dHB1dCA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAoIXRoaXMuX2NoYW5nZVNjcmlwdCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIGNvbnN0IHNjcmlwdExlbiA9IHRoaXMuX2NoYW5nZVNjcmlwdC50b0J1ZmZlcigpLmxlbmd0aDtcclxuICAvLyA4IGJ5dGVzIGZvciBzYXRvc2hpcyArIHNjcmlwdCBzaXplICsgYWN0dWFsIHNjcmlwdCBzaXplXHJcbiAgcmV0dXJuIDggKyBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKHNjcmlwdExlbikubGVuZ3RoICsgc2NyaXB0TGVuO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRVbnNwZW50VmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5fZ2V0SW5wdXRBbW91bnQoKSAtIHRoaXMuX2dldE91dHB1dEFtb3VudCgpO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9jbGVhclNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcclxuICBmb3IgKGNvbnN0IGlucHV0IG9mIHRoaXMuaW5wdXRzIHx8IFtdKSB7XHJcbiAgICBpbnB1dC5jbGVhclNpZ25hdHVyZXMoKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRXN0aW1hdGUgdGhlIHR4IHNpemUgYmVmb3JlIGlucHV0IHNpZ25hdHVyZXMgYXJlIGFkZGVkLlxyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9lc3RpbWF0ZVNpemUgPSBmdW5jdGlvbigpIHtcclxuICBsZXQgcmVzdWx0ID0gNDsgLy8gdmVyc2lvblxyXG5cclxuICBpZiAodGhpcy5oYXNXaXRuZXNzZXMoKSkge1xyXG4gICAgcmVzdWx0ICs9IC41O1xyXG4gIH1cclxuXHJcbiAgcmVzdWx0ICs9IEJ1ZmZlcldyaXRlci52YXJpbnRCdWZOdW0odGhpcy5pbnB1dHMubGVuZ3RoKS5sZW5ndGg7XHJcbiAgZm9yIChjb25zdCBpbnB1dCBvZiB0aGlzLmlucHV0cyB8fCBbXSkge1xyXG4gICAgcmVzdWx0ICs9IGlucHV0Ll9lc3RpbWF0ZVNpemUoKTtcclxuICB9XHJcblxyXG4gIHJlc3VsdCArPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKHRoaXMub3V0cHV0cy5sZW5ndGgpLmxlbmd0aDtcclxuICBmb3IgKGNvbnN0IG91dHB1dCBvZiB0aGlzLm91dHB1dHMgfHwgW10pIHtcclxuICAgIHJlc3VsdCArPSBvdXRwdXQuY2FsY3VsYXRlU2l6ZSgpO1xyXG4gIH1cclxuXHJcbiAgcmVzdWx0ICs9IDQ7IC8vIG5Mb2NrVGltZVxyXG4gIHJldHVybiBNYXRoLmNlaWwocmVzdWx0KTtcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fY2FsY3VsYXRlU2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkubGVuZ3RoO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9jYWxjdWxhdGVWU2l6ZSA9IGZ1bmN0aW9uKG5vUm91bmQpIHtcclxuICBjb25zdCB2c2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZVdlaWdodCgpIC8gNDtcclxuICByZXR1cm4gbm9Sb3VuZCA/IHZzaXplIDogTWF0aC5jZWlsKHZzaXplKTtcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fY2FsY3VsYXRlV2VpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICh0aGlzLnRvQnVmZmVyKHRydWUpLmxlbmd0aCAqIDMpICsgdGhpcy50b0J1ZmZlcihmYWxzZSkubGVuZ3RoO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9yZW1vdmVPdXRwdXQgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaW5kZXhdO1xyXG4gIHRoaXMub3V0cHV0cyA9IF8ud2l0aG91dCh0aGlzLm91dHB1dHMsIG91dHB1dCk7XHJcbiAgdGhpcy5fb3V0cHV0QW1vdW50ID0gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlbW92ZU91dHB1dCA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgdGhpcy5fcmVtb3ZlT3V0cHV0KGluZGV4KTtcclxuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTb3J0IGEgdHJhbnNhY3Rpb24ncyBpbnB1dHMgYW5kIG91dHB1dHMgYWNjb3JkaW5nIHRvIEJJUDY5XHJcbiAqXHJcbiAqIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjkubWVkaWF3aWtpfVxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpc1xyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLnNvcnRJbnB1dHMoZnVuY3Rpb24oaW5wdXRzKSB7XHJcbiAgICB2YXIgY29weSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGlucHV0cyk7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICBjb3B5LmZvckVhY2goKHgpID0+IHsgeC5pID0gaSsrfSk7XHJcbiAgICBjb3B5LnNvcnQoZnVuY3Rpb24oZmlyc3QsIHNlY29uZCkge1xyXG4gICAgIHJldHVybiBjb21wYXJlKGZpcnN0LnByZXZUeElkLCBzZWNvbmQucHJldlR4SWQpXHJcbiAgICAgICAgfHwgZmlyc3Qub3V0cHV0SW5kZXggLSBzZWNvbmQub3V0cHV0SW5kZXhcclxuICAgICAgICB8fCBmaXJzdC5pIC0gc2Vjb25kLmk7ICAvLyB0byBlbnN1cmUgc3RhYmxlIHNvcnRcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvcHk7XHJcbiAgfSk7XHJcbiAgdGhpcy5zb3J0T3V0cHV0cyhmdW5jdGlvbihvdXRwdXRzKSB7XHJcbiAgICB2YXIgY29weSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIG91dHB1dHMpO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgY29weS5mb3JFYWNoKCh4KSA9PiB7IHguaSA9IGkrK30pO1xyXG4gICAgY29weS5zb3J0KGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgICAgcmV0dXJuIGZpcnN0LnNhdG9zaGlzIC0gc2Vjb25kLnNhdG9zaGlzXHJcbiAgICAgICAgfHwgY29tcGFyZShmaXJzdC5zY3JpcHQudG9CdWZmZXIoKSwgc2Vjb25kLnNjcmlwdC50b0J1ZmZlcigpKVxyXG4gICAgICAgIHx8IGZpcnN0LmkgLSBzZWNvbmQuaTsgIC8vIHRvIGVuc3VyZSBzdGFibGUgc29ydFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY29weTtcclxuICB9KTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSYW5kb21pemUgdGhpcyB0cmFuc2FjdGlvbidzIG91dHB1dHMgb3JkZXJpbmcuIFRoZSBzaHVmZmxpbmcgYWxnb3JpdGhtIGlzIGFcclxuICogdmVyc2lvbiBvZiB0aGUgRmlzaGVyLVlhdGVzIHNodWZmbGUsIHByb3ZpZGVkIGJ5IGxvZGFzaCdzIF8uc2h1ZmZsZSgpLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpc1xyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNodWZmbGVPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMuc29ydE91dHB1dHMoXy5zaHVmZmxlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTb3J0IHRoaXMgdHJhbnNhY3Rpb24ncyBvdXRwdXRzLCBhY2NvcmRpbmcgdG8gYSBnaXZlbiBzb3J0aW5nIGZ1bmN0aW9uIHRoYXRcclxuICogdGFrZXMgYW4gYXJyYXkgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYSBuZXcgYXJyYXksIHdpdGggdGhlIHNhbWUgZWxlbWVudHNcclxuICogYnV0IHdpdGggYSBkaWZmZXJlbnQgb3JkZXIuIFRoZSBhcmd1bWVudCBmdW5jdGlvbiBNVVNUIE5PVCBtb2RpZnkgdGhlIG9yZGVyXHJcbiAqIG9mIHRoZSBvcmlnaW5hbCBhcnJheVxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0aW5nRnVuY3Rpb25cclxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5zb3J0T3V0cHV0cyA9IGZ1bmN0aW9uKHNvcnRpbmdGdW5jdGlvbikge1xyXG4gIHZhciBvdXRzID0gc29ydGluZ0Z1bmN0aW9uKHRoaXMub3V0cHV0cyk7XHJcbiAgcmV0dXJuIHRoaXMuX25ld091dHB1dE9yZGVyKG91dHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNvcnQgdGhpcyB0cmFuc2FjdGlvbidzIGlucHV0cywgYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gc29ydGluZyBmdW5jdGlvbiB0aGF0XHJcbiAqIHRha2VzIGFuIGFycmF5IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgbmV3IGFycmF5LCB3aXRoIHRoZSBzYW1lIGVsZW1lbnRzXHJcbiAqIGJ1dCB3aXRoIGEgZGlmZmVyZW50IG9yZGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0aW5nRnVuY3Rpb25cclxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5zb3J0SW5wdXRzID0gZnVuY3Rpb24oc29ydGluZ0Z1bmN0aW9uKSB7XHJcbiAgdGhpcy5pbnB1dHMgPSBzb3J0aW5nRnVuY3Rpb24odGhpcy5pbnB1dHMpO1xyXG4gIHRoaXMuX2NsZWFyU2lnbmF0dXJlcygpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9uZXdPdXRwdXRPcmRlciA9IGZ1bmN0aW9uKG5ld091dHB1dHMpIHtcclxuICB2YXIgaXNJbnZhbGlkU29ydGluZyA9ICh0aGlzLm91dHB1dHMubGVuZ3RoICE9PSBuZXdPdXRwdXRzLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF8uZGlmZmVyZW5jZSh0aGlzLm91dHB1dHMsIG5ld091dHB1dHMpLmxlbmd0aCAhPT0gMCk7XHJcbiAgaWYgKGlzSW52YWxpZFNvcnRpbmcpIHtcclxuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW52YWxpZFNvcnRpbmcoKTtcclxuICB9XHJcblxyXG4gIGlmICh0aGlzLl9jaGFuZ2VJbmRleCAhPSBudWxsKSB7XHJcbiAgICB2YXIgY2hhbmdlT3V0cHV0ID0gdGhpcy5vdXRwdXRzW3RoaXMuX2NoYW5nZUluZGV4XTtcclxuICAgIHRoaXMuX2NoYW5nZUluZGV4ID0gbmV3T3V0cHV0cy5pbmRleE9mKGNoYW5nZU91dHB1dCk7XHJcbiAgfVxyXG5cclxuICB0aGlzLm91dHB1dHMgPSBuZXdPdXRwdXRzO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlbW92ZUlucHV0ID0gZnVuY3Rpb24odHhJZCwgb3V0cHV0SW5kZXgpIHtcclxuICB2YXIgaW5kZXg7XHJcbiAgaWYgKCFvdXRwdXRJbmRleCAmJiAhaXNOYU4odHhJZCkpIHtcclxuICAgIGluZGV4ID0gdHhJZDtcclxuICB9IGVsc2Uge1xyXG4gICAgaW5kZXggPSB0aGlzLmlucHV0cy5maW5kSW5kZXgoZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgcmV0dXJuIGlucHV0LnByZXZUeElkLnRvU3RyaW5nKCdoZXgnKSA9PT0gdHhJZCAmJiBpbnB1dC5vdXRwdXRJbmRleCA9PT0gb3V0cHV0SW5kZXg7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmlucHV0cy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW52YWxpZEluZGV4KGluZGV4LCB0aGlzLmlucHV0cy5sZW5ndGgpO1xyXG4gIH1cclxuICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpbmRleF07XHJcbiAgdGhpcy5pbnB1dHMgPSBfLndpdGhvdXQodGhpcy5pbnB1dHMsIGlucHV0KTtcclxuICB0aGlzLl9pbnB1dEFtb3VudCA9IHVuZGVmaW5lZDtcclxuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcclxufTtcclxuXHJcbi8qIFNpZ25hdHVyZSBoYW5kbGluZyAqL1xyXG5cclxuLyoqXHJcbiAqIFNpZ24gdGhlIHRyYW5zYWN0aW9uIHVzaW5nIG9uZSBvciBtb3JlIHByaXZhdGUga2V5cy5cclxuICpcclxuICogSXQgdHJpZXMgdG8gc2lnbiBlYWNoIGlucHV0LCB2ZXJpZnlpbmcgdGhhdCB0aGUgc2lnbmF0dXJlIHdpbGwgYmUgdmFsaWRcclxuICogKG1hdGNoZXMgYSBwdWJsaWMga2V5KS5cclxuICpcclxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd8UHJpdmF0ZUtleX0gcHJpdmF0ZUtleVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCAtIG1ldGhvZCB1c2VkIHRvIHNpZ24gLSAnZWNkc2EnIG9yICdzY2hub3JyJ1xyXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IG1lcmtsZVJvb3QgLSBtZXJrbGUgcm9vdCBmb3IgdGFwcm9vdCBzaWduaW5nXHJcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24ocHJpdmF0ZUtleSwgc2lndHlwZSwgc2lnbmluZ01ldGhvZCwgbWVya2xlUm9vdCkge1xyXG4gICQuY2hlY2tTdGF0ZSh0aGlzLmhhc0FsbFV0eG9JbmZvKCksICdOb3QgYWxsIHV0eG8gaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uLicpO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHByaXZhdGVLZXkpKSB7XHJcbiAgICBmb3IgKGNvbnN0IHBrIG9mIHByaXZhdGVLZXkpIHtcclxuICAgICAgdGhpcy5zaWduKHBrLCBzaWd0eXBlLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiB0aGlzLmdldFNpZ25hdHVyZXMocHJpdmF0ZUtleSwgc2lndHlwZSwgc2lnbmluZ01ldGhvZCwgbWVya2xlUm9vdCkpIHtcclxuICAgIHRoaXMuYXBwbHlTaWduYXR1cmUoc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKHByaXZLZXksIHNpZ3R5cGUsIHNpZ25pbmdNZXRob2QsIG1lcmtsZVJvb3QpIHtcclxuICBpZiAodHlwZW9mIG1lcmtsZVJvb3QgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBtZXJrbGVSb290ID0gQnVmZmVyLmZyb20obWVya2xlUm9vdCwgJ2hleCcpO1xyXG4gIH1cclxuICBwcml2S2V5ID0gbmV3IFByaXZhdGVLZXkocHJpdktleSk7XHJcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gIGNvbnN0IGhhc2hEYXRhID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAocHJpdktleS5wdWJsaWNLZXkudG9CdWZmZXIoKSk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIGlucHV0LmdldFNpZ25hdHVyZXModGhpcywgcHJpdktleSwgaSwgc2lndHlwZSwgaGFzaERhdGEsIHNpZ25pbmdNZXRob2QsIG1lcmtsZVJvb3QpKSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaChzaWduYXR1cmUpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0cztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYSBzaWduYXR1cmUgdG8gdGhlIHRyYW5zYWN0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWduYXR1cmVcclxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ25hdHVyZS5pbnB1dEluZGV4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWduYXR1cmUuc2lndHlwZVxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gc2lnbmF0dXJlLnB1YmxpY0tleVxyXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlLnNpZ25hdHVyZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCAtICdlY2RzYScgdG8gc2lnbiB0cmFuc2FjdGlvblxyXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuYXBwbHlTaWduYXR1cmUgPSBmdW5jdGlvbihzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcclxuICB0aGlzLmlucHV0c1tzaWduYXR1cmUuaW5wdXRJbmRleF0uYWRkU2lnbmF0dXJlKHRoaXMsIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xyXG4gIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMgfHwgW10pIHtcclxuICAgIGlmIChpbnB1dC5pc0Z1bGx5U2lnbmVkID09PSBJbnB1dC5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLlVuYWJsZVRvVmVyaWZ5U2lnbmF0dXJlKFxyXG4gICAgICAgICdVbnJlY29nbml6ZWQgc2NyaXB0IGtpbmQsIG9yIG5vdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZXhlY3V0ZSBzY3JpcHQuJyArXHJcbiAgICAgICAgJ1RoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiBmcm9tIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbidcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXMuaW5wdXRzLmV2ZXJ5KGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQuaXNGdWxseVNpZ25lZCgpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbihzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcclxuICBpZiAodGhpcy5pbnB1dHNbc2lnbmF0dXJlLmlucHV0SW5kZXhdLmlzVmFsaWRTaWduYXR1cmUgPT09IElucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlKSB7XHJcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLlVuYWJsZVRvVmVyaWZ5U2lnbmF0dXJlKFxyXG4gICAgICAnVW5yZWNvZ25pemVkIHNjcmlwdCBraW5kLCBvciBub3QgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGV4ZWN1dGUgc2NyaXB0LicgK1xyXG4gICAgICAnVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uJ1xyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXMuaW5wdXRzW3NpZ25hdHVyZS5pbnB1dEluZGV4XS5pc1ZhbGlkU2lnbmF0dXJlKHRoaXMsIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFZlcmlmeSBFQ0RTQSBzaWduYXR1cmVcclxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZyBcclxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleSBcclxuICogQHBhcmFtIHtOdW1iZXJ9IG5pbiBcclxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdCBcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNhdG9zaGlzIFxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5jaGVja0VjZHNhU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnLCBwdWJrZXksIG5pbiwgc3Vic2NyaXB0LCBzYXRvc2hpcykge1xyXG4gIHZhciBzdWJzY3JpcHRCdWZmZXIgPSBzdWJzY3JpcHQudG9CdWZmZXIoKTtcclxuICB2YXIgc2NyaXB0Q29kZVdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICBzY3JpcHRDb2RlV3JpdGVyLndyaXRlVmFyaW50TnVtKHN1YnNjcmlwdEJ1ZmZlci5sZW5ndGgpO1xyXG4gIHNjcmlwdENvZGVXcml0ZXIud3JpdGUoc3Vic2NyaXB0QnVmZmVyKTtcclxuXHJcbiAgdmFyIHNhdG9zaGlzQnVmZmVyO1xyXG4gIGlmIChzYXRvc2hpcykge1xyXG4gICAgJC5jaGVja1N0YXRlKEpTVXRpbC5pc05hdHVyYWxOdW1iZXIoc2F0b3NoaXMpLCAnc2F0b3NoaXMgbmVlZHMgdG8gYmUgYSBuYXR1cmFsIG51bWJlcicpO1xyXG4gICAgc2F0b3NoaXNCdWZmZXIgPSBuZXcgQnVmZmVyV3JpdGVyKCkud3JpdGVVSW50NjRMRUJOKG5ldyBCTihzYXRvc2hpcykpLnRvQnVmZmVyKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNhdG9zaGlzQnVmZmVyID0gdGhpcy5pbnB1dHNbbmluXS5nZXRTYXRvc2hpc0J1ZmZlcigpO1xyXG4gIH1cclxuICB2YXIgdmVyaWZpZWQgPSBTaWdoYXNoV2l0bmVzcy52ZXJpZnkoXHJcbiAgICB0aGlzLFxyXG4gICAgc2lnLFxyXG4gICAgcHVia2V5LFxyXG4gICAgbmluLFxyXG4gICAgc2NyaXB0Q29kZVdyaXRlci50b0J1ZmZlcigpLFxyXG4gICAgc2F0b3NoaXNCdWZmZXJcclxuICApO1xyXG4gIHJldHVybiB2ZXJpZmllZDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogVmVyaWZ5IFNjaG5vcnIgc2lnbmF0dXJlXHJcbiAqIEBwYXJhbSB7U2lnbmF0dXJlfEJ1ZmZlcn0gc2lnIFxyXG4gKiBAcGFyYW0ge1B1YmxpY0tleXxCdWZmZXJ9IHB1YmtleSBcclxuICogQHBhcmFtIHtOdW1iZXJ9IG5pbiBcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ3ZlcnNpb24gXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBleGVjZGF0YSBcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuY2hlY2tTY2hub3JyU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnLCBwdWJrZXksIG5pbiwgc2lndmVyc2lvbiwgZXhlY2RhdGEpIHtcclxuICBpZiAoJC5pc1R5cGUocHVia2V5LCAnUHVibGljS2V5JykpIHtcclxuICAgIHB1YmtleSA9IHB1YmtleS5wb2ludC54LnRvQnVmZmVyKCk7XHJcbiAgfVxyXG4gICQuY2hlY2tBcmd1bWVudChwdWJrZXkgJiYgcHVia2V5Lmxlbmd0aCA9PT0gMzIsICdTY2hub3JyIHNpZ25hdHVyZXMgaGF2ZSAzMi1ieXRlIHB1YmxpYyBrZXlzLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbmZvcmNpbmcgdGhpcy4nKTtcclxuXHJcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzaWcpKSB7XHJcbiAgICBpZiAoc2lnLmxlbmd0aCAhPT0gNjQgJiYgc2lnLmxlbmd0aCAhPT0gNjUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc2lnID0gU2lnbmF0dXJlLmZyb21TY2hub3JyKHNpZyk7XHJcbiAgfVxyXG4gIC8vIE5vdGUgdGhhdCBpbiBUYXBzY3JpcHQgZXZhbHVhdGlvbiwgZW1wdHkgc2lnbmF0dXJlcyBhcmUgdHJlYXRlZCBzcGVjaWFsbHkgKGludmFsaWQgc2lnbmF0dXJlIHRoYXQgZG9lcyBub3RcclxuICAvLyBhYm9ydCBzY3JpcHQgZXhlY3V0aW9uKS4gVGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBJbnRlcnByZXRlci5ldmFsQ2hlY2tzaWdUYXBzY3JpcHQsIHdoaWNoIHdvbid0IGludm9rZVxyXG4gIC8vIENoZWNrU2Nobm9yclNpZ25hdHVyZSBpbiB0aGF0IGNhc2UuIEluIG90aGVyIGNvbnRleHRzLCB0aGV5IGFyZSBpbnZhbGlkIGxpa2UgZXZlcnkgb3RoZXIgc2lnbmF0dXJlIHdpdGhcclxuICAvLyBzaXplIGRpZmZlcmVudCBmcm9tIDY0IG9yIDY1LlxyXG4gICQuY2hlY2tBcmd1bWVudChzaWcuaXNTY2hub3JyLCAnU2lnbmF0dXJlIG11c3QgYmUgc2Nobm9ycicpO1xyXG5cclxuICBpZiAoIVNpZ2hhc2hTY2hub3JyLnZlcmlmeSh0aGlzLCBzaWcsIHB1YmtleSwgc2lndmVyc2lvbiwgbmluLCBleGVjZGF0YSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBoZXJlIGxhcmdlbHkgZm9yIGxlZ2FjeSByZWFzb25zLiBIb3dldmVyLCBpZiB0aGUgc2lnIHR5cGVcclxuICogaXMgYWxyZWFkeSBrbm93biAodmlhIHNpZ3ZlcnNpb24pLCB0aGVuIGl0IHdvdWxkIGJlIGJldHRlciB0byBjYWxsXHJcbiAqIGNoZWNrRWNkc2FTaWduYXR1cmUgb3IgY2hlY2tTY2hub3JyU2lnbmF0dXJlIGRpcmVjdGx5LlxyXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZyBTaWduYXR1cmUgdG8gdmVyaWZ5XHJcbiAqIEBwYXJhbSB7UHVibGljS2V5fEJ1ZmZlcn0gcHVia2V5IFB1YmxpYyBrZXkgdXNlZCB0byB2ZXJpZnkgc2lnXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuaW4gVHggaW5wdXQgaW5kZXggdG8gdmVyaWZ5IHNpZ25hdHVyZSBhZ2FpbnN0XHJcbiAqIEBwYXJhbSB7U2NyaXB0fSBzdWJzY3JpcHQgRUNEU0Egb25seVxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2lndmVyc2lvbiBTZWUgU2lnbmF0dXJlLlZlcnNpb24gZm9yIHZhbGlkIHZlcnNpb25zIChkZWZhdWx0OiAwIG9yIFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYXRvc2hpcyBFQ0RTQSBvbmx5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBleGVjZGF0YSBTY2hub3JyIG9ubHlcclxuICogQHJldHVybnMge0Jvb2xlYW59IHdoZXRoZXIgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCBmb3IgdGhpcyB0cmFuc2FjdGlvbiBpbnB1dFxyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnZlcmlmeVNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCwgc2lndmVyc2lvbiwgc2F0b3NoaXMsIGV4ZWNkYXRhKSB7XHJcbiAgaWYgKHNpZ3ZlcnNpb24gPT0gbnVsbCkge1xyXG4gICAgc2lndmVyc2lvbiA9IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0U7XHJcbiAgfVxyXG5cclxuICBzd2l0Y2goc2lndmVyc2lvbikge1xyXG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwOlxyXG4gICAgICByZXR1cm4gdGhpcy5jaGVja0VjZHNhU2lnbmF0dXJlKHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCwgc2F0b3NoaXMpO1xyXG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09UOlxyXG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQ6XHJcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrU2Nobm9yclNpZ25hdHVyZShzaWcsIHB1YmtleSwgbmluLCBzaWd2ZXJzaW9uLCBleGVjZGF0YSk7XHJcbiAgICBjYXNlIFNpZ25hdHVyZS5WZXJzaW9uLkJBU0U6XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gU2lnaGFzaC52ZXJpZnkodGhpcywgc2lnLCBwdWJrZXksIG5pbiwgc3Vic2NyaXB0KTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgdGhhdCBhIHRyYW5zYWN0aW9uIHBhc3NlcyBiYXNpYyBzYW5pdHkgdGVzdHMuIElmIG5vdCwgcmV0dXJuIGEgc3RyaW5nXHJcbiAqIGRlc2NyaWJpbmcgdGhlIGVycm9yLiBUaGlzIGZ1bmN0aW9uIGNvbnRhaW5zIHRoZSBzYW1lIGxvZ2ljIGFzXHJcbiAqIENoZWNrVHJhbnNhY3Rpb24gaW4gYml0Y29pbiBjb3JlLlxyXG4gKi9cclxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIEJhc2ljIGNoZWNrcyB0aGF0IGRvbid0IGRlcGVuZCBvbiBhbnkgY29udGV4dFxyXG4gIGlmICh0aGlzLmlucHV0cy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAndHJhbnNhY3Rpb24gdHhpbnMgZW1wdHknO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMub3V0cHV0cy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAndHJhbnNhY3Rpb24gdHhvdXRzIGVtcHR5JztcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGZvciBuZWdhdGl2ZSBvciBvdmVyZmxvdyBvdXRwdXQgdmFsdWVzXHJcbiAgdmFyIHZhbHVlb3V0Ym4gPSBuZXcgQk4oMCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciB0eG91dCA9IHRoaXMub3V0cHV0c1tpXTtcclxuXHJcbiAgICBpZiAodHhvdXQuaW52YWxpZFNhdG9zaGlzKCkpIHtcclxuICAgICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCAnICsgaSArICcgc2F0b3NoaXMgaXMgaW52YWxpZCc7XHJcbiAgICB9XHJcbiAgICBpZiAodHhvdXQuX3NhdG9zaGlzQk4uZ3QobmV3IEJOKFRyYW5zYWN0aW9uLk1BWF9NT05FWSwgMTApKSkge1xyXG4gICAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIHR4b3V0ICcgKyBpICsgJyBncmVhdGVyIHRoYW4gTUFYX01PTkVZJztcclxuICAgIH1cclxuICAgIHZhbHVlb3V0Ym4gPSB2YWx1ZW91dGJuLmFkZCh0eG91dC5fc2F0b3NoaXNCTik7XHJcbiAgICBpZiAodmFsdWVvdXRibi5ndChuZXcgQk4oVHJhbnNhY3Rpb24uTUFYX01PTkVZKSkpIHtcclxuICAgICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCAnICsgaSArICcgdG90YWwgb3V0cHV0IGdyZWF0ZXIgdGhhbiBNQVhfTU9ORVknO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2l6ZSBsaW1pdHNcclxuICBpZiAodGhpcy50b0J1ZmZlcigpLmxlbmd0aCA+IE1BWF9CTE9DS19TSVpFKSB7XHJcbiAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIG92ZXIgdGhlIG1heGltdW0gYmxvY2sgc2l6ZSc7XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGlucHV0c1xyXG4gIHZhciB0eGlubWFwID0ge307XHJcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdHhpbiA9IHRoaXMuaW5wdXRzW2ldO1xyXG5cclxuICAgIHZhciBpbnB1dGlkID0gdHhpbi5wcmV2VHhJZCArICc6JyArIHR4aW4ub3V0cHV0SW5kZXg7XHJcbiAgICBpZiAodHhpbm1hcFtpbnB1dGlkXSAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiAndHJhbnNhY3Rpb24gaW5wdXQgJyArIGkgKyAnIGR1cGxpY2F0ZSBpbnB1dCc7XHJcbiAgICB9XHJcbiAgICB0eGlubWFwW2lucHV0aWRdID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBpc0NvaW5iYXNlID0gdGhpcy5pc0NvaW5iYXNlKCk7XHJcbiAgaWYgKGlzQ29pbmJhc2UpIHtcclxuICAgIHZhciBidWYgPSB0aGlzLmlucHV0c1swXS5fc2NyaXB0QnVmZmVyO1xyXG4gICAgaWYgKGJ1Zi5sZW5ndGggPCAyIHx8IGJ1Zi5sZW5ndGggPiAxMDApIHtcclxuICAgICAgcmV0dXJuICdjb2luYmFzZSB0cmFuc2FjdGlvbiBzY3JpcHQgc2l6ZSBpbnZhbGlkJztcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzLmlucHV0c1tpXS5pc051bGwoKSkge1xyXG4gICAgICAgIHJldHVybiAndHJhbnNhY3Rpb24gaW5wdXQgJyArIGkgKyAnIGhhcyBudWxsIGlucHV0JztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbmFsb2dvdXMgdG8gYml0Y29pbmQncyBJc0NvaW5CYXNlIGZ1bmN0aW9uIGluIHRyYW5zYWN0aW9uLmhcclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5pc0NvaW5iYXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICh0aGlzLmlucHV0cy5sZW5ndGggPT09IDEgJiYgdGhpcy5pbnB1dHNbMF0uaXNOdWxsKCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgdGhpcyB0cmFuc2FjdGlvbiBjYW4gYmUgcmVwbGFjZWQgaW4gdGhlIG1lbXBvb2wgd2l0aCBhbm90aGVyXHJcbiAqIHRyYW5zYWN0aW9uIHRoYXQgcHJvdmlkZXMgYSBzdWZmaWNpZW50bHkgaGlnaGVyIGZlZSAoUkJGKS5cclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5pc1JCRiA9IGZ1bmN0aW9uKCkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgaWYgKGlucHV0LnNlcXVlbmNlTnVtYmVyIDwgSW5wdXQuTUFYSU5UIC0gMSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuYWJsZSB0aGlzIHRyYW5zYWN0aW9uIHRvIGJlIHJlcGxhY2VkIGluIHRoZSBtZW1wb29sIChSQkYpIGlmIGEgdHJhbnNhY3Rpb25cclxuICogaW5jbHVkZXMgYSBzdWZmaWNpZW50bHkgaGlnaGVyIGZlZS4gSXQgd2lsbCBzZXQgdGhlIHNlcXVlbmNlTnVtYmVyIHRvXHJcbiAqIERFRkFVTFRfUkJGX1NFUU5VTUJFUiBmb3IgYWxsIGlucHV0cyBpZiB0aGUgc2VxdWVuY2UgbnVtYmVyIGRvZXMgbm90XHJcbiAqIGFscmVhZHkgZW5hYmxlIFJCRi5cclxuICovXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5lbmFibGVSQkYgPSBmdW5jdGlvbigpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgIGlmIChpbnB1dC5zZXF1ZW5jZU51bWJlciA+PSBJbnB1dC5NQVhJTlQgLSAxKSB7XHJcbiAgICAgIGlucHV0LnNlcXVlbmNlTnVtYmVyID0gSW5wdXQuREVGQVVMVF9SQkZfU0VRTlVNQkVSO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZXRWZXJzaW9uID0gZnVuY3Rpb24odmVyc2lvbikge1xyXG4gICQuY2hlY2tBcmd1bWVudChcclxuICAgIEpTVXRpbC5pc05hdHVyYWxOdW1iZXIodmVyc2lvbikgJiYgdmVyc2lvbiA8PSBDVVJSRU5UX1ZFUlNJT04sXHJcbiAgICAnV3JvbmcgdmVyc2lvbiBudW1iZXInKTtcclxuICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/transaction.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/transaction/unspentoutput.js":
/*!*******************************************************!*\
  !*** ../bitcore-lib/lib/transaction/unspentoutput.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"../bitcore-lib/lib/util/js.js\");\r\n\r\nvar Script = __webpack_require__(/*! ../script */ \"../bitcore-lib/lib/script/index.js\");\r\nvar Address = __webpack_require__(/*! ../address */ \"../bitcore-lib/lib/address.js\");\r\nvar Unit = __webpack_require__(/*! ../unit */ \"../bitcore-lib/lib/unit.js\");\r\n\r\n/**\r\n * Represents an unspent output information: its script, associated amount and address,\r\n * transaction id and output index.\r\n *\r\n * @constructor\r\n * @param {object} data\r\n * @param {string} data.txid the previous transaction id\r\n * @param {string=} data.txId alias for `txid`\r\n * @param {number} data.vout the index in the transaction\r\n * @param {number=} data.outputIndex alias for `vout`\r\n * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds\r\n * @param {string|Script=} data.script alias for `scriptPubKey`\r\n * @param {number} data.amount amount of bitcoins associated\r\n * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 BTC = 1e8 satoshis)\r\n * @param {string|Address=} data.address the associated address to the script, if provided\r\n */\r\nfunction UnspentOutput(data) {\r\n  /* jshint maxcomplexity: 20 */\r\n  /* jshint maxstatements: 20 */\r\n  if (!(this instanceof UnspentOutput)) {\r\n    return new UnspentOutput(data);\r\n  }\r\n  $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');\r\n  var address = data.address ? new Address(data.address) : undefined;\r\n  var txId = data.txid ? data.txid : data.txId;\r\n  if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {\r\n    // TODO: Use the errors library\r\n    throw new Error('Invalid TXID in object', data);\r\n  }\r\n  var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;\r\n  if (!_.isNumber(outputIndex)) {\r\n    throw new Error('Invalid outputIndex, received ' + outputIndex);\r\n  }\r\n  $.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script),\r\n                  'Must provide the scriptPubKey for that output!');\r\n  var script = new Script(data.scriptPubKey || data.script);\r\n  $.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),\r\n                      'Must provide an amount for the output');\r\n  var amount = !_.isUndefined(data.amount) ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;\r\n  $.checkArgument(_.isNumber(amount), 'Amount must be a number');\r\n  JSUtil.defineImmutable(this, {\r\n    address: address,\r\n    txId: txId,\r\n    outputIndex: outputIndex,\r\n    script: script,\r\n    satoshis: amount\r\n  });\r\n}\r\n\r\n/**\r\n * Provide an informative output when displaying this object in the console\r\n * @returns string\r\n */\r\nUnspentOutput.prototype.inspect = function() {\r\n  return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex +\r\n         ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>';\r\n};\r\n\r\n/**\r\n * String representation: just \"txid:index\"\r\n * @returns string\r\n */\r\nUnspentOutput.prototype.toString = function() {\r\n  return this.txId + ':' + this.outputIndex;\r\n};\r\n\r\n/**\r\n * Deserialize an UnspentOutput from an object\r\n * @param {object|string} data\r\n * @return UnspentOutput\r\n */\r\nUnspentOutput.fromObject = function(data) {\r\n  return new UnspentOutput(data);\r\n};\r\n\r\n/**\r\n * Returns a plain object (no prototype or methods) with the associated info for this output\r\n * @return {object}\r\n */\r\nUnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() {\r\n  return {\r\n    address: this.address ? this.address.toString() : undefined,\r\n    txid: this.txId,\r\n    vout: this.outputIndex,\r\n    scriptPubKey: this.script.toBuffer().toString('hex'),\r\n    amount: Unit.fromSatoshis(this.satoshis).toBTC()\r\n  };\r\n};\r\n\r\nmodule.exports = UnspentOutput;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3Vuc3BlbnRvdXRwdXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMsdUVBQXVCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxpREFBWTtBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxxREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsaURBQVk7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLDJDQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vdW5zcGVudG91dHB1dC5qcz9mODcwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XHJcblxyXG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XHJcbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi4vYWRkcmVzcycpO1xyXG52YXIgVW5pdCA9IHJlcXVpcmUoJy4uL3VuaXQnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIHVuc3BlbnQgb3V0cHV0IGluZm9ybWF0aW9uOiBpdHMgc2NyaXB0LCBhc3NvY2lhdGVkIGFtb3VudCBhbmQgYWRkcmVzcyxcclxuICogdHJhbnNhY3Rpb24gaWQgYW5kIG91dHB1dCBpbmRleC5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhLnR4aWQgdGhlIHByZXZpb3VzIHRyYW5zYWN0aW9uIGlkXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gZGF0YS50eElkIGFsaWFzIGZvciBgdHhpZGBcclxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGEudm91dCB0aGUgaW5kZXggaW4gdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGF0YS5vdXRwdXRJbmRleCBhbGlhcyBmb3IgYHZvdXRgXHJcbiAqIEBwYXJhbSB7c3RyaW5nfFNjcmlwdH0gZGF0YS5zY3JpcHRQdWJLZXkgdGhlIHNjcmlwdCB0aGF0IG11c3QgYmUgcmVzb2x2ZWQgdG8gcmVsZWFzZSB0aGUgZnVuZHNcclxuICogQHBhcmFtIHtzdHJpbmd8U2NyaXB0PX0gZGF0YS5zY3JpcHQgYWxpYXMgZm9yIGBzY3JpcHRQdWJLZXlgXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFtb3VudCBhbW91bnQgb2YgYml0Y29pbnMgYXNzb2NpYXRlZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IGRhdGEuc2F0b3NoaXMgYWxpYXMgZm9yIGBhbW91bnRgLCBidXQgZXhwcmVzc2VkIGluIHNhdG9zaGlzICgxIEJUQyA9IDFlOCBzYXRvc2hpcylcclxuICogQHBhcmFtIHtzdHJpbmd8QWRkcmVzcz19IGRhdGEuYWRkcmVzcyB0aGUgYXNzb2NpYXRlZCBhZGRyZXNzIHRvIHRoZSBzY3JpcHQsIGlmIHByb3ZpZGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBVbnNwZW50T3V0cHV0KGRhdGEpIHtcclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMjAgKi9cclxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW5zcGVudE91dHB1dCkpIHtcclxuICAgIHJldHVybiBuZXcgVW5zcGVudE91dHB1dChkYXRhKTtcclxuICB9XHJcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3QoZGF0YSksICdNdXN0IHByb3ZpZGUgYW4gb2JqZWN0IGZyb20gd2hlcmUgdG8gZXh0cmFjdCBkYXRhJyk7XHJcbiAgdmFyIGFkZHJlc3MgPSBkYXRhLmFkZHJlc3MgPyBuZXcgQWRkcmVzcyhkYXRhLmFkZHJlc3MpIDogdW5kZWZpbmVkO1xyXG4gIHZhciB0eElkID0gZGF0YS50eGlkID8gZGF0YS50eGlkIDogZGF0YS50eElkO1xyXG4gIGlmICghdHhJZCB8fCAhSlNVdGlsLmlzSGV4YVN0cmluZyh0eElkKSB8fCB0eElkLmxlbmd0aCA+IDY0KSB7XHJcbiAgICAvLyBUT0RPOiBVc2UgdGhlIGVycm9ycyBsaWJyYXJ5XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVFhJRCBpbiBvYmplY3QnLCBkYXRhKTtcclxuICB9XHJcbiAgdmFyIG91dHB1dEluZGV4ID0gXy5pc1VuZGVmaW5lZChkYXRhLnZvdXQpID8gZGF0YS5vdXRwdXRJbmRleCA6IGRhdGEudm91dDtcclxuICBpZiAoIV8uaXNOdW1iZXIob3V0cHV0SW5kZXgpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3V0cHV0SW5kZXgsIHJlY2VpdmVkICcgKyBvdXRwdXRJbmRleCk7XHJcbiAgfVxyXG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZChkYXRhLnNjcmlwdFB1YktleSkgfHwgIV8uaXNVbmRlZmluZWQoZGF0YS5zY3JpcHQpLFxyXG4gICAgICAgICAgICAgICAgICAnTXVzdCBwcm92aWRlIHRoZSBzY3JpcHRQdWJLZXkgZm9yIHRoYXQgb3V0cHV0IScpO1xyXG4gIHZhciBzY3JpcHQgPSBuZXcgU2NyaXB0KGRhdGEuc2NyaXB0UHViS2V5IHx8IGRhdGEuc2NyaXB0KTtcclxuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQoZGF0YS5hbW91bnQpIHx8ICFfLmlzVW5kZWZpbmVkKGRhdGEuc2F0b3NoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgJ011c3QgcHJvdmlkZSBhbiBhbW91bnQgZm9yIHRoZSBvdXRwdXQnKTtcclxuICB2YXIgYW1vdW50ID0gIV8uaXNVbmRlZmluZWQoZGF0YS5hbW91bnQpID8gbmV3IFVuaXQuZnJvbUJUQyhkYXRhLmFtb3VudCkudG9TYXRvc2hpcygpIDogZGF0YS5zYXRvc2hpcztcclxuICAkLmNoZWNrQXJndW1lbnQoXy5pc051bWJlcihhbW91bnQpLCAnQW1vdW50IG11c3QgYmUgYSBudW1iZXInKTtcclxuICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKHRoaXMsIHtcclxuICAgIGFkZHJlc3M6IGFkZHJlc3MsXHJcbiAgICB0eElkOiB0eElkLFxyXG4gICAgb3V0cHV0SW5kZXg6IG91dHB1dEluZGV4LFxyXG4gICAgc2NyaXB0OiBzY3JpcHQsXHJcbiAgICBzYXRvc2hpczogYW1vdW50XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlIGFuIGluZm9ybWF0aXZlIG91dHB1dCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBvYmplY3QgaW4gdGhlIGNvbnNvbGVcclxuICogQHJldHVybnMgc3RyaW5nXHJcbiAqL1xyXG5VbnNwZW50T3V0cHV0LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICc8VW5zcGVudE91dHB1dDogJyArIHRoaXMudHhJZCArICc6JyArIHRoaXMub3V0cHV0SW5kZXggK1xyXG4gICAgICAgICAnLCBzYXRvc2hpczogJyArIHRoaXMuc2F0b3NoaXMgKyAnLCBhZGRyZXNzOiAnICsgdGhpcy5hZGRyZXNzICsgJz4nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN0cmluZyByZXByZXNlbnRhdGlvbjoganVzdCBcInR4aWQ6aW5kZXhcIlxyXG4gKiBAcmV0dXJucyBzdHJpbmdcclxuICovXHJcblVuc3BlbnRPdXRwdXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudHhJZCArICc6JyArIHRoaXMub3V0cHV0SW5kZXg7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVzZXJpYWxpemUgYW4gVW5zcGVudE91dHB1dCBmcm9tIGFuIG9iamVjdFxyXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IGRhdGFcclxuICogQHJldHVybiBVbnNwZW50T3V0cHV0XHJcbiAqL1xyXG5VbnNwZW50T3V0cHV0LmZyb21PYmplY3QgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBVbnNwZW50T3V0cHV0KGRhdGEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwbGFpbiBvYmplY3QgKG5vIHByb3RvdHlwZSBvciBtZXRob2RzKSB3aXRoIHRoZSBhc3NvY2lhdGVkIGluZm8gZm9yIHRoaXMgb3V0cHV0XHJcbiAqIEByZXR1cm4ge29iamVjdH1cclxuICovXHJcblVuc3BlbnRPdXRwdXQucHJvdG90eXBlLnRvT2JqZWN0ID0gVW5zcGVudE91dHB1dC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyA/IHRoaXMuYWRkcmVzcy50b1N0cmluZygpIDogdW5kZWZpbmVkLFxyXG4gICAgdHhpZDogdGhpcy50eElkLFxyXG4gICAgdm91dDogdGhpcy5vdXRwdXRJbmRleCxcclxuICAgIHNjcmlwdFB1YktleTogdGhpcy5zY3JpcHQudG9CdWZmZXIoKS50b1N0cmluZygnaGV4JyksXHJcbiAgICBhbW91bnQ6IFVuaXQuZnJvbVNhdG9zaGlzKHRoaXMuc2F0b3NoaXMpLnRvQlRDKClcclxuICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVbnNwZW50T3V0cHV0O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/transaction/unspentoutput.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/unit.js":
/*!**********************************!*\
  !*** ../bitcore-lib/lib/unit.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\nvar errors = __webpack_require__(/*! ./errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nvar UNITS = {\r\n  'BTC'      : [1e8, 8],\r\n  'mBTC'     : [1e5, 5],\r\n  'uBTC'     : [1e2, 2],\r\n  'bits'     : [1e2, 2],\r\n  'satoshis' : [1, 0]\r\n};\r\n\r\n/**\r\n * Utility for handling and converting bitcoins units. The supported units are\r\n * BTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an\r\n * amount and a unit code, or alternatively using static methods like {fromBTC}.\r\n * It also allows to be created from a fiat amount and the exchange rate, or\r\n * alternatively using the {fromFiat} static method.\r\n * You can consult for different representation of a unit instance using it's\r\n * {to} method, the fixed unit methods like {toSatoshis} or alternatively using\r\n * the unit accessors. It also can be converted to a fiat amount by providing the\r\n * corresponding BTC/fiat exchange rate.\r\n *\r\n * @example\r\n * ```javascript\r\n * var sats = Unit.fromBTC(1.3).toSatoshis();\r\n * var mili = Unit.fromBits(1.3).to(Unit.mBTC);\r\n * var bits = Unit.fromFiat(1.3, 350).bits;\r\n * var btc = new Unit(1.3, Unit.bits).BTC;\r\n * ```\r\n *\r\n * @param {Number} amount - The amount to be represented\r\n * @param {String|Number} code - The unit of the amount or the exchange rate\r\n * @returns {Unit} A new instance of an Unit\r\n * @constructor\r\n */\r\nfunction Unit(amount, code) {\r\n  if (!(this instanceof Unit)) {\r\n    return new Unit(amount, code);\r\n  }\r\n\r\n  // convert fiat to BTC\r\n  if (_.isNumber(code)) {\r\n    if (code <= 0) {\r\n      throw new errors.Unit.InvalidRate(code);\r\n    }\r\n    amount = amount / code;\r\n    code = Unit.BTC;\r\n  }\r\n\r\n  this._value = this._from(amount, code);\r\n\r\n  var self = this;\r\n  var defineAccesor = function(key) {\r\n    Object.defineProperty(self, key, {\r\n      get: function() { return self.to(key); },\r\n      enumerable: true,\r\n    });\r\n  };\r\n\r\n  Object.keys(UNITS).forEach(defineAccesor);\r\n}\r\n\r\nObject.keys(UNITS).forEach(function(key) {\r\n  Unit[key] = key;\r\n});\r\n\r\n/**\r\n * Returns a Unit instance created from JSON string or object\r\n *\r\n * @param {String|Object} json - JSON with keys: amount and code\r\n * @returns {Unit} A Unit instance\r\n */\r\nUnit.fromObject = function fromObject(data){\r\n  $.checkArgument(_.isObject(data), 'Argument is expected to be an object');\r\n  return new Unit(data.amount, data.code);\r\n};\r\n\r\n/**\r\n * Returns a Unit instance created from an amount in BTC\r\n *\r\n * @param {Number} amount - The amount in BTC\r\n * @returns {Unit} A Unit instance\r\n */\r\nUnit.fromBTC = function(amount) {\r\n  return new Unit(amount, Unit.BTC);\r\n};\r\n\r\n/**\r\n * Returns a Unit instance created from an amount in mBTC\r\n *\r\n * @param {Number} amount - The amount in mBTC\r\n * @returns {Unit} A Unit instance\r\n */\r\nUnit.fromMillis = Unit.fromMilis = function(amount) {\r\n  return new Unit(amount, Unit.mBTC);\r\n};\r\n\r\n/**\r\n * Returns a Unit instance created from an amount in bits\r\n *\r\n * @param {Number} amount - The amount in bits\r\n * @returns {Unit} A Unit instance\r\n */\r\nUnit.fromMicros = Unit.fromBits = function(amount) {\r\n  return new Unit(amount, Unit.bits);\r\n};\r\n\r\n/**\r\n * Returns a Unit instance created from an amount in satoshis\r\n *\r\n * @param {Number} amount - The amount in satoshis\r\n * @returns {Unit} A Unit instance\r\n */\r\nUnit.fromSatoshis = function(amount) {\r\n  return new Unit(amount, Unit.satoshis);\r\n};\r\n\r\n/**\r\n * Returns a Unit instance created from a fiat amount and exchange rate.\r\n *\r\n * @param {Number} amount - The amount in fiat\r\n * @param {Number} rate - The exchange rate BTC/fiat\r\n * @returns {Unit} A Unit instance\r\n */\r\nUnit.fromFiat = function(amount, rate) {\r\n  return new Unit(amount, rate);\r\n};\r\n\r\nUnit.prototype._from = function(amount, code) {\r\n  if (!UNITS[code]) {\r\n    throw new errors.Unit.UnknownCode(code);\r\n  }\r\n  return parseInt((amount * UNITS[code][0]).toFixed());\r\n};\r\n\r\n/**\r\n * Returns the value represented in the specified unit\r\n *\r\n * @param {String|Number} code - The unit code or exchange rate\r\n * @returns {Number} The converted value\r\n */\r\nUnit.prototype.to = function(code) {\r\n  if (_.isNumber(code)) {\r\n    if (code <= 0) {\r\n      throw new errors.Unit.InvalidRate(code);\r\n    }\r\n    return parseFloat((this.BTC * code).toFixed(2));\r\n  }\r\n\r\n  if (!UNITS[code]) {\r\n    throw new errors.Unit.UnknownCode(code);\r\n  }\r\n\r\n  var value = this._value / UNITS[code][0];\r\n  return parseFloat(value.toFixed(UNITS[code][1]));\r\n};\r\n\r\n/**\r\n * Returns the value represented in BTC\r\n *\r\n * @returns {Number} The value converted to BTC\r\n */\r\nUnit.prototype.toBTC = function() {\r\n  return this.to(Unit.BTC);\r\n};\r\n\r\n/**\r\n * Returns the value represented in mBTC\r\n *\r\n * @returns {Number} The value converted to mBTC\r\n */\r\nUnit.prototype.toMillis = Unit.prototype.toMilis = function() {\r\n  return this.to(Unit.mBTC);\r\n};\r\n\r\n/**\r\n * Returns the value represented in bits\r\n *\r\n * @returns {Number} The value converted to bits\r\n */\r\nUnit.prototype.toMicros = Unit.prototype.toBits = function() {\r\n  return this.to(Unit.bits);\r\n};\r\n\r\n/**\r\n * Returns the value represented in satoshis\r\n *\r\n * @returns {Number} The value converted to satoshis\r\n */\r\nUnit.prototype.toSatoshis = function() {\r\n  return this.to(Unit.satoshis);\r\n};\r\n\r\n/**\r\n * Returns the value represented in fiat\r\n *\r\n * @param {string} rate - The exchange rate between BTC/currency\r\n * @returns {Number} The value converted to satoshis\r\n */\r\nUnit.prototype.atRate = function(rate) {\r\n  return this.to(rate);\r\n};\r\n\r\n/**\r\n * Returns a the string representation of the value in satoshis\r\n *\r\n * @returns {string} the value in satoshis\r\n */\r\nUnit.prototype.toString = function() {\r\n  return this.satoshis + ' satoshis';\r\n};\r\n\r\n/**\r\n * Returns a plain object representation of the Unit\r\n *\r\n * @returns {Object} An object with the keys: amount and code\r\n */\r\nUnit.prototype.toObject = Unit.prototype.toJSON = function toObject() {\r\n  return {\r\n    amount: this.BTC,\r\n    code: Unit.BTC\r\n  };\r\n};\r\n\r\n/**\r\n * Returns a string formatted for the console\r\n *\r\n * @returns {string} the value in satoshis\r\n */\r\nUnit.prototype.inspect = function() {\r\n  return '<Unit: ' + this.toString() + '>';\r\n};\r\n\r\nmodule.exports = Unit;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3VuaXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvREFBVTtBQUMvQixRQUFRLG1CQUFPLENBQUMsc0VBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxRQUFRO0FBQy9FO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQSxJQUFJLElBQUkscUNBQXFDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi91bml0LmpzPzk1YTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuXHJcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xyXG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XHJcblxyXG52YXIgVU5JVFMgPSB7XHJcbiAgJ0JUQycgICAgICA6IFsxZTgsIDhdLFxyXG4gICdtQlRDJyAgICAgOiBbMWU1LCA1XSxcclxuICAndUJUQycgICAgIDogWzFlMiwgMl0sXHJcbiAgJ2JpdHMnICAgICA6IFsxZTIsIDJdLFxyXG4gICdzYXRvc2hpcycgOiBbMSwgMF1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGZvciBoYW5kbGluZyBhbmQgY29udmVydGluZyBiaXRjb2lucyB1bml0cy4gVGhlIHN1cHBvcnRlZCB1bml0cyBhcmVcclxuICogQlRDLCBtQlRDLCBiaXRzIChhbHNvIG5hbWVkIHVCVEMpIGFuZCBzYXRvc2hpcy4gQSB1bml0IGluc3RhbmNlIGNhbiBiZSBjcmVhdGVkIHdpdGggYW5cclxuICogYW1vdW50IGFuZCBhIHVuaXQgY29kZSwgb3IgYWx0ZXJuYXRpdmVseSB1c2luZyBzdGF0aWMgbWV0aG9kcyBsaWtlIHtmcm9tQlRDfS5cclxuICogSXQgYWxzbyBhbGxvd3MgdG8gYmUgY3JlYXRlZCBmcm9tIGEgZmlhdCBhbW91bnQgYW5kIHRoZSBleGNoYW5nZSByYXRlLCBvclxyXG4gKiBhbHRlcm5hdGl2ZWx5IHVzaW5nIHRoZSB7ZnJvbUZpYXR9IHN0YXRpYyBtZXRob2QuXHJcbiAqIFlvdSBjYW4gY29uc3VsdCBmb3IgZGlmZmVyZW50IHJlcHJlc2VudGF0aW9uIG9mIGEgdW5pdCBpbnN0YW5jZSB1c2luZyBpdCdzXHJcbiAqIHt0b30gbWV0aG9kLCB0aGUgZml4ZWQgdW5pdCBtZXRob2RzIGxpa2Uge3RvU2F0b3NoaXN9IG9yIGFsdGVybmF0aXZlbHkgdXNpbmdcclxuICogdGhlIHVuaXQgYWNjZXNzb3JzLiBJdCBhbHNvIGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBmaWF0IGFtb3VudCBieSBwcm92aWRpbmcgdGhlXHJcbiAqIGNvcnJlc3BvbmRpbmcgQlRDL2ZpYXQgZXhjaGFuZ2UgcmF0ZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiB2YXIgc2F0cyA9IFVuaXQuZnJvbUJUQygxLjMpLnRvU2F0b3NoaXMoKTtcclxuICogdmFyIG1pbGkgPSBVbml0LmZyb21CaXRzKDEuMykudG8oVW5pdC5tQlRDKTtcclxuICogdmFyIGJpdHMgPSBVbml0LmZyb21GaWF0KDEuMywgMzUwKS5iaXRzO1xyXG4gKiB2YXIgYnRjID0gbmV3IFVuaXQoMS4zLCBVbml0LmJpdHMpLkJUQztcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIGJlIHJlcHJlc2VudGVkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gY29kZSAtIFRoZSB1bml0IG9mIHRoZSBhbW91bnQgb3IgdGhlIGV4Y2hhbmdlIHJhdGVcclxuICogQHJldHVybnMge1VuaXR9IEEgbmV3IGluc3RhbmNlIG9mIGFuIFVuaXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBVbml0KGFtb3VudCwgY29kZSkge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVbml0KSkge1xyXG4gICAgcmV0dXJuIG5ldyBVbml0KGFtb3VudCwgY29kZSk7XHJcbiAgfVxyXG5cclxuICAvLyBjb252ZXJ0IGZpYXQgdG8gQlRDXHJcbiAgaWYgKF8uaXNOdW1iZXIoY29kZSkpIHtcclxuICAgIGlmIChjb2RlIDw9IDApIHtcclxuICAgICAgdGhyb3cgbmV3IGVycm9ycy5Vbml0LkludmFsaWRSYXRlKGNvZGUpO1xyXG4gICAgfVxyXG4gICAgYW1vdW50ID0gYW1vdW50IC8gY29kZTtcclxuICAgIGNvZGUgPSBVbml0LkJUQztcclxuICB9XHJcblxyXG4gIHRoaXMuX3ZhbHVlID0gdGhpcy5fZnJvbShhbW91bnQsIGNvZGUpO1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIGRlZmluZUFjY2Vzb3IgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYudG8oa2V5KTsgfSxcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIE9iamVjdC5rZXlzKFVOSVRTKS5mb3JFYWNoKGRlZmluZUFjY2Vzb3IpO1xyXG59XHJcblxyXG5PYmplY3Qua2V5cyhVTklUUykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICBVbml0W2tleV0gPSBrZXk7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBVbml0IGluc3RhbmNlIGNyZWF0ZWQgZnJvbSBKU09OIHN0cmluZyBvciBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIC0gSlNPTiB3aXRoIGtleXM6IGFtb3VudCBhbmQgY29kZVxyXG4gKiBAcmV0dXJucyB7VW5pdH0gQSBVbml0IGluc3RhbmNlXHJcbiAqL1xyXG5Vbml0LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGRhdGEpe1xyXG4gICQuY2hlY2tBcmd1bWVudChfLmlzT2JqZWN0KGRhdGEpLCAnQXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0Jyk7XHJcbiAgcmV0dXJuIG5ldyBVbml0KGRhdGEuYW1vdW50LCBkYXRhLmNvZGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBVbml0IGluc3RhbmNlIGNyZWF0ZWQgZnJvbSBhbiBhbW91bnQgaW4gQlRDXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IGluIEJUQ1xyXG4gKiBAcmV0dXJucyB7VW5pdH0gQSBVbml0IGluc3RhbmNlXHJcbiAqL1xyXG5Vbml0LmZyb21CVEMgPSBmdW5jdGlvbihhbW91bnQpIHtcclxuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCBVbml0LkJUQyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIFVuaXQgaW5zdGFuY2UgY3JlYXRlZCBmcm9tIGFuIGFtb3VudCBpbiBtQlRDXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IGluIG1CVENcclxuICogQHJldHVybnMge1VuaXR9IEEgVW5pdCBpbnN0YW5jZVxyXG4gKi9cclxuVW5pdC5mcm9tTWlsbGlzID0gVW5pdC5mcm9tTWlsaXMgPSBmdW5jdGlvbihhbW91bnQpIHtcclxuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCBVbml0Lm1CVEMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBVbml0IGluc3RhbmNlIGNyZWF0ZWQgZnJvbSBhbiBhbW91bnQgaW4gYml0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gVGhlIGFtb3VudCBpbiBiaXRzXHJcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcclxuICovXHJcblVuaXQuZnJvbU1pY3JvcyA9IFVuaXQuZnJvbUJpdHMgPSBmdW5jdGlvbihhbW91bnQpIHtcclxuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCBVbml0LmJpdHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBVbml0IGluc3RhbmNlIGNyZWF0ZWQgZnJvbSBhbiBhbW91bnQgaW4gc2F0b3NoaXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIFRoZSBhbW91bnQgaW4gc2F0b3NoaXNcclxuICogQHJldHVybnMge1VuaXR9IEEgVW5pdCBpbnN0YW5jZVxyXG4gKi9cclxuVW5pdC5mcm9tU2F0b3NoaXMgPSBmdW5jdGlvbihhbW91bnQpIHtcclxuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCBVbml0LnNhdG9zaGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgVW5pdCBpbnN0YW5jZSBjcmVhdGVkIGZyb20gYSBmaWF0IGFtb3VudCBhbmQgZXhjaGFuZ2UgcmF0ZS5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIFRoZSBhbW91bnQgaW4gZmlhdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmF0ZSAtIFRoZSBleGNoYW5nZSByYXRlIEJUQy9maWF0XHJcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcclxuICovXHJcblVuaXQuZnJvbUZpYXQgPSBmdW5jdGlvbihhbW91bnQsIHJhdGUpIHtcclxuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCByYXRlKTtcclxufTtcclxuXHJcblVuaXQucHJvdG90eXBlLl9mcm9tID0gZnVuY3Rpb24oYW1vdW50LCBjb2RlKSB7XHJcbiAgaWYgKCFVTklUU1tjb2RlXSkge1xyXG4gICAgdGhyb3cgbmV3IGVycm9ycy5Vbml0LlVua25vd25Db2RlKGNvZGUpO1xyXG4gIH1cclxuICByZXR1cm4gcGFyc2VJbnQoKGFtb3VudCAqIFVOSVRTW2NvZGVdWzBdKS50b0ZpeGVkKCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIHRoZSBzcGVjaWZpZWQgdW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGNvZGUgLSBUaGUgdW5pdCBjb2RlIG9yIGV4Y2hhbmdlIHJhdGVcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGNvbnZlcnRlZCB2YWx1ZVxyXG4gKi9cclxuVW5pdC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbihjb2RlKSB7XHJcbiAgaWYgKF8uaXNOdW1iZXIoY29kZSkpIHtcclxuICAgIGlmIChjb2RlIDw9IDApIHtcclxuICAgICAgdGhyb3cgbmV3IGVycm9ycy5Vbml0LkludmFsaWRSYXRlKGNvZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoKHRoaXMuQlRDICogY29kZSkudG9GaXhlZCgyKSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIVVOSVRTW2NvZGVdKSB7XHJcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlVuaXQuVW5rbm93bkNvZGUoY29kZSk7XHJcbiAgfVxyXG5cclxuICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZSAvIFVOSVRTW2NvZGVdWzBdO1xyXG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQoVU5JVFNbY29kZV1bMV0pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBpbiBCVENcclxuICpcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIHZhbHVlIGNvbnZlcnRlZCB0byBCVENcclxuICovXHJcblVuaXQucHJvdG90eXBlLnRvQlRDID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXMudG8oVW5pdC5CVEMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIG1CVENcclxuICpcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIHZhbHVlIGNvbnZlcnRlZCB0byBtQlRDXHJcbiAqL1xyXG5Vbml0LnByb3RvdHlwZS50b01pbGxpcyA9IFVuaXQucHJvdG90eXBlLnRvTWlsaXMgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy50byhVbml0Lm1CVEMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIGJpdHNcclxuICpcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIHZhbHVlIGNvbnZlcnRlZCB0byBiaXRzXHJcbiAqL1xyXG5Vbml0LnByb3RvdHlwZS50b01pY3JvcyA9IFVuaXQucHJvdG90eXBlLnRvQml0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLnRvKFVuaXQuYml0cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgaW4gc2F0b3NoaXNcclxuICpcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIHZhbHVlIGNvbnZlcnRlZCB0byBzYXRvc2hpc1xyXG4gKi9cclxuVW5pdC5wcm90b3R5cGUudG9TYXRvc2hpcyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLnRvKFVuaXQuc2F0b3NoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIGZpYXRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHJhdGUgLSBUaGUgZXhjaGFuZ2UgcmF0ZSBiZXR3ZWVuIEJUQy9jdXJyZW5jeVxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIHNhdG9zaGlzXHJcbiAqL1xyXG5Vbml0LnByb3RvdHlwZS5hdFJhdGUgPSBmdW5jdGlvbihyYXRlKSB7XHJcbiAgcmV0dXJuIHRoaXMudG8ocmF0ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlIGluIHNhdG9zaGlzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB2YWx1ZSBpbiBzYXRvc2hpc1xyXG4gKi9cclxuVW5pdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5zYXRvc2hpcyArICcgc2F0b3NoaXMnO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIFVuaXRcclxuICpcclxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGtleXM6IGFtb3VudCBhbmQgY29kZVxyXG4gKi9cclxuVW5pdC5wcm90b3R5cGUudG9PYmplY3QgPSBVbml0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgYW1vdW50OiB0aGlzLkJUQyxcclxuICAgIGNvZGU6IFVuaXQuQlRDXHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcclxuICpcclxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZhbHVlIGluIHNhdG9zaGlzXHJcbiAqL1xyXG5Vbml0LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICc8VW5pdDogJyArIHRoaXMudG9TdHJpbmcoKSArICc+JztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVW5pdDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/unit.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/uri.js":
/*!*********************************!*\
  !*** ../bitcore-lib/lib/uri.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\nvar URL = __webpack_require__(/*! url */ \"url\");\r\n\r\nvar Address = __webpack_require__(/*! ./address */ \"../bitcore-lib/lib/address.js\");\r\nvar Unit = __webpack_require__(/*! ./unit */ \"../bitcore-lib/lib/unit.js\");\r\n\r\n/**\r\n * Bitcore URI\r\n *\r\n * Instantiate an URI from a bitcoin URI String or an Object. An URI instance\r\n * can be created with a bitcoin uri string or an object. All instances of\r\n * URI are valid, the static method isValid allows checking before instantiation.\r\n *\r\n * All standard parameters can be found as members of the class, the address\r\n * is represented using an {Address} instance and the amount is represented in\r\n * satoshis. Any other non-standard parameters can be found under the extra member.\r\n *\r\n * @example\r\n * ```javascript\r\n *\r\n * var uri = new URI('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');\r\n * console.log(uri.address, uri.amount);\r\n * ```\r\n *\r\n * @param {string|Object} data - A bitcoin URI string or an Object\r\n * @param {Array.<string>=} knownParams - Required non-standard params\r\n * @throws {TypeError} Invalid bitcoin address\r\n * @throws {TypeError} Invalid amount\r\n * @throws {Error} Unknown required argument\r\n * @returns {URI} A new valid and frozen instance of URI\r\n * @constructor\r\n */\r\nvar URI = function(data, knownParams) {\r\n  if (!(this instanceof URI)) {\r\n    return new URI(data, knownParams);\r\n  }\r\n\r\n  this.extras = {};\r\n  this.knownParams = knownParams || [];\r\n  this.address = this.network = this.amount = this.message = null;\r\n\r\n  if (typeof(data) === 'string') {\r\n    var params = URI.parse(data);\r\n    if (params.amount) {\r\n      params.amount = this._parseAmount(params.amount);\r\n    }\r\n    this._fromObject(params);\r\n  } else if (typeof(data) === 'object') {\r\n    this._fromObject(data);\r\n  } else {\r\n    throw new TypeError('Unrecognized data format.');\r\n  }\r\n};\r\n\r\n/**\r\n * Instantiate a URI from a String\r\n *\r\n * @param {string} str - JSON string or object of the URI\r\n * @returns {URI} A new instance of a URI\r\n */\r\nURI.fromString = function fromString(str) {\r\n  if (typeof(str) !== 'string') {\r\n    throw new TypeError('Expected a string');\r\n  }\r\n  return new URI(str);\r\n};\r\n\r\n/**\r\n * Instantiate a URI from an Object\r\n *\r\n * @param {Object} data - object of the URI\r\n * @returns {URI} A new instance of a URI\r\n */\r\nURI.fromObject = function fromObject(json) {\r\n  return new URI(json);\r\n};\r\n\r\n/**\r\n * Check if an bitcoin URI string is valid\r\n *\r\n * @example\r\n * ```javascript\r\n *\r\n * var valid = URI.isValid('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');\r\n * // true\r\n * ```\r\n *\r\n * @param {string|Object} data - A bitcoin URI string or an Object\r\n * @param {Array.<string>=} knownParams - Required non-standard params\r\n * @returns {boolean} Result of uri validation\r\n */\r\nURI.isValid = function(arg, knownParams) {\r\n  try {\r\n    new URI(arg, knownParams);\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Convert a bitcoin URI string into a simple object.\r\n *\r\n * @param {string} uri - A bitcoin URI string\r\n * @throws {TypeError} Invalid bitcoin URI\r\n * @returns {Object} An object with the parsed params\r\n */\r\nURI.parse = function(uri) {\r\n  var info = URL.parse(uri, true);\r\n\r\n  if (info.protocol !== 'bitcoin:') {\r\n    throw new TypeError('Invalid bitcoin URI');\r\n  }\r\n\r\n  // workaround to host insensitiveness\r\n  var group = /[^:]*:\\/?\\/?([^?]*)/.exec(uri);\r\n  info.query.address = group && group[1] || undefined;\r\n\r\n  return info.query;\r\n};\r\n\r\nURI.Members = ['address', 'amount', 'message', 'label', 'r'];\r\n\r\n/**\r\n * Internal function to load the URI instance with an object.\r\n *\r\n * @param {Object} obj - Object with the information\r\n * @throws {TypeError} Invalid bitcoin address\r\n * @throws {TypeError} Invalid amount\r\n * @throws {Error} Unknown required argument\r\n */\r\nURI.prototype._fromObject = function(obj) {\r\n  /* jshint maxcomplexity: 10 */\r\n\r\n  if (!Address.isValid(obj.address)) {\r\n    throw new TypeError('Invalid bitcoin address');\r\n  }\r\n\r\n  this.address = new Address(obj.address);\r\n  this.network = this.address.network;\r\n  this.amount = obj.amount;\r\n\r\n  for (var key in obj) {\r\n    if (key === 'address' || key === 'amount') {\r\n      continue;\r\n    }\r\n\r\n    if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {\r\n      throw Error('Unknown required argument ' + key);\r\n    }\r\n\r\n    var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;\r\n    destination[key] = obj[key];\r\n  }\r\n};\r\n\r\n/**\r\n * Internal function to transform a BTC string amount into satoshis\r\n *\r\n * @param {string} amount - Amount BTC string\r\n * @throws {TypeError} Invalid amount\r\n * @returns {Object} Amount represented in satoshis\r\n */\r\nURI.prototype._parseAmount = function(amount) {\r\n  amount = Number(amount);\r\n  if (isNaN(amount)) {\r\n    throw new TypeError('Invalid amount');\r\n  }\r\n  return Unit.fromBTC(amount).toSatoshis();\r\n};\r\n\r\nURI.prototype.toObject = URI.prototype.toJSON = function toObject() {\r\n  var json = {};\r\n  for (var i = 0; i < URI.Members.length; i++) {\r\n    var m = URI.Members[i];\r\n    if (this.hasOwnProperty(m) && typeof(this[m]) !== 'undefined') {\r\n      json[m] = this[m].toString();\r\n    }\r\n  }\r\n  _.extend(json, this.extras);\r\n  return json;\r\n};\r\n\r\n/**\r\n * Will return a the string representation of the URI\r\n *\r\n * @returns {string} Bitcoin URI string\r\n */\r\nURI.prototype.toString = function() {\r\n  var query = {};\r\n  if (this.amount) {\r\n    query.amount = Unit.fromSatoshis(this.amount).toBTC();\r\n  }\r\n  if (this.message) {\r\n    query.message = this.message;\r\n  }\r\n  if (this.label) {\r\n    query.label = this.label;\r\n  }\r\n  if (this.r) {\r\n    query.r = this.r;\r\n  }\r\n  _.extend(query, this.extras);\r\n\r\n  return URL.format({\r\n    protocol: 'bitcoin:',\r\n    host: this.address,\r\n    query: query\r\n  });\r\n};\r\n\r\n/**\r\n * Will return a string formatted for the console\r\n *\r\n * @returns {string} Bitcoin URI\r\n */\r\nURI.prototype.inspect = function() {\r\n  return '<URI: ' + this.toString() + '>';\r\n};\r\n\r\nmodule.exports = URI;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3VyaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLDREQUFRO0FBQ3hCLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnREFBVztBQUNqQyxXQUFXLG1CQUFPLENBQUMsMENBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdXJpLmpzP2Q1ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybCcpO1xyXG5cclxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKTtcclxudmFyIFVuaXQgPSByZXF1aXJlKCcuL3VuaXQnKTtcclxuXHJcbi8qKlxyXG4gKiBCaXRjb3JlIFVSSVxyXG4gKlxyXG4gKiBJbnN0YW50aWF0ZSBhbiBVUkkgZnJvbSBhIGJpdGNvaW4gVVJJIFN0cmluZyBvciBhbiBPYmplY3QuIEFuIFVSSSBpbnN0YW5jZVxyXG4gKiBjYW4gYmUgY3JlYXRlZCB3aXRoIGEgYml0Y29pbiB1cmkgc3RyaW5nIG9yIGFuIG9iamVjdC4gQWxsIGluc3RhbmNlcyBvZlxyXG4gKiBVUkkgYXJlIHZhbGlkLCB0aGUgc3RhdGljIG1ldGhvZCBpc1ZhbGlkIGFsbG93cyBjaGVja2luZyBiZWZvcmUgaW5zdGFudGlhdGlvbi5cclxuICpcclxuICogQWxsIHN0YW5kYXJkIHBhcmFtZXRlcnMgY2FuIGJlIGZvdW5kIGFzIG1lbWJlcnMgb2YgdGhlIGNsYXNzLCB0aGUgYWRkcmVzc1xyXG4gKiBpcyByZXByZXNlbnRlZCB1c2luZyBhbiB7QWRkcmVzc30gaW5zdGFuY2UgYW5kIHRoZSBhbW91bnQgaXMgcmVwcmVzZW50ZWQgaW5cclxuICogc2F0b3NoaXMuIEFueSBvdGhlciBub24tc3RhbmRhcmQgcGFyYW1ldGVycyBjYW4gYmUgZm91bmQgdW5kZXIgdGhlIGV4dHJhIG1lbWJlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKlxyXG4gKiB2YXIgdXJpID0gbmV3IFVSSSgnYml0Y29pbjoxMkExTXlmWGJXNlJoZFJBWkVxb2ZhYzVqQ1FRandFUEJ1P2Ftb3VudD0xLjInKTtcclxuICogY29uc29sZS5sb2codXJpLmFkZHJlc3MsIHVyaS5hbW91bnQpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBkYXRhIC0gQSBiaXRjb2luIFVSSSBzdHJpbmcgb3IgYW4gT2JqZWN0XHJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBrbm93blBhcmFtcyAtIFJlcXVpcmVkIG5vbi1zdGFuZGFyZCBwYXJhbXNcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJbnZhbGlkIGJpdGNvaW4gYWRkcmVzc1xyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IEludmFsaWQgYW1vdW50XHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBVbmtub3duIHJlcXVpcmVkIGFyZ3VtZW50XHJcbiAqIEByZXR1cm5zIHtVUkl9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgVVJJXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFVSSSA9IGZ1bmN0aW9uKGRhdGEsIGtub3duUGFyYW1zKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVSSSkpIHtcclxuICAgIHJldHVybiBuZXcgVVJJKGRhdGEsIGtub3duUGFyYW1zKTtcclxuICB9XHJcblxyXG4gIHRoaXMuZXh0cmFzID0ge307XHJcbiAgdGhpcy5rbm93blBhcmFtcyA9IGtub3duUGFyYW1zIHx8IFtdO1xyXG4gIHRoaXMuYWRkcmVzcyA9IHRoaXMubmV0d29yayA9IHRoaXMuYW1vdW50ID0gdGhpcy5tZXNzYWdlID0gbnVsbDtcclxuXHJcbiAgaWYgKHR5cGVvZihkYXRhKSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBwYXJhbXMgPSBVUkkucGFyc2UoZGF0YSk7XHJcbiAgICBpZiAocGFyYW1zLmFtb3VudCkge1xyXG4gICAgICBwYXJhbXMuYW1vdW50ID0gdGhpcy5fcGFyc2VBbW91bnQocGFyYW1zLmFtb3VudCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9mcm9tT2JqZWN0KHBhcmFtcyk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YoZGF0YSkgPT09ICdvYmplY3QnKSB7XHJcbiAgICB0aGlzLl9mcm9tT2JqZWN0KGRhdGEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlY29nbml6ZWQgZGF0YSBmb3JtYXQuJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbnRpYXRlIGEgVVJJIGZyb20gYSBTdHJpbmdcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIEpTT04gc3RyaW5nIG9yIG9iamVjdCBvZiB0aGUgVVJJXHJcbiAqIEByZXR1cm5zIHtVUkl9IEEgbmV3IGluc3RhbmNlIG9mIGEgVVJJXHJcbiAqL1xyXG5VUkkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XHJcbiAgaWYgKHR5cGVvZihzdHIpICE9PSAnc3RyaW5nJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBVUkkoc3RyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBhIFVSSSBmcm9tIGFuIE9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIG9iamVjdCBvZiB0aGUgVVJJXHJcbiAqIEByZXR1cm5zIHtVUkl9IEEgbmV3IGluc3RhbmNlIG9mIGEgVVJJXHJcbiAqL1xyXG5VUkkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QoanNvbikge1xyXG4gIHJldHVybiBuZXcgVVJJKGpzb24pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGFuIGJpdGNvaW4gVVJJIHN0cmluZyBpcyB2YWxpZFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqXHJcbiAqIHZhciB2YWxpZCA9IFVSSS5pc1ZhbGlkKCdiaXRjb2luOjEyQTFNeWZYYlc2UmhkUkFaRXFvZmFjNWpDUVFqd0VQQnUnKTtcclxuICogLy8gdHJ1ZVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBkYXRhIC0gQSBiaXRjb2luIFVSSSBzdHJpbmcgb3IgYW4gT2JqZWN0XHJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBrbm93blBhcmFtcyAtIFJlcXVpcmVkIG5vbi1zdGFuZGFyZCBwYXJhbXNcclxuICogQHJldHVybnMge2Jvb2xlYW59IFJlc3VsdCBvZiB1cmkgdmFsaWRhdGlvblxyXG4gKi9cclxuVVJJLmlzVmFsaWQgPSBmdW5jdGlvbihhcmcsIGtub3duUGFyYW1zKSB7XHJcbiAgdHJ5IHtcclxuICAgIG5ldyBVUkkoYXJnLCBrbm93blBhcmFtcyk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBiaXRjb2luIFVSSSBzdHJpbmcgaW50byBhIHNpbXBsZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBBIGJpdGNvaW4gVVJJIHN0cmluZ1xyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IEludmFsaWQgYml0Y29pbiBVUklcclxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBwYXJhbXNcclxuICovXHJcblVSSS5wYXJzZSA9IGZ1bmN0aW9uKHVyaSkge1xyXG4gIHZhciBpbmZvID0gVVJMLnBhcnNlKHVyaSwgdHJ1ZSk7XHJcblxyXG4gIGlmIChpbmZvLnByb3RvY29sICE9PSAnYml0Y29pbjonKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGJpdGNvaW4gVVJJJyk7XHJcbiAgfVxyXG5cclxuICAvLyB3b3JrYXJvdW5kIHRvIGhvc3QgaW5zZW5zaXRpdmVuZXNzXHJcbiAgdmFyIGdyb3VwID0gL1teOl0qOlxcLz9cXC8/KFteP10qKS8uZXhlYyh1cmkpO1xyXG4gIGluZm8ucXVlcnkuYWRkcmVzcyA9IGdyb3VwICYmIGdyb3VwWzFdIHx8IHVuZGVmaW5lZDtcclxuXHJcbiAgcmV0dXJuIGluZm8ucXVlcnk7XHJcbn07XHJcblxyXG5VUkkuTWVtYmVycyA9IFsnYWRkcmVzcycsICdhbW91bnQnLCAnbWVzc2FnZScsICdsYWJlbCcsICdyJ107XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gbG9hZCB0aGUgVVJJIGluc3RhbmNlIHdpdGggYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdpdGggdGhlIGluZm9ybWF0aW9uXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBiaXRjb2luIGFkZHJlc3NcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJbnZhbGlkIGFtb3VudFxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gVW5rbm93biByZXF1aXJlZCBhcmd1bWVudFxyXG4gKi9cclxuVVJJLnByb3RvdHlwZS5fZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMCAqL1xyXG5cclxuICBpZiAoIUFkZHJlc3MuaXNWYWxpZChvYmouYWRkcmVzcykpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYml0Y29pbiBhZGRyZXNzJyk7XHJcbiAgfVxyXG5cclxuICB0aGlzLmFkZHJlc3MgPSBuZXcgQWRkcmVzcyhvYmouYWRkcmVzcyk7XHJcbiAgdGhpcy5uZXR3b3JrID0gdGhpcy5hZGRyZXNzLm5ldHdvcms7XHJcbiAgdGhpcy5hbW91bnQgPSBvYmouYW1vdW50O1xyXG5cclxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAoa2V5ID09PSAnYWRkcmVzcycgfHwga2V5ID09PSAnYW1vdW50Jykge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoL15yZXEtLy5leGVjKGtleSkgJiYgdGhpcy5rbm93blBhcmFtcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHJlcXVpcmVkIGFyZ3VtZW50ICcgKyBrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZXN0aW5hdGlvbiA9IFVSSS5NZW1iZXJzLmluZGV4T2Yoa2V5KSA+IC0xID8gdGhpcyA6IHRoaXMuZXh0cmFzO1xyXG4gICAgZGVzdGluYXRpb25ba2V5XSA9IG9ialtrZXldO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBCVEMgc3RyaW5nIGFtb3VudCBpbnRvIHNhdG9zaGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgLSBBbW91bnQgQlRDIHN0cmluZ1xyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IEludmFsaWQgYW1vdW50XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFtb3VudCByZXByZXNlbnRlZCBpbiBzYXRvc2hpc1xyXG4gKi9cclxuVVJJLnByb3RvdHlwZS5fcGFyc2VBbW91bnQgPSBmdW5jdGlvbihhbW91bnQpIHtcclxuICBhbW91bnQgPSBOdW1iZXIoYW1vdW50KTtcclxuICBpZiAoaXNOYU4oYW1vdW50KSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhbW91bnQnKTtcclxuICB9XHJcbiAgcmV0dXJuIFVuaXQuZnJvbUJUQyhhbW91bnQpLnRvU2F0b3NoaXMoKTtcclxufTtcclxuXHJcblVSSS5wcm90b3R5cGUudG9PYmplY3QgPSBVUkkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xyXG4gIHZhciBqc29uID0ge307XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBVUkkuTWVtYmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIG0gPSBVUkkuTWVtYmVyc1tpXTtcclxuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KG0pICYmIHR5cGVvZih0aGlzW21dKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAganNvblttXSA9IHRoaXNbbV0udG9TdHJpbmcoKTtcclxuICAgIH1cclxuICB9XHJcbiAgXy5leHRlbmQoanNvbiwgdGhpcy5leHRyYXMpO1xyXG4gIHJldHVybiBqc29uO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgcmV0dXJuIGEgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVVJJXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJpdGNvaW4gVVJJIHN0cmluZ1xyXG4gKi9cclxuVVJJLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBxdWVyeSA9IHt9O1xyXG4gIGlmICh0aGlzLmFtb3VudCkge1xyXG4gICAgcXVlcnkuYW1vdW50ID0gVW5pdC5mcm9tU2F0b3NoaXModGhpcy5hbW91bnQpLnRvQlRDKCk7XHJcbiAgfVxyXG4gIGlmICh0aGlzLm1lc3NhZ2UpIHtcclxuICAgIHF1ZXJ5Lm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2U7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmxhYmVsKSB7XHJcbiAgICBxdWVyeS5sYWJlbCA9IHRoaXMubGFiZWw7XHJcbiAgfVxyXG4gIGlmICh0aGlzLnIpIHtcclxuICAgIHF1ZXJ5LnIgPSB0aGlzLnI7XHJcbiAgfVxyXG4gIF8uZXh0ZW5kKHF1ZXJ5LCB0aGlzLmV4dHJhcyk7XHJcblxyXG4gIHJldHVybiBVUkwuZm9ybWF0KHtcclxuICAgIHByb3RvY29sOiAnYml0Y29pbjonLFxyXG4gICAgaG9zdDogdGhpcy5hZGRyZXNzLFxyXG4gICAgcXVlcnk6IHF1ZXJ5XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCByZXR1cm4gYSBzdHJpbmcgZm9ybWF0dGVkIGZvciB0aGUgY29uc29sZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCaXRjb2luIFVSSVxyXG4gKi9cclxuVVJJLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICc8VVJJOiAnICsgdGhpcy50b1N0cmluZygpICsgJz4nO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVUkk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/uri.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/util/buffer.js":
/*!*****************************************!*\
  !*** ../bitcore-lib/lib/util/buffer.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n\r\n\r\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\r\nvar assert = __webpack_require__(/*! assert */ \"assert\");\r\n\r\nvar js = __webpack_require__(/*! ./js */ \"../bitcore-lib/lib/util/js.js\");\r\nvar $ = __webpack_require__(/*! ./preconditions */ \"../bitcore-lib/lib/util/preconditions.js\");\r\n\r\nfunction equals(a, b) {\r\n  if (a.length !== b.length) {\r\n    return false;\r\n  }\r\n  var length = a.length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (a[i] !== b[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nmodule.exports = {\r\n  /**\r\n   * Fill a buffer with a value.\r\n   *\r\n   * @param {Buffer} buffer\r\n   * @param {number} value\r\n   * @return {Buffer}\r\n   */\r\n  fill: function fill(buffer, value) {\r\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\r\n    $.checkArgumentType(value, 'number', 'value');\r\n    var length = buffer.length;\r\n    for (var i = 0; i < length; i++) {\r\n      buffer[i] = value;\r\n    }\r\n    return buffer;\r\n  },\r\n\r\n  /**\r\n   * Return a copy of a buffer\r\n   *\r\n   * @param {Buffer} original\r\n   * @return {Buffer}\r\n   */\r\n  copy: function(original) {\r\n    var buffer = Buffer.alloc(original.length);\r\n    original.copy(buffer);\r\n    return buffer;\r\n  },\r\n\r\n  /**\r\n   * Returns true if the given argument is an instance of a buffer. Tests for\r\n   * both node's Buffer and Uint8Array\r\n   *\r\n   * @param {*} arg\r\n   * @return {boolean}\r\n   */\r\n  isBuffer: function isBuffer(arg) {\r\n    return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array;\r\n  },\r\n\r\n  /**\r\n   * Returns a zero-filled byte array\r\n   *\r\n   * @param {number} bytes\r\n   * @return {Buffer}\r\n   */\r\n  emptyBuffer: function emptyBuffer(bytes) {\r\n    $.checkArgumentType(bytes, 'number', 'bytes');\r\n    var result = Buffer.alloc(bytes);\r\n    for (var i = 0; i < bytes; i++) {\r\n      result.write('\\0', i);\r\n    }\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Concatenates a buffer\r\n   *\r\n   * Shortcut for <tt>buffer.Buffer.concat</tt>\r\n   */\r\n  concat: buffer.Buffer.concat,\r\n\r\n  equals: equals,\r\n  equal: equals,\r\n\r\n  /**\r\n   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value\r\n   *\r\n   * @param {number} integer\r\n   * @return {Buffer}\r\n   */\r\n  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {\r\n    $.checkArgumentType(integer, 'number', 'integer');\r\n    return Buffer.from([integer & 0xff]);\r\n  },\r\n\r\n  /**\r\n   * Transform a 4-byte integer into a Buffer of length 4.\r\n   *\r\n   * @param {number} integer\r\n   * @return {Buffer}\r\n   */\r\n  integerAsBuffer: function integerAsBuffer(integer) {\r\n    $.checkArgumentType(integer, 'number', 'integer');\r\n    var bytes = [];\r\n    bytes.push((integer >> 24) & 0xff);\r\n    bytes.push((integer >> 16) & 0xff);\r\n    bytes.push((integer >> 8) & 0xff);\r\n    bytes.push(integer & 0xff);\r\n    return Buffer.from(bytes);\r\n  },\r\n\r\n  /**\r\n   * Transform the first 4 values of a Buffer into a number, in little endian encoding\r\n   *\r\n   * @param {Buffer} buffer\r\n   * @return {number}\r\n   */\r\n  integerFromBuffer: function integerFromBuffer(buffer) {\r\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\r\n    return buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];\r\n  },\r\n\r\n  /**\r\n   * Transforms the first byte of an array into a number ranging from -128 to 127\r\n   * @param {Buffer} buffer\r\n   * @return {number}\r\n   */\r\n  integerFromSingleByteBuffer: function integerFromBuffer(buffer) {\r\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\r\n    return buffer[0];\r\n  },\r\n\r\n  /**\r\n   * Transforms a buffer into a string with a number in hexa representation\r\n   *\r\n   * Shorthand for <tt>buffer.toString('hex')</tt>\r\n   *\r\n   * @param {Buffer} buffer\r\n   * @return {string}\r\n   */\r\n  bufferToHex: function bufferToHex(buffer) {\r\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\r\n    return buffer.toString('hex');\r\n  },\r\n\r\n  /**\r\n   * Reverse a buffer\r\n   * @param {Buffer} param\r\n   * @return {Buffer}\r\n   */\r\n  reverse: function reverse(param) {\r\n    return (Buffer.from(param)).reverse();\r\n  },\r\n};\r\n\r\nmodule.exports.NULL_HASH = module.exports.fill(Buffer.alloc(32), 0);\r\nmodule.exports.EMPTY_BUFFER = Buffer.alloc(0);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3V0aWwvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QjtBQUNBLFNBQVMsbUJBQU8sQ0FBQywyQ0FBTTtBQUN2QixRQUFRLG1CQUFPLENBQUMsaUVBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUIsTUFBTTtBQUNyRCwyQkFBMkIsR0FBRyxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uLi9iaXRjb3JlLWxpYi9saWIvdXRpbC9idWZmZXIuanM/N2ZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcclxuXHJcbnZhciBqcyA9IHJlcXVpcmUoJy4vanMnKTtcclxudmFyICQgPSByZXF1aXJlKCcuL3ByZWNvbmRpdGlvbnMnKTtcclxuXHJcbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XHJcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgbGVuZ3RoID0gYS5sZW5ndGg7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgLyoqXHJcbiAgICogRmlsbCBhIGJ1ZmZlciB3aXRoIGEgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7QnVmZmVyfVxyXG4gICAqL1xyXG4gIGZpbGw6IGZ1bmN0aW9uIGZpbGwoYnVmZmVyLCB2YWx1ZSkge1xyXG4gICAgJC5jaGVja0FyZ3VtZW50VHlwZShidWZmZXIsICdCdWZmZXInLCAnYnVmZmVyJyk7XHJcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKHZhbHVlLCAnbnVtYmVyJywgJ3ZhbHVlJyk7XHJcbiAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgYnVmZmVyW2ldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGNvcHkgb2YgYSBidWZmZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBvcmlnaW5hbFxyXG4gICAqIEByZXR1cm4ge0J1ZmZlcn1cclxuICAgKi9cclxuICBjb3B5OiBmdW5jdGlvbihvcmlnaW5hbCkge1xyXG4gICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhvcmlnaW5hbC5sZW5ndGgpO1xyXG4gICAgb3JpZ2luYWwuY29weShidWZmZXIpO1xyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGEgYnVmZmVyLiBUZXN0cyBmb3JcclxuICAgKiBib3RoIG5vZGUncyBCdWZmZXIgYW5kIFVpbnQ4QXJyYXlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gYXJnXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBpc0J1ZmZlcjogZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XHJcbiAgICByZXR1cm4gYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihhcmcpIHx8IGFyZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHplcm8tZmlsbGVkIGJ5dGUgYXJyYXlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1xyXG4gICAqIEByZXR1cm4ge0J1ZmZlcn1cclxuICAgKi9cclxuICBlbXB0eUJ1ZmZlcjogZnVuY3Rpb24gZW1wdHlCdWZmZXIoYnl0ZXMpIHtcclxuICAgICQuY2hlY2tBcmd1bWVudFR5cGUoYnl0ZXMsICdudW1iZXInLCAnYnl0ZXMnKTtcclxuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MoYnl0ZXMpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XHJcbiAgICAgIHJlc3VsdC53cml0ZSgnXFwwJywgaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbmNhdGVuYXRlcyBhIGJ1ZmZlclxyXG4gICAqXHJcbiAgICogU2hvcnRjdXQgZm9yIDx0dD5idWZmZXIuQnVmZmVyLmNvbmNhdDwvdHQ+XHJcbiAgICovXHJcbiAgY29uY2F0OiBidWZmZXIuQnVmZmVyLmNvbmNhdCxcclxuXHJcbiAgZXF1YWxzOiBlcXVhbHMsXHJcbiAgZXF1YWw6IGVxdWFscyxcclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyBhIG51bWJlciBmcm9tIDAgdG8gMjU1IGludG8gYSBCdWZmZXIgb2Ygc2l6ZSAxIHdpdGggdGhhdCB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVnZXJcclxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9XHJcbiAgICovXHJcbiAgaW50ZWdlckFzU2luZ2xlQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gaW50ZWdlckFzU2luZ2xlQnl0ZUJ1ZmZlcihpbnRlZ2VyKSB7XHJcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGludGVnZXIsICdudW1iZXInLCAnaW50ZWdlcicpO1xyXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtpbnRlZ2VyICYgMHhmZl0pO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIDQtYnl0ZSBpbnRlZ2VyIGludG8gYSBCdWZmZXIgb2YgbGVuZ3RoIDQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZWdlclxyXG4gICAqIEByZXR1cm4ge0J1ZmZlcn1cclxuICAgKi9cclxuICBpbnRlZ2VyQXNCdWZmZXI6IGZ1bmN0aW9uIGludGVnZXJBc0J1ZmZlcihpbnRlZ2VyKSB7XHJcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGludGVnZXIsICdudW1iZXInLCAnaW50ZWdlcicpO1xyXG4gICAgdmFyIGJ5dGVzID0gW107XHJcbiAgICBieXRlcy5wdXNoKChpbnRlZ2VyID4+IDI0KSAmIDB4ZmYpO1xyXG4gICAgYnl0ZXMucHVzaCgoaW50ZWdlciA+PiAxNikgJiAweGZmKTtcclxuICAgIGJ5dGVzLnB1c2goKGludGVnZXIgPj4gOCkgJiAweGZmKTtcclxuICAgIGJ5dGVzLnB1c2goaW50ZWdlciAmIDB4ZmYpO1xyXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIGZpcnN0IDQgdmFsdWVzIG9mIGEgQnVmZmVyIGludG8gYSBudW1iZXIsIGluIGxpdHRsZSBlbmRpYW4gZW5jb2RpbmdcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgaW50ZWdlckZyb21CdWZmZXI6IGZ1bmN0aW9uIGludGVnZXJGcm9tQnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgJC5jaGVja0FyZ3VtZW50VHlwZShidWZmZXIsICdCdWZmZXInLCAnYnVmZmVyJyk7XHJcbiAgICByZXR1cm4gYnVmZmVyWzBdIDw8IDI0IHwgYnVmZmVyWzFdIDw8IDE2IHwgYnVmZmVyWzJdIDw8IDggfCBidWZmZXJbM107XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyB0aGUgZmlyc3QgYnl0ZSBvZiBhbiBhcnJheSBpbnRvIGEgbnVtYmVyIHJhbmdpbmcgZnJvbSAtMTI4IHRvIDEyN1xyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgaW50ZWdlckZyb21TaW5nbGVCeXRlQnVmZmVyOiBmdW5jdGlvbiBpbnRlZ2VyRnJvbUJ1ZmZlcihidWZmZXIpIHtcclxuICAgICQuY2hlY2tBcmd1bWVudFR5cGUoYnVmZmVyLCAnQnVmZmVyJywgJ2J1ZmZlcicpO1xyXG4gICAgcmV0dXJuIGJ1ZmZlclswXTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIGEgYnVmZmVyIGludG8gYSBzdHJpbmcgd2l0aCBhIG51bWJlciBpbiBoZXhhIHJlcHJlc2VudGF0aW9uXHJcbiAgICpcclxuICAgKiBTaG9ydGhhbmQgZm9yIDx0dD5idWZmZXIudG9TdHJpbmcoJ2hleCcpPC90dD5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgYnVmZmVyVG9IZXg6IGZ1bmN0aW9uIGJ1ZmZlclRvSGV4KGJ1ZmZlcikge1xyXG4gICAgJC5jaGVja0FyZ3VtZW50VHlwZShidWZmZXIsICdCdWZmZXInLCAnYnVmZmVyJyk7XHJcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXZlcnNlIGEgYnVmZmVyXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHBhcmFtXHJcbiAgICogQHJldHVybiB7QnVmZmVyfVxyXG4gICAqL1xyXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UocGFyYW0pIHtcclxuICAgIHJldHVybiAoQnVmZmVyLmZyb20ocGFyYW0pKS5yZXZlcnNlKCk7XHJcbiAgfSxcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLk5VTExfSEFTSCA9IG1vZHVsZS5leHBvcnRzLmZpbGwoQnVmZmVyLmFsbG9jKDMyKSwgMCk7XHJcbm1vZHVsZS5leHBvcnRzLkVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5hbGxvYygwKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/util/buffer.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/util/js.js":
/*!*************************************!*\
  !*** ../bitcore-lib/lib/util/js.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\n/**\r\n * Determines whether a string contains only hexadecimal values\r\n *\r\n * @name JSUtil.isHexa\r\n * @param {string} value\r\n * @return {boolean} true if the string is the hexa representation of a number\r\n */\r\nvar isHexa = function isHexa(value) {\r\n  if (!_.isString(value)) {\r\n    return false;\r\n  }\r\n  return /^[0-9a-fA-F]+$/.test(value);\r\n};\r\n\r\n/**\r\n * @namespace JSUtil\r\n */\r\nmodule.exports = {\r\n  /**\r\n   * Test if an argument is a valid JSON object. If it is, returns a truthy\r\n   * value (the json object decoded), so no double JSON.parse call is necessary\r\n   *\r\n   * @param {string} arg\r\n   * @return {Object|boolean} false if the argument is not a JSON string.\r\n   */\r\n  isValidJSON: function isValidJSON(arg) {\r\n    var parsed;\r\n    if (!_.isString(arg)) {\r\n      return false;\r\n    }\r\n    try {\r\n      parsed = JSON.parse(arg);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n    if (typeof(parsed) === 'object') {\r\n      return true;\r\n    }\r\n    return false;\r\n  },\r\n  isHexa: isHexa,\r\n  isHexaString: isHexa,\r\n\r\n  /**\r\n   * Clone an array\r\n   */\r\n  cloneArray: function(array) {\r\n    return [].concat(array);\r\n  },\r\n\r\n  /**\r\n   * Define immutable properties on a target object\r\n   *\r\n   * @param {Object} target - An object to be extended\r\n   * @param {Object} values - An object of properties\r\n   * @return {Object} The target object\r\n   */\r\n  defineImmutable: function defineImmutable(target, values) {\r\n    Object.keys(values).forEach(function(key){\r\n      Object.defineProperty(target, key, {\r\n        configurable: false,\r\n        enumerable: true,\r\n        value: values[key]\r\n      });\r\n    });\r\n    return target;\r\n  },\r\n  /**\r\n   * Checks that a value is a natural number, a positive integer or zero.\r\n   *\r\n   * @param {*} value\r\n   * @return {Boolean}\r\n   */\r\n  isNaturalNumber: function isNaturalNumber(value) {\r\n    return typeof value === 'number' &&\r\n      isFinite(value) &&\r\n      Math.floor(value) === value &&\r\n      value >= 0;\r\n  }\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3V0aWwvanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi4vYml0Y29yZS1saWIvbGliL3V0aWwvanMuanM/OGIwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBjb250YWlucyBvbmx5IGhleGFkZWNpbWFsIHZhbHVlc1xyXG4gKlxyXG4gKiBAbmFtZSBKU1V0aWwuaXNIZXhhXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgdGhlIGhleGEgcmVwcmVzZW50YXRpb24gb2YgYSBudW1iZXJcclxuICovXHJcbnZhciBpc0hleGEgPSBmdW5jdGlvbiBpc0hleGEodmFsdWUpIHtcclxuICBpZiAoIV8uaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiAvXlswLTlhLWZBLUZdKyQvLnRlc3QodmFsdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgSlNVdGlsXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAvKipcclxuICAgKiBUZXN0IGlmIGFuIGFyZ3VtZW50IGlzIGEgdmFsaWQgSlNPTiBvYmplY3QuIElmIGl0IGlzLCByZXR1cm5zIGEgdHJ1dGh5XHJcbiAgICogdmFsdWUgKHRoZSBqc29uIG9iamVjdCBkZWNvZGVkKSwgc28gbm8gZG91YmxlIEpTT04ucGFyc2UgY2FsbCBpcyBuZWNlc3NhcnlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcmdcclxuICAgKiBAcmV0dXJuIHtPYmplY3R8Ym9vbGVhbn0gZmFsc2UgaWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBhIEpTT04gc3RyaW5nLlxyXG4gICAqL1xyXG4gIGlzVmFsaWRKU09OOiBmdW5jdGlvbiBpc1ZhbGlkSlNPTihhcmcpIHtcclxuICAgIHZhciBwYXJzZWQ7XHJcbiAgICBpZiAoIV8uaXNTdHJpbmcoYXJnKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGFyZyk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YocGFyc2VkKSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuICBpc0hleGE6IGlzSGV4YSxcclxuICBpc0hleGFTdHJpbmc6IGlzSGV4YSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvbmUgYW4gYXJyYXlcclxuICAgKi9cclxuICBjbG9uZUFycmF5OiBmdW5jdGlvbihhcnJheSkge1xyXG4gICAgcmV0dXJuIFtdLmNvbmNhdChhcnJheSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmaW5lIGltbXV0YWJsZSBwcm9wZXJ0aWVzIG9uIGEgdGFyZ2V0IG9iamVjdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIEFuIG9iamVjdCB0byBiZSBleHRlbmRlZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xyXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRhcmdldCBvYmplY3RcclxuICAgKi9cclxuICBkZWZpbmVJbW11dGFibGU6IGZ1bmN0aW9uIGRlZmluZUltbXV0YWJsZSh0YXJnZXQsIHZhbHVlcykge1xyXG4gICAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogdmFsdWVzW2tleV1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfSxcclxuICAvKipcclxuICAgKiBDaGVja3MgdGhhdCBhIHZhbHVlIGlzIGEgbmF0dXJhbCBudW1iZXIsIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNOYXR1cmFsTnVtYmVyOiBmdW5jdGlvbiBpc05hdHVyYWxOdW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXHJcbiAgICAgIGlzRmluaXRlKHZhbHVlKSAmJlxyXG4gICAgICBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUgJiZcclxuICAgICAgdmFsdWUgPj0gMDtcclxuICB9XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/util/js.js\n");

/***/ }),

/***/ "../bitcore-lib/lib/util/preconditions.js":
/*!************************************************!*\
  !*** ../bitcore-lib/lib/util/preconditions.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar errors = __webpack_require__(/*! ../errors */ \"../bitcore-lib/lib/errors/index.js\");\r\nvar _ = __webpack_require__(/*! lodash */ \"../bitcore-lib/node_modules/lodash/lodash.js\");\r\n\r\nmodule.exports = {\r\n  checkState: function(condition, message) {\r\n    if (!condition) {\r\n      throw new errors.InvalidState(message);\r\n    }\r\n  },\r\n  checkArgument: function(condition, argumentName, message, docsPath) {\r\n    if (!condition) {\r\n      throw new errors.InvalidArgument(argumentName, message, docsPath);\r\n    }\r\n  },\r\n  checkArgumentType: function(argument, type, argumentName) {\r\n    argumentName = argumentName || '(unknown name)';\r\n    if (_.isString(type)) {\r\n      if (type === 'Buffer') {\r\n        var buffer = __webpack_require__(/*! buffer */ \"buffer\"); // './buffer' fails on cordova & RN\r\n        if (!buffer.Buffer.isBuffer(argument)) {\r\n          throw new errors.InvalidArgumentType(argument, type, argumentName);\r\n        }\r\n      } else if (typeof argument !== type && (argument && argument.constructor && argument.constructor.name !== type)) {\r\n        // Note that the constructor check is more reliable than the `instanceof` check below.\r\n        throw new errors.InvalidArgumentType(argument, type, argumentName);\r\n      }\r\n    } else {\r\n      if (!(argument instanceof type)) {\r\n        throw new errors.InvalidArgumentType(argument, type.name, argumentName);\r\n      }\r\n    }\r\n  },\r\n  isType: function(argument, type, argumentName) {\r\n    try {\r\n      this.checkArgumentType(argument, type, argumentName);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYml0Y29yZS1saWIvbGliL3V0aWwvcHJlY29uZGl0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHFEQUFXO0FBQ2hDLFFBQVEsbUJBQU8sQ0FBQyw0REFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUSxHQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4uL2JpdGNvcmUtbGliL2xpYi91dGlsL3ByZWNvbmRpdGlvbnMuanM/YzdhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBjaGVja1N0YXRlOiBmdW5jdGlvbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZFN0YXRlKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgY2hlY2tBcmd1bWVudDogZnVuY3Rpb24oY29uZGl0aW9uLCBhcmd1bWVudE5hbWUsIG1lc3NhZ2UsIGRvY3NQYXRoKSB7XHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudChhcmd1bWVudE5hbWUsIG1lc3NhZ2UsIGRvY3NQYXRoKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGNoZWNrQXJndW1lbnRUeXBlOiBmdW5jdGlvbihhcmd1bWVudCwgdHlwZSwgYXJndW1lbnROYW1lKSB7XHJcbiAgICBhcmd1bWVudE5hbWUgPSBhcmd1bWVudE5hbWUgfHwgJyh1bmtub3duIG5hbWUpJztcclxuICAgIGlmIChfLmlzU3RyaW5nKHR5cGUpKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSAnQnVmZmVyJykge1xyXG4gICAgICAgIHZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTsgLy8gJy4vYnVmZmVyJyBmYWlscyBvbiBjb3Jkb3ZhICYgUk5cclxuICAgICAgICBpZiAoIWJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYXJndW1lbnQpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudFR5cGUoYXJndW1lbnQsIHR5cGUsIGFyZ3VtZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCAhPT0gdHlwZSAmJiAoYXJndW1lbnQgJiYgYXJndW1lbnQuY29uc3RydWN0b3IgJiYgYXJndW1lbnQuY29uc3RydWN0b3IubmFtZSAhPT0gdHlwZSkpIHtcclxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGNvbnN0cnVjdG9yIGNoZWNrIGlzIG1vcmUgcmVsaWFibGUgdGhhbiB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJlbG93LlxyXG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50VHlwZShhcmd1bWVudCwgdHlwZSwgYXJndW1lbnROYW1lKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCEoYXJndW1lbnQgaW5zdGFuY2VvZiB0eXBlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50VHlwZShhcmd1bWVudCwgdHlwZS5uYW1lLCBhcmd1bWVudE5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBpc1R5cGU6IGZ1bmN0aW9uKGFyZ3VtZW50LCB0eXBlLCBhcmd1bWVudE5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuY2hlY2tBcmd1bWVudFR5cGUoYXJndW1lbnQsIHR5cGUsIGFyZ3VtZW50TmFtZSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../bitcore-lib/lib/util/preconditions.js\n");

/***/ }),

/***/ "./src/assets/images/large-thin-spinner.svg":
/*!**************************************************!*\
  !*** ./src/assets/images/large-thin-spinner.svg ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"src\":\"/_next/static/media/large-thin-spinner.83f15a53.svg\",\"height\":104,\"width\":104,\"blurWidth\":0,\"blurHeight\":0});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL2ltYWdlcy9sYXJnZS10aGluLXNwaW5uZXIuc3ZnIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxDQUFDLGtIQUFrSCIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi9zcmMvYXNzZXRzL2ltYWdlcy9sYXJnZS10aGluLXNwaW5uZXIuc3ZnP2Y2OGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2xhcmdlLXRoaW4tc3Bpbm5lci44M2YxNWE1My5zdmdcIixcImhlaWdodFwiOjEwNCxcIndpZHRoXCI6MTA0LFwiYmx1cldpZHRoXCI6MCxcImJsdXJIZWlnaHRcIjowfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/assets/images/large-thin-spinner.svg\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fsrc%5Cpages%5Cindex.tsx&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fsrc%5Cpages%5Cindex.tsx&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getServerSideProps: () => (/* binding */ getServerSideProps),\n/* harmony export */   getStaticPaths: () => (/* binding */ getStaticPaths),\n/* harmony export */   getStaticProps: () => (/* binding */ getStaticProps),\n/* harmony export */   reportWebVitals: () => (/* binding */ reportWebVitals),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   unstable_getServerProps: () => (/* binding */ unstable_getServerProps),\n/* harmony export */   unstable_getServerSideProps: () => (/* binding */ unstable_getServerSideProps),\n/* harmony export */   unstable_getStaticParams: () => (/* binding */ unstable_getStaticParams),\n/* harmony export */   unstable_getStaticPaths: () => (/* binding */ unstable_getStaticPaths),\n/* harmony export */   unstable_getStaticProps: () => (/* binding */ unstable_getStaticProps)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/pages/module.compiled */ \"./node_modules/next/dist/server/route-modules/pages/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! private-next-pages/_document */ \"./node_modules/next/dist/pages/_document.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! private-next-pages/_app */ \"./node_modules/next/dist/pages/_app.js\");\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src\\pages\\index.tsx */ \"./src/pages/index.tsx\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__]);\n_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the app and document modules.\n\n\n// Import the userland code.\n\n// Re-export the component (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'default'));\n// Re-export methods.\nconst getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'getStaticProps');\nconst getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'getStaticPaths');\nconst getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'getServerSideProps');\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'config');\nconst reportWebVitals = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'reportWebVitals');\n// Re-export legacy methods.\nconst unstable_getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'unstable_getStaticProps');\nconst unstable_getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'unstable_getStaticPaths');\nconst unstable_getStaticParams = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'unstable_getStaticParams');\nconst unstable_getServerProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'unstable_getServerProps');\nconst unstable_getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__, 'unstable_getServerSideProps');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES,\n        page: \"/index\",\n        pathname: \"/\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    components: {\n        // default export might not exist when optimized for data only\n        App: (private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default()),\n        Document: (private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default())\n    },\n    userland: _src_pages_index_tsx__WEBPACK_IMPORTED_MODULE_5__\n});\n\n//# sourceMappingURL=pages.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTJnBhZ2U9JTJGJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGc3JjJTVDcGFnZXMlNUNpbmRleC50c3gmYWJzb2x1dGVBcHBQYXRoPXByaXZhdGUtbmV4dC1wYWdlcyUyRl9hcHAmYWJzb2x1dGVEb2N1bWVudFBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2RvY3VtZW50Jm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDaEM7QUFDRTtBQUMxRDtBQUN5RDtBQUNWO0FBQy9DO0FBQ29EO0FBQ3BEO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyxpREFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyx1QkFBdUIsd0VBQUssQ0FBQyxpREFBUTtBQUNyQyx1QkFBdUIsd0VBQUssQ0FBQyxpREFBUTtBQUNyQywyQkFBMkIsd0VBQUssQ0FBQyxpREFBUTtBQUN6QyxlQUFlLHdFQUFLLENBQUMsaURBQVE7QUFDN0Isd0JBQXdCLHdFQUFLLENBQUMsaURBQVE7QUFDN0M7QUFDTyxnQ0FBZ0Msd0VBQUssQ0FBQyxpREFBUTtBQUM5QyxnQ0FBZ0Msd0VBQUssQ0FBQyxpREFBUTtBQUM5QyxpQ0FBaUMsd0VBQUssQ0FBQyxpREFBUTtBQUMvQyxnQ0FBZ0Msd0VBQUssQ0FBQyxpREFBUTtBQUM5QyxvQ0FBb0Msd0VBQUssQ0FBQyxpREFBUTtBQUN6RDtBQUNPLHdCQUF3QixrR0FBZ0I7QUFDL0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsK0RBQVc7QUFDeEIsa0JBQWtCLG9FQUFnQjtBQUNsQyxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQsaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Lz85OGE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL3BhZ2VzL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgaG9pc3QgfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL3RlbXBsYXRlcy9oZWxwZXJzXCI7XG4vLyBJbXBvcnQgdGhlIGFwcCBhbmQgZG9jdW1lbnQgbW9kdWxlcy5cbmltcG9ydCAqIGFzIGRvY3VtZW50IGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2RvY3VtZW50XCI7XG5pbXBvcnQgKiBhcyBhcHAgZnJvbSBcInByaXZhdGUtbmV4dC1wYWdlcy9fYXBwXCI7XG4vLyBJbXBvcnQgdGhlIHVzZXJsYW5kIGNvZGUuXG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiLi9zcmNcXFxccGFnZXNcXFxcaW5kZXgudHN4XCI7XG4vLyBSZS1leHBvcnQgdGhlIGNvbXBvbmVudCAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgJ2RlZmF1bHQnKTtcbi8vIFJlLWV4cG9ydCBtZXRob2RzLlxuZXhwb3J0IGNvbnN0IGdldFN0YXRpY1Byb3BzID0gaG9pc3QodXNlcmxhbmQsICdnZXRTdGF0aWNQcm9wcycpO1xuZXhwb3J0IGNvbnN0IGdldFN0YXRpY1BhdGhzID0gaG9pc3QodXNlcmxhbmQsICdnZXRTdGF0aWNQYXRocycpO1xuZXhwb3J0IGNvbnN0IGdldFNlcnZlclNpZGVQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCAnZ2V0U2VydmVyU2lkZVByb3BzJyk7XG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsICdjb25maWcnKTtcbmV4cG9ydCBjb25zdCByZXBvcnRXZWJWaXRhbHMgPSBob2lzdCh1c2VybGFuZCwgJ3JlcG9ydFdlYlZpdGFscycpO1xuLy8gUmUtZXhwb3J0IGxlZ2FjeSBtZXRob2RzLlxuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFN0YXRpY1Byb3BzID0gaG9pc3QodXNlcmxhbmQsICd1bnN0YWJsZV9nZXRTdGF0aWNQcm9wcycpO1xuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFN0YXRpY1BhdGhzID0gaG9pc3QodXNlcmxhbmQsICd1bnN0YWJsZV9nZXRTdGF0aWNQYXRocycpO1xuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFN0YXRpY1BhcmFtcyA9IGhvaXN0KHVzZXJsYW5kLCAndW5zdGFibGVfZ2V0U3RhdGljUGFyYW1zJyk7XG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U2VydmVyUHJvcHMgPSBob2lzdCh1c2VybGFuZCwgJ3Vuc3RhYmxlX2dldFNlcnZlclByb3BzJyk7XG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U2VydmVyU2lkZVByb3BzID0gaG9pc3QodXNlcmxhbmQsICd1bnN0YWJsZV9nZXRTZXJ2ZXJTaWRlUHJvcHMnKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuZXhwb3J0IGNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IFBhZ2VzUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLlBBR0VTLFxuICAgICAgICBwYWdlOiBcIi9pbmRleFwiLFxuICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogJycsXG4gICAgICAgIGZpbGVuYW1lOiAnJ1xuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICAvLyBkZWZhdWx0IGV4cG9ydCBtaWdodCBub3QgZXhpc3Qgd2hlbiBvcHRpbWl6ZWQgZm9yIGRhdGEgb25seVxuICAgICAgICBBcHA6IGFwcC5kZWZhdWx0LFxuICAgICAgICBEb2N1bWVudDogZG9jdW1lbnQuZGVmYXVsdFxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fsrc%5Cpages%5Cindex.tsx&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "./src/api/api.ts":
/*!************************!*\
  !*** ./src/api/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetcher: () => (/* binding */ fetcher),\n/* harmony export */   useApi: () => (/* binding */ useApi)\n/* harmony export */ });\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swr */ \"swr\");\n/* harmony import */ var _utilities_helper_methods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/helper-methods */ \"./src/utilities/helper-methods.ts\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"axios\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([swr__WEBPACK_IMPORTED_MODULE_0__, axios__WEBPACK_IMPORTED_MODULE_2__]);\n([swr__WEBPACK_IMPORTED_MODULE_0__, axios__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\nconst fetcher = (url, config)=>axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(url, config).then((res)=>res.data);\nconst useApi = (url, options)=>(0,swr__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_utilities_helper_methods__WEBPACK_IMPORTED_MODULE_1__.urlSafetyCheck)(url), fetcher, options);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2FwaS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5QjtBQUNrQztBQUNUO0FBRTNDLE1BQU1HLFVBQVUsQ0FBQ0MsS0FBYUMsU0FBZ0NILGlEQUFTLENBQUNFLEtBQUtDLFFBQVFFLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUMsSUFBSSxFQUFFO0FBQzNHLE1BQU1DLFNBQVMsQ0FBQ04sS0FBYU8sVUFDbENYLCtDQUFNQSxDQUFDQyx5RUFBY0EsQ0FBQ0csTUFBTUQsU0FBU1EsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi9zcmMvYXBpL2FwaS50cz83MGI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJztcclxuaW1wb3J0IHt1cmxTYWZldHlDaGVja30gZnJvbSAnLi4vdXRpbGl0aWVzL2hlbHBlci1tZXRob2RzJztcclxuaW1wb3J0IGF4aW9zLCB7IEF4aW9zUmVxdWVzdENvbmZpZyB9IGZyb20gJ2F4aW9zJztcclxuXHJcbmV4cG9ydCBjb25zdCBmZXRjaGVyID0gKHVybDogc3RyaW5nLCBjb25maWc/OiBBeGlvc1JlcXVlc3RDb25maWcpID0+IGF4aW9zLmdldCh1cmwsIGNvbmZpZykudGhlbihyZXMgPT4gcmVzLmRhdGEpO1xyXG5leHBvcnQgY29uc3QgdXNlQXBpID0gKHVybDogc3RyaW5nLCBvcHRpb25zPzogb2JqZWN0KSA9PlxyXG4gIHVzZVNXUih1cmxTYWZldHlDaGVjayh1cmwpLCBmZXRjaGVyLCBvcHRpb25zKTtcclxuIl0sIm5hbWVzIjpbInVzZVNXUiIsInVybFNhZmV0eUNoZWNrIiwiYXhpb3MiLCJmZXRjaGVyIiwidXJsIiwiY29uZmlnIiwiZ2V0IiwidGhlbiIsInJlcyIsImRhdGEiLCJ1c2VBcGkiLCJvcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/api.ts\n");

/***/ }),

/***/ "./src/assets/styles/colors.ts":
/*!*************************************!*\
  !*** ./src/assets/styles/colors.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   BitPay: () => (/* binding */ BitPay),\n/* harmony export */   Black: () => (/* binding */ Black),\n/* harmony export */   Error: () => (/* binding */ Error),\n/* harmony export */   Feather: () => (/* binding */ Feather),\n/* harmony export */   LightBlack: () => (/* binding */ LightBlack),\n/* harmony export */   LinkBlue: () => (/* binding */ LinkBlue),\n/* harmony export */   NeutralSlate: () => (/* binding */ NeutralSlate),\n/* harmony export */   Slate: () => (/* binding */ Slate),\n/* harmony export */   Slate30: () => (/* binding */ Slate30),\n/* harmony export */   SlateDark: () => (/* binding */ SlateDark),\n/* harmony export */   Warning: () => (/* binding */ Warning),\n/* harmony export */   White: () => (/* binding */ White)\n/* harmony export */ });\n/* Primary */ const BitPay = '#1A3B8B';\nconst Action = '#2240C4';\nconst Black = '#000000';\nconst Feather = '#F6F7FC';\nconst LightBlack = '#252525';\nconst Slate = '#9BA3AE';\nconst SlateDark = '#434D5A';\nconst White = '#FFFFFF';\nconst Error = '#C52A42';\nconst NeutralSlate = '#F5F7F8';\nconst Slate30 = '#E1E4E7';\nconst LinkBlue = '#4989FF';\nconst Warning = '#FDB455';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL3N0eWxlcy9jb2xvcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFdBQVcsR0FDSixNQUFNQSxTQUFTLFVBQVU7QUFDekIsTUFBTUMsU0FBUyxVQUFVO0FBQ3pCLE1BQU1DLFFBQVEsVUFBVTtBQUN4QixNQUFNQyxVQUFVLFVBQVU7QUFDMUIsTUFBTUMsYUFBYSxVQUFVO0FBQzdCLE1BQU1DLFFBQVEsVUFBVTtBQUN4QixNQUFNQyxZQUFZLFVBQVU7QUFDNUIsTUFBTUMsUUFBUSxVQUFVO0FBQ3hCLE1BQU1DLFFBQVEsVUFBVTtBQUN4QixNQUFNQyxlQUFlLFVBQVU7QUFDL0IsTUFBTUMsVUFBVSxVQUFVO0FBQzFCLE1BQU1DLFdBQVcsVUFBVTtBQUMzQixNQUFNQyxVQUFVLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4vc3JjL2Fzc2V0cy9zdHlsZXMvY29sb3JzLnRzP2Y0ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogUHJpbWFyeSAqL1xyXG5leHBvcnQgY29uc3QgQml0UGF5ID0gJyMxQTNCOEInO1xyXG5leHBvcnQgY29uc3QgQWN0aW9uID0gJyMyMjQwQzQnO1xyXG5leHBvcnQgY29uc3QgQmxhY2sgPSAnIzAwMDAwMCc7XHJcbmV4cG9ydCBjb25zdCBGZWF0aGVyID0gJyNGNkY3RkMnO1xyXG5leHBvcnQgY29uc3QgTGlnaHRCbGFjayA9ICcjMjUyNTI1JztcclxuZXhwb3J0IGNvbnN0IFNsYXRlID0gJyM5QkEzQUUnO1xyXG5leHBvcnQgY29uc3QgU2xhdGVEYXJrID0gJyM0MzRENUEnO1xyXG5leHBvcnQgY29uc3QgV2hpdGUgPSAnI0ZGRkZGRic7XHJcbmV4cG9ydCBjb25zdCBFcnJvciA9ICcjQzUyQTQyJztcclxuZXhwb3J0IGNvbnN0IE5ldXRyYWxTbGF0ZSA9ICcjRjVGN0Y4JztcclxuZXhwb3J0IGNvbnN0IFNsYXRlMzAgPSAnI0UxRTRFNyc7XHJcbmV4cG9ydCBjb25zdCBMaW5rQmx1ZSA9ICcjNDk4OUZGJztcclxuZXhwb3J0IGNvbnN0IFdhcm5pbmcgPSAnI0ZEQjQ1NSc7XHJcbiJdLCJuYW1lcyI6WyJCaXRQYXkiLCJBY3Rpb24iLCJCbGFjayIsIkZlYXRoZXIiLCJMaWdodEJsYWNrIiwiU2xhdGUiLCJTbGF0ZURhcmsiLCJXaGl0ZSIsIkVycm9yIiwiTmV1dHJhbFNsYXRlIiwiU2xhdGUzMCIsIkxpbmtCbHVlIiwiV2FybmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/assets/styles/colors.ts\n");

/***/ }),

/***/ "./src/assets/styles/global.ts":
/*!*************************************!*\
  !*** ./src/assets/styles/global.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConfirmationLabel: () => (/* binding */ ConfirmationLabel),\n/* harmony export */   DisplayFlex: () => (/* binding */ DisplayFlex),\n/* harmony export */   FooterHeight: () => (/* binding */ FooterHeight),\n/* harmony export */   GlobalStyles: () => (/* binding */ GlobalStyles),\n/* harmony export */   HeaderHeight: () => (/* binding */ HeaderHeight),\n/* harmony export */   HeaderZIndex: () => (/* binding */ HeaderZIndex),\n/* harmony export */   Truncate: () => (/* binding */ Truncate)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"styled-components\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors */ \"./src/assets/styles/colors.ts\");\n\n\nconst HeaderHeight = '80px';\nconst FooterHeight = '57px';\nconst HeaderZIndex = 10;\nconst Truncate = ()=>(0,styled_components__WEBPACK_IMPORTED_MODULE_0__.css)`\r\n   {\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n  }\r\n`;\nconst DisplayFlex = (styled_components__WEBPACK_IMPORTED_MODULE_0___default().div)`\r\n  display: flex;\r\n`;\nconst ConfirmationLabel = (styled_components__WEBPACK_IMPORTED_MODULE_0___default().span)`\r\n  padding: ${({ padding })=>padding || 0};\r\n  ${({ warning, error, greyed })=>{\n    if (greyed) {\n        return (0,styled_components__WEBPACK_IMPORTED_MODULE_0__.css)`\r\n        color: ${_colors__WEBPACK_IMPORTED_MODULE_1__.Slate};\r\n      `;\n    }\n    if (warning) {\n        return (0,styled_components__WEBPACK_IMPORTED_MODULE_0__.css)`\r\n        color: ${_colors__WEBPACK_IMPORTED_MODULE_1__.Warning};\r\n      `;\n    }\n    if (error) {\n        return (0,styled_components__WEBPACK_IMPORTED_MODULE_0__.css)`\r\n        color: ${_colors__WEBPACK_IMPORTED_MODULE_1__.Error};\r\n      `;\n    }\n}}\r\n`;\nconst GlobalStyles = (0,styled_components__WEBPACK_IMPORTED_MODULE_0__.createGlobalStyle)`\r\n  html,\r\n  body {\r\n    padding: 0;\r\n    margin: 0;\r\n    background: ${({ theme: { colors } })=>colors.background};\r\n    color:${({ theme: { colors } })=>colors.color};\r\n  }\r\n\r\n  a {\r\n    color: inherit;\r\n    text-decoration: none;\r\n  }\r\n\r\n  * {\r\n    box-sizing: border-box;\r\n    font-family: 'Heebo', Arial, Helvetica, sans-serif;\r\n    -webkit-font-smoothing: antialiased;\r\n    -moz-osx-font-smoothing: grayscale;\r\n  }\r\n\r\n  .currency-masonry-grid {\r\n    display: -webkit-box;\r\n    display: -ms-flexbox;\r\n    display: flex;\r\n    margin: 0 -1rem;\r\n    justify-content: center;\r\n  }\r\n\r\n  .currency-masonry-grid_column {\r\n    padding: 1rem;\r\n    max-width: 456px;\r\n  }\r\n\r\n  #nprogress .bar {\r\n    height: 4px;\r\n    background: #27c4f5 linear-gradient(to right, #27c4f5, #a307ba, #fd8d32, #70c050, #27c4f5);\r\n    background-size: 500%;\r\n    animation: 2s linear infinite barprogress, .3s fadein;\r\n  }\r\n\r\n  @keyframes barprogress {\r\n    0% {\r\n      background-position: 0 0\r\n    }\r\n    to {\r\n      background-position: 125% 0\r\n    }\r\n  }\r\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL3N0eWxlcy9nbG9iYWwudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNsQjtBQUV4QyxNQUFNTSxlQUFlLE9BQU87QUFDNUIsTUFBTUMsZUFBZSxPQUFPO0FBRTVCLE1BQU1DLGVBQWUsR0FBRztBQUV4QixNQUFNQyxXQUFXLElBQU1QLHNEQUFHLENBQUM7Ozs7OztBQU1sQyxDQUFDLENBQUM7QUFFSyxNQUFNUSxjQUFjViw4REFBVSxDQUFDOztBQUV0QyxDQUFDLENBQUM7QUFTSyxNQUFNWSxvQkFBb0JaLCtEQUFXLENBQXlCO1dBQzFELEVBQUUsQ0FBQyxFQUFDYyxPQUFPLEVBQUMsR0FBS0EsV0FBVyxFQUFFO0VBQ3ZDLEVBQUUsQ0FBQyxFQUFDQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFDO0lBQ3pCLElBQUlBLFFBQVE7UUFDVixPQUFPZixzREFBRyxDQUFDO2VBQ0YsRUFBRUUsMENBQUtBLENBQUM7TUFDakIsQ0FBQztJQUNIO0lBRUEsSUFBSVcsU0FBUztRQUNYLE9BQU9iLHNEQUFHLENBQUM7ZUFDRixFQUFFRyw0Q0FBT0EsQ0FBQztNQUNuQixDQUFDO0lBQ0g7SUFFQSxJQUFJVyxPQUFPO1FBQ1QsT0FBT2Qsc0RBQUcsQ0FBQztlQUNGLEVBQUVDLDBDQUFLQSxDQUFDO01BQ2pCLENBQUM7SUFDSDtBQUNGLEVBQUU7QUFDSixDQUFDLENBQUM7QUFFSyxNQUFNZSxlQUFlakIsb0VBQWlCLENBQUM7Ozs7O2dCQUs5QixFQUFFLENBQUMsRUFBQ2tCLE9BQU8sRUFBQ0MsTUFBTSxFQUFDLEVBQUMsR0FBS0EsT0FBT0MsVUFBVSxDQUFDO1VBQ2pELEVBQUUsQ0FBQyxFQUFDRixPQUFPLEVBQUNDLE1BQU0sRUFBQyxFQUFDLEdBQUtBLE9BQU9FLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDaEQsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uL3NyYy9hc3NldHMvc3R5bGVzL2dsb2JhbC50cz8zMWUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQsIHtjcmVhdGVHbG9iYWxTdHlsZSwgY3NzfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XHJcbmltcG9ydCB7RXJyb3IsIFNsYXRlLCBXYXJuaW5nfSBmcm9tICcuL2NvbG9ycyc7XHJcblxyXG5leHBvcnQgY29uc3QgSGVhZGVySGVpZ2h0ID0gJzgwcHgnO1xyXG5leHBvcnQgY29uc3QgRm9vdGVySGVpZ2h0ID0gJzU3cHgnO1xyXG5cclxuZXhwb3J0IGNvbnN0IEhlYWRlclpJbmRleCA9IDEwO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRydW5jYXRlID0gKCkgPT4gY3NzYFxyXG4gICB7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XHJcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gIH1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBEaXNwbGF5RmxleCA9IHN0eWxlZC5kaXZgXHJcbiAgZGlzcGxheTogZmxleDtcclxuYDtcclxuXHJcbmludGVyZmFjZSBDb25maXJtYXRpb25MYWJlbFByb3BzIHtcclxuICB3YXJuaW5nPzogYW55O1xyXG4gIGVycm9yPzogYW55O1xyXG4gIGdyZXllZD86IGFueTtcclxuICBwYWRkaW5nPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgQ29uZmlybWF0aW9uTGFiZWwgPSBzdHlsZWQuc3BhbjxDb25maXJtYXRpb25MYWJlbFByb3BzPmBcclxuICBwYWRkaW5nOiAkeyh7cGFkZGluZ30pID0+IHBhZGRpbmcgfHwgMH07XHJcbiAgJHsoe3dhcm5pbmcsIGVycm9yLCBncmV5ZWR9KSA9PiB7XHJcbiAgICBpZiAoZ3JleWVkKSB7XHJcbiAgICAgIHJldHVybiBjc3NgXHJcbiAgICAgICAgY29sb3I6ICR7U2xhdGV9O1xyXG4gICAgICBgO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh3YXJuaW5nKSB7XHJcbiAgICAgIHJldHVybiBjc3NgXHJcbiAgICAgICAgY29sb3I6ICR7V2FybmluZ307XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIHJldHVybiBjc3NgXHJcbiAgICAgICAgY29sb3I6ICR7RXJyb3J9O1xyXG4gICAgICBgO1xyXG4gICAgfVxyXG4gIH19XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgR2xvYmFsU3R5bGVzID0gY3JlYXRlR2xvYmFsU3R5bGVgXHJcbiAgaHRtbCxcclxuICBib2R5IHtcclxuICAgIHBhZGRpbmc6IDA7XHJcbiAgICBtYXJnaW46IDA7XHJcbiAgICBiYWNrZ3JvdW5kOiAkeyh7dGhlbWU6IHtjb2xvcnN9fSkgPT4gY29sb3JzLmJhY2tncm91bmR9O1xyXG4gICAgY29sb3I6JHsoe3RoZW1lOiB7Y29sb3JzfX0pID0+IGNvbG9ycy5jb2xvcn07XHJcbiAgfVxyXG5cclxuICBhIHtcclxuICAgIGNvbG9yOiBpbmhlcml0O1xyXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gIH1cclxuXHJcbiAgKiB7XHJcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gICAgZm9udC1mYW1pbHk6ICdIZWVibycsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XHJcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcclxuICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XHJcbiAgfVxyXG5cclxuICAuY3VycmVuY3ktbWFzb25yeS1ncmlkIHtcclxuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xyXG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgbWFyZ2luOiAwIC0xcmVtO1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgfVxyXG5cclxuICAuY3VycmVuY3ktbWFzb25yeS1ncmlkX2NvbHVtbiB7XHJcbiAgICBwYWRkaW5nOiAxcmVtO1xyXG4gICAgbWF4LXdpZHRoOiA0NTZweDtcclxuICB9XHJcblxyXG4gICNucHJvZ3Jlc3MgLmJhciB7XHJcbiAgICBoZWlnaHQ6IDRweDtcclxuICAgIGJhY2tncm91bmQ6ICMyN2M0ZjUgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjMjdjNGY1LCAjYTMwN2JhLCAjZmQ4ZDMyLCAjNzBjMDUwLCAjMjdjNGY1KTtcclxuICAgIGJhY2tncm91bmQtc2l6ZTogNTAwJTtcclxuICAgIGFuaW1hdGlvbjogMnMgbGluZWFyIGluZmluaXRlIGJhcnByb2dyZXNzLCAuM3MgZmFkZWluO1xyXG4gIH1cclxuXHJcbiAgQGtleWZyYW1lcyBiYXJwcm9ncmVzcyB7XHJcbiAgICAwJSB7XHJcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IDAgMFxyXG4gICAgfVxyXG4gICAgdG8ge1xyXG4gICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAxMjUlIDBcclxuICAgIH1cclxuICB9XHJcbmA7XHJcbiJdLCJuYW1lcyI6WyJzdHlsZWQiLCJjcmVhdGVHbG9iYWxTdHlsZSIsImNzcyIsIkVycm9yIiwiU2xhdGUiLCJXYXJuaW5nIiwiSGVhZGVySGVpZ2h0IiwiRm9vdGVySGVpZ2h0IiwiSGVhZGVyWkluZGV4IiwiVHJ1bmNhdGUiLCJEaXNwbGF5RmxleCIsImRpdiIsIkNvbmZpcm1hdGlvbkxhYmVsIiwic3BhbiIsInBhZGRpbmciLCJ3YXJuaW5nIiwiZXJyb3IiLCJncmV5ZWQiLCJHbG9iYWxTdHlsZXMiLCJ0aGVtZSIsImNvbG9ycyIsImJhY2tncm91bmQiLCJjb2xvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/assets/styles/global.ts\n");

/***/ }),

/***/ "./src/assets/styles/spinner.ts":
/*!**************************************!*\
  !*** ./src/assets/styles/spinner.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Spinner: () => (/* binding */ Spinner)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"styled-components\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_0__);\n\nconst Spin = (0,styled_components__WEBPACK_IMPORTED_MODULE_0__.keyframes)`\r\n  to {\r\n    transform: rotate(720deg);\r\n  }\r\n`;\nconst Spinner = (styled_components__WEBPACK_IMPORTED_MODULE_0___default().div)`\r\n  img {\r\n    animation: ${Spin} 1500ms cubic-bezier(0.5, 0, 0.25, 1) infinite;\r\n    user-select: none;\r\n  }\r\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL3N0eWxlcy9zcGlubmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRDtBQUVwRCxNQUFNRSxPQUFPRCw0REFBUyxDQUFDOzs7O0FBSXZCLENBQUM7QUFFTSxNQUFNRSxVQUFVSCw4REFBVSxDQUFDOztlQUVuQixFQUFFRSxLQUFLOzs7QUFHdEIsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uL3NyYy9hc3NldHMvc3R5bGVzL3NwaW5uZXIudHM/MDAxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkLCB7a2V5ZnJhbWVzfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XHJcblxyXG5jb25zdCBTcGluID0ga2V5ZnJhbWVzYFxyXG4gIHRvIHtcclxuICAgIHRyYW5zZm9ybTogcm90YXRlKDcyMGRlZyk7XHJcbiAgfVxyXG5gO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNwaW5uZXIgPSBzdHlsZWQuZGl2YFxyXG4gIGltZyB7XHJcbiAgICBhbmltYXRpb246ICR7U3Bpbn0gMTUwMG1zIGN1YmljLWJlemllcigwLjUsIDAsIDAuMjUsIDEpIGluZmluaXRlO1xyXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgfVxyXG5gO1xyXG4iXSwibmFtZXMiOlsic3R5bGVkIiwia2V5ZnJhbWVzIiwiU3BpbiIsIlNwaW5uZXIiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/assets/styles/spinner.ts\n");

/***/ }),

/***/ "./src/assets/styles/tile.ts":
/*!***********************************!*\
  !*** ./src/assets/styles/tile.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tile: () => (/* binding */ Tile),\n/* harmony export */   TileDescription: () => (/* binding */ TileDescription),\n/* harmony export */   TileLink: () => (/* binding */ TileLink)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"styled-components\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ \"./src/assets/styles/global.ts\");\n/* harmony import */ var _utilities_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/constants */ \"./src/utilities/constants.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colors */ \"./src/assets/styles/colors.ts\");\n\n\n\n\nconst Tile = (styled_components__WEBPACK_IMPORTED_MODULE_0___default().div)`\r\n  justify-content: space-between;\r\n  display: flex;\r\n  margin: ${({ margin })=>margin || 0};\r\n  padding: ${({ padding })=>padding || '10px 0'};\r\n\r\n  ${({ withBorderBottom, invertedBorderColor })=>{\n    if (withBorderBottom) {\n        return (0,styled_components__WEBPACK_IMPORTED_MODULE_0__.css)`\r\n        border-style: solid;\r\n        border-width: 0 0 1px 0;\r\n        border-color: ${({ theme: { dark } })=>dark ? '#1F1F1F' : _colors__WEBPACK_IMPORTED_MODULE_3__.Slate30};\r\n      `;\n    }\n    if (invertedBorderColor) {\n        return (0,styled_components__WEBPACK_IMPORTED_MODULE_0__.css)`\r\n        border-style: solid;\r\n        border-width: 0 0 1px 0;\r\n        border-color: ${({ theme: { dark } })=>dark ? '#090909' : _colors__WEBPACK_IMPORTED_MODULE_3__.NeutralSlate};\r\n      `;\n    }\n}};\r\n`;\nconst TileDescription = (styled_components__WEBPACK_IMPORTED_MODULE_0___default().div)`\r\n  ${({ noTruncate })=>{\n    if (!noTruncate) {\n        return (0,_global__WEBPACK_IMPORTED_MODULE_1__.Truncate)();\n    }\n}};\r\n\r\n  font-style: normal;\r\n  font-weight: ${({ value })=>value ? 'normal' : '500'};\r\n  font-size: ${({ value })=>value ? '16px' : '18px'};\r\n  line-height: 25px;\r\n  white-space: nowrap;\r\n  margin: ${({ margin })=>margin || 0};\r\n  padding: ${({ padding })=>padding || 0};\r\n  width: ${({ width })=>width || '100%'};\r\n  text-align: ${({ textAlign })=>textAlign || 'left'};\r\n  display: inline;\r\n\r\n  @media screen and (max-width: ${_utilities_constants__WEBPACK_IMPORTED_MODULE_2__.size.mobileL}) {\r\n    font-size: ${({ value })=>value ? '14px' : '16px'};\r\n  }\r\n`;\nconst TileLink = styled_components__WEBPACK_IMPORTED_MODULE_0___default()(TileDescription)`\r\n  color: ${({ disabled, theme: { colors } })=>disabled ? 'inherit' : colors.link};\r\n  cursor: ${({ disabled })=>disabled ? 'default' : 'pointer'};\r\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL3N0eWxlcy90aWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQThDO0FBQ1o7QUFDYTtBQUNBO0FBa0J4QyxNQUFNTSxPQUFPTiw4REFBVSxDQUFZOzs7VUFHaEMsRUFBRSxDQUFDLEVBQUNRLE1BQU0sRUFBQyxHQUFLQSxVQUFVLEVBQUU7V0FDM0IsRUFBRSxDQUFDLEVBQUNDLE9BQU8sRUFBQyxHQUFLQSxXQUFXLFNBQVM7O0VBRTlDLEVBQUUsQ0FBQyxFQUFDQyxnQkFBZ0IsRUFBRUMsbUJBQW1CLEVBQVk7SUFDbkQsSUFBSUQsa0JBQWtCO1FBQ3BCLE9BQU9ULHNEQUFHLENBQUM7OztzQkFHSyxFQUFFLENBQUMsRUFBQ1csT0FBTyxFQUFDQyxJQUFJLEVBQUMsRUFBQyxHQUFNQSxPQUFPLFlBQVlSLDRDQUFPQSxDQUFFO01BQ3BFLENBQUM7SUFDSDtJQUVBLElBQUlNLHFCQUFxQjtRQUN2QixPQUFPVixzREFBRyxDQUFDOzs7c0JBR0ssRUFBRSxDQUFDLEVBQUNXLE9BQU8sRUFBQ0MsSUFBSSxFQUFDLEVBQUMsR0FBTUEsT0FBTyxZQUFZVCxpREFBWUEsQ0FBRTtNQUN6RSxDQUFDO0lBQ0g7QUFDRixFQUFFO0FBQ0osQ0FBQyxDQUFDO0FBRUssTUFBTVUsa0JBQWtCZCw4REFBVSxDQUF1QjtFQUM5RCxFQUFFLENBQUMsRUFBQ2UsVUFBVSxFQUFDO0lBQ2IsSUFBSSxDQUFDQSxZQUFZO1FBQ2YsT0FBT2IsaURBQVFBO0lBQ2pCO0FBQ0YsRUFBRTs7O2VBR1csRUFBRSxDQUFDLEVBQUNjLEtBQUssRUFBQyxHQUFNQSxRQUFRLFdBQVcsTUFBTzthQUM1QyxFQUFFLENBQUMsRUFBQ0EsS0FBSyxFQUFDLEdBQU1BLFFBQVEsU0FBUyxPQUFROzs7VUFHNUMsRUFBRSxDQUFDLEVBQUNSLE1BQU0sRUFBQyxHQUFLQSxVQUFVLEVBQUU7V0FDM0IsRUFBRSxDQUFDLEVBQUNDLE9BQU8sRUFBQyxHQUFLQSxXQUFXLEVBQUU7U0FDaEMsRUFBRSxDQUFDLEVBQUNRLEtBQUssRUFBQyxHQUFLQSxTQUFTLE9BQU87Y0FDMUIsRUFBRSxDQUFDLEVBQUNDLFNBQVMsRUFBQyxHQUFLQSxhQUFhLE9BQU87OztnQ0FHckIsRUFBRWYsc0RBQUlBLENBQUNnQixPQUFPLENBQUM7ZUFDaEMsRUFBRSxDQUFDLEVBQUNILEtBQUssRUFBQyxHQUFNQSxRQUFRLFNBQVMsT0FBUTs7QUFFeEQsQ0FBQyxDQUFDO0FBTUssTUFBTUksV0FBV3BCLHdEQUFNQSxDQUFDYyxnQkFBK0IsQ0FBQztTQUN0RCxFQUFFLENBQUMsRUFBQ08sUUFBUSxFQUFFVCxPQUFPLEVBQUNVLE1BQU0sRUFBQyxFQUFDLEdBQU1ELFdBQVcsWUFBWUMsT0FBT0MsSUFBSSxDQUFFO1VBQ3ZFLEVBQUUsQ0FBQyxFQUFDRixRQUFRLEVBQUMsR0FBTUEsV0FBVyxZQUFZLFVBQVc7QUFDL0QsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uL3NyYy9hc3NldHMvc3R5bGVzL3RpbGUudHM/MGVmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkLCB7Y3NzfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XHJcbmltcG9ydCB7VHJ1bmNhdGV9IGZyb20gJy4vZ2xvYmFsJztcclxuaW1wb3J0IHtzaXplfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvY29uc3RhbnRzJztcclxuaW1wb3J0IHtOZXV0cmFsU2xhdGUsIFNsYXRlMzB9IGZyb20gJy4vY29sb3JzJztcclxuXHJcbmludGVyZmFjZSBUaWxlRGVzY3JpcHRpb25Qcm9wcyB7XHJcbiAgdmFsdWU/OiBhbnk7XHJcbiAgbm9UcnVuY2F0ZT86IGFueTtcclxuICBtYXJnaW4/OiBzdHJpbmc7XHJcbiAgcGFkZGluZz86IHN0cmluZztcclxuICB3aWR0aD86IHN0cmluZztcclxuICB0ZXh0QWxpZ24/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUaWxlUHJvcHMge1xyXG4gIHdpdGhCb3JkZXJCb3R0b20/OiBhbnk7XHJcbiAgaW52ZXJ0ZWRCb3JkZXJDb2xvcj86IGJvb2xlYW47XHJcbiAgbWFyZ2luPzogc3RyaW5nO1xyXG4gIHBhZGRpbmc/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUaWxlID0gc3R5bGVkLmRpdjxUaWxlUHJvcHM+YFxyXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIG1hcmdpbjogJHsoe21hcmdpbn0pID0+IG1hcmdpbiB8fCAwfTtcclxuICBwYWRkaW5nOiAkeyh7cGFkZGluZ30pID0+IHBhZGRpbmcgfHwgJzEwcHggMCd9O1xyXG5cclxuICAkeyh7d2l0aEJvcmRlckJvdHRvbSwgaW52ZXJ0ZWRCb3JkZXJDb2xvcn06IFRpbGVQcm9wcykgPT4ge1xyXG4gICAgaWYgKHdpdGhCb3JkZXJCb3R0b20pIHtcclxuICAgICAgcmV0dXJuIGNzc2BcclxuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xyXG4gICAgICAgIGJvcmRlci13aWR0aDogMCAwIDFweCAwO1xyXG4gICAgICAgIGJvcmRlci1jb2xvcjogJHsoe3RoZW1lOiB7ZGFya319KSA9PiAoZGFyayA/ICcjMUYxRjFGJyA6IFNsYXRlMzApfTtcclxuICAgICAgYDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW52ZXJ0ZWRCb3JkZXJDb2xvcikge1xyXG4gICAgICByZXR1cm4gY3NzYFxyXG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XHJcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAwIDAgMXB4IDA7XHJcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAkeyh7dGhlbWU6IHtkYXJrfX0pID0+IChkYXJrID8gJyMwOTA5MDknIDogTmV1dHJhbFNsYXRlKX07XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcbiAgfX07XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgVGlsZURlc2NyaXB0aW9uID0gc3R5bGVkLmRpdjxUaWxlRGVzY3JpcHRpb25Qcm9wcz5gXHJcbiAgJHsoe25vVHJ1bmNhdGV9KSA9PiB7XHJcbiAgICBpZiAoIW5vVHJ1bmNhdGUpIHtcclxuICAgICAgcmV0dXJuIFRydW5jYXRlKCk7XHJcbiAgICB9XHJcbiAgfX07XHJcblxyXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcclxuICBmb250LXdlaWdodDogJHsoe3ZhbHVlfSkgPT4gKHZhbHVlID8gJ25vcm1hbCcgOiAnNTAwJyl9O1xyXG4gIGZvbnQtc2l6ZTogJHsoe3ZhbHVlfSkgPT4gKHZhbHVlID8gJzE2cHgnIDogJzE4cHgnKX07XHJcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XHJcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuICBtYXJnaW46ICR7KHttYXJnaW59KSA9PiBtYXJnaW4gfHwgMH07XHJcbiAgcGFkZGluZzogJHsoe3BhZGRpbmd9KSA9PiBwYWRkaW5nIHx8IDB9O1xyXG4gIHdpZHRoOiAkeyh7d2lkdGh9KSA9PiB3aWR0aCB8fCAnMTAwJSd9O1xyXG4gIHRleHQtYWxpZ246ICR7KHt0ZXh0QWxpZ259KSA9PiB0ZXh0QWxpZ24gfHwgJ2xlZnQnfTtcclxuICBkaXNwbGF5OiBpbmxpbmU7XHJcblxyXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICR7c2l6ZS5tb2JpbGVMfSkge1xyXG4gICAgZm9udC1zaXplOiAkeyh7dmFsdWV9KSA9PiAodmFsdWUgPyAnMTRweCcgOiAnMTZweCcpfTtcclxuICB9XHJcbmA7XHJcblxyXG5pbnRlcmZhY2UgVGlsZUxpbmtQcm9wcyB7XHJcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVGlsZUxpbmsgPSBzdHlsZWQoVGlsZURlc2NyaXB0aW9uKTxUaWxlTGlua1Byb3BzPmBcclxuICBjb2xvcjogJHsoe2Rpc2FibGVkLCB0aGVtZToge2NvbG9yc319KSA9PiAoZGlzYWJsZWQgPyAnaW5oZXJpdCcgOiBjb2xvcnMubGluayl9O1xyXG4gIGN1cnNvcjogJHsoe2Rpc2FibGVkfSkgPT4gKGRpc2FibGVkID8gJ2RlZmF1bHQnIDogJ3BvaW50ZXInKX07XHJcbmA7XHJcbiJdLCJuYW1lcyI6WyJzdHlsZWQiLCJjc3MiLCJUcnVuY2F0ZSIsInNpemUiLCJOZXV0cmFsU2xhdGUiLCJTbGF0ZTMwIiwiVGlsZSIsImRpdiIsIm1hcmdpbiIsInBhZGRpbmciLCJ3aXRoQm9yZGVyQm90dG9tIiwiaW52ZXJ0ZWRCb3JkZXJDb2xvciIsInRoZW1lIiwiZGFyayIsIlRpbGVEZXNjcmlwdGlvbiIsIm5vVHJ1bmNhdGUiLCJ2YWx1ZSIsIndpZHRoIiwidGV4dEFsaWduIiwibW9iaWxlTCIsIlRpbGVMaW5rIiwiZGlzYWJsZWQiLCJjb2xvcnMiLCJsaW5rIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/assets/styles/tile.ts\n");

/***/ }),

/***/ "./src/assets/styles/titles.ts":
/*!*************************************!*\
  !*** ./src/assets/styles/titles.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MainTitle: () => (/* binding */ MainTitle),\n/* harmony export */   SecondaryTitle: () => (/* binding */ SecondaryTitle)\n/* harmony export */ });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"styled-components\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var src_utilities_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/utilities/constants */ \"./src/utilities/constants.ts\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framer-motion */ \"framer-motion\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([framer_motion__WEBPACK_IMPORTED_MODULE_2__]);\nframer_motion__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst MainTitle = styled_components__WEBPACK_IMPORTED_MODULE_0___default()(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.h1)`\r\n  font-style: normal;\r\n  font-weight: 500;\r\n  font-size: 50px;\r\n  line-height: 62px;\r\n\r\n  @media screen and (max-width: ${src_utilities_constants__WEBPACK_IMPORTED_MODULE_1__.size.tablet}) {\r\n    font-size: 25px;\r\n    line-height: 38px;\r\n  }\r\n`;\nconst SecondaryTitle = (styled_components__WEBPACK_IMPORTED_MODULE_0___default().h2)`\r\n  font-style: normal;\r\n  font-weight: bold;\r\n  font-size: 25px;\r\n  line-height: 34px;\r\n\r\n  @media screen and (max-width: ${src_utilities_constants__WEBPACK_IMPORTED_MODULE_1__.size.tablet}) {\r\n    font-size: 22px;\r\n    line-height: 30px;\r\n  }\r\n`;\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL3N0eWxlcy90aXRsZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ007QUFDUjtBQUU5QixNQUFNRyxZQUFZSCx3REFBTUEsQ0FBQ0UsaURBQU1BLENBQUNFLEVBQUUsQ0FBQyxDQUFDOzs7Ozs7Z0NBTVgsRUFBRUgseURBQUlBLENBQUNJLE1BQU0sQ0FBQzs7OztBQUk5QyxDQUFDLENBQUM7QUFFSyxNQUFNQyxpQkFBaUJOLDZEQUFTLENBQUM7Ozs7OztnQ0FNUixFQUFFQyx5REFBSUEsQ0FBQ0ksTUFBTSxDQUFDOzs7O0FBSTlDLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi9zcmMvYXNzZXRzL3N0eWxlcy90aXRsZXMudHM/ZTE0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcclxuaW1wb3J0IHtzaXplfSBmcm9tICdzcmMvdXRpbGl0aWVzL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7bW90aW9ufSBmcm9tICdmcmFtZXItbW90aW9uJztcclxuXHJcbmV4cG9ydCBjb25zdCBNYWluVGl0bGUgPSBzdHlsZWQobW90aW9uLmgxKWBcclxuICBmb250LXN0eWxlOiBub3JtYWw7XHJcbiAgZm9udC13ZWlnaHQ6IDUwMDtcclxuICBmb250LXNpemU6IDUwcHg7XHJcbiAgbGluZS1oZWlnaHQ6IDYycHg7XHJcblxyXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICR7c2l6ZS50YWJsZXR9KSB7XHJcbiAgICBmb250LXNpemU6IDI1cHg7XHJcbiAgICBsaW5lLWhlaWdodDogMzhweDtcclxuICB9XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgU2Vjb25kYXJ5VGl0bGUgPSBzdHlsZWQuaDJgXHJcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xyXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gIGZvbnQtc2l6ZTogMjVweDtcclxuICBsaW5lLWhlaWdodDogMzRweDtcclxuXHJcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogJHtzaXplLnRhYmxldH0pIHtcclxuICAgIGZvbnQtc2l6ZTogMjJweDtcclxuICAgIGxpbmUtaGVpZ2h0OiAzMHB4O1xyXG4gIH1cclxuYDtcclxuIl0sIm5hbWVzIjpbInN0eWxlZCIsInNpemUiLCJtb3Rpb24iLCJNYWluVGl0bGUiLCJoMSIsInRhYmxldCIsIlNlY29uZGFyeVRpdGxlIiwiaDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/assets/styles/titles.ts\n");

/***/ }),

/***/ "./src/components/currency-tile.tsx":
/*!******************************************!*\
  !*** ./src/components/currency-tile.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utilities_helper_methods__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/helper-methods */ \"./src/utilities/helper-methods.ts\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ \"styled-components\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(styled_components__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _assets_styles_tile__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../assets/styles/tile */ \"./src/assets/styles/tile.ts\");\n/* harmony import */ var _assets_images_large_thin_spinner_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../assets/images/large-thin-spinner.svg */ \"./src/assets/images/large-thin-spinner.svg\");\n/* harmony import */ var _assets_styles_spinner__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../assets/styles/spinner */ \"./src/assets/styles/spinner.ts\");\n/* harmony import */ var _utilities_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/constants */ \"./src/utilities/constants.ts\");\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-router-dom */ \"react-router-dom\");\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _api_api__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../api/api */ \"./src/api/api.ts\");\n/* harmony import */ var _assets_styles_colors__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../assets/styles/colors */ \"./src/assets/styles/colors.ts\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! chart.js */ \"chart.js\");\n/* harmony import */ var react_chartjs_2__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-chartjs-2 */ \"react-chartjs-2\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_api_api__WEBPACK_IMPORTED_MODULE_9__, chart_js__WEBPACK_IMPORTED_MODULE_11__, react_chartjs_2__WEBPACK_IMPORTED_MODULE_12__]);\n([_api_api__WEBPACK_IMPORTED_MODULE_9__, chart_js__WEBPACK_IMPORTED_MODULE_11__, react_chartjs_2__WEBPACK_IMPORTED_MODULE_12__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n\n\n\nchart_js__WEBPACK_IMPORTED_MODULE_11__.Chart.register(chart_js__WEBPACK_IMPORTED_MODULE_11__.CategoryScale, chart_js__WEBPACK_IMPORTED_MODULE_11__.LinearScale, chart_js__WEBPACK_IMPORTED_MODULE_11__.PointElement, chart_js__WEBPACK_IMPORTED_MODULE_11__.LineElement, chart_js__WEBPACK_IMPORTED_MODULE_11__.Title, chart_js__WEBPACK_IMPORTED_MODULE_11__.Tooltip, chart_js__WEBPACK_IMPORTED_MODULE_11__.Legend);\nconst gutter = '1.5rem';\nconst LightBackground = {\n    BTC: '#FFF1E0',\n    BCH: '#EFFFF6',\n    ETH: '#EBECF6',\n    LTC: '#FAFAFA',\n    DOGE: '#FDF8E6'\n};\nconst DarkBackground = {\n    BTC: '#0C0700',\n    BCH: '#020A05',\n    ETH: '#06070F',\n    LTC: '#0A0A0A',\n    DOGE: '#0B0903'\n};\nconst CurrencyTileDiv = (styled_components__WEBPACK_IMPORTED_MODULE_3___default().div)`\r\n  padding: ${gutter};\r\n  text-align: left;\r\n  border-radius: 8px;\r\n  background: ${({ currency, theme: { dark } })=>dark ? DarkBackground[currency] : LightBackground[currency]};\r\n  box-shadow: ${({ theme: { dark } })=>dark ? '0px 5px 20px -5px rgba(0, 0, 0, 0.18)' : 'none'};\r\n  margin-bottom: 2rem;\r\n\r\n  &:hover {\r\n    cursor: pointer;\r\n  }\r\n`;\nconst CurrencyTileHeader = (styled_components__WEBPACK_IMPORTED_MODULE_3___default().div)`\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-bottom: ${gutter};\r\n`;\nconst CurrencyName = (styled_components__WEBPACK_IMPORTED_MODULE_3___default().p)`\r\n  text-align: right;\r\n  font-size: 16px;\r\n  line-height: 18px;\r\n  margin: 0 0 0.1rem 0;\r\n`;\nconst CurrencyPrice = (styled_components__WEBPACK_IMPORTED_MODULE_3___default().p)`\r\n  font-size: 14px;\r\n  text-align: right;\r\n  margin: 0;\r\n`;\nconst CurrencyTileDesc = (styled_components__WEBPACK_IMPORTED_MODULE_3___default().p)`\r\n  margin: 0;\r\n  font-weight: ${({ value })=>value ? 'normal' : '500'};\r\n  font-size: 14px;\r\n  line-height: 27px;\r\n  color: ${({ theme: { dark } })=>dark ? _assets_styles_colors__WEBPACK_IMPORTED_MODULE_10__.White : _assets_styles_colors__WEBPACK_IMPORTED_MODULE_10__.SlateDark};\r\n`;\nconst PositionDiv = styled_components__WEBPACK_IMPORTED_MODULE_3___default()((0,_assets_styles_spinner__WEBPACK_IMPORTED_MODULE_6__.Spinner))`\r\n  min-height: 200px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  ${({ error })=>error && (0,styled_components__WEBPACK_IMPORTED_MODULE_3__.css)`\r\n      color: ${_assets_styles_colors__WEBPACK_IMPORTED_MODULE_10__.Error};\r\n      font-size: 16px;\r\n    `}\r\n`;\nconst ChartContainer = (styled_components__WEBPACK_IMPORTED_MODULE_3___default().div)`\r\n  max-height: 100px;\r\n  margin: 2rem -${gutter};\r\n`;\nconst CurrencyTile = ({ currency })=>{\n    const navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_8__.useNavigate)();\n    const apiRoot = (0,_utilities_helper_methods__WEBPACK_IMPORTED_MODULE_2__.getApiRoot)(currency);\n    const refreshInterval = (0,_utilities_helper_methods__WEBPACK_IMPORTED_MODULE_2__.getDefaultRefreshInterval)(currency);\n    let price;\n    const url = `${apiRoot}/${currency}/mainnet/block?limit=1`;\n    const { data, error } = (0,_api_api__WEBPACK_IMPORTED_MODULE_9__.useApi)(url, {\n        refreshInterval\n    });\n    const { data: priceDetails } = (0,_api_api__WEBPACK_IMPORTED_MODULE_9__.useApi)(`https://bitpay.com/rates/${currency}/usd`);\n    const { data: priceDisplay } = (0,_api_api__WEBPACK_IMPORTED_MODULE_9__.useApi)(`https://bitpay.com/currencies/prices?currencyPairs=[\"${currency}:USD\"]`);\n    if (priceDetails?.data) {\n        const { data: { rate } } = priceDetails;\n        price = rate;\n    }\n    let priceList = [];\n    if (priceDisplay?.data) {\n        priceList = priceDisplay.data[0].priceDisplay;\n    }\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDiv, {\n            currency: currency,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PositionDiv, {\n                error: true,\n                children: \"Error getting latest block\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                lineNumber: 156,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n            lineNumber: 155,\n            columnNumber: 7\n        }, undefined);\n    }\n    if (!data) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDiv, {\n            currency: currency,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PositionDiv, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                    src: _assets_images_large_thin_spinner_svg__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n                    height: 30,\n                    width: 30,\n                    alt: \"spinner\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                    lineNumber: 165,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                lineNumber: 164,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n            lineNumber: 163,\n            columnNumber: 7\n        }, undefined);\n    }\n    const { height, time, transactionCount, size } = data[0];\n    const gotoAllBlocks = async ()=>{\n        await navigate(`/${currency}/mainnet/blocks`);\n    };\n    const imgSrc = `https://bitpay.com/img/icon/currencies/${currency}.svg`;\n    const chartData = {\n        labels: priceList,\n        datasets: [\n            {\n                data: priceList,\n                fill: false,\n                spanGaps: true,\n                borderColor: _utilities_constants__WEBPACK_IMPORTED_MODULE_7__.colorCodes[currency],\n                borderWidth: 2,\n                pointRadius: 0\n            }\n        ]\n    };\n    const options = {\n        scales: {\n            x: {\n                display: false\n            },\n            y: {\n                display: false\n            }\n        },\n        plugins: {\n            legend: {\n                display: false\n            }\n        },\n        events: [],\n        responsive: true,\n        maintainAspectRatio: false,\n        tension: 0.5\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDiv, {\n        currency: currency,\n        onClick: gotoAllBlocks,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileHeader, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                        src: imgSrc,\n                        width: 35,\n                        height: 35,\n                        alt: currency + ' logo'\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 214,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyName, {\n                                children: currency\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                                lineNumber: 216,\n                                columnNumber: 11\n                            }, undefined),\n                            price && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyPrice, {\n                                children: [\n                                    price,\n                                    \" USD\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                                lineNumber: 217,\n                                columnNumber: 21\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 215,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                lineNumber: 213,\n                columnNumber: 7\n            }, undefined),\n            priceList.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChartContainer, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_chartjs_2__WEBPACK_IMPORTED_MODULE_12__.Line, {\n                    data: chartData,\n                    options: options,\n                    \"aria-label\": \"price line chart\",\n                    role: \"img\"\n                }, currency, false, {\n                    fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                    lineNumber: 223,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                lineNumber: 222,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_assets_styles_tile__WEBPACK_IMPORTED_MODULE_4__.Tile, {\n                padding: \"0\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDesc, {\n                        children: \"Height\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 234,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDesc, {\n                        value: true,\n                        children: height\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 235,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                lineNumber: 233,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_assets_styles_tile__WEBPACK_IMPORTED_MODULE_4__.Tile, {\n                padding: \"0\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDesc, {\n                        children: \"Mined\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 239,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDesc, {\n                        value: true,\n                        children: (0,_utilities_helper_methods__WEBPACK_IMPORTED_MODULE_2__.buildTime)(time)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 240,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                lineNumber: 238,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_assets_styles_tile__WEBPACK_IMPORTED_MODULE_4__.Tile, {\n                padding: \"0\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDesc, {\n                        children: \"Transaction\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 244,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDesc, {\n                        value: true,\n                        children: transactionCount\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 245,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                lineNumber: 243,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_assets_styles_tile__WEBPACK_IMPORTED_MODULE_4__.Tile, {\n                padding: \"0\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDesc, {\n                        children: \"Size\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 249,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CurrencyTileDesc, {\n                        value: true,\n                        children: size\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                        lineNumber: 250,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n                lineNumber: 248,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, currency, true, {\n        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\components\\\\currency-tile.tsx\",\n        lineNumber: 212,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(CurrencyTile));\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y2s6Ly9pbnNpZ2h0Ly4vc3JjL2NvbXBvbmVudHMvY3VycmVuY3ktdGlsZS50c3g/NzIzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0ZDLCBtZW1vfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7YnVpbGRUaW1lLCBnZXRBcGlSb290LCBnZXREZWZhdWx0UmVmcmVzaEludGVydmFsfSBmcm9tICcuLi91dGlsaXRpZXMvaGVscGVyLW1ldGhvZHMnO1xyXG5pbXBvcnQgc3R5bGVkLCB7Y3NzfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XHJcbmltcG9ydCB7VGlsZX0gZnJvbSAnLi4vYXNzZXRzL3N0eWxlcy90aWxlJztcclxuaW1wb3J0IExhcmdlVGhpblNwaW5uZXIgZnJvbSAnLi4vYXNzZXRzL2ltYWdlcy9sYXJnZS10aGluLXNwaW5uZXIuc3ZnJztcclxuaW1wb3J0IHtTcGlubmVyfSBmcm9tICcuLi9hc3NldHMvc3R5bGVzL3NwaW5uZXInO1xyXG5cclxuaW1wb3J0IHtjb2xvckNvZGVzfSBmcm9tICcuLi91dGlsaXRpZXMvY29uc3RhbnRzJztcclxuaW1wb3J0IHt1c2VOYXZpZ2F0ZX0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XHJcbmltcG9ydCB7dXNlQXBpfSBmcm9tICcuLi9hcGkvYXBpJztcclxuaW1wb3J0IHtFcnJvciwgU2xhdGVEYXJrLCBXaGl0ZX0gZnJvbSAnLi4vYXNzZXRzL3N0eWxlcy9jb2xvcnMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBDaGFydCBhcyBDaGFydEpTLFxyXG4gIENhdGVnb3J5U2NhbGUsXHJcbiAgTGluZWFyU2NhbGUsXHJcbiAgUG9pbnRFbGVtZW50LFxyXG4gIExpbmVFbGVtZW50LFxyXG4gIFRpdGxlLFxyXG4gIFRvb2x0aXAsXHJcbiAgTGVnZW5kLFxyXG59IGZyb20gJ2NoYXJ0LmpzJ1xyXG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAncmVhY3QtY2hhcnRqcy0yJ1xyXG5cclxuQ2hhcnRKUy5yZWdpc3RlcihcclxuICBDYXRlZ29yeVNjYWxlLFxyXG4gIExpbmVhclNjYWxlLFxyXG4gIFBvaW50RWxlbWVudCxcclxuICBMaW5lRWxlbWVudCxcclxuICBUaXRsZSxcclxuICBUb29sdGlwLFxyXG4gIExlZ2VuZFxyXG4pXHJcblxyXG5jb25zdCBndXR0ZXIgPSAnMS41cmVtJztcclxuXHJcbmNvbnN0IExpZ2h0QmFja2dyb3VuZDoge1trZXkgaW4gc3RyaW5nXTogc3RyaW5nfSA9IHtcclxuICBCVEM6ICcjRkZGMUUwJyxcclxuICBCQ0g6ICcjRUZGRkY2JyxcclxuICBFVEg6ICcjRUJFQ0Y2JyxcclxuICBMVEM6ICcjRkFGQUZBJyxcclxuICBET0dFOiAnI0ZERjhFNicsXHJcbn07XHJcblxyXG5jb25zdCBEYXJrQmFja2dyb3VuZDoge1trZXkgaW4gc3RyaW5nXTogc3RyaW5nfSA9IHtcclxuICBCVEM6ICcjMEMwNzAwJyxcclxuICBCQ0g6ICcjMDIwQTA1JyxcclxuICBFVEg6ICcjMDYwNzBGJyxcclxuICBMVEM6ICcjMEEwQTBBJyxcclxuICBET0dFOiAnIzBCMDkwMycsXHJcbn07XHJcblxyXG5pbnRlcmZhY2UgQ3VycmVuY3lUaWxlRGl2UHJvcHMge1xyXG4gIGN1cnJlbmN5OiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IEN1cnJlbmN5VGlsZURpdiA9IHN0eWxlZC5kaXY8Q3VycmVuY3lUaWxlRGl2UHJvcHM+YFxyXG4gIHBhZGRpbmc6ICR7Z3V0dGVyfTtcclxuICB0ZXh0LWFsaWduOiBsZWZ0O1xyXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcclxuICBiYWNrZ3JvdW5kOiAkeyh7Y3VycmVuY3ksIHRoZW1lOiB7ZGFya319KSA9PlxyXG4gICAgZGFyayA/IERhcmtCYWNrZ3JvdW5kW2N1cnJlbmN5XSA6IExpZ2h0QmFja2dyb3VuZFtjdXJyZW5jeV19O1xyXG4gIGJveC1zaGFkb3c6ICR7KHt0aGVtZToge2Rhcmt9fSkgPT4gKGRhcmsgPyAnMHB4IDVweCAyMHB4IC01cHggcmdiYSgwLCAwLCAwLCAwLjE4KScgOiAnbm9uZScpfTtcclxuICBtYXJnaW4tYm90dG9tOiAycmVtO1xyXG5cclxuICAmOmhvdmVyIHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICB9XHJcbmA7XHJcblxyXG5jb25zdCBDdXJyZW5jeVRpbGVIZWFkZXIgPSBzdHlsZWQuZGl2YFxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgbWFyZ2luLWJvdHRvbTogJHtndXR0ZXJ9O1xyXG5gO1xyXG5cclxuY29uc3QgQ3VycmVuY3lOYW1lID0gc3R5bGVkLnBgXHJcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XHJcbiAgZm9udC1zaXplOiAxNnB4O1xyXG4gIGxpbmUtaGVpZ2h0OiAxOHB4O1xyXG4gIG1hcmdpbjogMCAwIDAuMXJlbSAwO1xyXG5gO1xyXG5cclxuY29uc3QgQ3VycmVuY3lQcmljZSA9IHN0eWxlZC5wYFxyXG4gIGZvbnQtc2l6ZTogMTRweDtcclxuICB0ZXh0LWFsaWduOiByaWdodDtcclxuICBtYXJnaW46IDA7XHJcbmA7XHJcblxyXG5pbnRlcmZhY2UgQ3VycmVuY3lUaWxlRGVzY1Byb3BzIHtcclxuICB2YWx1ZT86IGFueTtcclxufVxyXG5cclxuY29uc3QgQ3VycmVuY3lUaWxlRGVzYyA9IHN0eWxlZC5wPEN1cnJlbmN5VGlsZURlc2NQcm9wcz5gXHJcbiAgbWFyZ2luOiAwO1xyXG4gIGZvbnQtd2VpZ2h0OiAkeyh7dmFsdWV9KSA9PiAodmFsdWUgPyAnbm9ybWFsJyA6ICc1MDAnKX07XHJcbiAgZm9udC1zaXplOiAxNHB4O1xyXG4gIGxpbmUtaGVpZ2h0OiAyN3B4O1xyXG4gIGNvbG9yOiAkeyh7dGhlbWU6IHtkYXJrfX0pID0+IChkYXJrID8gV2hpdGUgOiBTbGF0ZURhcmspfTtcclxuYDtcclxuXHJcbmludGVyZmFjZSBQb3NpdGlvbkRpdlByb3BzIHtcclxuICBlcnJvcj86IGFueTtcclxufVxyXG5cclxuY29uc3QgUG9zaXRpb25EaXYgPSBzdHlsZWQoU3Bpbm5lcik8UG9zaXRpb25EaXZQcm9wcz5gXHJcbiAgbWluLWhlaWdodDogMjAwcHg7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICR7KHtlcnJvcn0pID0+XHJcbiAgICBlcnJvciAmJlxyXG4gICAgY3NzYFxyXG4gICAgICBjb2xvcjogJHtFcnJvcn07XHJcbiAgICAgIGZvbnQtc2l6ZTogMTZweDtcclxuICAgIGB9XHJcbmA7XHJcblxyXG5jb25zdCBDaGFydENvbnRhaW5lciA9IHN0eWxlZC5kaXZgXHJcbiAgbWF4LWhlaWdodDogMTAwcHg7XHJcbiAgbWFyZ2luOiAycmVtIC0ke2d1dHRlcn07XHJcbmA7XHJcblxyXG5pbnRlcmZhY2UgQ3VycmVuY3lUaWxlUHJvcHMge1xyXG4gIGN1cnJlbmN5OiBzdHJpbmc7XHJcbn1cclxuY29uc3QgQ3VycmVuY3lUaWxlOiBGQzxDdXJyZW5jeVRpbGVQcm9wcz4gPSAoe2N1cnJlbmN5fSkgPT4ge1xyXG4gIGNvbnN0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcclxuICBjb25zdCBhcGlSb290ID0gZ2V0QXBpUm9vdChjdXJyZW5jeSk7XHJcbiAgY29uc3QgcmVmcmVzaEludGVydmFsID0gZ2V0RGVmYXVsdFJlZnJlc2hJbnRlcnZhbChjdXJyZW5jeSk7XHJcbiAgbGV0IHByaWNlO1xyXG5cclxuICBjb25zdCB1cmwgPSBgJHthcGlSb290fS8ke2N1cnJlbmN5fS9tYWlubmV0L2Jsb2NrP2xpbWl0PTFgO1xyXG4gIGNvbnN0IHtkYXRhLCBlcnJvcn0gPSB1c2VBcGkodXJsLCB7cmVmcmVzaEludGVydmFsfSk7XHJcbiAgY29uc3Qge2RhdGE6IHByaWNlRGV0YWlsc30gPSB1c2VBcGkoYGh0dHBzOi8vYml0cGF5LmNvbS9yYXRlcy8ke2N1cnJlbmN5fS91c2RgKTtcclxuICBjb25zdCB7ZGF0YTogcHJpY2VEaXNwbGF5fSA9IHVzZUFwaShcclxuICAgIGBodHRwczovL2JpdHBheS5jb20vY3VycmVuY2llcy9wcmljZXM/Y3VycmVuY3lQYWlycz1bXCIke2N1cnJlbmN5fTpVU0RcIl1gLFxyXG4gICk7XHJcblxyXG4gIGlmIChwcmljZURldGFpbHM/LmRhdGEpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgZGF0YToge3JhdGV9LFxyXG4gICAgfSA9IHByaWNlRGV0YWlscztcclxuICAgIHByaWNlID0gcmF0ZTtcclxuICB9XHJcblxyXG4gIGxldCBwcmljZUxpc3Q6IGFueVtdID0gW107XHJcbiAgaWYgKHByaWNlRGlzcGxheT8uZGF0YSkge1xyXG4gICAgcHJpY2VMaXN0ID0gcHJpY2VEaXNwbGF5LmRhdGFbMF0ucHJpY2VEaXNwbGF5O1xyXG4gIH1cclxuXHJcbiAgaWYgKGVycm9yKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8Q3VycmVuY3lUaWxlRGl2IGN1cnJlbmN5PXtjdXJyZW5jeX0+XHJcbiAgICAgICAgPFBvc2l0aW9uRGl2IGVycm9yPkVycm9yIGdldHRpbmcgbGF0ZXN0IGJsb2NrPC9Qb3NpdGlvbkRpdj5cclxuICAgICAgPC9DdXJyZW5jeVRpbGVEaXY+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFkYXRhKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8Q3VycmVuY3lUaWxlRGl2IGN1cnJlbmN5PXtjdXJyZW5jeX0+XHJcbiAgICAgICAgPFBvc2l0aW9uRGl2PlxyXG4gICAgICAgICAgPGltZyBzcmM9e0xhcmdlVGhpblNwaW5uZXJ9IGhlaWdodD17MzB9IHdpZHRoPXszMH0gYWx0PSdzcGlubmVyJyAvPlxyXG4gICAgICAgIDwvUG9zaXRpb25EaXY+XHJcbiAgICAgIDwvQ3VycmVuY3lUaWxlRGl2PlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHtoZWlnaHQsIHRpbWUsIHRyYW5zYWN0aW9uQ291bnQsIHNpemV9ID0gZGF0YVswXTtcclxuICBjb25zdCBnb3RvQWxsQmxvY2tzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgYXdhaXQgbmF2aWdhdGUoYC8ke2N1cnJlbmN5fS9tYWlubmV0L2Jsb2Nrc2ApO1xyXG4gIH07XHJcbiAgY29uc3QgaW1nU3JjID0gYGh0dHBzOi8vYml0cGF5LmNvbS9pbWcvaWNvbi9jdXJyZW5jaWVzLyR7Y3VycmVuY3l9LnN2Z2A7XHJcblxyXG4gIGNvbnN0IGNoYXJ0RGF0YSA9IHtcclxuICAgIGxhYmVsczogcHJpY2VMaXN0LFxyXG4gICAgZGF0YXNldHM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGRhdGE6IHByaWNlTGlzdCxcclxuICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICBzcGFuR2FwczogdHJ1ZSxcclxuICAgICAgICBib3JkZXJDb2xvcjogY29sb3JDb2Rlc1tjdXJyZW5jeV0sXHJcbiAgICAgICAgYm9yZGVyV2lkdGg6IDIsXHJcbiAgICAgICAgcG9pbnRSYWRpdXM6IDAsXHJcbiAgICAgIH0sXHJcbiAgICBdLFxyXG4gIH07XHJcblxyXG4gIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICBzY2FsZXM6IHtcclxuICAgICAgeDoge1xyXG4gICAgICAgIGRpc3BsYXk6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgICB5OiB7XHJcbiAgICAgICAgZGlzcGxheTogZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgcGx1Z2luczoge1xyXG4gICAgICBsZWdlbmQ6IHtcclxuICAgICAgICBkaXNwbGF5OiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBldmVudHM6IFtdLCAvLyBkb24ndCBsaXN0ZW4gZm9yIGFueSBkZWZhdWx0IGV2ZW50cyBsaWtlIG1vdXNlb3ZlciwgY2xpY2ssIGV0Yy5cclxuICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuICAgIHRlbnNpb246IDAuNSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPEN1cnJlbmN5VGlsZURpdiBjdXJyZW5jeT17Y3VycmVuY3l9IG9uQ2xpY2s9e2dvdG9BbGxCbG9ja3N9IGtleT17Y3VycmVuY3l9PlxyXG4gICAgICA8Q3VycmVuY3lUaWxlSGVhZGVyPlxyXG4gICAgICAgIDxpbWcgc3JjPXtpbWdTcmN9IHdpZHRoPXszNX0gaGVpZ2h0PXszNX0gYWx0PXtjdXJyZW5jeSArICcgbG9nbyd9IC8+XHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgIDxDdXJyZW5jeU5hbWU+e2N1cnJlbmN5fTwvQ3VycmVuY3lOYW1lPlxyXG4gICAgICAgICAge3ByaWNlICYmIDxDdXJyZW5jeVByaWNlPntwcmljZX0gVVNEPC9DdXJyZW5jeVByaWNlPn1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9DdXJyZW5jeVRpbGVIZWFkZXI+XHJcblxyXG4gICAgICB7cHJpY2VMaXN0Lmxlbmd0aCA+IDAgJiYgKFxyXG4gICAgICAgIDxDaGFydENvbnRhaW5lcj5cclxuICAgICAgICAgIDxMaW5lXHJcbiAgICAgICAgICAgIGtleT17Y3VycmVuY3l9XHJcbiAgICAgICAgICAgIGRhdGE9e2NoYXJ0RGF0YX1cclxuICAgICAgICAgICAgb3B0aW9ucz17b3B0aW9uc31cclxuICAgICAgICAgICAgYXJpYS1sYWJlbD0ncHJpY2UgbGluZSBjaGFydCdcclxuICAgICAgICAgICAgcm9sZT0naW1nJ1xyXG4gICAgICAgICAgLz5cclxuICAgICAgICA8L0NoYXJ0Q29udGFpbmVyPlxyXG4gICAgICApfVxyXG5cclxuICAgICAgPFRpbGUgcGFkZGluZz0nMCc+XHJcbiAgICAgICAgPEN1cnJlbmN5VGlsZURlc2M+SGVpZ2h0PC9DdXJyZW5jeVRpbGVEZXNjPlxyXG4gICAgICAgIDxDdXJyZW5jeVRpbGVEZXNjIHZhbHVlPntoZWlnaHR9PC9DdXJyZW5jeVRpbGVEZXNjPlxyXG4gICAgICA8L1RpbGU+XHJcblxyXG4gICAgICA8VGlsZSBwYWRkaW5nPScwJz5cclxuICAgICAgICA8Q3VycmVuY3lUaWxlRGVzYz5NaW5lZDwvQ3VycmVuY3lUaWxlRGVzYz5cclxuICAgICAgICA8Q3VycmVuY3lUaWxlRGVzYyB2YWx1ZT57YnVpbGRUaW1lKHRpbWUpfTwvQ3VycmVuY3lUaWxlRGVzYz5cclxuICAgICAgPC9UaWxlPlxyXG5cclxuICAgICAgPFRpbGUgcGFkZGluZz0nMCc+XHJcbiAgICAgICAgPEN1cnJlbmN5VGlsZURlc2M+VHJhbnNhY3Rpb248L0N1cnJlbmN5VGlsZURlc2M+XHJcbiAgICAgICAgPEN1cnJlbmN5VGlsZURlc2MgdmFsdWU+e3RyYW5zYWN0aW9uQ291bnR9PC9DdXJyZW5jeVRpbGVEZXNjPlxyXG4gICAgICA8L1RpbGU+XHJcblxyXG4gICAgICA8VGlsZSBwYWRkaW5nPScwJz5cclxuICAgICAgICA8Q3VycmVuY3lUaWxlRGVzYz5TaXplPC9DdXJyZW5jeVRpbGVEZXNjPlxyXG4gICAgICAgIDxDdXJyZW5jeVRpbGVEZXNjIHZhbHVlPntzaXplfTwvQ3VycmVuY3lUaWxlRGVzYz5cclxuICAgICAgPC9UaWxlPlxyXG4gICAgPC9DdXJyZW5jeVRpbGVEaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG1lbW8oQ3VycmVuY3lUaWxlKTtcclxuIl0sIm5hbWVzIjpbIm1lbW8iLCJidWlsZFRpbWUiLCJnZXRBcGlSb290IiwiZ2V0RGVmYXVsdFJlZnJlc2hJbnRlcnZhbCIsInN0eWxlZCIsImNzcyIsIlRpbGUiLCJMYXJnZVRoaW5TcGlubmVyIiwiU3Bpbm5lciIsImNvbG9yQ29kZXMiLCJ1c2VOYXZpZ2F0ZSIsInVzZUFwaSIsIkVycm9yIiwiU2xhdGVEYXJrIiwiV2hpdGUiLCJDaGFydCIsIkNoYXJ0SlMiLCJDYXRlZ29yeVNjYWxlIiwiTGluZWFyU2NhbGUiLCJQb2ludEVsZW1lbnQiLCJMaW5lRWxlbWVudCIsIlRpdGxlIiwiVG9vbHRpcCIsIkxlZ2VuZCIsIkxpbmUiLCJyZWdpc3RlciIsImd1dHRlciIsIkxpZ2h0QmFja2dyb3VuZCIsIkJUQyIsIkJDSCIsIkVUSCIsIkxUQyIsIkRPR0UiLCJEYXJrQmFja2dyb3VuZCIsIkN1cnJlbmN5VGlsZURpdiIsImRpdiIsImN1cnJlbmN5IiwidGhlbWUiLCJkYXJrIiwiQ3VycmVuY3lUaWxlSGVhZGVyIiwiQ3VycmVuY3lOYW1lIiwicCIsIkN1cnJlbmN5UHJpY2UiLCJDdXJyZW5jeVRpbGVEZXNjIiwidmFsdWUiLCJQb3NpdGlvbkRpdiIsImVycm9yIiwiQ2hhcnRDb250YWluZXIiLCJDdXJyZW5jeVRpbGUiLCJuYXZpZ2F0ZSIsImFwaVJvb3QiLCJyZWZyZXNoSW50ZXJ2YWwiLCJwcmljZSIsInVybCIsImRhdGEiLCJwcmljZURldGFpbHMiLCJwcmljZURpc3BsYXkiLCJyYXRlIiwicHJpY2VMaXN0IiwiaW1nIiwic3JjIiwiaGVpZ2h0Iiwid2lkdGgiLCJhbHQiLCJ0aW1lIiwidHJhbnNhY3Rpb25Db3VudCIsInNpemUiLCJnb3RvQWxsQmxvY2tzIiwiaW1nU3JjIiwiY2hhcnREYXRhIiwibGFiZWxzIiwiZGF0YXNldHMiLCJmaWxsIiwic3BhbkdhcHMiLCJib3JkZXJDb2xvciIsImJvcmRlcldpZHRoIiwicG9pbnRSYWRpdXMiLCJvcHRpb25zIiwic2NhbGVzIiwieCIsImRpc3BsYXkiLCJ5IiwicGx1Z2lucyIsImxlZ2VuZCIsImV2ZW50cyIsInJlc3BvbnNpdmUiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwidGVuc2lvbiIsIm9uQ2xpY2siLCJsZW5ndGgiLCJhcmlhLWxhYmVsIiwicm9sZSIsInBhZGRpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/currency-tile.tsx\n");

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utilities_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/constants */ \"./src/utilities/constants.ts\");\n/* harmony import */ var _assets_styles_titles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../assets/styles/titles */ \"./src/assets/styles/titles.ts\");\n/* harmony import */ var _components_currency_tile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/currency-tile */ \"./src/components/currency-tile.tsx\");\n/* harmony import */ var react_masonry_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-masonry-css */ \"react-masonry-css\");\n/* harmony import */ var react_masonry_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_masonry_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! framer-motion */ \"framer-motion\");\n/* harmony import */ var _utilities_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utilities/animations */ \"./src/utilities/animations.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _utilities_hooks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utilities/hooks */ \"./src/utilities/hooks/index.ts\");\n/* harmony import */ var _store_app_actions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../store/app.actions */ \"./src/store/app.actions.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_assets_styles_titles__WEBPACK_IMPORTED_MODULE_2__, _components_currency_tile__WEBPACK_IMPORTED_MODULE_3__, framer_motion__WEBPACK_IMPORTED_MODULE_5__, _utilities_hooks__WEBPACK_IMPORTED_MODULE_8__, _store_app_actions__WEBPACK_IMPORTED_MODULE_9__]);\n([_assets_styles_titles__WEBPACK_IMPORTED_MODULE_2__, _components_currency_tile__WEBPACK_IMPORTED_MODULE_3__, framer_motion__WEBPACK_IMPORTED_MODULE_5__, _utilities_hooks__WEBPACK_IMPORTED_MODULE_8__, _store_app_actions__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\nconst Home = ()=>{\n    const breakpointColumnsObj = {\n        default: 3,\n        1200: 2,\n        768: 1\n    };\n    const dispatch = (0,_utilities_hooks__WEBPACK_IMPORTED_MODULE_8__.useAppDispatch)();\n    (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(()=>{\n        dispatch((0,_store_app_actions__WEBPACK_IMPORTED_MODULE_9__.changeCurrency)(''));\n        dispatch((0,_store_app_actions__WEBPACK_IMPORTED_MODULE_9__.changeNetwork)(''));\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_5__.motion.div, {\n        variants: _utilities_animations__WEBPACK_IMPORTED_MODULE_6__.routerFadeIn,\n        animate: \"animate\",\n        initial: \"initial\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_assets_styles_titles__WEBPACK_IMPORTED_MODULE_2__.SecondaryTitle, {\n                children: \"Latest Blocks\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\pages\\\\index.tsx\",\n                lineNumber: 27,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_masonry_css__WEBPACK_IMPORTED_MODULE_4___default()), {\n                breakpointCols: breakpointColumnsObj,\n                className: \"currency-masonry-grid\",\n                columnClassName: \"currency-masonry-grid_column\",\n                children: _utilities_constants__WEBPACK_IMPORTED_MODULE_1__.SUPPORTED_CURRENCIES.map((currency)=>{\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_currency_tile__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        currency: currency\n                    }, currency, false, {\n                        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\pages\\\\index.tsx\",\n                        lineNumber: 34,\n                        columnNumber: 18\n                    }, undefined);\n                })\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\pages\\\\index.tsx\",\n                lineNumber: 29,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Gavin\\\\Desktop\\\\Thought Insight Conver\\\\bitcore\\\\packages\\\\insight\\\\src\\\\pages\\\\index.tsx\",\n        lineNumber: 26,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Home);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RDtBQUNMO0FBQ0E7QUFDZjtBQUNIO0FBQ2dCO0FBQ2Q7QUFDVztBQUVpQjtBQUVuRSxNQUFNVyxPQUFpQjtJQUNyQixNQUFNQyx1QkFBdUI7UUFDM0JDLFNBQVM7UUFDVCxNQUFNO1FBQ04sS0FBSztJQUNQO0lBQ0EsTUFBTUMsV0FBV04sZ0VBQWNBO0lBRS9CRCxnREFBU0EsQ0FBQztRQUNSTyxTQUFTTCxrRUFBY0EsQ0FBQztRQUN4QkssU0FBU0osaUVBQWFBLENBQUM7SUFDekIsR0FBRyxFQUFFO0lBRUwscUJBQ0UsOERBQUNOLGlEQUFNQSxDQUFDVyxHQUFHO1FBQUNDLFVBQVVYLCtEQUFZQTtRQUFFWSxTQUFRO1FBQVVDLFNBQVE7OzBCQUM1RCw4REFBQ2pCLGlFQUFjQTswQkFBQzs7Ozs7OzBCQUVoQiw4REFBQ0UsMERBQU9BO2dCQUNOZ0IsZ0JBQWdCUDtnQkFDaEJRLFdBQVU7Z0JBQ1ZDLGlCQUFnQjswQkFDZnJCLHNFQUFvQkEsQ0FBQ3NCLEdBQUcsQ0FBQ0MsQ0FBQUE7b0JBQ3hCLHFCQUFPLDhEQUFDckIsaUVBQVlBO3dCQUFDcUIsVUFBVUE7dUJBQWVBOzs7OztnQkFDaEQ7Ozs7Ozs7Ozs7OztBQUlSO0FBRUEsaUVBQWVaLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnNpZ2h0Ly4vc3JjL3BhZ2VzL2luZGV4LnRzeD8xOWEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U1VQUE9SVEVEX0NVUlJFTkNJRVN9IGZyb20gJy4uL3V0aWxpdGllcy9jb25zdGFudHMnO1xyXG5pbXBvcnQge1NlY29uZGFyeVRpdGxlfSBmcm9tICcuLi9hc3NldHMvc3R5bGVzL3RpdGxlcyc7XHJcbmltcG9ydCBDdXJyZW5jeVRpbGUgZnJvbSAnLi4vY29tcG9uZW50cy9jdXJyZW5jeS10aWxlJztcclxuaW1wb3J0IE1hc29ucnkgZnJvbSAncmVhY3QtbWFzb25yeS1jc3MnO1xyXG5pbXBvcnQge21vdGlvbn0gZnJvbSAnZnJhbWVyLW1vdGlvbic7XHJcbmltcG9ydCB7cm91dGVyRmFkZUlufSBmcm9tICcuLi91dGlsaXRpZXMvYW5pbWF0aW9ucyc7XHJcbmltcG9ydCBSZWFjdCwge3VzZUVmZmVjdH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge3VzZUFwcERpc3BhdGNofSBmcm9tICcuLi91dGlsaXRpZXMvaG9va3MnO1xyXG5cclxuaW1wb3J0IHtjaGFuZ2VDdXJyZW5jeSwgY2hhbmdlTmV0d29ya30gZnJvbSAnLi4vc3RvcmUvYXBwLmFjdGlvbnMnO1xyXG5cclxuY29uc3QgSG9tZTogUmVhY3QuRkMgPSAoKSA9PiB7XHJcbiAgY29uc3QgYnJlYWtwb2ludENvbHVtbnNPYmogPSB7XHJcbiAgICBkZWZhdWx0OiAzLFxyXG4gICAgMTIwMDogMixcclxuICAgIDc2ODogMSxcclxuICB9O1xyXG4gIGNvbnN0IGRpc3BhdGNoID0gdXNlQXBwRGlzcGF0Y2goKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGRpc3BhdGNoKGNoYW5nZUN1cnJlbmN5KCcnKSk7XHJcbiAgICBkaXNwYXRjaChjaGFuZ2VOZXR3b3JrKCcnKSk7XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPG1vdGlvbi5kaXYgdmFyaWFudHM9e3JvdXRlckZhZGVJbn0gYW5pbWF0ZT0nYW5pbWF0ZScgaW5pdGlhbD0naW5pdGlhbCc+XHJcbiAgICAgIDxTZWNvbmRhcnlUaXRsZT5MYXRlc3QgQmxvY2tzPC9TZWNvbmRhcnlUaXRsZT5cclxuXHJcbiAgICAgIDxNYXNvbnJ5XHJcbiAgICAgICAgYnJlYWtwb2ludENvbHM9e2JyZWFrcG9pbnRDb2x1bW5zT2JqfVxyXG4gICAgICAgIGNsYXNzTmFtZT0nY3VycmVuY3ktbWFzb25yeS1ncmlkJ1xyXG4gICAgICAgIGNvbHVtbkNsYXNzTmFtZT0nY3VycmVuY3ktbWFzb25yeS1ncmlkX2NvbHVtbic+XHJcbiAgICAgICAge1NVUFBPUlRFRF9DVVJSRU5DSUVTLm1hcChjdXJyZW5jeSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gPEN1cnJlbmN5VGlsZSBjdXJyZW5jeT17Y3VycmVuY3l9IGtleT17Y3VycmVuY3l9IC8+O1xyXG4gICAgICAgIH0pfVxyXG4gICAgICA8L01hc29ucnk+XHJcbiAgICA8L21vdGlvbi5kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhvbWU7XHJcbiJdLCJuYW1lcyI6WyJTVVBQT1JURURfQ1VSUkVOQ0lFUyIsIlNlY29uZGFyeVRpdGxlIiwiQ3VycmVuY3lUaWxlIiwiTWFzb25yeSIsIm1vdGlvbiIsInJvdXRlckZhZGVJbiIsIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlQXBwRGlzcGF0Y2giLCJjaGFuZ2VDdXJyZW5jeSIsImNoYW5nZU5ldHdvcmsiLCJIb21lIiwiYnJlYWtwb2ludENvbHVtbnNPYmoiLCJkZWZhdWx0IiwiZGlzcGF0Y2giLCJkaXYiLCJ2YXJpYW50cyIsImFuaW1hdGUiLCJpbml0aWFsIiwiYnJlYWtwb2ludENvbHMiLCJjbGFzc05hbWUiLCJjb2x1bW5DbGFzc05hbWUiLCJtYXAiLCJjdXJyZW5jeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n");

/***/ }),

/***/ "./src/store/app.actions.ts":
/*!**********************************!*\
  !*** ./src/store/app.actions.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeCurrency: () => (/* binding */ changeCurrency),\n/* harmony export */   changeNetwork: () => (/* binding */ changeNetwork),\n/* harmony export */   changeTheme: () => (/* binding */ changeTheme)\n/* harmony export */ });\n/* harmony import */ var _app_reducer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.reducer */ \"./src/store/app.reducer.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_app_reducer__WEBPACK_IMPORTED_MODULE_0__]);\n_app_reducer__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nconst { changeTheme, changeNetwork, changeCurrency } = _app_reducer__WEBPACK_IMPORTED_MODULE_0__.appSlice.actions;\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RvcmUvYXBwLmFjdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF1QztBQUVoQyxNQUFNLEVBQUNDLFdBQVcsRUFBRUMsYUFBYSxFQUFFQyxjQUFjLEVBQUMsR0FBR0gsa0RBQVFBLENBQUNJLE9BQU8sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi9zcmMvc3RvcmUvYXBwLmFjdGlvbnMudHM/N2E1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2FwcFNsaWNlfSBmcm9tICcuL2FwcC5yZWR1Y2VyJztcclxuXHJcbmV4cG9ydCBjb25zdCB7Y2hhbmdlVGhlbWUsIGNoYW5nZU5ldHdvcmssIGNoYW5nZUN1cnJlbmN5fSA9IGFwcFNsaWNlLmFjdGlvbnM7XHJcbiJdLCJuYW1lcyI6WyJhcHBTbGljZSIsImNoYW5nZVRoZW1lIiwiY2hhbmdlTmV0d29yayIsImNoYW5nZUN1cnJlbmN5IiwiYWN0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/store/app.actions.ts\n");

/***/ }),

/***/ "./src/store/app.reducer.ts":
/*!**********************************!*\
  !*** ./src/store/app.reducer.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appSlice: () => (/* binding */ appSlice),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"@reduxjs/toolkit\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__]);\n_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\r\n * Define Initial state\r\n */ const getInitialTheme = ()=>{\n    if (false) {}\n    return 'light';\n};\nconst initialState = {\n    loading: false,\n    theme: getInitialTheme(),\n    network: '',\n    currency: ''\n};\n/**\r\n * Reducer and State modifications\r\n */ const appSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: 'app',\n    initialState,\n    reducers: {\n        // Use the PayloadAction type to declare the contents of `action.payload`\n        changeTheme: (state, action)=>{\n            if (false) {}\n            state.theme = action.payload;\n        },\n        changeNetwork: (state, action)=>{\n            state.network = action.payload.toLowerCase();\n        },\n        changeCurrency: (state, action)=>{\n            state.currency = action.payload.toUpperCase();\n        }\n    }\n});\n/**\r\n * Reducer Export\r\n */ /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (appSlice.reducer);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RvcmUvYXBwLnJlZHVjZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTREO0FBWTVEOztDQUVDLEdBQ0QsTUFBTUMsa0JBQWtCO0lBQ3RCLElBQUksS0FBNkIsRUFBRSxFQVFsQztJQUNELE9BQU87QUFDVDtBQUVBLE1BQU1PLGVBQXlCO0lBQzdCQyxTQUFTO0lBQ1RDLE9BQU9UO0lBQ1BVLFNBQVM7SUFDVEMsVUFBVTtBQUNaO0FBRUE7O0NBRUMsR0FDTSxNQUFNQyxXQUFXYiw2REFBV0EsQ0FBQztJQUNsQ2MsTUFBTTtJQUNOTjtJQUNBTyxVQUFVO1FBQ1IseUVBQXlFO1FBQ3pFQyxhQUFhLENBQUNDLE9BQU9DO1lBQ25CLElBQUksS0FBNkIsRUFBRSxFQUVsQztZQUNERCxNQUFNUCxLQUFLLEdBQUdRLE9BQU9FLE9BQU87UUFDOUI7UUFDQUMsZUFBZSxDQUFDSixPQUFPQztZQUNyQkQsTUFBTU4sT0FBTyxHQUFHTyxPQUFPRSxPQUFPLENBQUNFLFdBQVc7UUFDNUM7UUFDQUMsZ0JBQWdCLENBQUNOLE9BQU9DO1lBQ3RCRCxNQUFNTCxRQUFRLEdBQUdNLE9BQU9FLE9BQU8sQ0FBQ0ksV0FBVztRQUM3QztJQUNGO0FBQ0YsR0FBRztBQUVIOztDQUVDLEdBQ0QsaUVBQWVYLFNBQVNZLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi9zcmMvc3RvcmUvYXBwLnJlZHVjZXIudHM/ZjA0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NyZWF0ZVNsaWNlLCBQYXlsb2FkQWN0aW9ufSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgdHlwZXMgZm9yIHRoZSBzdGF0ZVxyXG4gKi9cclxuaW50ZXJmYWNlIEFwcFN0YXRlIHtcclxuICBsb2FkaW5nOiBib29sZWFuO1xyXG4gIHRoZW1lOiBzdHJpbmc7XHJcbiAgY3VycmVuY3k/OiBzdHJpbmc7XHJcbiAgbmV0d29yaz86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmluZSBJbml0aWFsIHN0YXRlXHJcbiAqL1xyXG5jb25zdCBnZXRJbml0aWFsVGhlbWUgPSAoKTogc3RyaW5nID0+IHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGNvbnN0IHN0b3JlZFRoZW1lID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0aGVtZScpO1xyXG4gICAgaWYgKHN0b3JlZFRoZW1lKSB7XHJcbiAgICAgIHJldHVybiBzdG9yZWRUaGVtZTtcclxuICAgIH1cclxuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYT8uKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJykubWF0Y2hlcykge1xyXG4gICAgICByZXR1cm4gJ2RhcmsnO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gJ2xpZ2h0JztcclxufTtcclxuXHJcbmNvbnN0IGluaXRpYWxTdGF0ZTogQXBwU3RhdGUgPSB7XHJcbiAgbG9hZGluZzogZmFsc2UsXHJcbiAgdGhlbWU6IGdldEluaXRpYWxUaGVtZSgpLFxyXG4gIG5ldHdvcms6ICcnLFxyXG4gIGN1cnJlbmN5OiAnJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWR1Y2VyIGFuZCBTdGF0ZSBtb2RpZmljYXRpb25zXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYXBwU2xpY2UgPSBjcmVhdGVTbGljZSh7XHJcbiAgbmFtZTogJ2FwcCcsXHJcbiAgaW5pdGlhbFN0YXRlLFxyXG4gIHJlZHVjZXJzOiB7XHJcbiAgICAvLyBVc2UgdGhlIFBheWxvYWRBY3Rpb24gdHlwZSB0byBkZWNsYXJlIHRoZSBjb250ZW50cyBvZiBgYWN0aW9uLnBheWxvYWRgXHJcbiAgICBjaGFuZ2VUaGVtZTogKHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248J2RhcmsnIHwgJ2xpZ2h0Jz4pID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0aGVtZScsIGFjdGlvbi5wYXlsb2FkKTtcclxuICAgICAgfVxyXG4gICAgICBzdGF0ZS50aGVtZSA9IGFjdGlvbi5wYXlsb2FkO1xyXG4gICAgfSxcclxuICAgIGNoYW5nZU5ldHdvcms6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHN0cmluZz4pID0+IHtcclxuICAgICAgc3RhdGUubmV0d29yayA9IGFjdGlvbi5wYXlsb2FkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9LFxyXG4gICAgY2hhbmdlQ3VycmVuY3k6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHN0cmluZz4pID0+IHtcclxuICAgICAgc3RhdGUuY3VycmVuY3kgPSBhY3Rpb24ucGF5bG9hZC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfSxcclxuICB9LFxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBSZWR1Y2VyIEV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYXBwU2xpY2UucmVkdWNlcjtcclxuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiZ2V0SW5pdGlhbFRoZW1lIiwic3RvcmVkVGhlbWUiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJpbml0aWFsU3RhdGUiLCJsb2FkaW5nIiwidGhlbWUiLCJuZXR3b3JrIiwiY3VycmVuY3kiLCJhcHBTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsImNoYW5nZVRoZW1lIiwic3RhdGUiLCJhY3Rpb24iLCJzZXRJdGVtIiwicGF5bG9hZCIsImNoYW5nZU5ldHdvcmsiLCJ0b0xvd2VyQ2FzZSIsImNoYW5nZUN1cnJlbmN5IiwidG9VcHBlckNhc2UiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/store/app.reducer.ts\n");

/***/ }),

/***/ "./src/utilities/animations.ts":
/*!*************************************!*\
  !*** ./src/utilities/animations.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorExitAnime: () => (/* binding */ ErrorExitAnime),\n/* harmony export */   fadeIn: () => (/* binding */ fadeIn),\n/* harmony export */   fadeInTransition: () => (/* binding */ fadeInTransition),\n/* harmony export */   imageFadeIn: () => (/* binding */ imageFadeIn),\n/* harmony export */   routerFadeIn: () => (/* binding */ routerFadeIn)\n/* harmony export */ });\nconst fadeIn = {\n    animate: {\n        opacity: 1,\n        transition: {\n            bounce: 0,\n            duration: 0.05,\n            ease: 'linear'\n        }\n    },\n    initial: {\n        opacity: 0\n    },\n    exit: {\n        opacity: 0\n    }\n};\nconst fadeInTransition = {\n    initial: {\n        opacity: 0,\n        y: 10\n    },\n    animate: {\n        opacity: 1,\n        y: 0,\n        transition: {\n            bounce: 0,\n            duration: 0.1,\n            ease: 'linear',\n            delay: 0.05\n        }\n    },\n    exit: {\n        opacity: 0,\n        y: 10\n    }\n};\nconst routerFadeIn = {\n    initial: {\n        opacity: 0,\n        y: 10\n    },\n    animate: {\n        opacity: 1,\n        y: 0,\n        transition: {\n            bounce: 0,\n            duration: 0.1,\n            ease: 'linear',\n            delay: 0.01\n        }\n    }\n};\nconst ErrorExitAnime = {\n    exit: {\n        opacity: 0,\n        height: 0,\n        transition: {\n            bounce: 0\n        },\n        duration: 0.01\n    }\n};\nconst imageFadeIn = {\n    animate: {\n        opacity: 1,\n        duration: 0.01\n    },\n    initial: {\n        opacity: 0\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL2FuaW1hdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBTyxNQUFNQSxTQUFTO0lBQ3BCQyxTQUFTO1FBQ1BDLFNBQVM7UUFDVEMsWUFBWTtZQUNWQyxRQUFRO1lBQ1JDLFVBQVU7WUFDVkMsTUFBTTtRQUNSO0lBQ0Y7SUFDQUMsU0FBUztRQUNQTCxTQUFTO0lBQ1g7SUFDQU0sTUFBTTtRQUNKTixTQUFTO0lBQ1g7QUFDRixFQUFFO0FBRUssTUFBTU8sbUJBQW1CO0lBQzlCRixTQUFTO1FBQ1BMLFNBQVM7UUFDVFEsR0FBRztJQUNMO0lBQ0FULFNBQVM7UUFDUEMsU0FBUztRQUNUUSxHQUFHO1FBQ0hQLFlBQVk7WUFDVkMsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZDLE1BQU07WUFDTkssT0FBTztRQUNUO0lBQ0Y7SUFDQUgsTUFBTTtRQUNKTixTQUFTO1FBQ1RRLEdBQUc7SUFDTDtBQUNGLEVBQUU7QUFFSyxNQUFNRSxlQUFlO0lBQzFCTCxTQUFTO1FBQ1BMLFNBQVM7UUFDVFEsR0FBRztJQUNMO0lBQ0FULFNBQVM7UUFDUEMsU0FBUztRQUNUUSxHQUFHO1FBQ0hQLFlBQVk7WUFDVkMsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZDLE1BQU07WUFDTkssT0FBTztRQUNUO0lBQ0Y7QUFDRixFQUFFO0FBRUssTUFBTUUsaUJBQWlCO0lBQzVCTCxNQUFNO1FBQ0pOLFNBQVM7UUFDVFksUUFBUTtRQUNSWCxZQUFZO1lBQUNDLFFBQVE7UUFBQztRQUN0QkMsVUFBVTtJQUNaO0FBQ0YsRUFBRTtBQUVLLE1BQU1VLGNBQWM7SUFDekJkLFNBQVM7UUFDUEMsU0FBUztRQUNURyxVQUFVO0lBQ1o7SUFDQUUsU0FBUztRQUNQTCxTQUFTO0lBQ1g7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uL3NyYy91dGlsaXRpZXMvYW5pbWF0aW9ucy50cz85ZDI5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBmYWRlSW4gPSB7XHJcbiAgYW5pbWF0ZToge1xyXG4gICAgb3BhY2l0eTogMSxcclxuICAgIHRyYW5zaXRpb246IHtcclxuICAgICAgYm91bmNlOiAwLFxyXG4gICAgICBkdXJhdGlvbjogMC4wNSxcclxuICAgICAgZWFzZTogJ2xpbmVhcicsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgaW5pdGlhbDoge1xyXG4gICAgb3BhY2l0eTogMCxcclxuICB9LFxyXG4gIGV4aXQ6IHtcclxuICAgIG9wYWNpdHk6IDAsXHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmYWRlSW5UcmFuc2l0aW9uID0ge1xyXG4gIGluaXRpYWw6IHtcclxuICAgIG9wYWNpdHk6IDAsXHJcbiAgICB5OiAxMCxcclxuICB9LFxyXG4gIGFuaW1hdGU6IHtcclxuICAgIG9wYWNpdHk6IDEsXHJcbiAgICB5OiAwLFxyXG4gICAgdHJhbnNpdGlvbjoge1xyXG4gICAgICBib3VuY2U6IDAsXHJcbiAgICAgIGR1cmF0aW9uOiAwLjEsXHJcbiAgICAgIGVhc2U6ICdsaW5lYXInLFxyXG4gICAgICBkZWxheTogMC4wNSxcclxuICAgIH0sXHJcbiAgfSxcclxuICBleGl0OiB7XHJcbiAgICBvcGFjaXR5OiAwLFxyXG4gICAgeTogMTAsXHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByb3V0ZXJGYWRlSW4gPSB7XHJcbiAgaW5pdGlhbDoge1xyXG4gICAgb3BhY2l0eTogMCxcclxuICAgIHk6IDEwLFxyXG4gIH0sXHJcbiAgYW5pbWF0ZToge1xyXG4gICAgb3BhY2l0eTogMSxcclxuICAgIHk6IDAsXHJcbiAgICB0cmFuc2l0aW9uOiB7XHJcbiAgICAgIGJvdW5jZTogMCxcclxuICAgICAgZHVyYXRpb246IDAuMSxcclxuICAgICAgZWFzZTogJ2xpbmVhcicsXHJcbiAgICAgIGRlbGF5OiAwLjAxLFxyXG4gICAgfSxcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEVycm9yRXhpdEFuaW1lID0ge1xyXG4gIGV4aXQ6IHtcclxuICAgIG9wYWNpdHk6IDAsXHJcbiAgICBoZWlnaHQ6IDAsXHJcbiAgICB0cmFuc2l0aW9uOiB7Ym91bmNlOiAwfSxcclxuICAgIGR1cmF0aW9uOiAwLjAxLFxyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW1hZ2VGYWRlSW4gPSB7XHJcbiAgYW5pbWF0ZToge1xyXG4gICAgb3BhY2l0eTogMSxcclxuICAgIGR1cmF0aW9uOiAwLjAxLFxyXG4gIH0sXHJcbiAgaW5pdGlhbDoge1xyXG4gICAgb3BhY2l0eTogMCxcclxuICB9LFxyXG59O1xyXG4iXSwibmFtZXMiOlsiZmFkZUluIiwiYW5pbWF0ZSIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9uIiwiYm91bmNlIiwiZHVyYXRpb24iLCJlYXNlIiwiaW5pdGlhbCIsImV4aXQiLCJmYWRlSW5UcmFuc2l0aW9uIiwieSIsImRlbGF5Iiwicm91dGVyRmFkZUluIiwiRXJyb3JFeGl0QW5pbWUiLCJoZWlnaHQiLCJpbWFnZUZhZGVJbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utilities/animations.ts\n");

/***/ }),

/***/ "./src/utilities/constants.ts":
/*!************************************!*\
  !*** ./src/utilities/constants.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_ROOT: () => (/* binding */ API_ROOT),\n/* harmony export */   API_ROOT_ETH: () => (/* binding */ API_ROOT_ETH),\n/* harmony export */   COIN: () => (/* binding */ COIN),\n/* harmony export */   DEFAULT_RBF_SEQ_NUMBER: () => (/* binding */ DEFAULT_RBF_SEQ_NUMBER),\n/* harmony export */   ETH_DEFAULT_REFRESH_INTERVAL: () => (/* binding */ ETH_DEFAULT_REFRESH_INTERVAL),\n/* harmony export */   SUPPORTED_CURRENCIES: () => (/* binding */ SUPPORTED_CURRENCIES),\n/* harmony export */   UTXO_DEFAULT_REFRESH_INTERVAL: () => (/* binding */ UTXO_DEFAULT_REFRESH_INTERVAL),\n/* harmony export */   colorCodes: () => (/* binding */ colorCodes),\n/* harmony export */   device: () => (/* binding */ device),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\nconst SUPPORTED_CURRENCIES = [\n    'BTC',\n    'BCH',\n    'ETH'\n];\n// export const SUPPORTED_CURRENCIES = ['THT', 'tTHT'];\nconst API_ROOT = 'https://api.bitcore.io/api';\nconst API_ROOT_ETH = 'https://api-eth.bitcore.io/api';\nconst ETH_DEFAULT_REFRESH_INTERVAL = 300000;\nconst UTXO_DEFAULT_REFRESH_INTERVAL = 600000;\nconst COIN = 100000000;\nconst DEFAULT_RBF_SEQ_NUMBER = 0xffffffff;\nconst colorCodes = {\n    BTC: '#F7931A',\n    BCH: '#2FCF6E',\n    ETH: '#6B71D6',\n    LTC: '#868686',\n    DOGE: '#B29832',\n    THT: '#2222FF'\n};\n// Media breakpoints\nconst size = {\n    mobileS: '320px',\n    mobileM: '375px',\n    mobileL: '425px',\n    tablet: '768px',\n    laptop: '1024px',\n    laptopL: '1440px',\n    desktop: '2560px'\n};\nconst device = {\n    mobileS: `(min-width: ${size.mobileS})`,\n    mobileM: `(min-width: ${size.mobileM})`,\n    mobileL: `(min-width: ${size.mobileL})`,\n    tablet: `(min-width: ${size.tablet})`,\n    laptop: `(min-width: ${size.laptop})`,\n    laptopL: `(min-width: ${size.laptopL})`,\n    desktop: `(min-width: ${size.desktop})`,\n    desktopL: `(min-width: ${size.desktop})`\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL2NvbnN0YW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQU8sTUFBTUEsdUJBQXVCO0lBQUM7SUFBTztJQUFPO0NBQU0sQ0FBQztBQUMxRCx1REFBdUQ7QUFDaEQsTUFBTUMsV0FBVyw2QkFBNkI7QUFDOUMsTUFBTUMsZUFBZSxpQ0FBaUM7QUFDdEQsTUFBTUMsK0JBQStCLE9BQU87QUFDNUMsTUFBTUMsZ0NBQWdDLE9BQU87QUFDN0MsTUFBTUMsT0FBTyxVQUFVO0FBQ3ZCLE1BQU1DLHlCQUF5QixXQUFXO0FBRTFDLE1BQU1DLGFBQWtCO0lBQzdCQyxLQUFLO0lBQ0xDLEtBQUs7SUFDTEMsS0FBSztJQUNMQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsS0FBSztBQUNQLEVBQUU7QUFFRixvQkFBb0I7QUFDYixNQUFNQyxPQUFPO0lBQ2xCQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxTQUFTO0FBQ1gsRUFBRTtBQUVLLE1BQU1DLFNBQVM7SUFDcEJQLFNBQVMsQ0FBQyxZQUFZLEVBQUVELEtBQUtDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkNDLFNBQVMsQ0FBQyxZQUFZLEVBQUVGLEtBQUtFLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkNDLFNBQVMsQ0FBQyxZQUFZLEVBQUVILEtBQUtHLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkNDLFFBQVEsQ0FBQyxZQUFZLEVBQUVKLEtBQUtJLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDckNDLFFBQVEsQ0FBQyxZQUFZLEVBQUVMLEtBQUtLLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDckNDLFNBQVMsQ0FBQyxZQUFZLEVBQUVOLEtBQUtNLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkNDLFNBQVMsQ0FBQyxZQUFZLEVBQUVQLEtBQUtPLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkNFLFVBQVUsQ0FBQyxZQUFZLEVBQUVULEtBQUtPLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDMUMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi9zcmMvdXRpbGl0aWVzL2NvbnN0YW50cy50cz9iYjMyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBTVVBQT1JURURfQ1VSUkVOQ0lFUyA9IFsnQlRDJywgJ0JDSCcsICdFVEgnXTtcclxuLy8gZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9DVVJSRU5DSUVTID0gWydUSFQnLCAndFRIVCddO1xyXG5leHBvcnQgY29uc3QgQVBJX1JPT1QgPSAnaHR0cHM6Ly9hcGkuYml0Y29yZS5pby9hcGknO1xyXG5leHBvcnQgY29uc3QgQVBJX1JPT1RfRVRIID0gJ2h0dHBzOi8vYXBpLWV0aC5iaXRjb3JlLmlvL2FwaSc7XHJcbmV4cG9ydCBjb25zdCBFVEhfREVGQVVMVF9SRUZSRVNIX0lOVEVSVkFMID0gMzAwMDAwO1xyXG5leHBvcnQgY29uc3QgVVRYT19ERUZBVUxUX1JFRlJFU0hfSU5URVJWQUwgPSA2MDAwMDA7XHJcbmV4cG9ydCBjb25zdCBDT0lOID0gMTAwMDAwMDAwO1xyXG5leHBvcnQgY29uc3QgREVGQVVMVF9SQkZfU0VRX05VTUJFUiA9IDB4ZmZmZmZmZmY7XHJcblxyXG5leHBvcnQgY29uc3QgY29sb3JDb2RlczogYW55ID0ge1xyXG4gIEJUQzogJyNGNzkzMUEnLFxyXG4gIEJDSDogJyMyRkNGNkUnLFxyXG4gIEVUSDogJyM2QjcxRDYnLFxyXG4gIExUQzogJyM4Njg2ODYnLFxyXG4gIERPR0U6ICcjQjI5ODMyJyxcclxuICBUSFQ6ICcjMjIyMkZGJ1xyXG59O1xyXG5cclxuLy8gTWVkaWEgYnJlYWtwb2ludHNcclxuZXhwb3J0IGNvbnN0IHNpemUgPSB7XHJcbiAgbW9iaWxlUzogJzMyMHB4JyxcclxuICBtb2JpbGVNOiAnMzc1cHgnLFxyXG4gIG1vYmlsZUw6ICc0MjVweCcsXHJcbiAgdGFibGV0OiAnNzY4cHgnLFxyXG4gIGxhcHRvcDogJzEwMjRweCcsXHJcbiAgbGFwdG9wTDogJzE0NDBweCcsXHJcbiAgZGVza3RvcDogJzI1NjBweCcsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGV2aWNlID0ge1xyXG4gIG1vYmlsZVM6IGAobWluLXdpZHRoOiAke3NpemUubW9iaWxlU30pYCxcclxuICBtb2JpbGVNOiBgKG1pbi13aWR0aDogJHtzaXplLm1vYmlsZU19KWAsXHJcbiAgbW9iaWxlTDogYChtaW4td2lkdGg6ICR7c2l6ZS5tb2JpbGVMfSlgLFxyXG4gIHRhYmxldDogYChtaW4td2lkdGg6ICR7c2l6ZS50YWJsZXR9KWAsXHJcbiAgbGFwdG9wOiBgKG1pbi13aWR0aDogJHtzaXplLmxhcHRvcH0pYCxcclxuICBsYXB0b3BMOiBgKG1pbi13aWR0aDogJHtzaXplLmxhcHRvcEx9KWAsXHJcbiAgZGVza3RvcDogYChtaW4td2lkdGg6ICR7c2l6ZS5kZXNrdG9wfSlgLFxyXG4gIGRlc2t0b3BMOiBgKG1pbi13aWR0aDogJHtzaXplLmRlc2t0b3B9KWAsXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJTVVBQT1JURURfQ1VSUkVOQ0lFUyIsIkFQSV9ST09UIiwiQVBJX1JPT1RfRVRIIiwiRVRIX0RFRkFVTFRfUkVGUkVTSF9JTlRFUlZBTCIsIlVUWE9fREVGQVVMVF9SRUZSRVNIX0lOVEVSVkFMIiwiQ09JTiIsIkRFRkFVTFRfUkJGX1NFUV9OVU1CRVIiLCJjb2xvckNvZGVzIiwiQlRDIiwiQkNIIiwiRVRIIiwiTFRDIiwiRE9HRSIsIlRIVCIsInNpemUiLCJtb2JpbGVTIiwibW9iaWxlTSIsIm1vYmlsZUwiLCJ0YWJsZXQiLCJsYXB0b3AiLCJsYXB0b3BMIiwiZGVza3RvcCIsImRldmljZSIsImRlc2t0b3BMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/constants.ts\n");

/***/ }),

/***/ "./src/utilities/helper-methods.ts":
/*!*****************************************!*\
  !*** ./src/utilities/helper-methods.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aggregateItems: () => (/* binding */ aggregateItems),\n/* harmony export */   buildTime: () => (/* binding */ buildTime),\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getApiRoot: () => (/* binding */ getApiRoot),\n/* harmony export */   getConvertedValue: () => (/* binding */ getConvertedValue),\n/* harmony export */   getDefaultRefreshInterval: () => (/* binding */ getDefaultRefreshInterval),\n/* harmony export */   getFee: () => (/* binding */ getFee),\n/* harmony export */   getFormattedDate: () => (/* binding */ getFormattedDate),\n/* harmony export */   getLib: () => (/* binding */ getLib),\n/* harmony export */   hasUnconfirmedInputs: () => (/* binding */ hasUnconfirmedInputs),\n/* harmony export */   isRBF: () => (/* binding */ isRBF),\n/* harmony export */   normalizeParams: () => (/* binding */ normalizeParams),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   urlSafetyCheck: () => (/* binding */ urlSafetyCheck)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/utilities/constants.ts\");\n/* harmony import */ var bitcore_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bitcore-lib */ \"../bitcore-lib/index.js\");\n/* harmony import */ var bitcore_lib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bitcore_lib__WEBPACK_IMPORTED_MODULE_1__);\n\n\n// import BitcoreLibCash from 'bitcore-lib-cash';\n// import BitcoreLibDoge from 'bitcore-lib-doge';\n// import BitcoreLibLtc from 'bitcore-lib-ltc';\nconst buildTime = (time)=>{\n    const diffMs = Math.abs(Date.now() - Date.parse(time));\n    const minutes = Math.floor(diffMs / 1000 / 60);\n    if (minutes === 0) {\n        return 'a few seconds';\n    }\n    if (minutes < 2) {\n        return 'a minute';\n    }\n    return minutes + ' minutes';\n};\nconst getApiRoot = (currency)=>[\n        'ETH'\n    ].includes(currency) ? _constants__WEBPACK_IMPORTED_MODULE_0__.API_ROOT_ETH : _constants__WEBPACK_IMPORTED_MODULE_0__.API_ROOT;\nconst getDefaultRefreshInterval = (currency)=>[\n        'ETH'\n    ].includes(currency) ? _constants__WEBPACK_IMPORTED_MODULE_0__.ETH_DEFAULT_REFRESH_INTERVAL : _constants__WEBPACK_IMPORTED_MODULE_0__.UTXO_DEFAULT_REFRESH_INTERVAL;\nconst urlSafetyCheck = (url)=>url.includes('undefined') ? null : url;\nconst aggregateItems = (items)=>{\n    if (!items) {\n        return [];\n    }\n    const l = items.length;\n    const ret = [];\n    const tmp = {};\n    let u = 0;\n    for(let i = 0; i < l; i++){\n        let notAddr = false;\n        // non standard input\n        if (items[i].scriptSig && !items[i].address) {\n            items[i].address = 'Unparsed address [' + u++ + ']';\n            items[i].notAddr = true;\n            notAddr = true;\n        }\n        // non standard output\n        if (items[i].scriptPubKey && !items[i].scriptPubKey.addresses) {\n            items[i].scriptPubKey.addresses = [\n                'Unparsed address [' + u++ + ']'\n            ];\n            items[i].notAddr = true;\n            notAddr = true;\n        }\n        // multiple addr at output\n        if (items[i].scriptPubKey && items[i].scriptPubKey.addresses.length > 1) {\n            items[i].address = items[i].scriptPubKey.addresses.join(',');\n            ret.push(items[i]);\n            continue;\n        }\n        const address = items[i].address || items[i].scriptPubKey && items[i].scriptPubKey.addresses[0];\n        if (!tmp[address]) {\n            tmp[address] = {};\n            tmp[address].valueSat = 0;\n            tmp[address].count = 0;\n            tmp[address].address = address;\n            tmp[address].items = [];\n        }\n        tmp[address].isSpent = items[i].spentTxId;\n        items[i].uiConfirmations = items[i].spentHeight - items[i].mintHeight;\n        tmp[address].doubleSpentTxID = tmp[address].doubleSpentTxID || items[i].doubleSpentTxID;\n        tmp[address].doubleSpentIndex = tmp[address].doubleSpentIndex || items[i].doubleSpentIndex;\n        tmp[address].dbError = tmp[address].dbError || items[i].dbError;\n        tmp[address].valueSat += Math.round(items[i].value * _constants__WEBPACK_IMPORTED_MODULE_0__.COIN);\n        tmp[address].items.push(items[i]);\n        tmp[address].notAddr = notAddr;\n        if (items[i].unconfirmedInput) {\n            tmp[address].unconfirmedInput = true;\n        }\n        tmp[address].count++;\n    }\n    for (const v of Object.keys(tmp)){\n        const obj = tmp[v];\n        obj.value = obj.value || parseInt(obj.valueSat, 10) / _constants__WEBPACK_IMPORTED_MODULE_0__.COIN;\n        ret.push(obj);\n    }\n    return ret;\n};\nconst getFee = (tx)=>{\n    const sumSatoshis = (arr)=>arr.reduce((prev, cur)=>prev + cur.value, 0);\n    const inputs = sumSatoshis(tx.inputs);\n    const outputs = sumSatoshis(tx.outputs);\n    return tx.isCoinBase ? 0 : inputs - outputs;\n};\nconst getAddress = (v)=>{\n    if (v.address === 'false') {\n        return 'Unparsed address';\n    }\n    return v.address;\n};\nconst isRBF = (inputs)=>{\n    return inputs.some((input)=>input.sequenceNumber && input.sequenceNumber < _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_RBF_SEQ_NUMBER - 1);\n};\nconst hasUnconfirmedInputs = (inputs)=>{\n    return inputs.some((input)=>input.mintHeight < 0);\n};\nconst getFormattedDate = (dateStr)=>{\n    if (!dateStr) {\n        return;\n    }\n    const date = new Date(dateStr);\n    return date.toLocaleString();\n};\nconst getConvertedValue = (value, chain)=>{\n    switch(chain){\n        case 'ETH':\n            value = (value * 1e-18).toFixed(18);\n            value = Math.round(value * Math.pow(10, 8)) / Math.pow(10, 8);\n            break;\n        default:\n            value = (value * 1e-8).toFixed(8);\n            value = Math.round(value * Math.pow(10, 8)) / Math.pow(10, 8);\n            break;\n    }\n    if (value === 0.0) {\n        value = 0;\n    }\n    return value;\n};\nfunction sleep(duration) {\n    return new Promise((resolve)=>window.setTimeout(resolve, duration));\n}\nconst normalizeParams = (currency, network)=>{\n    return {\n        currency: currency.toUpperCase(),\n        network: network.toLowerCase()\n    };\n};\nconst getLib = (currency)=>{\n    switch(currency.toUpperCase()){\n        case 'BTC':\n        default:\n            return (bitcore_lib__WEBPACK_IMPORTED_MODULE_1___default());\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixPQUFPQyxLQUFLQyxjQUFjO0FBQzVCLEVBQUU7QUFFSyxNQUFNQyxvQkFBb0IsQ0FBQzNCLE9BQVk0QjtJQUM1QyxPQUFRQTtRQUNOLEtBQUs7WUFDSDVCLFFBQVEsQ0FBQ0EsUUFBUSxLQUFJLEVBQUc2QixPQUFPLENBQUM7WUFDaEM3QixRQUFRdkMsS0FBS3NDLEtBQUssQ0FBQ0MsUUFBUXZDLEtBQUtxRSxHQUFHLENBQUMsSUFBSSxNQUFNckUsS0FBS3FFLEdBQUcsQ0FBQyxJQUFJO1lBQzNEO1FBQ0Y7WUFDRTlCLFFBQVEsQ0FBQ0EsUUFBUSxJQUFHLEVBQUc2QixPQUFPLENBQUM7WUFDL0I3QixRQUFRdkMsS0FBS3NDLEtBQUssQ0FBQ0MsUUFBUXZDLEtBQUtxRSxHQUFHLENBQUMsSUFBSSxNQUFNckUsS0FBS3FFLEdBQUcsQ0FBQyxJQUFJO1lBQzNEO0lBQ0o7SUFFQSxJQUFJOUIsVUFBVSxLQUFLO1FBQ2pCQSxRQUFRO0lBQ1Y7SUFFQSxPQUFPQTtBQUNULEVBQUU7QUFFSyxTQUFTK0IsTUFBTUMsUUFBZ0I7SUFDcEMsT0FBTyxJQUFJQyxRQUFjQyxDQUFBQSxVQUFXQyxPQUFPQyxVQUFVLENBQUNGLFNBQVNGO0FBQ2pFO0FBRU8sTUFBTUssa0JBQWtCLENBQzdCcEUsVUFDQXFFO0lBRUEsT0FBTztRQUFDckUsVUFBVUEsU0FBU3NFLFdBQVc7UUFBSUQsU0FBU0EsUUFBUUUsV0FBVztJQUFFO0FBQzFFLEVBQUU7QUFFSyxNQUFNQyxTQUFTLENBQUN4RTtJQUNyQixPQUFRQSxTQUFTc0UsV0FBVztRQUMxQixLQUFLO1FBQ0w7WUFDRSxPQUFPbEYsb0RBQVVBO0lBT3JCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc2lnaHQvLi9zcmMvdXRpbGl0aWVzL2hlbHBlci1tZXRob2RzLnRzP2NiYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBBUElfUk9PVCxcclxuICBBUElfUk9PVF9FVEgsXHJcbiAgQ09JTixcclxuICBERUZBVUxUX1JCRl9TRVFfTlVNQkVSLFxyXG4gIEVUSF9ERUZBVUxUX1JFRlJFU0hfSU5URVJWQUwsXHJcbiAgVVRYT19ERUZBVUxUX1JFRlJFU0hfSU5URVJWQUwsXHJcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQge0Jsb2NrVHJhbnNhY3Rpb25EZXRhaWxzfSBmcm9tICcuL21vZGVscyc7XHJcbmltcG9ydCBCaXRjb3JlTGliIGZyb20gJ2JpdGNvcmUtbGliJztcclxuLy8gaW1wb3J0IEJpdGNvcmVMaWJDYXNoIGZyb20gJ2JpdGNvcmUtbGliLWNhc2gnO1xyXG4vLyBpbXBvcnQgQml0Y29yZUxpYkRvZ2UgZnJvbSAnYml0Y29yZS1saWItZG9nZSc7XHJcbi8vIGltcG9ydCBCaXRjb3JlTGliTHRjIGZyb20gJ2JpdGNvcmUtbGliLWx0Yyc7XHJcblxyXG5leHBvcnQgY29uc3QgYnVpbGRUaW1lID0gKHRpbWU6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgZGlmZk1zID0gTWF0aC5hYnMoRGF0ZS5ub3coKSAtIERhdGUucGFyc2UodGltZSkpO1xyXG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKGRpZmZNcyAvIDEwMDAgLyA2MCk7XHJcblxyXG4gIGlmIChtaW51dGVzID09PSAwKSB7XHJcbiAgICByZXR1cm4gJ2EgZmV3IHNlY29uZHMnO1xyXG4gIH1cclxuXHJcbiAgaWYgKG1pbnV0ZXMgPCAyKSB7XHJcbiAgICByZXR1cm4gJ2EgbWludXRlJztcclxuICB9XHJcblxyXG4gIHJldHVybiBtaW51dGVzICsgJyBtaW51dGVzJztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRBcGlSb290ID0gKGN1cnJlbmN5OiBzdHJpbmcpOiBzdHJpbmcgPT5cclxuICBbJ0VUSCddLmluY2x1ZGVzKGN1cnJlbmN5KSA/IEFQSV9ST09UX0VUSCA6IEFQSV9ST09UO1xyXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdFJlZnJlc2hJbnRlcnZhbCA9IChjdXJyZW5jeTogc3RyaW5nKTogbnVtYmVyID0+XHJcbiAgWydFVEgnXS5pbmNsdWRlcyhjdXJyZW5jeSkgPyBFVEhfREVGQVVMVF9SRUZSRVNIX0lOVEVSVkFMIDogVVRYT19ERUZBVUxUX1JFRlJFU0hfSU5URVJWQUw7XHJcbmV4cG9ydCBjb25zdCB1cmxTYWZldHlDaGVjayA9ICh1cmw6IHN0cmluZykgPT4gKHVybC5pbmNsdWRlcygndW5kZWZpbmVkJykgPyBudWxsIDogdXJsKTtcclxuXHJcbmV4cG9ydCBjb25zdCBhZ2dyZWdhdGVJdGVtcyA9IChpdGVtczogYW55W10pOiBhbnlbXSA9PiB7XHJcbiAgaWYgKCFpdGVtcykge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbDogbnVtYmVyID0gaXRlbXMubGVuZ3RoO1xyXG5cclxuICBjb25zdCByZXQ6IGFueVtdID0gW107XHJcbiAgY29uc3QgdG1wOiBhbnkgPSB7fTtcclxuICBsZXQgdSA9IDA7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBsZXQgbm90QWRkciA9IGZhbHNlO1xyXG4gICAgLy8gbm9uIHN0YW5kYXJkIGlucHV0XHJcbiAgICBpZiAoaXRlbXNbaV0uc2NyaXB0U2lnICYmICFpdGVtc1tpXS5hZGRyZXNzKSB7XHJcbiAgICAgIGl0ZW1zW2ldLmFkZHJlc3MgPSAnVW5wYXJzZWQgYWRkcmVzcyBbJyArIHUrKyArICddJztcclxuICAgICAgaXRlbXNbaV0ubm90QWRkciA9IHRydWU7XHJcbiAgICAgIG5vdEFkZHIgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG5vbiBzdGFuZGFyZCBvdXRwdXRcclxuICAgIGlmIChpdGVtc1tpXS5zY3JpcHRQdWJLZXkgJiYgIWl0ZW1zW2ldLnNjcmlwdFB1YktleS5hZGRyZXNzZXMpIHtcclxuICAgICAgaXRlbXNbaV0uc2NyaXB0UHViS2V5LmFkZHJlc3NlcyA9IFsnVW5wYXJzZWQgYWRkcmVzcyBbJyArIHUrKyArICddJ107XHJcbiAgICAgIGl0ZW1zW2ldLm5vdEFkZHIgPSB0cnVlO1xyXG4gICAgICBub3RBZGRyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtdWx0aXBsZSBhZGRyIGF0IG91dHB1dFxyXG4gICAgaWYgKGl0ZW1zW2ldLnNjcmlwdFB1YktleSAmJiBpdGVtc1tpXS5zY3JpcHRQdWJLZXkuYWRkcmVzc2VzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgaXRlbXNbaV0uYWRkcmVzcyA9IGl0ZW1zW2ldLnNjcmlwdFB1YktleS5hZGRyZXNzZXMuam9pbignLCcpO1xyXG4gICAgICByZXQucHVzaChpdGVtc1tpXSk7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZHJlc3M6IHN0cmluZyA9XHJcbiAgICAgIGl0ZW1zW2ldLmFkZHJlc3MgfHwgKGl0ZW1zW2ldLnNjcmlwdFB1YktleSAmJiBpdGVtc1tpXS5zY3JpcHRQdWJLZXkuYWRkcmVzc2VzWzBdKTtcclxuXHJcbiAgICBpZiAoIXRtcFthZGRyZXNzXSkge1xyXG4gICAgICB0bXBbYWRkcmVzc10gPSB7fTtcclxuICAgICAgdG1wW2FkZHJlc3NdLnZhbHVlU2F0ID0gMDtcclxuICAgICAgdG1wW2FkZHJlc3NdLmNvdW50ID0gMDtcclxuICAgICAgdG1wW2FkZHJlc3NdLmFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgICB0bXBbYWRkcmVzc10uaXRlbXMgPSBbXTtcclxuICAgIH1cclxuICAgIHRtcFthZGRyZXNzXS5pc1NwZW50ID0gaXRlbXNbaV0uc3BlbnRUeElkO1xyXG5cclxuICAgIGl0ZW1zW2ldLnVpQ29uZmlybWF0aW9ucyA9IGl0ZW1zW2ldLnNwZW50SGVpZ2h0IC0gaXRlbXNbaV0ubWludEhlaWdodDtcclxuXHJcbiAgICB0bXBbYWRkcmVzc10uZG91YmxlU3BlbnRUeElEID0gdG1wW2FkZHJlc3NdLmRvdWJsZVNwZW50VHhJRCB8fCBpdGVtc1tpXS5kb3VibGVTcGVudFR4SUQ7XHJcbiAgICB0bXBbYWRkcmVzc10uZG91YmxlU3BlbnRJbmRleCA9IHRtcFthZGRyZXNzXS5kb3VibGVTcGVudEluZGV4IHx8IGl0ZW1zW2ldLmRvdWJsZVNwZW50SW5kZXg7XHJcbiAgICB0bXBbYWRkcmVzc10uZGJFcnJvciA9IHRtcFthZGRyZXNzXS5kYkVycm9yIHx8IGl0ZW1zW2ldLmRiRXJyb3I7XHJcbiAgICB0bXBbYWRkcmVzc10udmFsdWVTYXQgKz0gTWF0aC5yb3VuZChpdGVtc1tpXS52YWx1ZSAqIENPSU4pO1xyXG4gICAgdG1wW2FkZHJlc3NdLml0ZW1zLnB1c2goaXRlbXNbaV0pO1xyXG4gICAgdG1wW2FkZHJlc3NdLm5vdEFkZHIgPSBub3RBZGRyO1xyXG5cclxuICAgIGlmIChpdGVtc1tpXS51bmNvbmZpcm1lZElucHV0KSB7XHJcbiAgICAgIHRtcFthZGRyZXNzXS51bmNvbmZpcm1lZElucHV0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0bXBbYWRkcmVzc10uY291bnQrKztcclxuICB9XHJcblxyXG4gIGZvciAoY29uc3QgdiBvZiBPYmplY3Qua2V5cyh0bXApKSB7XHJcbiAgICBjb25zdCBvYmo6IGFueSA9IHRtcFt2XTtcclxuICAgIG9iai52YWx1ZSA9IG9iai52YWx1ZSB8fCBwYXJzZUludChvYmoudmFsdWVTYXQsIDEwKSAvIENPSU47XHJcbiAgICByZXQucHVzaChvYmopO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRGZWUgPSAodHg6IEJsb2NrVHJhbnNhY3Rpb25EZXRhaWxzKTogbnVtYmVyID0+IHtcclxuICBjb25zdCBzdW1TYXRvc2hpczogYW55ID0gKGFycjogYW55KTogbnVtYmVyID0+XHJcbiAgICBhcnIucmVkdWNlKChwcmV2OiBhbnksIGN1cjogYW55KSA9PiBwcmV2ICsgY3VyLnZhbHVlLCAwKTtcclxuICBjb25zdCBpbnB1dHM6IG51bWJlciA9IHN1bVNhdG9zaGlzKHR4LmlucHV0cyk7XHJcbiAgY29uc3Qgb3V0cHV0czogbnVtYmVyID0gc3VtU2F0b3NoaXModHgub3V0cHV0cyk7XHJcbiAgcmV0dXJuIHR4LmlzQ29pbkJhc2UgPyAwIDogaW5wdXRzIC0gb3V0cHV0cztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRBZGRyZXNzID0gKHY6IGFueSk6IHN0cmluZyA9PiB7XHJcbiAgaWYgKHYuYWRkcmVzcyA9PT0gJ2ZhbHNlJykge1xyXG4gICAgcmV0dXJuICdVbnBhcnNlZCBhZGRyZXNzJztcclxuICB9XHJcblxyXG4gIHJldHVybiB2LmFkZHJlc3M7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaXNSQkYgPSAoaW5wdXRzOiBhbnkpOiBib29sZWFuID0+IHtcclxuICByZXR1cm4gaW5wdXRzLnNvbWUoXHJcbiAgICAoaW5wdXQ6IGFueSkgPT4gaW5wdXQuc2VxdWVuY2VOdW1iZXIgJiYgaW5wdXQuc2VxdWVuY2VOdW1iZXIgPCBERUZBVUxUX1JCRl9TRVFfTlVNQkVSIC0gMSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGhhc1VuY29uZmlybWVkSW5wdXRzID0gKGlucHV0czogYW55KTogYm9vbGVhbiA9PiB7XHJcbiAgcmV0dXJuIGlucHV0cy5zb21lKChpbnB1dDogYW55KSA9PiBpbnB1dC5taW50SGVpZ2h0IDwgMCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Rm9ybWF0dGVkRGF0ZSA9IChkYXRlU3RyOiBzdHJpbmcgfCBudWxsKSA9PiB7XHJcbiAgaWYgKCFkYXRlU3RyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cik7XHJcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcoKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDb252ZXJ0ZWRWYWx1ZSA9ICh2YWx1ZTogYW55LCBjaGFpbjogc3RyaW5nKTogbnVtYmVyID0+IHtcclxuICBzd2l0Y2ggKGNoYWluKSB7XHJcbiAgICBjYXNlICdFVEgnOlxyXG4gICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDFlLTE4KS50b0ZpeGVkKDE4KTtcclxuICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogTWF0aC5wb3coMTAsIDgpKSAvIE1hdGgucG93KDEwLCA4KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDFlLTgpLnRvRml4ZWQoOCk7XHJcbiAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIE1hdGgucG93KDEwLCA4KSkgLyBNYXRoLnBvdygxMCwgOCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgaWYgKHZhbHVlID09PSAwLjApIHtcclxuICAgIHZhbHVlID0gMDtcclxuICB9XHJcblxyXG4gIHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzbGVlcChkdXJhdGlvbjogbnVtYmVyKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhcmFtcyA9IChcclxuICBjdXJyZW5jeTogc3RyaW5nLFxyXG4gIG5ldHdvcms6IHN0cmluZyxcclxuKToge2N1cnJlbmN5OiBzdHJpbmc7IG5ldHdvcms6IHN0cmluZ30gPT4ge1xyXG4gIHJldHVybiB7Y3VycmVuY3k6IGN1cnJlbmN5LnRvVXBwZXJDYXNlKCksIG5ldHdvcms6IG5ldHdvcmsudG9Mb3dlckNhc2UoKX07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TGliID0gKGN1cnJlbmN5OiBzdHJpbmcpID0+IHtcclxuICBzd2l0Y2ggKGN1cnJlbmN5LnRvVXBwZXJDYXNlKCkpIHtcclxuICAgIGNhc2UgJ0JUQyc6XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gQml0Y29yZUxpYjtcclxuICAgIC8vIGNhc2UgJ0JDSCc6XHJcbiAgICAvLyAgIHJldHVybiBCaXRjb3JlTGliQ2FzaDtcclxuICAgIC8vIGNhc2UgJ0RPR0UnOlxyXG4gICAgLy8gICByZXR1cm4gQml0Y29yZUxpYkRvZ2U7XHJcbiAgICAvLyBjYXNlICdMVEMnOlxyXG4gICAgLy8gICByZXR1cm4gQml0Y29yZUxpYkx0YztcclxuICB9XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJBUElfUk9PVCIsIkFQSV9ST09UX0VUSCIsIkNPSU4iLCJERUZBVUxUX1JCRl9TRVFfTlVNQkVSIiwiRVRIX0RFRkFVTFRfUkVGUkVTSF9JTlRFUlZBTCIsIlVUWE9fREVGQVVMVF9SRUZSRVNIX0lOVEVSVkFMIiwiQml0Y29yZUxpYiIsImJ1aWxkVGltZSIsInRpbWUiLCJkaWZmTXMiLCJNYXRoIiwiYWJzIiwiRGF0ZSIsIm5vdyIsInBhcnNlIiwibWludXRlcyIsImZsb29yIiwiZ2V0QXBpUm9vdCIsImN1cnJlbmN5IiwiaW5jbHVkZXMiLCJnZXREZWZhdWx0UmVmcmVzaEludGVydmFsIiwidXJsU2FmZXR5Q2hlY2siLCJ1cmwiLCJhZ2dyZWdhdGVJdGVtcyIsIml0ZW1zIiwibCIsImxlbmd0aCIsInJldCIsInRtcCIsInUiLCJpIiwibm90QWRkciIsInNjcmlwdFNpZyIsImFkZHJlc3MiLCJzY3JpcHRQdWJLZXkiLCJhZGRyZXNzZXMiLCJqb2luIiwicHVzaCIsInZhbHVlU2F0IiwiY291bnQiLCJpc1NwZW50Iiwic3BlbnRUeElkIiwidWlDb25maXJtYXRpb25zIiwic3BlbnRIZWlnaHQiLCJtaW50SGVpZ2h0IiwiZG91YmxlU3BlbnRUeElEIiwiZG91YmxlU3BlbnRJbmRleCIsImRiRXJyb3IiLCJyb3VuZCIsInZhbHVlIiwidW5jb25maXJtZWRJbnB1dCIsInYiLCJPYmplY3QiLCJrZXlzIiwib2JqIiwicGFyc2VJbnQiLCJnZXRGZWUiLCJ0eCIsInN1bVNhdG9zaGlzIiwiYXJyIiwicmVkdWNlIiwicHJldiIsImN1ciIsImlucHV0cyIsIm91dHB1dHMiLCJpc0NvaW5CYXNlIiwiZ2V0QWRkcmVzcyIsImlzUkJGIiwic29tZSIsImlucHV0Iiwic2VxdWVuY2VOdW1iZXIiLCJoYXNVbmNvbmZpcm1lZElucHV0cyIsImdldEZvcm1hdHRlZERhdGUiLCJkYXRlU3RyIiwiZGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwiZ2V0Q29udmVydGVkVmFsdWUiLCJjaGFpbiIsInRvRml4ZWQiLCJwb3ciLCJzbGVlcCIsImR1cmF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ3aW5kb3ciLCJzZXRUaW1lb3V0Iiwibm9ybWFsaXplUGFyYW1zIiwibmV0d29yayIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJnZXRMaWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utilities/helper-methods.ts\n");

/***/ }),

/***/ "./src/utilities/hooks/index.ts":
/*!**************************************!*\
  !*** ./src/utilities/hooks/index.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _useAppDispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useAppDispatch */ \"./src/utilities/hooks/useAppDispatch.ts\");\n/* harmony import */ var _useAppSelector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useAppSelector */ \"./src/utilities/hooks/useAppSelector.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_useAppDispatch__WEBPACK_IMPORTED_MODULE_0__, _useAppSelector__WEBPACK_IMPORTED_MODULE_1__]);\n([_useAppDispatch__WEBPACK_IMPORTED_MODULE_0__, _useAppSelector__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _useAppDispatch__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _useAppDispatch__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _useAppSelector__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _useAppSelector__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL2hvb2tzL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFpQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uL3NyYy91dGlsaXRpZXMvaG9va3MvaW5kZXgudHM/NGVjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL3VzZUFwcERpc3BhdGNoJztcclxuZXhwb3J0ICogZnJvbSAnLi91c2VBcHBTZWxlY3Rvcic7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/hooks/index.ts\n");

/***/ }),

/***/ "./src/utilities/hooks/useAppDispatch.ts":
/*!***********************************************!*\
  !*** ./src/utilities/hooks/useAppDispatch.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAppDispatch: () => (/* binding */ useAppDispatch)\n/* harmony export */ });\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-redux */ \"react-redux\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([react_redux__WEBPACK_IMPORTED_MODULE_0__]);\nreact_redux__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n'use client;';\n\nconst useAppDispatch = ()=>{\n    return (0,react_redux__WEBPACK_IMPORTED_MODULE_0__.useDispatch)();\n};\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL2hvb2tzL3VzZUFwcERpc3BhdGNoLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFFd0M7QUFPakMsTUFBTUMsaUJBQWlCO0lBQzVCLE9BQU9ELHdEQUFXQTtBQUNwQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uL3NyYy91dGlsaXRpZXMvaG9va3MvdXNlQXBwRGlzcGF0Y2gudHM/NjQ4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudDsnXHJcblxyXG5pbXBvcnQge3VzZURpc3BhdGNofSBmcm9tICdyZWFjdC1yZWR1eCc7XHJcbmltcG9ydCB7VW5rbm93bkFjdGlvbn0gZnJvbSAncmVkdXgnO1xyXG5pbXBvcnQge1RodW5rRGlzcGF0Y2h9IGZyb20gJ3JlZHV4LXRodW5rJztcclxuaW1wb3J0IHtSb290U3RhdGV9IGZyb20gJy4uLy4uL3N0b3JlJztcclxuXHJcbmV4cG9ydCB0eXBlIEFwcERpc3BhdGNoID0gVGh1bmtEaXNwYXRjaDxSb290U3RhdGUsIHVua25vd24sIFVua25vd25BY3Rpb24+O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUFwcERpc3BhdGNoID0gKCkgPT4ge1xyXG4gIHJldHVybiB1c2VEaXNwYXRjaDxBcHBEaXNwYXRjaD4oKTtcclxufTtcclxuIl0sIm5hbWVzIjpbInVzZURpc3BhdGNoIiwidXNlQXBwRGlzcGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utilities/hooks/useAppDispatch.ts\n");

/***/ }),

/***/ "./src/utilities/hooks/useAppSelector.ts":
/*!***********************************************!*\
  !*** ./src/utilities/hooks/useAppSelector.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAppSelector: () => (/* binding */ useAppSelector)\n/* harmony export */ });\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-redux */ \"react-redux\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([react_redux__WEBPACK_IMPORTED_MODULE_0__]);\nreact_redux__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nconst useAppSelector = react_redux__WEBPACK_IMPORTED_MODULE_0__.useSelector;\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL2hvb2tzL3VzZUFwcFNlbGVjdG9yLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThEO0FBR3ZELE1BQU1DLGlCQUFpQkQsb0RBQVdBLENBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zaWdodC8uL3NyYy91dGlsaXRpZXMvaG9va3MvdXNlQXBwU2VsZWN0b3IudHM/MTJkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1R5cGVkVXNlU2VsZWN0b3JIb29rLCB1c2VTZWxlY3Rvcn0gZnJvbSAncmVhY3QtcmVkdXgnO1xyXG5pbXBvcnQge1Jvb3RTdGF0ZX0gZnJvbSAnLi4vLi4vc3RvcmUnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUFwcFNlbGVjdG9yID0gdXNlU2VsZWN0b3IgYXMgVHlwZWRVc2VTZWxlY3Rvckhvb2s8Um9vdFN0YXRlPjtcclxuIl0sIm5hbWVzIjpbInVzZVNlbGVjdG9yIiwidXNlQXBwU2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utilities/hooks/useAppSelector.ts\n");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "process/browser.js":
/*!*************************************!*\
  !*** external "process/browser.js" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("process/browser.js");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react-masonry-css":
/*!************************************!*\
  !*** external "react-masonry-css" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-masonry-css");

/***/ }),

/***/ "react-router-dom":
/*!***********************************!*\
  !*** external "react-router-dom" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-router-dom");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "react/jsx-runtime":
/*!************************************!*\
  !*** external "react/jsx-runtime" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-runtime");

/***/ }),

/***/ "styled-components":
/*!************************************!*\
  !*** external "styled-components" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("styled-components");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "@reduxjs/toolkit":
/*!***********************************!*\
  !*** external "@reduxjs/toolkit" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = import("@reduxjs/toolkit");;

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = import("axios");;

/***/ }),

/***/ "chart.js":
/*!***************************!*\
  !*** external "chart.js" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = import("chart.js");;

/***/ }),

/***/ "framer-motion":
/*!********************************!*\
  !*** external "framer-motion" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = import("framer-motion");;

/***/ }),

/***/ "react-chartjs-2":
/*!**********************************!*\
  !*** external "react-chartjs-2" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = import("react-chartjs-2");;

/***/ }),

/***/ "react-redux":
/*!******************************!*\
  !*** external "react-redux" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = import("react-redux");;

/***/ }),

/***/ "swr":
/*!**********************!*\
  !*** external "swr" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = import("swr");;

/***/ }),

/***/ "../bitcore-lib/package.json":
/*!***********************************!*\
  !*** ../bitcore-lib/package.json ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"bitcore-lib","version":"10.2.1","description":"A pure and powerful JavaScript Bitcoin library.","author":"BitPay <dev@bitpay.com>","main":"index.js","scripts":{"test":"gulp test","test:ci":"npm run test","coverage":"gulp coverage","build":"gulp","pub":"npm run build && npm publish"},"keywords":["bitcoin","transaction","address","p2p","ecies","cryptocurrency","blockchain","payment","bip21","bip32","bip37","bip69","bip70","multisig"],"repository":{"type":"git","url":"https://github.com/bitpay/bitcore/tree/master/packages/bitcore-lib"},"browser":{"request":"browser-request"},"dependencies":{"bech32":"=2.0.0","bn.js":"=5.2.1","bs58":"^6.0.0","buffer-compare":"=1.1.1","elliptic":"^6.5.7","inherits":"=2.0.4","lodash":"^4.17.21"},"devDependencies":{"bitcore-build":"file:../bitcore-build","brfs":"^2.0.2","chai":"^5.1.1","gulp":"^5.0.0","sinon":"^18.0.0"},"license":"MIT","gitHead":"012cc0216a9bc6b195035855bd17149bad41acd1"}');

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@swc","vendor-chunks/elliptic","vendor-chunks/hash.js","vendor-chunks/inherits","vendor-chunks/bs58","vendor-chunks/base-x","vendor-chunks/minimalistic-crypto-utils","vendor-chunks/minimalistic-assert","vendor-chunks/lodash","vendor-chunks/hmac-drbg","vendor-chunks/buffer-compare","vendor-chunks/brorand","vendor-chunks/bn.js","vendor-chunks/bech32"], () => (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F&preferredRegion=&absolutePagePath=.%2Fsrc%5Cpages%5Cindex.tsx&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();